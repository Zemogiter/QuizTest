<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KGySoft.CoreLibraries</name>
    </assembly>
    <members>
        <member name="T:KGySoft.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.ItemNotNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:KGySoft.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:KGySoft.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:KGySoft.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for method output
            means that the methos doesn't return normally (throws or terminates the process).<br/>
            Value <c>canbenull</c> is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute
            with rows separated by semicolon. There is no notion of order rows, all rows are checked
            for applicability and applied per each program state tracked by R# analysis.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:KGySoft.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:KGySoft.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:KGySoft.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:KGySoft.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:KGySoft.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:KGySoft.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:KGySoft.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:KGySoft.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:KGySoft.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:KGySoft.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:KGySoft.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:KGySoft.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:KGySoft.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:KGySoft.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:KGySoft.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:KGySoft.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:KGySoft.Annotations.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:KGySoft.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:KGySoft.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:KGySoft.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>>
        </member>
        <member name="P:KGySoft.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:KGySoft.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:KGySoft.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:KGySoft.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:KGySoft.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:KGySoft.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:KGySoft.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:KGySoft.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:KGySoft.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:KGySoft.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:KGySoft.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:KGySoft.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:KGySoft.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:KGySoft.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:KGySoft.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:KGySoft.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.NoReorderAttribute">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:KGySoft.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:KGySoft.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:KGySoft.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:KGySoft.Collections.AllowNullDictionary`2">
            <summary>
            Represents a dictionary, which allows <see langword="null"/> as a key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <seealso cref="T:System.Collections.Generic.IDictionary`2" />
        </member>
        <member name="T:KGySoft.Collections.Array2D`1">
            <summary>
            Represents a rectangular array, whose indexer access is faster than a regular 2D array.
            It supports accessing its rows or the whole content as a single dimensional <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            Depending on the used platform it supports <see cref="T:System.Buffers.ArrayPool`1"/> allocation and casting to <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <remarks>
            <para>In .NET Core 2.1/.NET Standard 2.1 and above an <see cref="T:KGySoft.Collections.Array2D`1"/> instance can be easily turned to a <see cref="T:System.Span`1"/> instance (either by cast or by the <see cref="P:KGySoft.Collections.Array2D`1.AsSpan"/> property).</para>
            <para>The actual underlying single dimensional array can be accessed via the <see cref="P:KGySoft.Collections.Array2D`1.Buffer"/> property that has an <see cref="P:KGySoft.Collections.ArraySection`1.UnderlyingArray"/> property.</para>
            <para>If the current platform supports it, the underlying array might be obtained by using the <see cref="T:System.Buffers.ArrayPool`1"/>.
            <note>Unlike the underlying <see cref="T:KGySoft.Collections.ArraySection`1"/>, the <see cref="T:KGySoft.Collections.Array2D`1"/> implements the <see cref="T:System.IDisposable"/> interface.
            Calling the <see cref="M:KGySoft.Collections.Array2D`1.Dispose">Dispose</see> method is required if the <see cref="T:KGySoft.Collections.Array2D`1"/> was not created from an existing <see cref="T:KGySoft.Collections.ArraySection`1"/>
            instance. Not calling the <see cref="M:KGySoft.Collections.Array2D`1.Dispose">Dispose</see> method may lead to decreased application performance.</note></para>
            <para>Due to the <see cref="M:KGySoft.Collections.Array2D`1.Dispose">Dispose</see> method <see cref="T:KGySoft.Collections.Array2D`1"/> is a non-<c>readonly</c>&#160;<see langword="struct"/>.
            It is not recommended to use it as a <c>readonly</c> field; otherwise, accessing its members would make the pre-C# 8.0 compilers to create defensive copies,
            which leads to a slight performance degradation.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Width">
            <summary>
            Gets the width of this <see cref="T:KGySoft.Collections.Array2D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Height">
            <summary>
            Gets the height of this <see cref="T:KGySoft.Collections.Array2D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Length">
            <summary>
            Gets the total length of this <see cref="T:KGySoft.Collections.Array2D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Buffer">
            <summary>
            Gets the underlying buffer as a single dimensional <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.AsMemory">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.Array2D`1"/> instance as a <see cref="T:System.Memory`1"/> instance.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.AsSpan">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.Array2D`1"/> instance as a <see cref="T:System.Span`1"/> instance.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.IsNull">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.Array2D`1"/> instance represents a <see langword="null"/> array.
            <br/>Please note that the <see cref="M:KGySoft.Collections.Array2D`1.ToArray">ToArray</see>/<see cref="M:KGySoft.Collections.Array2D`1.To2DArray">To2DArray</see>/<see cref="M:KGySoft.Collections.Array2D`1.ToJaggedArray">ToJaggedArray</see> methods
            return <see langword="null"/> when this property returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.IsNullOrEmpty">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.Array2D`1"/> instance represents an empty or a <see langword="null"/> array.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the element at the specified coordinates. Parameter order is the same as in case of a regular two-dimensional array.
            <br/>To return a reference to an element use the <see cref="M:KGySoft.Collections.Array2D`1.GetElementReference(System.Int32,System.Int32)">GetElementReference</see> method instead.
            </summary>
            <param name="y">The Y-coordinate (row index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <param name="x">The X-coordinate (column index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <returns>The element at the specified indices.</returns>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Item(System.Int32)">
            <summary>
            Gets a row of the <see cref="T:KGySoft.Collections.Array2D`1"/> as an <see cref="T:KGySoft.Collections.ArraySection`1"/> instance.
            </summary>
            <param name="y">The index of the row to obtain.</param>
            <returns>An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance that represents a row of this <see cref="T:KGySoft.Collections.Array2D`1"/> instance.</returns>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Item(System.Index)">
            <summary>
            Gets a row of the <see cref="T:KGySoft.Collections.Array2D`1"/> as an <see cref="T:KGySoft.Collections.ArraySection`1"/> instance.
            </summary>
            <param name="y">The index of the row to obtain.</param>
            <returns>An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance that represents a row of this <see cref="T:KGySoft.Collections.Array2D`1"/> instance.</returns>
            <remarks><note>This member is available in .NET Core 3.0/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.Array2D`1.Item(System.Range)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.Array2D`1"/> instance, which represents a subrange of rows of the current instance indicated by the specified <paramref name="range"/>.
            </summary>
            <param name="range">The range of rows to get.</param>
            <returns>The subrange of rows of the current <see cref="T:KGySoft.Collections.Array2D`1"/> instance indicated by the specified <paramref name="range"/>.</returns>
            <remarks><note>This member is available in .NET Core 3.0/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.op_Implicit(KGySoft.Collections.Array2D{`0})~KGySoft.Collections.ArraySection{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:KGySoft.Collections.Array2D`1"/> to <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
            <param name="array">The <see cref="T:KGySoft.Collections.Array2D`1"/> to be converted to an <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
            <returns>
            An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance that represents the original array.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.op_Implicit(KGySoft.Collections.Array2D{`0})~System.Span{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:KGySoft.Collections.Array2D`1"/> to <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see>.
            </summary>
            <param name="array">The <see cref="T:KGySoft.Collections.Array2D`1"/> to be converted to a <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see>.</param>
            <returns>
            A <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see> instance that represents the specified <see cref="T:KGySoft.Collections.Array2D`1"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.op_Equality(KGySoft.Collections.Array2D{`0},KGySoft.Collections.Array2D{`0})">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.Collections.Array2D`1"/> instances have the same value.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the equality check.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.op_Inequality(KGySoft.Collections.Array2D{`0},KGySoft.Collections.Array2D{`0})">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.Collections.Array2D`1"/> instances have different values.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the inequality check.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Array2D`1"/> struct using the specified <paramref name="height"/> and <paramref name="width"/>.
            Parameter order is the same as in case of instantiating a regular two-dimensional array.
            <br/>If the created <see cref="T:KGySoft.Collections.Array2D`1"/> is not used anymore the <see cref="M:KGySoft.Collections.Array2D`1.Dispose">Dispose</see> method should be called to
            return the possibly <see cref="T:System.Buffers.ArrayPool`1"/>-allocated underlying buffer to the pool.
            </summary>
            <param name="height">The height of the array to be created.</param>
            <param name="width">The width of the array to be created.</param>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.#ctor(KGySoft.Collections.ArraySection{`0},System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Array2D`1"/> struct from an existing <see cref="T:KGySoft.Collections.ArraySection`1"/>
            using the specified <paramref name="height"/> and <paramref name="width"/>.
            No heap allocation occurs when using this constructor overload.
            </summary>
            <param name="buffer">The desired underlying buffer for the <see cref="T:KGySoft.Collections.Array2D`1"/> instance to be created.
            It must have sufficient capacity for the specified dimensions. Even if <paramref name="buffer"/> owns an array rented from
            the <see cref="T:System.Buffers.ArrayPool`1"/>, calling the <see cref="M:KGySoft.Collections.Array2D`1.Dispose">Dispose</see> method on the created <see cref="T:KGySoft.Collections.Array2D`1"/>
            instance does not return the underlying array to the pool. In such case it is the caller's responsibility to release the <paramref name="buffer"/>.</param>
            <param name="height">The height of the array to be created.</param>
            <param name="width">The width of the array to be created.</param>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.Slice(System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.Array2D`1"/> instance, which represents a subrange of rows of the current instance starting with the specified <paramref name="startRowIndex"/>.
            </summary>
            <param name="startRowIndex">The offset that points to the first row of the returned <see cref="T:KGySoft.Collections.Array2D`1"/>.</param>
            <returns>The subrange of rows of the current <see cref="T:KGySoft.Collections.Array2D`1"/> instance starting with the specified <paramref name="startRowIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.Slice(System.Int32,System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.Array2D`1"/> instance, which represents a subrange of rows of the current instance indicated by the specified <paramref name="startRowIndex"/> and <paramref name="rowCount"/>.
            </summary>
            <param name="startRowIndex">The offset that points to the first row of the returned <see cref="T:KGySoft.Collections.Array2D`1"/>.</param>
            <param name="rowCount">The desired number of rows of the returned <see cref="T:KGySoft.Collections.Array2D`1"/>.</param>
            <returns>The subrange of rows of the current <see cref="T:KGySoft.Collections.Array2D`1"/> instance indicated by the specified <paramref name="startRowIndex"/> and <paramref name="rowCount"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.GetElementReference(System.Int32,System.Int32)">
            <summary>
            Gets the reference to the element at the specified indices. Parameter order is the same as in case of a regular two-dimensional array.
            </summary>
            <param name="y">The Y-coordinate (row index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <param name="x">The X-coordinate (column index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the items of this <see cref="T:KGySoft.Collections.Array2D`1"/>.
            </summary>
            <returns>An <see cref="T:KGySoft.Collections.ArraySectionEnumerator`1"/> instance that can be used to iterate though the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/>.</returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.Dispose">
            <summary>
            Releases the underlying buffer. If this <see cref="T:KGySoft.Collections.Array2D`1"/> instance was instantiated by the <see cref="M:KGySoft.Collections.Array2D`1.#ctor(System.Int32,System.Int32)">self allocating constructor</see>,
            then this method must be called when the <see cref="T:KGySoft.Collections.Array2D`1"/> is not used anymore.
            On platforms that do not support the <see cref="T:System.Buffers.ArrayPool`1"/> class this method simply clears the self instance.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.GetPinnableReference">
            <summary>
            Returns a reference to the first element in this <see cref="T:KGySoft.Collections.Array2D`1"/>.
            This makes possible to use the <see cref="T:KGySoft.Collections.Array2D`1"/> in a <see langword="fixed"/> statement.
            </summary>
            <returns>A reference to the first element in this <see cref="T:KGySoft.Collections.Array2D`1"/>, or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array2D`1.Length"/> is zero.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.Equals(KGySoft.Collections.Array2D{`0})">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.Collections.Array2D`1"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">An <see cref="T:KGySoft.Collections.Array2D`1"/> instance to compare with this instance.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object">object</see> is equal to this instance.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the specified object is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.GetHashCode">
            <summary>
            Returns a hash code for this <see cref="T:KGySoft.Collections.Array2D`1"/> instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.ToArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/> to a new single dimensional array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array2D`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.To2DArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/> to a new two dimensional array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array2D`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array2D`1.ToJaggedArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/> to a new jagged array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.Array2D`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array2D`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="T:KGySoft.Collections.Array3D`1">
            <summary>
            Represents a cubic array, whose indexer access is faster than a regular 3D array.
            It supports accessing its planes as <see cref="T:KGySoft.Collections.Array2D`1"/> instances, or the whole content as a single dimensional <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            Depending on the used platform it supports <see cref="T:System.Buffers.ArrayPool`1"/> allocation and casting to <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <remarks>
            <para>In .NET Core 2.1/.NET Standard 2.1 and above an <see cref="T:KGySoft.Collections.Array3D`1"/> instance can be easily turned to a <see cref="T:System.Span`1"/> instance (either by cast or by the <see cref="P:KGySoft.Collections.Array3D`1.AsSpan"/> property).</para>
            <para>The actual underlying single dimensional array can be accessed via the <see cref="P:KGySoft.Collections.Array3D`1.Buffer"/> property that has an <see cref="P:KGySoft.Collections.ArraySection`1.UnderlyingArray"/> property.</para>
            <para>If the current platform supports it, the underlying array might be obtained by using the <see cref="T:System.Buffers.ArrayPool`1"/>.
            <note>Unlike the underlying <see cref="T:KGySoft.Collections.ArraySection`1"/>, the <see cref="T:KGySoft.Collections.Array3D`1"/> implements the <see cref="T:System.IDisposable"/> interface.
            Calling the <see cref="M:KGySoft.Collections.Array3D`1.Dispose">Dispose</see> method is required if the <see cref="T:KGySoft.Collections.Array3D`1"/> was not created from an existing <see cref="T:KGySoft.Collections.ArraySection`1"/>
            instance. Not calling the <see cref="M:KGySoft.Collections.Array3D`1.Dispose">Dispose</see> method may lead to decreased application performance.</note></para>
            <para>Due to the <see cref="M:KGySoft.Collections.Array3D`1.Dispose">Dispose</see> method <see cref="T:KGySoft.Collections.Array3D`1"/> is a non-<c>readonly</c>&#160;<see langword="struct"/>.
            It is not recommended to use it as a <c>readonly</c> field; otherwise, accessing its members would make the pre-C# 8.0 compilers to create defensive copies,
            which leads to a slight performance degradation.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Width">
            <summary>
            Gets the width of this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Height">
            <summary>
            Gets the height of this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Depth">
            <summary>
            Gets the depth of this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Length">
            <summary>
            Gets the total length of this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Buffer">
            <summary>
            Gets the underlying buffer as a single dimensional <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.AsMemory">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.Array3D`1"/> instance as a <see cref="T:System.Memory`1"/> instance.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.AsSpan">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.Array3D`1"/> instance as a <see cref="T:System.Span`1"/> instance.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.IsNull">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.Array3D`1"/> instance represents a <see langword="null"/> array.
            <br/>Please note that the <see cref="M:KGySoft.Collections.Array3D`1.ToArray">ToArray</see>/<see cref="M:KGySoft.Collections.Array3D`1.To3DArray">To3DArray</see>/<see cref="M:KGySoft.Collections.Array3D`1.ToJaggedArray">ToJaggedArray</see> methods
            return <see langword="null"/> when this property returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.IsNullOrEmpty">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.Array3D`1"/> instance represents an empty or a <see langword="null"/> array.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets or sets the element at the specified indices. Parameter order is the same as in case of a regular three-dimensional array.
            <br/>To return a reference to an element use the <see cref="M:KGySoft.Collections.Array3D`1.GetElementReference(System.Int32,System.Int32,System.Int32)">GetElementReference</see> method instead.
            </summary>
            <param name="z">The Z-coordinate (depth index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <param name="y">The Y-coordinate (row index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <param name="x">The X-coordinate (column index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <returns>The element at the specified indices.</returns>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Item(System.Int32)">
            <summary>
            Gets a plane of the <see cref="T:KGySoft.Collections.Array3D`1"/> as an <see cref="T:KGySoft.Collections.Array2D`1"/> instance.
            </summary>
            <param name="z">The depth index of the plane to obtain.</param>
            <returns>An <see cref="T:KGySoft.Collections.Array2D`1"/> instance that represents a plane of this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.</returns>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Item(System.Index)">
            <summary>
            Gets a plane of the <see cref="T:KGySoft.Collections.Array3D`1"/> as an <see cref="T:KGySoft.Collections.Array2D`1"/> instance.
            </summary>
            <param name="z">The depth index of the plane to obtain.</param>
            <returns>An <see cref="T:KGySoft.Collections.Array2D`1"/> instance that represents a plane of this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.</returns>
            <remarks><note>This member is available in .NET Core 3.0/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.Array3D`1.Item(System.Range)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.Array3D`1"/> instance, which represents a subrange of planes of the current instance indicated by the specified <paramref name="range"/>.
            </summary>
            <param name="range">The range of planes to get.</param>
            <returns>The subrange of planes of the current <see cref="T:KGySoft.Collections.Array3D`1"/> instance indicated by the specified <paramref name="range"/>.</returns>
            <remarks><note>This member is available in .NET Core 3.0/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.op_Implicit(KGySoft.Collections.Array3D{`0})~KGySoft.Collections.ArraySection{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:KGySoft.Collections.Array3D`1"/> to <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
            <param name="array">The <see cref="T:KGySoft.Collections.Array3D`1"/> to be converted to an <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
            <returns>
            An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance that represents the original array.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.op_Implicit(KGySoft.Collections.Array3D{`0})~System.Span{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:KGySoft.Collections.Array3D`1"/> to <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see>.
            </summary>
            <param name="array">The <see cref="T:KGySoft.Collections.Array3D`1"/> to be converted to a <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see>.</param>
            <returns>
            A <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see> instance that represents the specified <see cref="T:KGySoft.Collections.Array3D`1"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.op_Equality(KGySoft.Collections.Array3D{`0},KGySoft.Collections.Array3D{`0})">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.Collections.Array3D`1"/> instances have the same value.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the equality check.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.op_Inequality(KGySoft.Collections.Array3D{`0},KGySoft.Collections.Array3D{`0})">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.Collections.Array3D`1"/> instances have different values.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the inequality check.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Array3D`1"/> struct using the specified <paramref name="depth"/>, <paramref name="height"/> and <paramref name="width"/>.
            Parameter order is the same as in case of instantiating a regular three-dimensional array.
            <br/>If the created <see cref="T:KGySoft.Collections.Array3D`1"/> is not used anymore the <see cref="M:KGySoft.Collections.Array3D`1.Dispose">Dispose</see> method should be called to
            return the possibly <see cref="T:System.Buffers.ArrayPool`1"/>-allocated underlying buffer to the pool.
            </summary>
            <param name="depth">The depth of the array to be created.</param>
            <param name="height">The height of the array to be created.</param>
            <param name="width">The width of the array to be created.</param>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.#ctor(KGySoft.Collections.ArraySection{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Array3D`1"/> struct from an existing <see cref="T:KGySoft.Collections.ArraySection`1"/>
            using the specified <paramref name="depth"/>, <paramref name="height"/> and <paramref name="width"/>.
            No heap allocation occurs when using this constructor overload.
            </summary>
            <param name="buffer">The desired underlying buffer for the <see cref="T:KGySoft.Collections.Array3D`1"/> instance to be created.
            It must have sufficient capacity for the specified dimensions. Even if <paramref name="buffer"/> owns an array rented from
            the <see cref="T:System.Buffers.ArrayPool`1"/>, calling the <see cref="M:KGySoft.Collections.Array3D`1.Dispose">Dispose</see> method on the created <see cref="T:KGySoft.Collections.Array3D`1"/>
            instance does not return the underlying array to the pool. In such case it is the caller's responsibility to release the <paramref name="buffer"/>.</param>
            <param name="depth">The depth of the array to be created.</param>
            <param name="height">The height of the array to be created.</param>
            <param name="width">The width of the array to be created.</param>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.Slice(System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.Array3D`1"/> instance, which represents a subrange of planes of the current instance starting with the specified <paramref name="startPlaneIndex"/>.
            </summary>
            <param name="startPlaneIndex">The offset that points to the first plane of the returned <see cref="T:KGySoft.Collections.Array3D`1"/>.</param>
            <returns>The subrange of planes of the current <see cref="T:KGySoft.Collections.Array3D`1"/> instance starting with the specified <paramref name="startPlaneIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.Slice(System.Int32,System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.Array3D`1"/> instance, which represents a subrange of planes of the current instance indicated by the specified <paramref name="startPlaneIndex"/> and <paramref name="planeCount"/>.
            </summary>
            <param name="startPlaneIndex">The offset that points to the first plane of the returned <see cref="T:KGySoft.Collections.Array3D`1"/>.</param>
            <param name="planeCount">The desired number of planes of the returned <see cref="T:KGySoft.Collections.Array3D`1"/>.</param>
            <returns>The subrange of planes of the current <see cref="T:KGySoft.Collections.Array3D`1"/> instance indicated by the specified <paramref name="startPlaneIndex"/> and <paramref name="planeCount"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.GetElementReference(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the reference to the element at the specified indices. Parameter order is the same as in case of a regular three-dimensional array.
            </summary>
            <param name="z">The Z-coordinate (depth index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <param name="y">The Y-coordinate (row index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <param name="x">The X-coordinate (column index) of the item to get or set. Please note that for the best performance no separate range check is performed on the coordinates.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the items of this <see cref="T:KGySoft.Collections.Array3D`1"/>.
            </summary>
            <returns>An <see cref="T:KGySoft.Collections.ArraySectionEnumerator`1"/> instance that can be used to iterate though the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/>.</returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.Dispose">
            <summary>
            Releases the underlying buffer. If this <see cref="T:KGySoft.Collections.Array3D`1"/> instance was instantiated by the <see cref="M:KGySoft.Collections.Array3D`1.#ctor(System.Int32,System.Int32,System.Int32)">self allocating constructor</see>,
            then this method must be called when the <see cref="T:KGySoft.Collections.Array3D`1"/> is not used anymore.
            On platforms that do not support the <see cref="T:System.Buffers.ArrayPool`1"/> class this method simply clears the self instance.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.GetPinnableReference">
            <summary>
            Returns a reference to the first element in this <see cref="T:KGySoft.Collections.Array3D`1"/>.
            This makes possible to use the <see cref="T:KGySoft.Collections.Array3D`1"/> in a <see langword="fixed"/> statement.
            </summary>
            <returns>A reference to the first element in this <see cref="T:KGySoft.Collections.Array3D`1"/>, or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array3D`1.Length"/> is zero.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.Equals(KGySoft.Collections.Array3D{`0})">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.Collections.Array3D`1"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">An <see cref="T:KGySoft.Collections.Array3D`1"/> instance to compare with this instance.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object">object</see> is equal to this instance.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the specified object is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.GetHashCode">
            <summary>
            Returns a hash code for this <see cref="T:KGySoft.Collections.Array3D`1"/> instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.ToArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/> to a new single dimensional array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array3D`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.To3DArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/> to a new three dimensional array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array3D`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.Array3D`1.ToJaggedArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/> to a new jagged array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.Array3D`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.Array3D`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="T:KGySoft.Collections.ArraySection`1">
            <summary>
            Represents a one dimensional array or a section of an array.
            This type is very similar to <see cref="T:System.ArraySegment`1"/>/<see cref="T:System.Memory`1"><![CDATA[Memory<T>]]></see> types but can be used on every platform in the same way
            and it is faster than <see cref="T:System.Memory`1"><![CDATA[Memory<T>]]></see> in most cases. Depending on the used platform it supports <see cref="T:System.Buffers.ArrayPool`1"/> allocation.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <remarks>
            <para>The <see cref="T:KGySoft.Collections.ArraySection`1"/> type is similar to the combination of the <see cref="T:System.Memory`1"/> type and the .NET Core version of the <see cref="T:System.ArraySegment`1"/> type.</para>
            <para>In .NET Core 2.1/.NET Standard 2.1 and above an <see cref="T:KGySoft.Collections.ArraySection`1"/> instance can be easily turned to a <see cref="T:System.Span`1"/> instance (either by cast or by the <see cref="P:KGySoft.Collections.ArraySection`1.AsSpan"/> property),
            which is much faster than using the <see cref="P:System.Memory`1.Span">Span</see> property of a <see cref="T:System.Memory`1"/> instance.</para>
            <para>If an <see cref="T:KGySoft.Collections.ArraySection`1"/> is created by the <see cref="M:KGySoft.Collections.ArraySection`1.#ctor(System.Int32,System.Boolean)">constructor with a specified size</see>, then depending on the size and the
            current platform the underlying array might be obtained by using the <see cref="T:System.Buffers.ArrayPool`1"/>. 
            <note>An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance that was instantiated by the <see cref="M:KGySoft.Collections.ArraySection`1.#ctor(System.Int32,System.Boolean)">self allocating constructor</see> must be released by calling the <see cref="M:KGySoft.Collections.ArraySection`1.Release">Release</see>
            method when it is not used anymore. The <see cref="T:KGySoft.Collections.ArraySection`1"/> type does not implement <see cref="T:System.IDisposable"/> because releasing is not required when <see cref="T:KGySoft.Collections.ArraySection`1"/> is created
            from an existing array but not calling it when it would be needed may lead to decreased application performance.</note></para>
            <para>Though <see cref="T:KGySoft.Collections.ArraySection`1"/> is practically immutable (has only <see langword="readonly"/> fields) it is not marked as <c>readonly</c>,
            which is needed for the <see cref="M:KGySoft.Collections.ArraySection`1.Release">Release</see> method to work properly. As <see cref="T:KGySoft.Collections.ArraySection`1"/> is a
            non-<c>readonly</c>&#160;<see langword="struct"/> it is not recommended to use it as a <c>readonly</c> field; otherwise,
            accessing its members would make the pre-C# 8.0 compilers to create defensive copies, which leads to a slight performance degradation.</para>
            </remarks>
        </member>
        <member name="F:KGySoft.Collections.ArraySection`1.Null">
            <summary>
            Represents the <see langword="null"/>&#160;<see cref="T:KGySoft.Collections.ArraySection`1"/>. This field is read-only.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ArraySection`1.Empty">
            <summary>
            Represents the empty <see cref="T:KGySoft.Collections.ArraySection`1"/>. This field is read-only.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.UnderlyingArray">
            <summary>
            Gets the underlying array of this <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.Offset">
            <summary>
            Gets the offset, which denotes the start position of this <see cref="T:KGySoft.Collections.ArraySection`1"/> within the <see cref="P:KGySoft.Collections.ArraySection`1.UnderlyingArray"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.Length">
            <summary>
            Gets the number of elements in this <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.IsNull">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.ArraySection`1"/> instance represents a <see langword="null"/> array.
            <br/>Please note that the <see cref="M:KGySoft.Collections.ArraySection`1.ToArray">ToArray</see> method returns <see langword="null"/> when this property returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.IsNullOrEmpty">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.ArraySection`1"/> instance represents an empty array section or a <see langword="null"/> array.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.AsMemory">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.ArraySection`1"/> instance as a <see cref="T:System.Memory`1"/> instance.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.AsSpan">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.ArraySection`1"/> instance as a <see cref="T:System.Span`1"/> instance.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.AsArraySegment">
            <summary>
            Returns the current <see cref="T:KGySoft.Collections.ArraySection`1"/> instance as an <see cref="T:System.ArraySegment`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ArraySection`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified <paramref name="index"/>.
            <br/>To return a reference to an element use the <see cref="M:KGySoft.Collections.ArraySection`1.GetElementReference(System.Int32)">GetElementReference</see> method instead.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.op_Implicit(`0[])~KGySoft.Collections.ArraySection{`0}">
            <summary>
            Performs an implicit conversion from array of <typeparamref name="T"/> to <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
            <param name="array">The array to be converted to an <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
            <returns>
            An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance that represents the original array.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.op_Implicit(KGySoft.Collections.ArraySection{`0})~System.Span{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:KGySoft.Collections.ArraySection`1"/> to <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see>.
            </summary>
            <param name="arraySection">The <see cref="T:KGySoft.Collections.ArraySection`1"/> to be converted to a <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see>.</param>
            <returns>
            A <see cref="T:System.Span`1"><![CDATA[Span<T>]]></see> instance that represents the specified <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.op_Equality(KGySoft.Collections.ArraySection{`0},KGySoft.Collections.ArraySection{`0})">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.Collections.ArraySection`1"/> instances have the same value.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the equality check.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.op_Inequality(KGySoft.Collections.ArraySection{`0},KGySoft.Collections.ArraySection{`0})">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.Collections.ArraySection`1"/> instances have different values.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the inequality check.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ArraySection`1" /> struct using an internally allocated buffer.
            <br/>When using this overload, the returned <see cref="T:KGySoft.Collections.ArraySection`1"/> instance must be released
            by the <see cref="M:KGySoft.Collections.ArraySection`1.Release">Release</see> method if it is not used anymore.
            </summary>
            <param name="length">The length of the <see cref="T:KGySoft.Collections.ArraySection`1"/> to be created.</param>
            <param name="assureClean"><see langword="true"/> to make sure the allocated array is zero-initialized;
            otherwise, <see langword="false"/>. Affects larger arrays only, if current platform supports using <see cref="T:System.Buffers.ArrayPool`1"/>. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ArraySection`1" /> struct from the specified <paramref name="array"/>.
            No heap allocation occurs when using this constructor overload.
            </summary>
            <param name="array">The array to initialize the new <see cref="T:KGySoft.Collections.ArraySection`1"/> instance from.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ArraySection`1" /> struct from the specified <paramref name="array"/>
            using the specified <paramref name="offset"/> and <paramref name="length"/>.
            No heap allocation occurs when using this constructor overload.
            </summary>
            <param name="array">The array to initialize the new <see cref="T:KGySoft.Collections.ArraySection`1"/> instance from.</param>
            <param name="offset">The index of the first element in the <paramref name="array"/> to include in the new <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
            <param name="length">The number of items to include in the new <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.#ctor(`0[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ArraySection`1" /> struct from the specified <paramref name="array"/>
            using the specified <paramref name="offset"/>.
            No heap allocation occurs when using this constructor overload.
            </summary>
            <param name="array">The array to initialize the new <see cref="T:KGySoft.Collections.ArraySection`1"/> instance from.</param>
            <param name="offset">The index of the first element in the <paramref name="array"/> to include in the new <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Clear">
            <summary>
            Clears the items in this <see cref="T:KGySoft.Collections.ArraySection`1"/> instance so all elements will have the default value of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Slice(System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.ArraySection`1"/> instance, which represents a subsection of the current instance with the specified <paramref name="startIndex"/>.
            </summary>
            <param name="startIndex">The offset that points to the first item of the returned section.</param>
            <returns>The subsection of the current <see cref="T:KGySoft.Collections.ArraySection`1"/> instance with the specified <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Slice(System.Int32,System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.Collections.ArraySection`1"/> instance, which represents a subsection of the current instance with the specified <paramref name="startIndex"/> and <paramref name="length"/>.
            </summary>
            <param name="startIndex">The offset that points to the first item of the returned section.</param>
            <param name="length">The desired length of the returned section.</param>
            <returns>The subsection of the current <see cref="T:KGySoft.Collections.ArraySection`1"/> instance with the specified <paramref name="startIndex"/> and <paramref name="length"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.GetPinnableReference">
            <summary>
            Returns a reference to the first element in this <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            This makes possible to use the <see cref="T:KGySoft.Collections.ArraySection`1"/> in a <see langword="fixed"/> statement.
            </summary>
            <returns>A reference to the first element in this <see cref="T:KGySoft.Collections.ArraySection`1"/>, or <see langword="null"/> if <see cref="P:KGySoft.Collections.ArraySection`1.IsNullOrEmpty"/> is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.ToArray">
            <summary>
            Copies the elements of this <see cref="T:KGySoft.Collections.ArraySection`1"/> to a new array.
            </summary>
            <returns>An array containing copies of the elements of this <see cref="T:KGySoft.Collections.ArraySection`1"/>,
            or <see langword="null"/> if <see cref="P:KGySoft.Collections.ArraySection`1.IsNull"/> is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.AsArray2D(System.Int32,System.Int32)">
            <summary>
            Gets this <see cref="T:KGySoft.Collections.ArraySection`1"/> as an <see cref="T:KGySoft.Collections.Array2D`1"/> instance
            using the specified <paramref name="height"/> and <paramref name="width"/>.
            The <see cref="T:KGySoft.Collections.ArraySection`1"/> must have enough capacity for the specified dimensions.
            </summary>
            <param name="height">The height of the array to be returned.</param>
            <param name="width">The width of the array to be returned.</param>
            <returns>An <see cref="T:KGySoft.Collections.Array2D`1"/> instance using this <see cref="T:KGySoft.Collections.ArraySection`1"/> as its underlying buffer that has the specified dimensions.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.AsArray3D(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets this <see cref="T:KGySoft.Collections.ArraySection`1"/> as an <see cref="T:KGySoft.Collections.Array3D`1"/> instance
            using the specified <paramref name="height"/> and <paramref name="width"/>.
            The <see cref="T:KGySoft.Collections.ArraySection`1"/> must have enough capacity for the specified dimensions.
            </summary>
            <param name="depth">The depth of the array to be returned.</param>
            <param name="height">The height of the array to be returned.</param>
            <param name="width">The width of the array to be returned.</param>
            <returns>An <see cref="T:KGySoft.Collections.Array3D`1"/> instance using this <see cref="T:KGySoft.Collections.ArraySection`1"/> as its underlying buffer that has the specified dimensions.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.GetElementReference(System.Int32)">
            <summary>
            Gets the reference to the element at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The index of the element to get the reference for.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in this <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Contains(`0)">
            <summary>
            Determines whether this <see cref="T:KGySoft.Collections.ArraySection`1"/> contains the specific <paramref name="item"/>.
            </summary>
            <returns>
            <see langword="true"/> if <paramref name="item"/> is found in this <see cref="T:KGySoft.Collections.ArraySection`1"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="item">The object to locate in this <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the items of this <see cref="T:KGySoft.Collections.ArraySection`1"/> to a compatible one-dimensional array, starting at a particular index.
            </summary>
            <param name="target">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this <see cref="T:KGySoft.Collections.ArraySection`1"/>.</param>
            <param name="targetIndex">The zero-based index in <paramref name="target"/> at which copying begins. This parameter is optional.
            <br/>Default value: 0.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.CopyTo(KGySoft.Collections.ArraySection{`0},System.Int32)">
            <summary>
            Copies the items of this <see cref="T:KGySoft.Collections.ArraySection`1"/> to a compatible instance, starting at a particular index.
            </summary>
            <param name="target">The <see cref="T:KGySoft.Collections.ArraySection`1"/> that is the destination of the elements copied from this instance.</param>
            <param name="targetIndex">The zero-based index in <paramref name="target"/> at which copying begins.</param>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the items of this <see cref="T:KGySoft.Collections.ArraySection`1"/>.
            </summary>
            <returns>An <see cref="T:KGySoft.Collections.ArraySectionEnumerator`1"/> instance that can be used to iterate though the elements of this <see cref="T:KGySoft.Collections.ArraySection`1"/>.</returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Release">
            <summary>
            Releases the underlying array. If this <see cref="T:KGySoft.Collections.ArraySection`1"/> instance was instantiated by the <see cref="M:KGySoft.Collections.ArraySection`1.#ctor(System.Int32,System.Boolean)">self allocating constructor</see>,
            then this method must be called when the <see cref="T:KGySoft.Collections.ArraySection`1"/> is not used anymore.
            On platforms that do not support the <see cref="T:System.Buffers.ArrayPool`1"/> class this method simply sets the self instance to <see cref="F:KGySoft.Collections.ArraySection`1.Null"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Equals(KGySoft.Collections.ArraySection{`0})">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.Collections.ArraySection`1"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance to compare with this instance.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object">object</see> is equal to this instance.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the specified object is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySection`1.GetHashCode">
            <summary>
            Returns a hash code for this <see cref="T:KGySoft.Collections.ArraySection`1"/> instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="T:KGySoft.Collections.ArraySectionEnumerator`1">
            <summary>
            Enumerates the elements of an <see cref="T:KGySoft.Collections.ArraySection`1" />, <see cref="T:KGySoft.Collections.Array2D`1" /> or <see cref="T:KGySoft.Collections.Array3D`1" /> instance.
            </summary>
            <typeparam name="T">The type of the enumerated elements.</typeparam>
        </member>
        <member name="P:KGySoft.Collections.ArraySectionEnumerator`1.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ArraySectionEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.ArraySectionEnumerator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.Cache`2">
            <summary>
            Represents a generic cache. If an item loader is specified, then cache expansion is transparent: the user needs only to read the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> to retrieve items.
            When a non-existing key is accessed, then the item is loaded automatically by the loader function that was passed to the
            <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.
            If the cache is full (elements <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches the <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element has to be stored, then
            the oldest or least recent used element (depends on the value of <see cref="P:KGySoft.Collections.Cache`2.Behavior"/>) is removed from the cache.
            </summary>
            <typeparam name="TKey">Type of the keys stored in the cache.</typeparam>
            <typeparam name="TValue">Type of the values stored in the cache.</typeparam>
            <remarks>
            <note type="tip">To create a thread-safe <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance that fits the best for your needs use the members of the <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/> class.</note>
            <para><see cref="T:KGySoft.Collections.Cache`2"/> type provides a fast-access storage with limited capacity and transparent access. If you need to store
            items that are expensive to retrieve (for example from a database or remote service) and you don't want to run out of memory because of
            just storing newer and newer elements without getting rid of old ones, then this type might fit your expectations.
            Once a value is stored in the cache, its retrieval by using its key is very fast, close to O(1).</para>
            <para>A cache store must meet the following three criteria:
            <list type="number">
            <item><term>Associative access</term><description>Accessing elements works the same way as in case of the <see cref="T:System.Collections.Generic.Dictionary`2"/> type.
            <see cref="T:KGySoft.Collections.Cache`2"/> implements both the generic <see cref="T:System.Collections.Generic.IDictionary`2"/> and the non-generic <see cref="T:System.Collections.IDictionary"/> interfaces so can be
            used similarly as <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Hashtable"/> types.</description></item>
            <item><term>Transparency</term><description>Users of the cache need only to read the cache by its <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> property.
            If needed, elements will be automatically loaded on the first access.</description></item>
            <item><term>Size management</term><description><see cref="T:KGySoft.Collections.Cache`2"/> type has a <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>, which is the allowed maximal elements count. If the cache is full, the
            oldest or least recent used element will be automatically removed from the cache (see <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property).</description></item>
            </list></para>
            <para>Since <see cref="T:KGySoft.Collections.Cache`2"/> implements <see cref="T:System.Collections.Generic.IDictionary`2"/> interface, <see cref="M:KGySoft.Collections.Cache`2.Add(`0,`1)">Add</see>, <see cref="M:KGySoft.Collections.Cache`2.Remove(`0)">Remove</see>, <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see> and
            <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> methods are available for it, and these methods work exactly the same way as in case the <see cref="T:System.Collections.Generic.Dictionary`2"/> type. But using these methods
            usually are not necessary, unless we want to manually manage cache content or when cache is initialized without an item loader. Normally after cache is instantiated,
            it is needed to be accessed only by the getter accessor of its indexer.</para>
            <note type="caution">
            Serializing a cache instance by <see cref="T:System.Runtime.Serialization.IFormatter"/> implementations involves the serialization of the item loader delegate. To deserialize a cache the assembly of the loader must be accessible. If you need to
            serialize cache instances try to use static methods as data loaders and avoid using anonymous delegates or lambda expressions, otherwise it is not guaranteed that another
            implementations or versions of CLR will able to deserialize data and resolve the compiler-generated members.
            </note>
            <note type="warning">
            .NET Core does not support serializing delegates. If the <see cref="T:KGySoft.Collections.Cache`2"/> instance was initialized by a loader delegate it is possible that serialization
            throws a <see cref="T:System.Runtime.Serialization.SerializationException"/> on some platforms.
            </note>
            </remarks>
            <threadsafety instance="false">Members of this type are not safe for multi-threaded operations, though a thread-safe accessor can be obtained for the <see cref="T:KGySoft.Collections.Cache`2"/>
            by the <see cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">GetThreadSafeAccessor</see> method. To get a thread-safe wrapper for all members use the
            <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.AsThreadSafe``2(System.Collections.Generic.IDictionary{``0,``1})">AsThreadSafe</see> extension method instead.
            <note>If a <see cref="T:KGySoft.Collections.Cache`2"/> instance is wrapped into a <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance, then the whole cache will be locked during the time when the item loader delegate is being called.
            If that is not desirable consider to use the <see cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">GetThreadSafeAccessor</see> method instead with the default arguments and access the cache only via the returned accessor.</note>
            <note type="tip">To create a thread-safe <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance that fits the best for your needs use the members of the <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/> class.</note>
            </threadsafety>
            <example>
            The following example shows the suggested usage of <see cref="T:KGySoft.Collections.Cache`2"/>.
            <note type="tip">Try also <a href="https://dotnetfiddle.net/YGDY9c" target="_blank">online</a>.</note>
            <code lang="C#"><![CDATA[
            using System;
            using System.Collections.Generic;
            using KGySoft.Collections;
            
            class Example
            {
                private static Cache<int, bool> isPrimeCache;
            
                public static void Main()
                {
                    // Cache capacity is initialized to store maximum 4 values
                    isPrimeCache = new Cache<int, bool>(ItemLoader, 4);
            
                    // If cache is full the least recent used element will be deleted
                    isPrimeCache.Behavior = CacheBehavior.RemoveLeastRecentUsedElement;
            
                    // cache is now empty
                    DumpCache();
            
                    // reading the cache invokes the loader method
                    CheckPrime(13);
            
                    // reading a few more values
                    CheckPrime(23);
                    CheckPrime(33);
                    CheckPrime(43);
            
                    // dumping content
                    DumpCache();
            
                    // accessing an already read item does not invoke loader again
                    // Now it changes cache order because of the chosen behavior
                    CheckPrime(13);
                    DumpCache();
            
                    // reading a new element with full cache will delete an old one (now 23)
                    CheckPrime(111);
                    DumpCache();
            
                    // but accessing a deleted element causes to load it again
                    CheckPrime(23);
                    DumpCache();
            
                    // dumping some statistics
                    Console.WriteLine(isPrimeCache.GetStatistics().ToString());
                }
            
                // This is the item loader method. It can access database or perform slow calculations.
                // If cache is meant to be serialized it should be a static method rather than an anonymous delegate or lambda expression.
                private static bool ItemLoader(int number)
                {
                    Console.WriteLine("Item loading has been invoked for value {0}", number);
            
                    // In this example item loader checks whether the given number is a prime by a not too efficient algorithm.
                    if (number <= 1)
                        return false;
                    if (number % 2 == 0)
                        return true;
                    int i = 3;
                    int sqrt = (int)Math.Floor(Math.Sqrt(number));
                    while (i <= sqrt)
                    {
                        if (number % i == 0)
                            return false;
                        i += 2;
                    }
            
                    return true;
                }
            
                private static void CheckPrime(int number)
                {
                    // cache is used transparently here: indexer is always just read
                    bool isPrime = isPrimeCache[number];
                    Console.WriteLine("{0} is a prime: {1}", number, isPrime);
                }
            
                private static void DumpCache()
                {
                    Console.WriteLine();
                    Console.WriteLine("Cache elements count: {0}", isPrimeCache.Count);
                    if (isPrimeCache.Count > 0)
                    {
                        // enumerating through the cache shows the elements in the evaluation order
                        Console.WriteLine("Cache elements:");
                        foreach (KeyValuePair<int, bool> item in isPrimeCache)
                        {
                            Console.WriteLine("\tKey: {0},\tValue: {1}", item.Key, item.Value);
                        }
                    }
            
                    Console.WriteLine();
                }
            }
            
            // This code example produces the following output:
            //
            // Cache elements count: 0
            // 
            // Item loading has been invoked for value 13
            // 13 is a prime: True
            // Item loading has been invoked for value 23
            // 23 is a prime: True
            // Item loading has been invoked for value 33
            // 33 is a prime: False
            // Item loading has been invoked for value 43
            // 43 is a prime: True
            // 
            // Cache elements count: 4
            // Cache elements:
            // Key: 13,        Value: True
            // Key: 23,        Value: True
            // Key: 33,        Value: False
            // Key: 43,        Value: True
            // 
            // 13 is a prime: True
            // 
            // Cache elements count: 4
            // Cache elements:
            // Key: 23,        Value: True
            // Key: 33,        Value: False
            // Key: 43,        Value: True
            // Key: 13,        Value: True
            // 
            // Item loading has been invoked for value 111
            // 111 is a prime: False
            // 
            // Cache elements count: 4
            // Cache elements:
            // Key: 33,        Value: False
            // Key: 43,        Value: True
            // Key: 13,        Value: True
            // Key: 111,       Value: False
            // 
            // Item loading has been invoked for value 23
            // 23 is a prime: True
            // 
            // Cache elements count: 4
            // Cache elements:
            // Key: 43,        Value: True
            // Key: 13,        Value: True
            // Key: 111,       Value: False
            // Key: 23,        Value: True
            // 
            // Cache<Int32, Boolean> cache statistics:
            // Count: 4
            // Capacity: 4
            // Number of writes: 6
            // Number of reads: 7
            // Number of cache hits: 1
            // Number of deletes: 2
            // Hit rate: 14,29%]]></code></example>
            <seealso cref="T:KGySoft.Collections.CacheBehavior"/>
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/>
            <seealso cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>
        </member>
        <member name="T:KGySoft.Collections.Cache`2.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.Cache`2"/> instance in the evaluation order.
            </summary>
            <seealso cref="T:KGySoft.Collections.Cache`2"/>
        </member>
        <member name="T:KGySoft.Collections.Cache`2.CacheStatistics">
            <summary>
            Retrieves statistics of a <see cref="T:KGySoft.Collections.Cache`2"/> instance.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.Cache`2.Entry.NextInBucket">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last
            </summary>
        </member>
        <member name="F:KGySoft.Collections.Cache`2.Entry.NextInOrder">
            <summary>
            Zero-based index of next item in the evaluation order or -1 if last
            </summary>
        </member>
        <member name="F:KGySoft.Collections.Cache`2.Entry.PrevInOrder">
            <summary>
            Zero-based index of previous item in the evaluation order or -1 if first
            </summary>
        </member>
        <member name="F:KGySoft.Collections.Cache`2.nullLoader">
            <summary>
            A loader function that can be used at constructors if you want to manage element additions to the cache manually.
            If you want to get an element with a non-existing key using this loader, a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> will be thrown.
            This field is read-only.
            <remarks>
            When this field is used as loader function at one of the constructors, the <see cref="T:KGySoft.Collections.Cache`2"/> can be used
            similarly to a <see cref="T:System.Collections.Generic.Dictionary`2"/>: existence of keys should be tested by <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)"/> or <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)"/>
            methods, and elements should be added by <see cref="M:KGySoft.Collections.Cache`2.Add(`0,`1)"/> method or by setter of the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)"/> property.
            The only difference to a <see cref="T:System.Collections.Generic.Dictionary`2"/> is that <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is still maintained so
            when the <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> equals to <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>), and
            a new element is added, then an element will be dropped from the cache depending on the current <see cref="P:KGySoft.Collections.Cache`2.Behavior"/>.
            </remarks>
            </summary>
            <seealso cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func`2,System.Int32,System.Collections.Generic.IEqualityComparer`1)"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Item(`0)"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.Capacity">
            <summary>
            Gets or sets the capacity of the cache. If new value is smaller than elements count (value of the <see cref="P:KGySoft.Collections.Cache`2.Count"/> property),
            then old or least used elements (depending on <see cref="P:KGySoft.Collections.Cache`2.Behavior"/>) will be removed from <see cref="T:KGySoft.Collections.Cache`2"/>.
            <br/>Default value: <c>128</c>, if the <see cref="T:KGySoft.Collections.Cache`2"/> was initialized without specifying a capacity; otherwise, as it was initialized.
            </summary>
            <remarks>
            <para>If new value is smaller than elements count, then cost of setting this property is O(n), where n is the difference of
            <see cref="P:KGySoft.Collections.Cache`2.Count"/> before setting the property and the new capacity to set.</para>
            <para>If new value is larger than elements count, and <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> returns <see langword="true"/>, then cost of setting this property is O(n),
            where n is the new capacity.</para>
            <para>Otherwise, the cost of setting this property is O(1).</para>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Count"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.Behavior">
            <summary>
            Gets or sets the cache behavior when cache is full and an element has to be removed.
            The cache is full, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches the <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>.
            Default value: <see cref="F:KGySoft.Collections.CacheBehavior.RemoveLeastRecentUsedElement"/>.
            </summary>
            <remarks>
            <para>
            When cache is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element
            has to be stored, then an element has to be dropped out from the cache. The dropping-out strategy is
            specified by this property. The suggested behavior depends on cache usage. See possible behaviors at <see cref="T:KGySoft.Collections.CacheBehavior"/> enumeration.
            </para>
            <note>
            Changing value of this property will not reorganize cache, just switches between the maintaining strategies.
            Cache order is maintained on accessing a value.
            </note>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Count"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="T:KGySoft.Collections.CacheBehavior"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.EnsureCapacity">
            <summary>
            Gets or sets whether adding the first item to the cache or resetting <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> on a non-empty cache should
            allocate memory for all cache entries.
            <br/>Default value: <see langword="false"/>, unless you use the <see cref="T:System.Collections.Generic.IDictionary`2"/> initializer
            <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">constructor</see>,
            which initializes this property to <see langword="true"/>.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is large (10,000 or bigger), and the cache is not likely to be full, the recommended value is <see langword="false"/>.</para>
            <para>When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is <see langword="true"/>, the full capacity of the inner storage is allocated when the first
            item is added to the cache. Otherwise, inner storage is allocated dynamically, increasing its size again and again until the preset <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is reached.
            When increasing occurs the storage size is increased to a prime number close to the double of the previous storage size.
            <note>When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is <see langword="false"/>, then after the last storage doubling the internally allocated storage can be much bigger than <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>.
            But setting <see langword="true"/> to this property trims the possibly exceeded size to a prime value close to the actual capacity.</note>
            </para>
            <para>When cache is not empty and <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is just turned on, the cost of setting this property is O(n),
            where n is <see cref="P:KGySoft.Collections.Cache`2.Count"/>. In any other cases cost of setting this property is O(1).</para>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.Keys">
            <summary>
            Gets the keys stored in the cache in evaluation order.
            </summary>
            <remarks>
            <para>The order of the keys in the <see cref="T:System.Collections.Generic.ICollection`1"/> represents the evaluation order. When the <see cref="T:KGySoft.Collections.Cache`2"/> is full, the element with the first key will be dropped.</para>
            <para>The returned <see cref="T:System.Collections.Generic.ICollection`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.ICollection`1"/> refers back to the keys in the original <see cref="T:KGySoft.Collections.Cache`2"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.Cache`2"/> continue to be reflected in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</para>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.Values">
            <summary>
            Gets the values stored in the cache in evaluation order.
            </summary>
            <remarks>
            <para>The order of the values in the <see cref="T:System.Collections.Generic.ICollection`1"/> represents the evaluation order. When the <see cref="T:KGySoft.Collections.Cache`2"/> is full, the element with the value key will be dropped.</para>
            <para>The returned <see cref="T:System.Collections.Generic.ICollection`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.ICollection`1"/> refers back to the values in the original <see cref="T:KGySoft.Collections.Cache`2"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.Cache`2"/> continue to be reflected in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</para>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.Count">
            <summary>
            Gets number of elements currently stored in this <see cref="T:KGySoft.Collections.Cache`2"/> instance.
            </summary>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.DisposeDroppedValues">
            <summary>
            Gets or sets whether internally dropped values are disposed if they implement <see cref="T:System.IDisposable"/>.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>If the value of this property is <see langword="true"/>, then a disposable value will be disposed, if
            <list type="bullet">
            <item>The <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> equals <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>), and
            a new item has to be stored so an element has to be dropped.</item>
            <item><see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is decreased and therefore elements has to be dropped.</item>
            <item>The <see cref="T:KGySoft.Collections.Cache`2"/> is accessed via an <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance and item for the same <typeparamref name="TKey"/>
            has been loaded concurrently so all but one loaded elements have to be discarded.</item>
            </list>
            </para>
            <note>In all cases when values are removed or replaced explicitly by the public members values are not disposed.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.Cache`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified <paramref name="key"/>. When an element with a non-existing key
            is read, and an item loader was specified by the appropriate <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>,
            then the value is retrieved by the specified loader delegate of this <see cref="T:KGySoft.Collections.Cache`2"/> instance.
            </summary>
            <param name="key">Key of the element to get or set.</param>
            <returns>The element with the specified <paramref name="key"/>.</returns>
            <remarks>
            <para>Getting this property retrieves the needed element, while setting adds a new item (or overwrites an already existing item).
            If this <see cref="T:KGySoft.Collections.Cache`2"/> instance was initialized by a non-<see langword="null"/> item loader, then it is enough to use only the get accessor because that will
            load elements into the cache by the delegate instance that was passed to the <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.
            When the cache was initialized without an item loader, then getting a non-existing key will throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/>.</para>
            <para>If an item loader was passed to the <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>, then
            it is transparent whether the returned value of this property was in the cache before retrieving it.
            To test whether a key exists in the cache, use the <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see> method. To retrieve a key only when it already exists in the cache,
            use the <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> method.</para>
            <para>When the <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> equals to <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and
            a new item is added, an element (depending on <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property) will be dropped from the cache.</para>
            <para>If <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is <see langword="true"/>, getting or setting this property approaches an O(1) operation. Otherwise,
            when the capacity of the inner storage must be increased to accommodate a new element, this property becomes an O(n) operation, where n is <see cref="P:KGySoft.Collections.Cache`2.Count"/>.</para>
            <para><note type="tip">You can retrieve a thread-safe accessor by the <see cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">GetThreadSafeAccessor</see> method.</note></para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved, the <see cref="T:KGySoft.Collections.Cache`2"/> has been initialized without an item loader
            and <paramref name="key"/> does not exist in the cache.</exception>
            <seealso cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
            <seealso cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Cache`2"/> class with default capacity of 128 and no item loader.
            </summary>
            <remarks>
            <para>When <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element is about to be stored, then an
            element will be dropped out from the cache. The strategy is controlled by <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            <para>This constructor does not specify an item loader so you have to add elements manually to this <see cref="T:KGySoft.Collections.Cache`2"/> instance. In this case
            the <see cref="T:KGySoft.Collections.Cache`2"/> can be used similarly to a <see cref="T:System.Collections.Generic.Dictionary`2"/>: before getting an element, its existence must be checked by <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see>
            or <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> methods, though <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is still maintained based on the strategy specified in the <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Cache`2"/> class with specified <paramref name="capacity"/> capacity and <paramref name="comparer"/> and no item loader.
            </summary>
            <param name="capacity"><see cref="P:KGySoft.Collections.Cache`2.Capacity"/> of the <see cref="T:KGySoft.Collections.Cache`2"/> (possible maximum value of <see cref="P:KGySoft.Collections.Cache`2.Count"/>)</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.Cache`2"/> must be unique according to the specified comparer.</para>
            <para>The <paramref name="capacity"/> of a <see cref="T:KGySoft.Collections.Cache`2"/> is the maximum number of elements that the <see cref="T:KGySoft.Collections.Cache`2"/> can hold. When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            is <see langword="true"/>, the internal store is allocated when the first element is added to the cache. When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is <see langword="false"/>, then as elements are added to the
            <see cref="T:KGySoft.Collections.Cache`2"/>, the inner storage is automatically increased as required until <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is reached or exceeded. When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is
            turned on while there are elements in the <see cref="T:KGySoft.Collections.Cache`2"/>, then internal storage will be reallocated to have exactly the same size that <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> defines.
            The possible exceeding storage will be trimmed in this case.</para>
            <para>When <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element is about to be stored, then an
            element will be dropped out from the cache. The strategy is controlled by <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            <para>This constructor does not specify an item loader so you have to add elements manually to this <see cref="T:KGySoft.Collections.Cache`2"/> instance. In this case
            the <see cref="T:KGySoft.Collections.Cache`2"/> can be used similarly to a <see cref="T:System.Collections.Generic.Dictionary`2"/>: before getting an element, its existence must be checked by <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see>
            or <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> methods, though <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is still maintained based on the strategy specified in the <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Cache`2"/> class with the specified <paramref name="comparer"/>, default capacity of 128 and no item loader.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.Cache`2"/> must be unique according to the specified comparer.</para>
            <para>When <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element is about to be stored, then an
            element will be dropped out from the cache. The strategy is controlled by <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            <para>This constructor does not specify an item loader so you have to add elements manually to this <see cref="T:KGySoft.Collections.Cache`2"/> instance. In this case
            the <see cref="T:KGySoft.Collections.Cache`2"/> can be used similarly to a <see cref="T:System.Collections.Generic.Dictionary`2"/>: before getting an element, its existence must be checked by <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see>
            or <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> methods, though <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is still maintained based on the strategy specified in the <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new <see cref="T:KGySoft.Collections.Cache`2"/> instance with the given <paramref name="itemLoader"/> and <paramref name="comparer"/> using default capacity of 128.
            </summary>
            <param name="itemLoader">A delegate that contains the item loader routine. This delegate is accessed whenever a non-cached item is about to be loaded by reading the
            <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see>.
            If <see langword="null"/>, then similarly to a regular <see cref="T:System.Collections.Generic.Dictionary`2"/>, a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> will be thrown on accessing a non-existing key.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.Cache`2"/> must be unique according to the specified comparer.</para>
            <para>When <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element is about to be stored, then an
            element will be dropped out from the cache. The strategy is controlled by <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            <para>If you want to add elements manually to the <see cref="T:KGySoft.Collections.Cache`2"/>, then you can pass <see langword="null"/> to the <paramref name="itemLoader"/> parameter. In this case
            the <see cref="T:KGySoft.Collections.Cache`2"/> can be used similarly to a <see cref="T:System.Collections.Generic.Dictionary`2"/>: before getting an element, its existence must be checked by <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see>
            or <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> methods, though <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is still maintained based on the strategy specified in the <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            </remarks>
            <overloads><see cref="T:KGySoft.Collections.Cache`2"/> type has four different public constructors for initializing the item loader delegate, capacity and key comparer.</overloads>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new <see cref="T:KGySoft.Collections.Cache`2"/> instance with the given <paramref name="itemLoader"/>, <paramref name="capacity"/> and <paramref name="comparer"/>.
            </summary>
            <param name="itemLoader">A delegate that contains the item loader routine. This delegate is accessed whenever a non-cached item is about to be loaded by reading the
            <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see>.
            If <see langword="null"/>, then similarly to a regular <see cref="T:System.Collections.Generic.Dictionary`2"/>, a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> will be thrown on accessing a non-existing key.</param>
            <param name="capacity"><see cref="P:KGySoft.Collections.Cache`2.Capacity"/> of the <see cref="T:KGySoft.Collections.Cache`2"/> (possible maximum value of <see cref="P:KGySoft.Collections.Cache`2.Count"/>). This parameter is optional.
            <br/>Default value: <c>128</c>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.Cache`2"/> must be unique according to the specified comparer.</para>
            <para>The <paramref name="capacity"/> of a <see cref="T:KGySoft.Collections.Cache`2"/> is the maximum number of elements that the <see cref="T:KGySoft.Collections.Cache`2"/> can hold. When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            is <see langword="true"/>, the internal store is allocated when the first element is added to the cache. When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is <see langword="false"/>, then as elements are added to the
            <see cref="T:KGySoft.Collections.Cache`2"/>, the inner storage is automatically increased as required until <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is reached or exceeded. When <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is
            turned on while there are elements in the <see cref="T:KGySoft.Collections.Cache`2"/>, then internal storage will be reallocated to have exactly the same size that <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> defines.
            The possible exceeding storage will be trimmed in this case.</para>
            <para>When <see cref="T:KGySoft.Collections.Cache`2"/> is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>) and a new element is about to be stored, then an
            element will be dropped out from the cache. The strategy is controlled by <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            <para>If you want to add elements manually to the <see cref="T:KGySoft.Collections.Cache`2"/>, then you can pass <see langword="null"/> to the <paramref name="itemLoader"/> parameter. In this case
            the <see cref="T:KGySoft.Collections.Cache`2"/> can be used similarly to a <see cref="T:System.Collections.Generic.Dictionary`2"/>: before getting an element, its existence must be checked by <see cref="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">ContainsKey</see>
            or <see cref="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">TryGetValue</see> methods, though <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> is still maintained based on the strategy specified in the <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less or equal to 0.</exception>
            <overloads><see cref="T:KGySoft.Collections.Cache`2"/> type has four different public constructors for initializing the item loader delegate, capacity and key comparer.</overloads>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Cache`2"/> class from the specified <paramref name="dictionary"/> and <paramref name="comparer"/>, with no item loader.
            The <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> will be initialized to the number of elements in <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary whose elements are added to the <see cref="T:KGySoft.Collections.Cache`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.Cache`2"/> must be unique according to the specified comparer.</para>
            <para>This constructor does not specify an item loader and initializes <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> to the number of elements in
            the specified <paramref name="dictionary"/>. Meaning, adding new elements manually will drop an element unless you increase <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>,
            and reading the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> with a non-existing key will throw
            a <see cref="T:System.Collections.Generic.KeyNotFoundException"/>.</para>
            <para>This constructor sets <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> to <see langword="true"/>, so no multiple allocations occur during the initialization.</para>
            </remarks>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.Cache`2"/> class from serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this deserialization.</param>
            <remarks><note type="inherit">If an inherited type serializes data, which may affect the hashes of the keys, then override
            the <see cref="M:KGySoft.Collections.Cache`2.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">OnDeserialization</see> method and use that to restore the data of the derived instance.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.Touch(`0)">
            <summary>
            Renews the value with the specified <paramref name="key"/> in the evaluation order.
            </summary>
            <param name="key">The key of the item to renew.</param>
            <remarks>
            <para><see cref="T:KGySoft.Collections.Cache`2"/> maintains an evaluation order for the stored elements. When the <see cref="T:KGySoft.Collections.Cache`2"/> is full
            (that is when <see cref="P:KGySoft.Collections.Cache`2.Count"/> equals to <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>), then adding a new element will drop the element, which is the first one in the evaluation order.
            By calling this method, the element with the specified <paramref name="key"/> will be sent to the back in the evaluation order.</para>
            <para>When <see cref="P:KGySoft.Collections.Cache`2.Behavior"/> is <see cref="F:KGySoft.Collections.CacheBehavior.RemoveLeastRecentUsedElement"/> (which is the default behavior), then whenever an existing element
            is accessed in the <see cref="T:KGySoft.Collections.Cache`2"/>, then it will be touched internally.</para>
            <para>This method approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key"/> does not exist in the <see cref="T:KGySoft.Collections.Cache`2"/>.</exception>
            <seealso cref="P:KGySoft.Collections.Cache`2.Behavior"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.RefreshValue(`0)">
            <summary>
            Refreshes the value of the <paramref name="key"/> in the <see cref="T:KGySoft.Collections.Cache`2"/> even if it already exists in the cache
            by using the item loader that was passed to the <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.
            </summary>
            <param name="key">The key of the item to refresh.</param>
            <remarks>
            <para>The loaded value will be stored in the <see cref="T:KGySoft.Collections.Cache`2"/>. If a value already existed in the cache for the given <paramref name="key"/>, then the value will be replaced.</para>
            <para><note type="caution">Do not use this method when the <see cref="T:KGySoft.Collections.Cache`2"/> was initialized without an item loader.</note></para>
            <para>To get the refreshed value as well, use <see cref="M:KGySoft.Collections.Cache`2.GetValueUncached(`0)"/> method instead.</para>
            <para>The cost of this method depends on the cost of the item loader function that was passed to the constructor. Refreshing the already loaded value approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The <see cref="T:KGySoft.Collections.Cache`2"/> has been initialized without an item loader.</exception>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.GetValueUncached(`0)">
            <summary>
            Loads the value of the <paramref name="key"/> even if it already exists in the <see cref="T:KGySoft.Collections.Cache`2"/>
            by using the item loader that was passed to the <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.
            </summary>
            <param name="key">The key of the item to reload.</param>
            <returns>A <typeparamref name="TValue"/> instance that was retrieved by the item loader that was used to initialize this <see cref="T:KGySoft.Collections.Cache`2"/> instance.</returns>
            <remarks>
            <para>To get a value from the <see cref="T:KGySoft.Collections.Cache`2"/>, and using the item loader only when <paramref name="key"/> does not exist in the cache,
            read the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> property.</para>
            <para>The loaded value will be stored in the <see cref="T:KGySoft.Collections.Cache`2"/>. If a value already existed in the cache for the given <paramref name="key"/>, then the value will be replaced.</para>
            <para><note type="caution">Do not use this method when the <see cref="T:KGySoft.Collections.Cache`2"/> was initialized without an item loader.</note></para>
            <para>The cost of this method depends on the cost of the item loader function that was passed to the constructor. Handling the already loaded value approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The <see cref="T:KGySoft.Collections.Cache`2"/> has been initialized without an item loader.</exception>
            <seealso cref="P:KGySoft.Collections.Cache`2.Item(`0)"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.ContainsValue(`1)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.Cache`2"/> contains a specific value.
            </summary>
            <param name="value">The value to locate in the <see cref="T:KGySoft.Collections.Cache`2"/>.
            The value can be <see langword="null"/> for reference types.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.Cache`2"/> contains an element with the specified <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="TValue"/> is an <see langword="enum"/> type,
            or the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other <typeparamref name="TValue"/> types.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.Reset">
            <summary>
            Clears the <see cref="T:KGySoft.Collections.Cache`2"/> and resets statistics.
            </summary>
            <remarks>
            <para>The <see cref="P:KGySoft.Collections.Cache`2.Count"/> property is set to 0, and references to other objects from elements of the collection are also released.
            The <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> remains unchanged. The statistics will be reset.</para>
            <para>This method is an O(1) operation.</para>
            </remarks>
            <seealso cref="M:KGySoft.Collections.Cache`2.Clear"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.GetStatistics">
            <summary>
            Gets an <see cref="T:KGySoft.Collections.ICacheStatistics"/> instance that provides statistical information about this <see cref="T:KGySoft.Collections.Cache`2"/>.
            </summary>
            <returns>An <see cref="T:KGySoft.Collections.ICacheStatistics"/> instance that provides statistical information about the <see cref="T:KGySoft.Collections.Cache`2"/>.</returns>
            <remarks>
            <para>The returned <see cref="T:KGySoft.Collections.ICacheStatistics"/> instance is a wrapper around the <see cref="T:KGySoft.Collections.Cache`2"/> and reflects any changes
            happened to the cache immediately. Therefore it is not necessary to call this method again whenever new statistics are required.</para>
            <para>This method is an O(1) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:KGySoft.Collections.Cache`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference types.</param>
            <remarks>
            <para>You need to call this method only when this <see cref="T:KGySoft.Collections.Cache`2"/> instance was initialized without using an item loader.
            Otherwise, you need only to read the get accessor of the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> property,
            which automatically invokes the item loader to add new items.</para>
            <para>If the <paramref name="key"/> of element already exists in the cache, this method throws an exception.
            In contrast, using the setter of the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> property replaces the old value with the new one.</para>
            <para>If you want to renew an element in the evaluation order, use the <see cref="M:KGySoft.Collections.Cache`2.Touch(`0)">Touch</see> method.</para>
            <para>If <see cref="P:KGySoft.Collections.Cache`2.EnsureCapacity"/> is <see langword="true"/> this method approaches an O(1) operation. Otherwise, when the capacity of the inner storage must be increased to accommodate the new element,
            this method becomes an O(n) operation, where n is <see cref="P:KGySoft.Collections.Cache`2.Count"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="key"/> already exists in the cache.</exception>
            <seealso cref="P:KGySoft.Collections.Cache`2.Item(`0)"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.Remove(`0)">
            <summary>
            Removes the value with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.Cache`2"/>.
            </summary>
            <param name="key">Key of the item to remove.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>. This method also returns <see langword="false"/> if key was not found in the <see cref="T:KGySoft.Collections.Cache`2"/>.</returns>
            <remarks><para>If the <see cref="T:KGySoft.Collections.Cache`2"/> does not contain an element with the specified key, the <see cref="T:KGySoft.Collections.Cache`2"/> remains unchanged. No exception is thrown.</para>
            <para>This method approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to gets the value associated with the specified <paramref name="key"/> without using the item loader passed to the <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.
            </summary>
            <returns>
            <see langword="true"/>, if cache contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <remarks>
            <para>Use this method if the <see cref="T:KGySoft.Collections.Cache`2"/> was initialized without an item loader, or when you want to determine if a
            <paramref name="key"/> exists in the <see cref="T:KGySoft.Collections.Cache`2"/> and if so, you want to get the value as well.
            Reading the <see cref="P:KGySoft.Collections.Cache`2.Item(`0)">indexer</see> property would transparently load a non-existing element by
            calling the item loader delegate that was passed to the <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.</para>
            <para>Works exactly the same way as in case of <see cref="T:System.Collections.Generic.Dictionary`2"/> class. If <paramref name="key"/> is not found, does not use the
            item loader passed to the constructor.</para>
            <para>If the <paramref name="key"/> is not found, then the <paramref name="value"/> parameter gets the appropriate default value
            for the type <typeparamref name="TValue"/>; for example, 0 (zero) for integer types, <see langword="false"/> for Boolean types, and <see langword="null"/> for reference types.</para>
            <para>This method approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <seealso cref="P:KGySoft.Collections.Cache`2.Item(`0)"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.Cache`2"/> contains a specific key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:KGySoft.Collections.Cache`2"/>.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.Cache`2"/> contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.</returns>
            <remarks><para>This method approaches an O(1) operation.</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:KGySoft.Collections.Cache`2"/>.
            </summary>
            <remarks>
            <para>The <see cref="P:KGySoft.Collections.Cache`2.Count"/> property is set to 0, and references to other objects from elements of the collection are also released.
            The <see cref="P:KGySoft.Collections.Cache`2.Capacity"/> remains unchanged.</para>
            <para>This method is an O(1) operation.</para>
            </remarks>
            <seealso cref="M:KGySoft.Collections.Cache`2.Reset"/>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:KGySoft.Collections.Cache`2"/> elements in the evaluation order.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the <see cref="T:KGySoft.Collections.Cache`2"/>.
            </returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">
            <summary>
            Gets a thread safe accessor for this <see cref="T:KGySoft.Collections.Cache`2"/> instance. As it provides only a
            single readable indexer, it makes sense only if an item loader was passed to the appropriate
            <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>
            and the cache will not be accessed by other members but via the returned accessor.
            </summary>
            <param name="protectItemLoader"><see langword="true"/> to ensure that also the item loader is locked if a new element has to be loaded and
            <see langword="false"/> to allow the item loader to be called concurrently. In latter case the <see cref="T:KGySoft.Collections.Cache`2"/> is not locked during the time the item loader is being called
            but it can happen that values for same key are loaded multiple times and all but one will be discarded. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance providing a thread-safe readable indexer for this <see cref="T:KGySoft.Collections.Cache`2"/> instance.</returns>
            <remarks>
            <note type="tip">
            <list type="bullet">
            <item>To create a thread-safe <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance that fits the best for your needs use the members of the <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/> class.</item>
            <item>To access all <see cref="T:System.Collections.Generic.IDictionary`2"/> members of the <see cref="T:KGySoft.Collections.Cache`2"/> in a thread-safe manner use it via a <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance.</item>
            </list></note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            In a derived class populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the additional data of the derived type needed to serialize the target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization.</param>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">
            <summary>
            In a derived class restores the state the deserialized instance.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.DropFirst">
            <summary>
            Removes the first (oldest or the least used) item from the cache.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.Cache`2.Insert(`0,`1,System.Boolean)">
            <summary>
            Inserting a new element into the cache
            </summary>
        </member>
        <member name="T:KGySoft.Collections.BinarySearchHelper`1">
            <summary>
            Base class for performing binary search on a <see cref="T:KGySoft.Collections.CircularList`1"/>. This class uses a comparer for the search.
            This class accesses the <see cref="T:KGySoft.Collections.CircularList`1"/> through its indexer, so it is slower than Array.BinarySearch, so used only when section to search is wrapped.
            Not a nested private class because must have its own generic parameter due to the derived <see cref="T:KGySoft.Collections.ComparableBinarySearchHelper`1"/>.
            </summary>
            <typeparam name="T">Same as T in <see cref="T:KGySoft.Collections.CircularList`1"/>.</typeparam>
        </member>
        <member name="M:KGySoft.Collections.BinarySearchHelper`1.BinarySearchWithComparer(KGySoft.Collections.CircularList{`0},System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Performs a binary search on the list using the comparer.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.BinarySearchHelper`1.BinarySearch(KGySoft.Collections.CircularList{`0},System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Performs a binary search on the list using the comparer or the default comparer, when comparer is null.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ComparableBinarySearchHelper`1">
            <summary>
            Helper class for performing binary search on a <see cref="T:KGySoft.Collections.CircularList`1"/>. This class can handles elements as <see cref="T:System.IComparable`1"/> instances.
            This class accesses the <see cref="T:KGySoft.Collections.CircularList`1"/> through its indexer, so it is slower than Array.BinarySearch, so used only when section to search is wrapped.
            Not a nested private class because must have its own generic parameter due to the <see cref="T:System.IComparable`1"/> constraint.
            </summary>
            <typeparam name="TComparable">Represents a <see cref="T:System.IComparable`1"/> type.</typeparam>
        </member>
        <member name="M:KGySoft.Collections.ComparableBinarySearchHelper`1.BinarySearchAsComparable(KGySoft.Collections.CircularList{`0},System.Int32,System.Int32,`0)">
            <summary>
            Performs a binary search on the list. Elements are constrained to be <see cref="T:System.IComparable`1"/> instances.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ComparableBinarySearchHelper`1.BinarySearch(KGySoft.Collections.CircularList{`0},System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Performs a binary search on the list. When comparer is specified, it is used, otherwise, using <see cref="M:System.IComparable`1.CompareTo(`0)"/> on elements.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CircularList`1">
            <summary>
            Implements an <see cref="T:System.Collections.Generic.IList`1"/> where inserting/removing at the beginning/end position are O(1) operations.
            <see cref="T:KGySoft.Collections.CircularList`1"/> is fully compatible with <see cref="T:System.Collections.Generic.List`1"/> but has a better performance in several cases.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <remarks>
            <para>Circularity means a dynamic start/end position in the internal store. If inserting/removing elements is required typically
            at the first/last position, then using <see cref="T:KGySoft.Collections.CircularList`1"/> could be a good choice because these operations have an O(1) cost. Inserting/removing at
            other positions have generally O(n) cost, though these operations are optimized for not moving more than n/2 elements.</para>
            <para><see cref="T:KGySoft.Collections.CircularList`1"/> is fully compatible with <see cref="T:System.Collections.Generic.List`1"/> as it implements all of the public members of <see cref="T:System.Collections.Generic.List`1"/>.</para>
            <para><see cref="T:KGySoft.Collections.CircularList`1"/> can be a good option instead of <see cref="T:System.Collections.Generic.LinkedList`1"/>, too. Generally <see cref="T:System.Collections.Generic.LinkedList`1"/> is considered
            to be a good choice when elements should be inserted/removed at the middle of the list. However, unless a direct reference is kept to a
            <see cref="T:System.Collections.Generic.LinkedListNode`1"/> to be removed or before/after which the new element has to be inserted, then the insert/remove operation will be
            very slow in <see cref="T:System.Collections.Generic.LinkedList`1"/>, as it has no indexed access, and the node has to be located by iterating the elements. Therefore in most cases
            <see cref="T:KGySoft.Collections.CircularList`1"/> outperforms <see cref="T:System.Collections.Generic.LinkedList`1"/> in most practical cases.</para>
            <para>Adding elements to the first/last position are generally O(1) operations. If the capacity needs to be increased to accommodate the
            new element, adding becomes an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>. Though when elements are continuously added to the list,
            the amortized cost of adding methods (<see cref="M:KGySoft.Collections.CircularList`1.Add(`0)">Add</see>, <see cref="M:KGySoft.Collections.CircularList`1.AddLast(`0)">AddLast</see>, <see cref="M:KGySoft.Collections.CircularList`1.AddFirst(`0)">AddFirst</see> or <see cref="M:KGySoft.Collections.CircularList`1.Insert(System.Int32,`0)">Insert</see>
            at the first/last position) is O(1) due to the low frequency of increasing capacity. For example, when 20 million
            items are added to a <see cref="T:KGySoft.Collections.CircularList`1"/> that was created by the default constructor, capacity is increased only 23 times.</para>
            <para>Inserting more elements are also optimized. If the length of the <see cref="T:KGySoft.Collections.CircularList`1"/> is n and the length of the collection to insert is m, then the cost of <see cref="M:KGySoft.Collections.CircularList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">InsertRange</see>
            to the first or last position is O(m). When the collection is inserted in the middle of the <see cref="T:KGySoft.Collections.CircularList`1"/>, the cost is O(Max(n, m)), and in practice no more than n/2 elements are moved in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            In contrast, inserting a collection into the first position of a <see cref="T:System.Collections.Generic.List`1"/> moves all of the already existing elements. And if the collection to insert does not implement <see cref="T:System.Collections.Generic.ICollection`1"/>, then
            <see cref="T:System.Collections.Generic.List`1"/> works with an O(n * m) cost as it will insert the elements one by one, shifting the elements by 1 in every iteration.</para>
            <para><see cref="T:KGySoft.Collections.CircularList`1"/> provides an O(1) solution also for emptying the collection: the <see cref="M:KGySoft.Collections.CircularList`1.Reset">Reset</see> method clears all elements and resets the internal capacity to 0 in one
            quick step. The effect is the same as calling the <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> and <see cref="M:KGySoft.Collections.CircularList`1.TrimExcess">TrimExcess</see> methods in a row but the latter solution has an O(n) cost.</para>
            <para>When a list is populated only by the <see cref="M:KGySoft.Collections.CircularList`1.Add(`0)">Add</see> method or by the indexer, and then it is never modified, <see cref="T:System.Collections.Generic.List`1"/> class can have a slightly better
            performance. Though when the list is enumerated as an <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation (occurs for example, when the list is used in LINQ queries or when used
            as an <see cref="T:System.Collections.Generic.IList`1"/> instance), then <see cref="T:KGySoft.Collections.CircularList`1"/> can be a better choice than <see cref="T:System.Collections.Generic.List`1"/> because the enumerator of
            <see cref="T:System.Collections.Generic.List`1"/> class has worse performance when it is boxed into an <see cref="T:System.Collections.Generic.IEnumerator`1"/> reference. While the <see cref="M:KGySoft.Collections.CircularList`1.GetEnumerator">GetEnumerator</see> method of
            <see cref="T:KGySoft.Collections.CircularList`1"/> returns a value type enumerator (similarly to the <see cref="T:System.Collections.Generic.List`1"/> class), when the enumerator is obtained via the <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            interface, the <see cref="T:KGySoft.Collections.CircularList`1"/> returns a reference type to avoid boxing and to provide a better performance.
            </para>
            </remarks>
            <div style="display:none"><example/></div>
        </member>
        <member name="T:KGySoft.Collections.CircularList`1.ComparisonWrapper">
            <summary>
            Wraps a <see cref="T:System.Comparison`1"/> delegate into an <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CircularList`1.EnumeratorAsReference">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.CircularList`1"/>. This enumerator is exactly the same as <see cref="T:KGySoft.Collections.CircularList`1.Enumerator"/>,
            but is implemented as a reference type. This is returned when enumerator is requested as an <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface
            to avoid performance hit of boxing.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CircularList`1.SimpleEnumeratorAsReference">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.CircularList`1"/> when start index is 0. This enumerator is returned when enumerator is
            requested as an <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface to avoid performance hit of boxing.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CircularList`1.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.CircularList`1.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Enumerator.Dispose">
            <summary>
            Releases the enumerator
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="P:KGySoft.Collections.CircularList`1.Capacity">
            <summary>
            Gets or sets the actual size of the internal storage of held elements.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity is set to a value that is less than <see cref="P:KGySoft.Collections.CircularList`1.Count"/>. </exception>
            <remarks>
            <para>Capacity is the number of elements that the <see cref="T:KGySoft.Collections.CircularList`1"/> can store before resizing is required, whereas
            <see cref="P:KGySoft.Collections.CircularList`1.Count"/> is the number of elements that are actually in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</para>
            <para>Capacity is always greater than or equal to <see cref="P:KGySoft.Collections.CircularList`1.Count"/>. If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> exceeds <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> while adding elements,
            the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.</para>
            <para>If the capacity is significantly larger than the count and you want to reduce the memory used by the <see cref="T:KGySoft.Collections.CircularList`1"/>,
            you can decrease capacity by calling the <see cref="M:KGySoft.Collections.CircularList`1.TrimExcess">TrimExcess</see> method or by setting the <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> property explicitly.
            When the value of <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> is set explicitly, the internal array is also reallocated to accommodate the specified capacity,
            and all the elements are copied.</para>
            <para>Retrieving the value of this property is an O(1) operation; setting the property is an O(n) operation, where n is the number of stored elements.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.CircularList`1.Count">
            <summary>
            Gets the number of elements contained in the list.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.CircularList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero or greater or equal to <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.#ctor">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularList`1"/> that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularList`1"/> with the elements of provided <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> of the <see cref="T:KGySoft.Collections.CircularList`1"/> is at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
            <returns>The new capacity of the <see cref="T:KGySoft.Collections.CircularList`1"/>.</returns>
            <remarks>
            <para>If the specified <paramref name="capacity"/> is less than or equal to the current <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, then the <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> is left unchanged.</para>
            <para>If the specified <paramref name="capacity"/> is less than twice of the current <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, then current <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> is doubled.</para>
            <para>If the specified <paramref name="capacity"/> is at least twice of the current <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, then <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> is set to the specified <paramref name="capacity"/>.</para>
            <para>If capacity is changed, then this method is an O(n) operation where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>. If capacity is not changed, then this method is an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> must not be negative.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the list, if that number (<see cref="P:KGySoft.Collections.CircularList`1.Count"/>) is less than the 90 percent of <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>.
            </summary>
            <remarks>
            <para>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.
            The cost of reallocating and copying a large list can be considerable, however, so the <see cref="M:KGySoft.Collections.CircularList`1.TrimExcess">TrimExcess</see> method does nothing if the list is
            at more than 90 percent of capacity. This avoids incurring a large reallocation cost for a relatively small gain.</para>
            <para>This method is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</para>
            <para>To reset a list to its initial state, call the <see cref="M:KGySoft.Collections.CircularList`1.Reset">Reset</see> method. Calling the <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> and <see cref="M:KGySoft.Collections.CircularList`1.TrimExcess">TrimExcess</see> methods has the same effect; however,
            <see cref="M:KGySoft.Collections.CircularList`1.Reset">Reset</see> method is an O(1) operation, while <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> is an O(n) operation. Trimming an empty list sets the capacity of the list to 0.</para>
            <para>The capacity can also be set using the <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> property.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Add(`0)">
            <summary>
            Adds an <paramref name="item"/> to the end of the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="item">The item to add to the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <remarks>
            <para><see cref="T:KGySoft.Collections.CircularList`1"/> accepts <see langword="null"/> as a valid value for reference and nullable types and allows duplicate elements.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> already equals <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, the capacity of the list is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> is less than <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, this method is an O(1) operation. If the capacity needs to be increased to accommodate the
            new element, this method becomes an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.
            When adding elements continuously, the amortized cost of this method is O(1) due to the low frequency of increasing capacity. For example, when 20 million
            items are added to a <see cref="T:KGySoft.Collections.CircularList`1"/> that was created by the default constructor, capacity is increased only 23 times.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.AddLast(`0)">
            <summary>
            Adds an <paramref name="item"/> to the end of the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="item">The item to add to the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <remarks>
            <para><see cref="T:KGySoft.Collections.CircularList`1"/> accepts <see langword="null"/> as a valid value for reference and nullable types and allows duplicate elements.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> already equals <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, the capacity of the list is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> is less than <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, this method is an O(1) operation. If the capacity needs to be increased to accommodate the
            new element, this method becomes an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.
            When adding elements continuously, the amortized cost of this method is O(1) due to the low frequency of increasing capacity. For example, when 20 million
            items are added to a <see cref="T:KGySoft.Collections.CircularList`1"/> that was created by the default constructor, capacity is increased only 23 times.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.AddFirst(`0)">
            <summary>
            Adds an <paramref name="item"/> to the beginning of the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="item">The item to add to the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <remarks>
            <para><see cref="T:KGySoft.Collections.CircularList`1"/> accepts <see langword="null"/> as a valid value for reference and nullable types and allows duplicate elements.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> already equals <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, the capacity of the list is increased by automatically reallocating the internal array,
            and the existing elements are copied to the new array before the new element is added.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularList`1.Count"/> is less than <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/>, this method is an O(1) operation. If the capacity needs to be increased to accommodate the
            new element, this method becomes an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.
            When adding elements continuously, the amortized cost of this method is O(1) due to the low frequency of increasing capacity. For example, when 20 million
            items are added to a <see cref="T:KGySoft.Collections.CircularList`1"/> that was created by the default constructor, capacity is increased only 23 times.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a <paramref name="collection"/> to the end of the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="collection">The collection to add to the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <remarks>
            <para>If the length of the <see cref="T:KGySoft.Collections.CircularList`1"/> is n and the length of the collection to insert is m, then this method has O(m) cost.</para>
            <para>If capacity increase is needed (considering actual list size) the cost is O(Max(n, m)).</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> must not be <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an <paramref name="item"/> to the <see cref="T:KGySoft.Collections.CircularList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the list.</exception>
            <remarks>Inserting an item at the first or last position are O(1) operations if no capacity increase is needed. Otherwise, insertion is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a <paramref name="collection"/> into the <see cref="T:KGySoft.Collections.CircularList`1"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="collection">The collection to insert into the list.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> must not be <see langword="null"/>.</exception>
            <remarks>
            <para>If the length of the <see cref="T:KGySoft.Collections.CircularList`1"/> is n and the length of the collection to insert is m, then inserting to the first or last position has O(m) cost.</para>
            <para>If capacity increase is needed (considering actual list size), or when the collection is inserted in the middle of the <see cref="T:KGySoft.Collections.CircularList`1"/>, the cost is O(Max(n, m)), and in practice no more than n/2 elements are moved.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of the specific <paramref name="item"/> from the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <returns>
            <see langword="true"/> if <paramref name="item"/> was successfully removed from the <see cref="T:KGySoft.Collections.CircularList`1"/>; otherwise, <see langword="false"/>.
            This method also returns false if <paramref name="item"/> is not found in the original list.
            </returns>
            <remarks>
            <para>If the position of the element to remove is known it is recommended to use the <see cref="M:KGySoft.Collections.CircularList`1.RemoveAt(System.Int32)">RemoveAt</see> method instead.</para>
            <para>This method has an O(n) cost.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveLast">
            <summary>
            Removes the last element from the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <returns><see langword="true"/>, if the list was not empty before the removal, otherwise, <see langword="false"/>.</returns>
            <remarks>This method has an O(1) cost.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveFirst">
            <summary>
            Removes the first element of the see <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <returns><see langword="true"/>, if the list was not empty before the removal, otherwise, <see langword="false"/>.</returns>
            <remarks>This method has an O(1) cost.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item from the <see cref="T:KGySoft.Collections.CircularList`1"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <remarks>Removing an item at the first or last position are O(1) operations. At other positions removal is an O(n) operation, though
            the method is optimized for not moving more than n/2 elements.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes <paramref name="count"/> amount of items from the <see cref="T:KGySoft.Collections.CircularList`1"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            <br/>-or-
            <br/><paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> and <paramref name="count"/> do not denote a valid range of elements in the list.</exception>
            <remarks>Removing items at the first or last positions are O(1) operations considering list size. At other positions removal is an O(n) operation, though
            the method is optimized for not moving more than n/2 elements.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements from the <see cref="T:KGySoft.Collections.CircularList`1"/> that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1"/> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements removed from the list.</returns>
            <remarks>
            <para>The <see cref="T:System.Predicate`1"/> is a delegate to a method that returns <see langword="true"/> if the object passed to it matches the conditions defined in the delegate.
            The elements of the current <see cref="T:KGySoft.Collections.CircularList`1"/> are individually passed to the <see cref="T:System.Predicate`1"/> delegate, and the elements that match the conditions
            are removed from the list.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="match"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Clear">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <remarks>
            <para><see cref="P:KGySoft.Collections.CircularList`1.Count"/> is set to 0, and references to other objects from elements of the collection are also released.</para>
            <para>If <typeparamref name="T"/> is a value type and contains no managed references, then this method is an O(1) operation.
            Otherwise, this method is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</para>
            <para><see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> remains unchanged. To reset the capacity of the list to 0 as well, call the <see cref="M:KGySoft.Collections.CircularList`1.Reset"/> method instead, which is an O(1) operation.
            Calling <see cref="M:KGySoft.Collections.CircularList`1.TrimExcess">TrimExcess</see> after <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> also resets the list, though <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> has more cost.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Reset">
            <summary>
            Removes all items from the list and resets the <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> of the list to 0.
            </summary>
            <remarks>
            <para><see cref="P:KGySoft.Collections.CircularList`1.Count"/> and <see cref="P:KGySoft.Collections.CircularList`1.Capacity"/> are set to 0, and references to other objects from elements of the collection are also released.</para>
            <para>This method is an O(1) operation.</para>
            <para>Calling <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> and then <see cref="M:KGySoft.Collections.CircularList`1.TrimExcess">TrimExcess</see> methods also resets the list, though <see cref="M:KGySoft.Collections.CircularList`1.Clear">Clear</see> is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ReplaceRange(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes <paramref name="count"/> amount of items from the <see cref="T:KGySoft.Collections.CircularList`1"/> at the specified <paramref name="index"/> and
            inserts the specified <paramref name="collection"/> at the same position. The number of elements in <paramref name="collection"/> can be different from the amount of removed items.
            </summary>
            <param name="index">The zero-based index of the first item to remove and also the index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="count">The number of items to remove.</param>
            <param name="collection">The collection to insert into the list.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> must not be <see langword="null"/>.</exception>
            <remarks>
            <para>If the length of the <see cref="T:KGySoft.Collections.CircularList`1"/> is n and the length of the collection to insert is m, then replacement at the first or last position has O(m) cost.</para>
            <para>If the elements to remove and to add have the same size, then the cost is O(m) at any position.</para>
            <para>If capacity increase is needed (considering actual list size), or when the replacement of different amount of elements to remove and insert is performed in the middle of the <see cref="T:KGySoft.Collections.CircularList`1"/>, the cost is O(Max(n, m)), and in practice no more than n/2 elements are moved.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Contains(`0)">
            <summary>
            Determines whether the list contains the specific <paramref name="item"/>.
            </summary>
            <returns>
            <see langword="true"/> if <paramref name="item"/> is found in the <see cref="T:KGySoft.Collections.CircularList`1"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
            <remarks>
            <para>The list is searched forward starting at the first element and ending at the last element.</para>
            <para>Only in .NET Framework, this method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="T"/> is an <see langword="enum"/> type.
            Otherwise, the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> will be used.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.IndexOf(`0,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the range
            of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that extends from the specified index to the last element.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <param name="index">The zero-based starting index of the search.</param>
            <returns>
            The zero-based index of the first occurrence of item within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/>
            that extends from index to the last element, if found; otherwise, –1.
            </returns>
            <para>The list is searched forward starting at <paramref name="index"/> and ending at the last element.</para>
            <para>Only in .NET Framework, this method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="T"/> is an <see langword="enum"/> type.
            Otherwise, the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> will be used.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the range
            of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <param name="index">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <returns>
            The index of <paramref name="item"/> if found within the range of elements in the list that starts at <paramref name="index"/>
            and contains <paramref name="count"/> number of elements, if found; otherwise, -1.
            </returns>
            <para>The list is searched forward starting at <paramref name="index"/> and ending at <paramref name="index"/> plus <paramref name="count"/> minus 1,
            if <paramref name="count"/> is greater than 0.</para>
            <para>Only in .NET Framework, this method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="T"/> is an <see langword="enum"/> type.
            Otherwise, the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> will be used.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.LastIndexOf(`0)">
            <summary>
            Determines the index of the last occurrence of a specific item in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <returns>
            The index of the last occurrence of the <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
            <para>The list is searched backward starting at the last element and ending at the first element.</para>
            <para>Only in .NET Framework, this method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="T"/> is an <see langword="enum"/> type.
            Otherwise, the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> will be used.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that
            extends from the first element to the specified <paramref name="index"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <param name="index">The zero-based starting index of the backward search.</param>
            <returns>
            The zero-based index of the last occurrence of <paramref name="item"/> within the range of elements in the list that extends from the first element to <paramref name="index"/>, if found; otherwise, –1.
            </returns>
            <para>The list is searched backward starting at <paramref name="index"/> and ending at the first element.</para>
            <para>Only in .NET Framework, this method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="T"/> is an <see langword="enum"/> type.
            Otherwise, the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> will be used.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that
            contains the specified number of elements and ends at the specified <paramref name="index"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <param name="index">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <returns>
            The zero-based index of the last occurrence of <paramref name="item"/> within the range of elements in the list that contains <paramref name="count"/> number of elements and ends at <paramref name="item"/>, if found; otherwise, –1.
            </returns>
            <para>The list is searched backward starting at the last element and ending at the first element.</para>
            <para>Only in .NET Framework, this method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="T"/> is an <see langword="enum"/> type.
            Otherwise, the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> will be used.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the zero-based index of the first occurrence within the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, –1.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based
            index of the first occurrence within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that extends from the specified index to the last element.
            </summary>
            <param name="index">The zero-based starting index of the search.</param>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, –1.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of
            the first occurrence within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="index">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, –1.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the zero-based index of the last occurrence within the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, –1.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index
            of the last occurrence within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that extends from the first element to the specified index.
            </summary>
            <param name="index">The zero-based starting index of the backward search.</param>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, –1.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of
            the last occurrence within the range of elements in the <see cref="T:KGySoft.Collections.CircularList`1"/> that contains the specified number of elements and ends at the specified index.
            </summary>
            <param name="index">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match"/>, if found; otherwise, –1.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Exists(System.Predicate{`0})">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.CircularList`1"/> contains elements that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">The delegate that defines the conditions of the elements to search for.</param>
            <returns><see langword="true"/> if the list contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false"/>.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Find(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the first occurrence within the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The first element that matches the conditions defined by the specified predicate, if found;
            otherwise, the default value for type <typeparamref name="T"/>.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindLast(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the last occurrence within the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>The last element that matches the conditions defined by the specified predicate, if found;
            otherwise, the default value for type <typeparamref name="T"/>.</returns>
            <remarks>This method performs a linear search; therefore, this method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.FindAll(System.Predicate{`0})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">A delegate that defines the conditions of the element to search for.</param>
            <returns>A <see cref="T:KGySoft.Collections.CircularList`1"/> containing all the elements that match the conditions defined by the specified predicate, if found;
            otherwise, an empty <see cref="T:KGySoft.Collections.CircularList`1"/>.</returns>
            <remarks>This method is an O(n) operation.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.BinarySearch(`0)">
            <summary>
            Searches the entire sorted list for an element using the default comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be <see langword="null"/> for reference types.</param>
            <returns>The zero-based index of <paramref name="item"/> in the sorted <see cref="T:KGySoft.Collections.CircularList`1"/>, if <paramref name="item"/> is found; otherwise, a negative number
            that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</returns>
            <remarks>
            <para>If <typeparamref name="T"/> is an <see langword="enum"/>, this method uses the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>; otherwise,
            the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for type <typeparamref name="T"/> to determine the order of list elements.
            The <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> property checks whether type <typeparamref name="T"/> implements the <see cref="T:System.IComparable`1"/> generic interface
            and uses that implementation, if available. If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether type <typeparamref name="T"/> implements
            the <see cref="T:System.IComparable"/> interface. If type <typeparamref name="T"/> does not implement either interface, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see>
            throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>The list must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</para>
            <para>Comparing <see langword="null"/> with any reference type is allowed and does not generate an exception when using the <see cref="T:System.IComparable`1"/> generic interface. When sorting, <see langword="null"/> is considered to be less than any other object.</para>
            <para>If the list contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</para>
            <para>If the list does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the <see cref="T:KGySoft.Collections.CircularList`1"/>, this index should be used as the insertion point to maintain the sort order.</para>
            <para>This method is an O(log n) operation, where n is the number of elements in the range.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find an implementation of the <see cref="T:System.IComparable`1"/> generic interface or the <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the entire sorted <see cref="T:KGySoft.Collections.CircularList`1"/> for an element using the specified comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be <see langword="null"/> for reference types.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements, or <see langword="null"/> to use the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer"/> for <see langword="enum"/> element types, or the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/> for other element types.</param>
            <returns>The zero-based index of <paramref name="item"/> in the sorted list, if <paramref name="item"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</returns>
            <remarks>
            <para>The <paramref name="comparer"/> customizes how the elements are compared. For example, you can use a <see cref="T:System.Collections.CaseInsensitiveComparer"/> instance as the comparer to perform case-insensitive string searches.</para>
            <para>If <paramref name="comparer"/> is provided, the elements of the list are compared to the specified value using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.</para>
            <para>If comparer is <see langword="null"/>, then if <typeparamref name="T"/> is an <see langword="enum"/>, this method uses the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>; otherwise,
            the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for type <typeparamref name="T"/> to determine the order of list elements.
            The <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> property checks whether type <typeparamref name="T"/> implements the <see cref="T:System.IComparable`1"/> generic interface
            and uses that implementation, if available. If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether type <typeparamref name="T"/> implements
            the <see cref="T:System.IComparable"/> interface. If type <typeparamref name="T"/> does not implement either interface, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see>
            throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>The list must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</para>
            <para>If comparer is <see langword="null"/>, comparing <see langword="null"/> with any reference type is allowed and does not generate an exception when using the <see cref="T:System.IComparable`1"/> generic interface. When sorting, <see langword="null"/> is considered to be less than any other object.</para>
            <para>If the list contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</para>
            <para>If the list does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the <see cref="T:KGySoft.Collections.CircularList`1"/>, this index should be used as the insertion point to maintain the sort order.</para>
            <para>This method is an O(log n) operation, where n is the number of elements in the range.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException"><paramref name="comparer"/> is <see langword="null"/>, and the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find an implementation of the <see cref="T:System.IComparable`1"/> generic interface or the <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a range of elements in the sorted <see cref="T:KGySoft.Collections.CircularList`1"/> for an element using the specified <paramref name="comparer"/> and returns the zero-based index of the element.
            </summary>
            <param name="index">The zero-based starting index of the range to search.</param>
            <param name="count">The length of the range to search.</param>
            <param name="item">The object to locate. The value can be <see langword="null"/> for reference types.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements, or <see langword="null"/> to use the
            <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> for <see langword="enum"/> element types, or the default comparer
            <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for other element types.</param>
            <returns>The zero-based index of <paramref name="item"/> in the sorted list, if <paramref name="item"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of <see cref="P:KGySoft.Collections.CircularList`1.Count"/>.</returns>
            <remarks>
            <para>The <paramref name="comparer"/> customizes how the elements are compared. For example, you can use a <see cref="T:System.Collections.CaseInsensitiveComparer"/> instance as the comparer to perform case-insensitive string searches.</para>
            <para>If <paramref name="comparer"/> is provided, the elements of the list are compared to the specified value using the specified <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.</para>
            <para>If comparer is <see langword="null"/>, then if <typeparamref name="T"/> is an <see langword="enum"/>, this method uses the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>; otherwise,
            the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for type <typeparamref name="T"/> to determine the order of list elements.
            The <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> property checks whether type <typeparamref name="T"/> implements the <see cref="T:System.IComparable`1"/> generic interface
            and uses that implementation, if available. If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether type <typeparamref name="T"/> implements
            the <see cref="T:System.IComparable"/> interface. If type <typeparamref name="T"/> does not implement either interface, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see>
            throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>The list must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</para>
            <para>If comparer is <see langword="null"/>, comparing <see langword="null"/> with any reference type is allowed and does not generate an exception when using the <see cref="T:System.IComparable`1"/> generic interface. When sorting, <see langword="null"/> is considered to be less than any other object.</para>
            <para>If the list contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</para>
            <para>If the list does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the <see cref="T:KGySoft.Collections.CircularList`1"/>, this index should be used as the insertion point to maintain the sort order.</para>
            <para>This method is an O(log n) operation, where n is the number of elements in the range.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0.
            <br/>-or-
            <br/><paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> and <paramref name="count"/> do not denote a valid range in the list.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="comparer"/> is <see langword="null"/>, and the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/> cannot find an implementation of the <see cref="T:System.IComparable`1"/> generic interface or the <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ToArray">
            <summary>
            Copies the elements of the list to a new array.
            </summary>
            <returns>An array containing copies of the elements of the list.</returns>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.AsReadOnly">
            <summary>
            Returns a read-only <see cref="T:System.Collections.Generic.IList`1"/> wrapper for the current collection.
            </summary>
            <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> that acts as a read-only wrapper around the current <see cref="T:KGySoft.Collections.CircularList`1"/>.</returns>
            <remarks>
            <para>To prevent any modifications to <see cref="T:KGySoft.Collections.CircularList`1"/>, expose <see cref="T:KGySoft.Collections.CircularList`1"/> only through this wrapper.
            A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> does not expose methods that modify the collection. However, if changes are made to the underlying <see cref="T:KGySoft.Collections.CircularList`1"/>,
            the read-only collection reflects those changes.</para>
            <para>This method is an O(1) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            Converts the elements in the current list to another type, and returns a <see cref="T:KGySoft.Collections.CircularList`1"/> containing the converted elements.
            </summary>
            <typeparam name="TOutput">The type of the elements of the target list.</typeparam>
            <param name="converter">A <see cref="T:System.Converter`2"/> delegate that converts each element from one type to another type.</param>
            <returns>A <see cref="T:KGySoft.Collections.CircularList`1"/> of the target type containing the converted elements from the current list.</returns>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire <see cref="T:KGySoft.Collections.CircularList`1"/> to a compatible one-dimensional array, starting at a particular array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0 equal to or greater than the length of <paramref name="array"/>.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source list is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the <see cref="T:KGySoft.Collections.CircularList`1"/> to a compatible one-dimensional array, starting at the specified index of the target array.
            </summary>
            <param name="index">The zero-based index in the source list at which copying begins.</param>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <param name="count">The number of elements to copy.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.
            <br/>-or-<br/>
            <paramref name="arrayIndex"/> is less than 0.
            <br/>-or-<br/>
            <paramref name="count"/> is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
            <br/>-or-<br/>
            The number of elements in the source list is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Reverse">
            <summary>
            Reverses the order of the elements in the entire <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the order of the elements in the specified range.
            </summary>
            <param name="index">The zero-based starting index of the range to reverse.</param>
            <param name="count">The number of elements in the range to reverse.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the list.
            <br/>-or-
            <br/><paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> and <paramref name="count"/> do not denote a valid range of elements in the list.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Sort">
            <summary>
            Sorts the elements in the entire <see cref="T:KGySoft.Collections.CircularList`1"/> using the default comparer.
            </summary>
            <remarks>
            <para>If <typeparamref name="T"/> is an <see langword="enum"/>, this method uses
            the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>; otherwise, the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether type <typeparamref name="T"/>
            implements the <see cref="T:System.IComparable`1"/> generic interface and uses that implementation, if available. If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks
            whether type <typeparamref name="T"/> implements the <see cref="T:System.IComparable"/> interface.
            If type <typeparamref name="T"/> does not implement either interface, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
            In contrast, a stable sort preserves the order of elements that are equal.</para>
            <para>On average, this method is an O(n log n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>; in the worst case it is an O(n ^ 2) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in the entire <see cref="T:KGySoft.Collections.CircularList`1"/> using the specified <paramref name="comparer"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements, or <see langword="null"/> 
            to use the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.</param>
            <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparer"/> caused an error during the sort.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="comparer"/> is <see langword="null"/>, and the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/>
            cannot find implementation of the <see cref="T:System.IComparable`1"/> generic interface or the <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.</exception>
            <remarks>
            <para>If comparer is <see langword="null"/>, then if <typeparamref name="T"/> is an <see langword="enum"/>, this method uses
            the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>; otherwise, the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether type <typeparamref name="T"/>
            implements the <see cref="T:System.IComparable`1"/> generic interface and uses that implementation, if available. If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks
            whether type <typeparamref name="T"/> implements the <see cref="T:System.IComparable"/> interface.
            If type <typeparamref name="T"/> does not implement either interface, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
            In contrast, a stable sort preserves the order of elements that are equal.</para>
            <para>On average, this method is an O(n log n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>; in the worst case it is an O(n ^ 2) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Sort(System.Comparison{`0})">
            <summary>
            Sorts the elements in the entire <see cref="T:KGySoft.Collections.CircularList`1"/> using the specified <see cref="T:System.Comparison`1"/>.
            </summary>
            <param name="comparison">The <see cref="T:System.Comparison`1"/> to use when comparing elements.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparison"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparison"/> caused an error during the sort.</exception>
            <remarks>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
            In contrast, a stable sort preserves the order of elements that are equal.</para>
            <para>On average, this method is an O(n log n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>; in the worst case it is an O(n ^ 2) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a range of elements in <see cref="T:KGySoft.Collections.CircularList`1"/> using the specified <paramref name="comparer"/>.
            </summary>
            <param name="index">The zero-based starting index of the range to sort.</param>
            <param name="count">The length of the range to sort.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing elements, or <see langword="null"/> 
            to use the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0.
            <br/>-or-<br/><paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> and <paramref name="count"/> do not specify a valid range in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            <br/>-or-<br/><paramref name="count"/>The implementation of <paramref name="comparer"/> caused an error during the sort.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="comparer"/> is <see langword="null"/>, and the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default"/>
            cannot find implementation of the <see cref="T:System.IComparable`1"/> generic interface or the <see cref="T:System.IComparable"/> interface for type <typeparamref name="T"/>.</exception>
            <remarks>
            <para>If comparer is <see langword="null"/>, then if <typeparamref name="T"/> is an <see langword="enum"/>, this method uses
            the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>; otherwise, the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether type <typeparamref name="T"/>
            implements the <see cref="T:System.IComparable`1"/> generic interface and uses that implementation, if available. If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks
            whether type <typeparamref name="T"/> implements the <see cref="T:System.IComparable"/> interface.
            If type <typeparamref name="T"/> does not implement either interface, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
            In contrast, a stable sort preserves the order of elements that are equal.</para>
            <para>On average, this method is an O(n log n) operation, where n is <see cref="P:KGySoft.Collections.CircularList`1.Count"/>; in the worst case it is an O(n ^ 2) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each element of the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="action">The <see cref="T:System.Action`1"/> delegate to perform on each element of the <see cref="T:KGySoft.Collections.CircularList`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The list has been modified during the operation.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <returns>An <see cref="T:KGySoft.Collections.CircularList`1.Enumerator"/> instance that can be used to iterate though the elements of the <see cref="T:KGySoft.Collections.CircularList`1"/>.</returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Creates a shallow copy of a range of elements in the source <see cref="T:KGySoft.Collections.CircularList`1"/>.
            </summary>
            <param name="index">The zero-based index at which the range starts.</param>
            <param name="count">The number of elements in the range.</param>
            <returns>A shallow copy of a range of elements in the source <see cref="T:KGySoft.Collections.CircularList`1"/>.</returns>
            <remarks>
            <para>A shallow copy of a collection of reference types, or a subset of that collection, contains only the references to the elements of the collection.
            The objects themselves are not copied. The references in the new list point to the same objects as the references in the original list.</para>
            <para>A shallow copy of a collection of value types, or a subset of that collection, contains the elements of the collection.
            However, if the elements of the collection contain references to other objects, those objects are not copied.
            The references in the elements of the new collection point to the same objects as the references in the elements of the original collection.</para>
            <para>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</para>
            <para>This method is an O(n) operation, where n is count.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines whether every element in the <see cref="T:KGySoft.Collections.CircularList`1"/> matches the conditions defined by the specified predicate.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1"/> delegate that defines the conditions to check against the elements.</param>
            <returns><see langword="true"/> if every element in the list matches the conditions defined by the specified predicate; otherwise, <see langword="false"/>.
            If the list has no elements, the return value is <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ElementAt(System.Int32)">
            <summary>
            Gets an element without check
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.InternalBinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Performs a binary search without check
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.AddLast(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a <paramref name="collection"/> to the end of the list.
            </summary>
            <param name="collection">The collection to add to the list.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.AddFirst(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a <paramref name="collection"/> to the beginning of the list.
            </summary>
            <param name="collection">The collection to add to the list.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveFirst(System.Int32)">
            <summary>
            Removes the first n elements of the list where n is <paramref name="count"/>.
            </summary>
            <param name="count">Number of items to remove.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.RemoveLast(System.Int32)">
            <summary>
            Removes the last n elements of the list where n is <paramref name="count"/>.
            </summary>
            <param name="count">Number of items to remove.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ShiftUp(System.Int32,System.Int32)">
            <summary>
            Shifts elements up in the stored items by 1.
            </summary>
            <param name="index">Bottom index of the elements to shift.</param>
            <param name="elemCount">Count of elements to shift up.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ShiftUp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Shifts elements up in the stored items by <paramref name="shiftCount"/>.
            </summary>
            <param name="index">Bottom index of the elements to shift.</param>
            <param name="elemCount">Count of elements to shift up.</param>
            <param name="shiftCount">Distance of the shift.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ShiftDown(System.Int32,System.Int32)">
            <summary>
            Shifts elements down in the stored items by 1.
            </summary>
            <param name="index">Top index of the elements to shift.</param>
            <param name="elemCount">Count of elements to shift down</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ShiftDown(System.Int32,System.Int32,System.Int32)">
            <summary>
            Shifts elements down in the stored items by <paramref name="shiftCount"/>.
            </summary>
            <param name="index">Top index of the elements to shift.</param>
            <param name="elemCount">Count of elements to shift down</param>
            <param name="shiftCount">Distance of the shift.</param>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.ElementAtNonZeroStart(System.Int32)">
            <summary>
            Gets an element without check, from any base.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CircularSortedList`2">
            <summary>
            Represents a dictionary of key/value pairs that are sorted by key based on the associated <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            The dictionary behaves as list as well, as it has a direct indexed access to the elements through <see cref="P:KGySoft.Collections.CircularSortedList`2.Keys"/> and <see cref="P:KGySoft.Collections.CircularSortedList`2.Values"/> properties or by the <see cref="M:KGySoft.Collections.CircularSortedList`2.ElementAt(System.Int32)">ElementAt</see> method.
            <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is fully compatible with <see cref="T:System.Collections.Generic.SortedList`2"/>, but is generally faster than that.
            </summary>
            <typeparam name="TKey">Type of the keys stored in the sorted list.</typeparam>
            <typeparam name="TValue">Type of the values stored in the sorted list.</typeparam>
            <remarks>
            <para>
            The <see cref="T:KGySoft.Collections.CircularSortedList`2"/> generic class is an array of key/value pairs with O(log n) retrieval,
            where n is the number of elements in the dictionary. In that regard it is similar to the <see cref="T:System.Collections.Generic.SortedList`2"/> and <see cref="T:System.Collections.Generic.SortedDictionary`2"/> generic classes.
            These three classes serve a similar purpose, and all have O(log n) retrieval. Where the three classes differ is in memory use and speed of insertion and removal:
            <list type="table">
            <listheader><term>Collection type</term><description>Behavior</description></listheader>
            <item><term><see cref="T:System.Collections.Generic.SortedDictionary`2"/></term>
            <description>
            <list type="bullet">
            <item><em>Store model and memory:</em> Elements are stored in a binary search tree where every node is an instance of a class, which references the left and right
            child nodes and wraps a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> of the element to be stored. (A node is similar to <see cref="T:System.Collections.Generic.LinkedListNode`1"/> instances in a <see cref="T:System.Collections.Generic.LinkedList`1"/>).
            This sorted dictionary variant consumes the most memory.</item>
            <item><em>Insertion and removal:</em> These operations have generally O(log n) cost at any position, which is the best of any sorted dictionary variants, though
            due to the slower navigation among nodes, the better general cost starts to outperform the other sorted dictionaries only in case of many elements (hundreds or thousands of elements).</item>
            <item><em>Populating from sorted data:</em> Adding a new element is always an O(log n) operation. Though when populating from sorted data, the tree always needed
            to be re-balanced, so it has worse performance than populating from random data.</item>
            <item><em>Enumerating the collection:</em> Considering that navigating among nodes is slower than array access, this sorted dictionary variant has the worst enumeration performance.</item>
            </list>
            </description></item>
            <item><term><see cref="T:System.Collections.Generic.SortedList`2"/></term>
            <description>
            <list type="bullet">
            <item><em>Store model and memory:</em> Keys and values are stored in separated arrays, which is the most compact storage form among the sorted dictionaries.</item>
            <item><em>Insertion and removal:</em> Position of the element is searched with binary search in the array, which in an O(log n) operation.
            Insertion/removal at the last position has a constant additional cost, so inserting/removing at the end has O(log n) cost, otherwise O(n) cost.</item>
            <item><em>Populating from sorted data:</em> Since position of the elements are always checked, adding a new element to the end has always O(log n) cost, though it is faster than in case of a <see cref="T:System.Collections.Generic.SortedDictionary`2"/>.
            Though, populating from a reverse ordered data has the worst possible performance, because every already existing element has to be shifted in the underlying arrays.</item>
            <item><em>Enumerating the collection:</em> Really fast, it is actually a traversal of arrays.</item>
            </list>
            </description></item>
            <item><term><see cref="T:KGySoft.Collections.CircularSortedList`2"/></term>
            <description>
            <list type="bullet">
            <item><em>Store model and memory:</em> Keys and values are stored in separated <see cref="T:KGySoft.Collections.CircularList`1"/> instances, which is a wrapper class around an array. This is a minimal overhead
            compared to the <see cref="T:System.Collections.Generic.SortedList`2"/> class.</item>
            <item><em>Insertion and removal:</em> When inserting a new element, first of all it is checked, whether it comes to the last or first position. Due to the underlying <see cref="T:KGySoft.Collections.CircularList`1"/>,
            inserting at the first/last position are O(1) operations. Removing an element from the last/first position by the <see cref="M:KGySoft.Collections.CircularSortedList`2.Remove(`0)">Remove</see> method has an O(log n) cost, because the item is found by binary search.
            However, removing the first or last element by the <see cref="M:KGySoft.Collections.CircularSortedList`2.RemoveAt(System.Int32)">RemoveAt</see> method is an O(1) operation. When an element is inserted/removed
            at any other position, it has generally O(n) cost, though the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is designed so, that in worst case no more than half of the elements will be moved.</item>
            <item><em>Populating from sorted data:</em> Inserting element to the end or to the first position is O(1) cost, so it is faster than any other sorted dictionary types, even if populating from reverse ordered data.</item>
            <item><em>Enumerating the collection:</em> Really fast, it is actually a traversal of arrays.</item>
            </list>
            </description></item>
            </list>
            </para>
            <para>Similarly to <see cref="T:System.Collections.Generic.SortedList`2"/>, <see cref="T:KGySoft.Collections.CircularSortedList`2"/> supports efficient indexed retrieval of keys and values through the collections returned by the <see cref="P:KGySoft.Collections.CircularSortedList`2.Keys"/> and <see cref="P:KGySoft.Collections.CircularSortedList`2.Values"/> properties.
            It is not necessary to regenerate the lists when the properties are accessed, because the lists are just wrappers for the internal arrays of keys and values.</para>
            <para><see cref="T:KGySoft.Collections.CircularSortedList`2"/> is implemented as a pair of <see cref="T:KGySoft.Collections.CircularList`1"/> of key/value pairs, sorted by the key. Each element can be retrieved as a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> object.</para>
            <para>Key objects must be immutable as long as they are used as keys in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>. Every key in a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> must be unique.
            A key cannot be <see langword="null"/>, but a value can be, if the type of values in the list, <typeparamref name="TValue"/>, is a reference type, or is a <see cref="T:System.Nullable`1"/> type.</para>
            <para><see cref="T:KGySoft.Collections.CircularSortedList`2"/> implements <see cref="T:System.Collections.Generic.IList`1"/> as well, so it can be indexed directly when cast to <see cref="T:System.Collections.Generic.IList`1"/> or though the <see cref="P:KGySoft.Collections.CircularSortedList`2.AsList"/> property:
            <code lang="C#"><![CDATA[KeyValuePair<int, string> firstItem = myCircularSortedList.AsList[0];]]></code>
            Setting the <see cref="P:System.Collections.Generic.IList`1.Item(System.Int32)">IList&lt;T&gt;.Item</see> property or using the <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)">IList&lt;T&gt;.Insert</see> method throws
            a <see cref="T:System.NotSupportedException"/> for <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, as the position of an element cannot be set directly, it always depends on the comparer implementation.</para>
            <para><see cref="T:KGySoft.Collections.CircularSortedList`2"/> requires a comparer implementation to sort and to perform comparisons.
            If comparer is not defined when <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is instantiated by one of the constructors, the comparer will be chosen automatically.
            When <typeparamref name="TKey"/> is en <see langword="enum"/> type, the comparer will be the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer"><![CDATA[EnumComparer<TEnum>.Comparer]]></see>.
            Otherwise, the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> will be chosen. The default comparer checks whether the key type <typeparamref name="TKey"/> implements <see cref="T:System.IComparable`1"/> and uses that implementation, if available.
            If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether the key type <typeparamref name="TKey"/> implements <see cref="T:System.IComparable"/>. If the key type <typeparamref name="TKey"/> does not implement
            either interface, you can specify an <see cref="T:System.IComparable`1"/> implementation in a constructor overload that accepts a comparer parameter.</para>
            <para>The capacity of a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is the number of elements the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> can hold. As elements are added to a <see cref="T:KGySoft.Collections.CircularSortedList`2"/>,
            the capacity is automatically increased as required by reallocating the internal array. The capacity can be decreased by calling <see cref="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">TrimExcess</see> or by setting the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> property explicitly.
            Decreasing the capacity reallocates memory and copies all the elements in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</para>
            </remarks>
        </member>
        <member name="T:KGySoft.Collections.CircularSortedList`2.EnumeratorAsReference">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            This enumerator is exactly the same as <see cref="T:KGySoft.Collections.CircularSortedList`2.Enumerator"/>,
            but is implemented as a reference type. This is returned when
            enumerator is requested as an <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface
            to avoid performance hit of boxing.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.EnumeratorAsReference.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.EnumeratorAsReference.Dispose">
            <summary>
            Releases the enumerator
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.EnumeratorAsReference.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.EnumeratorAsReference.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="T:KGySoft.Collections.CircularSortedList`2.SimpleEnumeratorAsReference">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> when start index is 0.
            This enumerator is returned when enumerator is requested as an <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface
            to avoid performance hit of boxing.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CircularSortedList`2.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Enumerator.Dispose">
            <summary>
            Releases the enumerator
            </summary>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Capacity">
            <summary>
            Gets or sets the actual size of the internal storage of held elements.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Capacity is set to a value that is less than <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>. </exception>
            <remarks>
            <para>Capacity is the number of elements that the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> can store before resizing is required, whereas
            <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/> is the number of elements that are actually in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</para>
            <para>Capacity is always greater than or equal to <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>. If <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/> exceeds <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> while adding elements,
            the capacity is increased by automatically reallocating the internal <see cref="T:KGySoft.Collections.CircularList`1"/> before copying the old elements and adding the new elements.</para>
            <para>If the capacity is significantly larger than the count and you want to reduce the memory used by the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>,
            you can decrease capacity by calling the <see cref="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">TrimExcess</see> method or by setting the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> property explicitly.
            When the value of <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> is set explicitly, the array in the internal <see cref="T:KGySoft.Collections.CircularList`1"/> is also reallocated to accommodate the specified capacity,
            and all the elements are copied.</para>
            <para>Retrieving the value of this property is an O(1) operation; setting the property is an O(n) operation, where n is the new capacity.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IComparer`1"/> that is used in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Keys">
            <summary>
            Gets an indexable list containing the keys in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, in sorted order.
            </summary>
            <remarks>
            <para>The order of the keys in the <see cref="T:System.Collections.Generic.IList`1"/> is the same as the order in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</para>
            <para>The returned <see cref="T:System.Collections.Generic.IList`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.IList`1"/> refers back to the keys in the original <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> continue to be reflected in the returned <see cref="T:System.Collections.Generic.IList`1"/>.</para>
            <para>The collection returned by the <see cref="P:KGySoft.Collections.CircularSortedList`2.Keys"/> property provides an efficient way to retrieve keys by index. It is not necessary to regenerate the list when the
            property is accessed, because the list is just a wrapper for the internal <see cref="T:KGySoft.Collections.CircularList`1"/> of keys. The following code shows the use of the <see cref="P:KGySoft.Collections.CircularSortedList`2.Keys"/> property for indexed
            retrieval of keys from a sorted list of elements with string keys:</para>
            <code lang="C#">string v = mySortedList.Keys[3];</code>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Values">
            <summary>
            Gets an indexable list containing the values in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, in the order of the sorted keys.
            </summary>
            <remarks>
            <para>The order of the values in the <see cref="T:System.Collections.Generic.IList`1"/> is the same as the order in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</para>
            <para>The returned <see cref="T:System.Collections.Generic.IList`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.IList`1"/> refers back to the values in the original <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> continue to be reflected in the returned <see cref="T:System.Collections.Generic.IList`1"/>.</para>
            <para>The collection returned by the <see cref="P:KGySoft.Collections.CircularSortedList`2.Values"/> property provides an efficient way to retrieve keys by index. It is not necessary to regenerate the list when the
            property is accessed, because the list is just a wrapper for the internal <see cref="T:KGySoft.Collections.CircularList`1"/> of values. The following code shows the use of the <see cref="P:KGySoft.Collections.CircularSortedList`2.Values"/> property for indexed
            retrieval of values from a sorted list of elements with string values:</para>
            <code lang="C#">string v = mySortedList.Values[3];</code>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.AsList">
            <summary>
            Gets the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> cast to an <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <remarks>
            <para><see cref="T:KGySoft.Collections.CircularSortedList`2"/> implements both <see cref="T:System.Collections.Generic.IDictionary`2"/>
            and <see cref="T:System.Collections.Generic.IList`1"/> interfaces. This means, for example, that two indexers are available
            for it: <see cref="P:System.Collections.Generic.IDictionary`2.Item(`0)">IDictionary&lt;TKey,TValue&gt;.Item[TKey]</see> and
            <see cref="P:System.Collections.Generic.IList`1.Item(System.Int32)">IList&lt;T&gt;.Item[int]</see>. Latter is
            implemented as explicit interface implementation to avoid ambiguity when <typeparamref name="TKey"/> is <see cref="T:System.Int32">int</see>,
            so the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> should be cast to <see cref="T:System.Collections.Generic.IList`1"/> when the list indexer
            is used. Alternatively, the <see cref="P:KGySoft.Collections.CircularSortedList`2.AsList"/> property can be used to use the indexer (and other members) of <see cref="T:System.Collections.Generic.IList`1"/> interface
            as it is demonstrated in the example below.
            </para>
            <para>This property is an O(1) operation.</para>
            <example>
            <code lang="C#"><![CDATA[
            var coll = new CircularSortedList<int, string> { { 1, "One" }, { 2, "Two" } };
            var value = coll[1]; // value contains "One" - same as ((IDictionary<int, string>)coll)[1];
            var item = coll.AsList[1]; // item contains KeyValuePair<int, string>(2, "Two") - same as ((IList<KeyValuepair<int, string>>)coll)[1];
            ]]></code>
            </example>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <returns>
            The number of key/value pairs contained in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </returns>
        </member>
        <member name="P:KGySoft.Collections.CircularSortedList`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            The element with the specified <paramref name="key"/>.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.</exception>
            <remarks>
            <para>A key cannot be <see langword="null"/>, but a value can be, if the type of values in the list, <typeparamref name="TValue"/>, is a reference or <see cref="T:System.Nullable`1"/> type.</para>
            <para>If the <paramref name="key"/> is not found when a value is being retrieved, <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is thrown.
            If the key is not found when a value is being set, the key and value are added.</para>
            <para>You can also use this property to add new elements by setting the value of a key that does not exist in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, for example:
            <code lang="C#">myCollection["myNonexistentKey"] = myValue;</code>
            However, if the specified key already exists in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, setting this property
            overwrites the old value. In contrast, the <see cref="M:KGySoft.Collections.CircularSortedList`2.Add(`0,`1)">Add</see> method throws an <see cref="T:System.ArgumentException"/>, when <paramref name="key"/> already exists in the collection.</para>
            <para>Retrieving the value of this property is an O(log n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>. Setting the property is an O(1) operation if the <paramref name="key"/>
            is at the first or last position. Otherwise, setting this property is an O(log n) operation, if the <paramref name="key"/> already exists in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            If the <paramref name="key"/> is not in the list, and the new element is not at the first or last position, setting the property is an O(n) operation. If insertion causes a resize, the operation is O(n).</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.#ctor">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularSortedList`2"/> with empty capacity and a default comparer.
            </summary>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> must be unique according to the specified comparer.</para>
            <para>When <typeparamref name="TKey"/> is en <see langword="enum"/> type, the comparer will be the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>.
            Otherwise, the default comparer <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> will be chosen.
            The default comparer checks whether the key type <typeparamref name="TKey"/> implements <see cref="T:System.IComparable`1"/> and uses that implementation, if available.
            If not, <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> checks whether the key type <typeparamref name="TKey"/> implements <see cref="T:System.IComparable"/>.
            If the key type <typeparamref name="TKey"/> does not implement
            either interface, you can specify an <see cref="T:System.IComparable`1"/> implementation in a constructor overload that accepts a comparer parameter.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, that is empty, and has the specified initial <paramref name="capacity"/>,
            and uses the specified <paramref name="comparer"/>.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/>&#160;<typeparamref name="TKey"/> types, or <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> must be unique according to the specified comparer.</para>
            <para>The capacity of a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is the number of elements that the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> can hold before resizing.
            As elements are added to a <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, the capacity is automatically increased as required by reallocating the array of the internal <see cref="T:KGySoft.Collections.CircularList`1"/>.</para>
            <para>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</para>
            <para>The capacity can be decreased by calling <see cref="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">TrimExcess</see> or by setting the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> property explicitly.
            Decreasing the capacity reallocates memory and copies all the elements in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularSortedList`2"/> with empty capacity, that uses the specified <paramref name="comparer"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/>&#160;<typeparamref name="TKey"/> types, or <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for other types.</param>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> must be unique according to the specified comparer.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, that initializes its elements from the provided <paramref name="dictionary"/>,
            and uses the specified <paramref name="comparer"/>.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"/> whose elements are copied to the new S<see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/>&#160;<typeparamref name="TKey"/> types, or <see cref="P:System.Collections.Generic.Comparer`1.Default">Comparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="dictionary"/> contains one or more duplicate keys.</exception>
            <remarks>
            <para>Every key in a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> must be unique according to the specified <paramref name="comparer"/>; likewise, every key in the source <paramref name="dictionary"/> must
            also be unique according to the specified <paramref name="comparer"/>.</para>
            <para>The capacity of the new <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is set to the number of elements in <paramref name="dictionary"/>, so no resizing takes place while the list is being populated.</para>
            <para>If the data in <paramref name="dictionary"/> are sorted, this constructor is an O(n) operation, where n is the number of elements in <paramref name="dictionary"/>.
            Otherwise it is an O(n*n) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> of the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
            <returns>The new capacity of the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</returns>
            <remarks>
            <para>If the specified <paramref name="capacity"/> is less than or equal to the current <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/>, then the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> is left unchanged.</para>
            <para>If the specified <paramref name="capacity"/> is less than twice of the current <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/>, then current <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> is doubled.</para>
            <para>If the specified <paramref name="capacity"/> is at least twice of the current <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/>, then <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> is set to the specified <paramref name="capacity"/>.</para>
            <para>If capacity is changed, then this method is an O(n) operation where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>. If capacity is not changed, then this method is an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> must not be negative.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, if that number is less than 90 percent of current capacity.
            </summary>
            <remarks>
            <para>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection. The cost of reallocating and
            copying a large <see cref="T:KGySoft.Collections.CircularSortedList`2"/> can be considerable, however, so the TrimExcess method does nothing if the list is at more
            than 90 percent of capacity. This avoids incurring a large reallocation cost for a relatively small gain.</para>
            <para>This method is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</para>
            <para>To reset a <see cref="T:KGySoft.Collections.CircularSortedList`2"/> to its initial state, call the <see cref="M:KGySoft.Collections.CircularSortedList`2.Reset">Reset</see> method. Calling the <see cref="M:KGySoft.Collections.CircularSortedList`2.Clear">Clear</see> and <see cref="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">TrimExcess</see> methods has the same effect; however,
            <see cref="M:KGySoft.Collections.CircularSortedList`2.Reset">Reset</see> method is an O(1) operation, while <see cref="M:KGySoft.Collections.CircularSortedList`2.Clear">Clear</see>> is an O(n) operation. Trimming an empty <see cref="T:KGySoft.Collections.CircularSortedList`2"/> sets the capacity of the list to 0.</para>
            <para>The capacity can also be set using the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> property.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference and <see cref="T:System.Nullable`1"/> types.</param>
            <returns>The zero-based index in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> at which the key-value pair has been added.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</exception>
            <remarks>
            <para>A key cannot be <see langword="null"/>, but a value can be, if the type of values in the sorted list, <typeparamref name="TValue"/>, is a reference or <see cref="T:System.Nullable`1"/> type.</para>
            <para>You can also use the <see cref="P:KGySoft.Collections.CircularSortedList`2.Item(`0)">indexer</see> to add new elements by setting the value of a
            key that does not exist in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>. for example:
            <code lang="C#"><![CDATA[myCollection["myNonexistentKey"] = myValue;]]></code>
            However, if the specified key already exists in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, setting the <see cref="P:KGySoft.Collections.CircularSortedList`2.Item(`0)">indexer</see>
            overwrites the old value. In contrast, the <see cref="M:KGySoft.Collections.CircularSortedList`2.Add(`0,`1)">Add</see> method does not modify existing elements.</para>
            <para>If <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/> already equals <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/>, the capacity of the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> is increased by
            automatically reallocating the array in internal <see cref="T:KGySoft.Collections.CircularList`1"/>, and the existing elements are copied to the new array before the new element is added.</para>
            <para>This method is an O(n) operation for unsorted data, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>. It is an O(1) operation if the new element is added at the end or the head of the list.
            If insertion causes a resize, the operation is O(n).</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.SetValueAtIndex(System.Int32,`1)">
            <summary>
            Sets the value of an element at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the value to set.</param>
            <param name="value">The value to set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> contains an element with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/>, if the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> contains an element with the <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key to locate in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <remarks>This method is an O(log n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.ContainsValue(`1)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> contains a specific value.
            </summary>
            <param name="value">The value to locate in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>. The value can be <see langword="null"/> for reference and <see cref="T:System.Nullable`1"/> types.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> contains an element with the specified <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="TValue"/> is an <see langword="enum"/> type,
            or the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other <typeparamref name="TValue"/> types.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the <paramref name="value"/> associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/> if the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <remarks>
            <para>If the <paramref name="key"/> is not found, then the value parameter gets the appropriate default value for the value type <typeparamref name="TValue"/>;
            for example, zero (0) for integer types, <see langword="false"/> for Boolean types, and <see langword="null"/> for reference types.</para>
            <para>This method performs a binary search; therefore, this method is an O(log n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.IndexOfKey(`0)">
            <summary>
            Searches for the specified <paramref name="key"/> and returns the zero-based index within the entire <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <param name="key">The key to locate in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</param>
            <returns>The zero-based index of <paramref name="key"/> within the entire <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, if found; otherwise, -1.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <remarks>This method performs a binary search; therefore, this method is an O(log n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.IndexOfValue(`1)">
            <summary>
            Searches for the specified value and returns the zero-based index of the first occurrence within the entire <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <param name="value">The value to locate in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            The value can be <see langword="null"/> for reference and <see cref="T:System.Nullable`1"/> types.</param>
            <returns>The zero-based index of the first occurrence of value within the entire <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, if found; otherwise, -1.</returns>
            <remarks>
            <para>This method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="TValue"/> is an <see langword="enum"/> type,
            or the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other <typeparamref name="TValue"/> types.
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> checks whether the value type <typeparamref name="TValue"/> implements <see cref="T:System.IEquatable`1"/> and uses
            that implementation, if available. If not, <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> uses <see cref="M:System.Object.Equals(System.Object)">Object.Equals</see>.
            </para>
            <para>This method performs a linear search; therefore, the average execution time is proportional to <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>. That is, this method is an O(n)
            operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.ElementAt(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> of the <typeparamref name="TKey"/> and <typeparamref name="TValue"/> elements
            at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.GetKeyAtIndex(System.Int32)">
            <summary>
            Gets the key of an element at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the key to get.</param>
            <returns>The key at the specified <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.GetValueAtIndex(System.Int32)">
            <summary>
            Gets the value of an element at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the value to get.</param>
            <returns>The value at the specified <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection in the order of the sorted keys.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Reset">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> and resets the <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> to 0.
            </summary>
            <remarks>
            <para><see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/> and <see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> are set to 0, and references to other objects from elements of the collection are also released.</para>
            <para>This method is an O(1) operation.</para>
            <para>Calling <see cref="M:KGySoft.Collections.CircularSortedList`2.Clear">Clear</see> and then <see cref="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">TrimExcess</see> methods also resets the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>, though
            <see cref="M:KGySoft.Collections.CircularSortedList`2.Clear">Clear</see> is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Remove(`0)">
            <summary>
            Removes the element with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <returns>
            <see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <remarks>This method performs a binary search; however, the elements are moved up to fill in the open spot.
            So this method is an O(log n) operation, when the first or last element is removed; otherwise, O(n), where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.
            If it is known that the first or last element should be removed, use <see cref="M:KGySoft.Collections.CircularSortedList`2.RemoveAt(System.Int32)"/> instead, which is an O(1) operation in this case.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.</exception>
            <remarks>When the first or the last element is removed, this method is an O(1) operation; otherwise, an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.Clear">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.CircularSortedList`2"/>.
            </summary>
            <remarks>
            <para><see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/> is set to 0, and references to other objects from elements of the collection are also released.</para>
            <para>This method is an O(n) operation, where n is <see cref="P:KGySoft.Collections.CircularSortedList`2.Count"/>.</para>
            <para><see cref="P:KGySoft.Collections.CircularSortedList`2.Capacity"/> remains unchanged. To reset the capacity of the <see cref="T:KGySoft.Collections.CircularSortedList`2"/> to 0 as well,
            call the <see cref="M:KGySoft.Collections.CircularSortedList`2.Reset">Reset</see> method instead, which is an O(1) operation.
            Calling <see cref="M:KGySoft.Collections.CircularSortedList`2.TrimExcess">TrimExcess</see> after <see cref="M:KGySoft.Collections.CircularSortedList`2.Clear">Clear</see> also resets the list, though <see cref="M:KGySoft.Collections.CircularSortedList`2.Clear">Clear</see> has more cost.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.SearchKeyOptimizedLastOrFirst(`0)">
            <summary>
            Searches a key element first checking the last and first items.
            </summary>
            <param name="key">The key element to search</param>
            <returns>The non-negative index if key is found; otherwise, the bitwise complement of the index where the element can be inserted.</returns>
        </member>
        <member name="M:KGySoft.Collections.CircularSortedList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:KGySoft.Collections.HashHelper.maxPrime">
            <summary>
            The maximum prime value smaller than 0x7FEFFFFF, which is the value of Array.MaxArrayLength.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.HashHelper.primes">
            <summary>
            Contains nearest primes for 2 and 10 powers can be used for typical capacities
            as well as "near enough" primes for dynamically increased capacities.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.HashHelper.IsPrime(System.Int32)">
            <summary>
            Determines whether the specified n is prime using the Miller-Rabin test.
            See https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/
            </summary>
        </member>
        <member name="M:KGySoft.Collections.HashHelper.MillerTest(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Prime test for a number n-1 = d * 2^r with an arbitrary a value.
            If returns false, n is composite for sure. If returns true, n is probably prime.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.HashHelper.Power(System.Int64,System.Int32,System.Int32)">
            <summary>
            Returns (x^y) % p
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ListSegment`1">
            <summary>
            Wraps a segment of an <see cref="T:System.Collections.Generic.IList`1"/> for read-only purposes.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.LockFreeCache`2.GrowOnlyDictionary">
            <summary>
            Represents a lock-free thread safe dictionary where items can only be added and queried but not replaced or deleted.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.LockFreeCache`2.GrowOnlyDictionary.Bucket">
            <summary>
            Just a volatile reference holder so array items can be treated volatile.
            This is needed because in older targeted platforms there is no generic Volatile.Read/Write
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockFreeCache`2.GrowOnlyDictionary.GetBucketIndex(System.UInt32)">
            <summary>
            An if in a non-virtual method is still faster than calling an abstract method, a delegate or even a C# 9 function pointer
            </summary>
        </member>
        <member name="F:KGySoft.Collections.LockFreeCache`2.ReadOnlyDictionary.Entry.Next">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last.
            In this collection there are no deleted items.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockFreeCache`2.ReadOnlyDictionary.GetBucketIndex(System.UInt32)">
            <summary>
            An if in a non-virtual method is still faster than calling an abstract method, a delegate or even a C# 9 function pointer
            </summary>
        </member>
        <member name="T:KGySoft.Collections.LockFreeCacheOptions">
            <summary>
            Represents the options for creating a fast, lock-free, thread safe cache by the
            <see cref="O:KGySoft.Collections.ThreadSafeCacheFactory.Create"><![CDATA[ThreadSafeCacheFactory.Create<TKey, TValue>]]></see> methods.
            <br/>To see when to use <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> or <see cref="T:KGySoft.Collections.LockingCacheOptions"/> see the <strong>Remarks</strong> section.
            of the <see cref="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0},KGySoft.Collections.ThreadSafeCacheOptionsBase)"/> method.
            </summary>
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory" />
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheOptionsBase" />
        </member>
        <member name="P:KGySoft.Collections.LockFreeCacheOptions.InitialCapacity">
            <summary>
            Gets or sets the initial capacity of the cache.
            <br/>Default value: <c>16</c>.
            <br/>See also the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/> property for details.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity">
            <summary>
            Gets or sets the maximum number of elements, which triggers a merge operation from the underlying dynamic growing storage into the faster read-only storage.
            Specifies also the number of elements to be kept when older elements are dropped from the cache. The actual maximum number of stored items may be about twice of this value.
            <br/>Default value: <c>1024</c>.
            </summary>
            <remarks>
            <para>The value of the <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/> property must be greater or equal to the value of the <see cref="P:KGySoft.Collections.LockFreeCacheOptions.InitialCapacity"/> property.</para>
            <para>When the first element is about to be stored a dynamic storage is allocated that can optimally store about as many elements as specified by the <see cref="P:KGySoft.Collections.LockFreeCacheOptions.InitialCapacity"/> property.
            When the number of stored elements reaches <see cref="P:KGySoft.Collections.LockFreeCacheOptions.InitialCapacity"/> capacity, then content of the dynamic storage is copied into a faster read-only storage, and for additional elements
            a new dynamic storage is allocated with either doubled capacity or the specified <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/>, whichever is less.</para>
            <para>Once the number of stored elements in the dynamically growing storage reaches <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/>, the complete previous content of the faster read-only storage is replaced
            by the elements in the growing storage. Therefore, when adding new items continuously, the number of stored elements will be between <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/> and twice of <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/>.</para>
            <para>If it cannot be really estimated how many items in the cache will be stored, then you can set the <see cref="P:KGySoft.Collections.LockFreeCacheOptions.MergeInterval"/> property,
            which can trigger a merge operation to the faster storage by time, regardless of reaching the required capacity limit.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.LockFreeCacheOptions.MergeInterval">
            <summary>
            Gets or sets a time period, which may trigger a merge operation into the faster read-only storage even when no new elements are added.
            If <see langword="null"/>, then time-based merging is disabled.
            <br/>Default value: <see langword="null"/>.
            </summary>
            <remarks>
            <para>Even if this property is set, capacity-based merging works as described in the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/> property.</para>
            <para>Even if this property is set, no extra resources (such as timer) are used. No merging occurs if elements are retrieved from the faster read-only cache.
            A time-based merging may occur only if the dynamically growing storage is accessed.</para>
            <para>Once the stored number of elements reaches <see cref="P:KGySoft.Collections.LockFreeCacheOptions.ThresholdCapacity"/> the value of this property is ignored.</para>
            <para>Depending on the targeted platform it is possible that no time-based merging occurs more often than 15 milliseconds.</para>
            <note type="tip">Set this property when it is likely that the number of stored elements will not reach the specified capacities (maybe even <see cref="P:KGySoft.Collections.LockFreeCacheOptions.InitialCapacity"/>)
            and you still want to make sure that the stored elements are merged into the faster read-only storage even if no newer elements are added.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.LockFreeCacheOptions.HashingStrategy">
            <summary>
            Gets or sets the hashing strategy to be used by the cache.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockFreeCacheOptions.CreateInstance``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc/>
        </member>
        <member name="T:KGySoft.Collections.LockingCacheOptions">
            <summary>
            Represents the options for creating a thread-safe accessor by the
            <see cref="O:KGySoft.Collections.ThreadSafeCacheFactory.Create"><![CDATA[ThreadSafeCacheFactory.Create<TKey, TValue>]]></see> methods
            <br/>To see when to use <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> or <see cref="T:KGySoft.Collections.LockingCacheOptions"/> see the <strong>Remarks</strong> section.
            of the <see cref="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0},KGySoft.Collections.ThreadSafeCacheOptionsBase)"/> method.
            </summary>
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory" />
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheOptionsBase" />
        </member>
        <member name="P:KGySoft.Collections.LockingCacheOptions.Capacity">
            <summary>
            Gets or sets the capacity of the cache to be created. If the cache is full, then the oldest or the least recent used element
            (depending on the <see cref="P:KGySoft.Collections.LockingCacheOptions.Behavior"/> property) will be dropped from the cache.
            <br/>Default value: <c>1024</c>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockingCacheOptions.PreallocateCapacity">
            <summary>
            Gets or sets whether adding the first item to the cache should allocate memory the full cache <see cref="P:KGySoft.Collections.LockingCacheOptions.Capacity"/>.
            If <see langword="false"/>, then the internal storage is dynamically reallocated while adding new elements until reaching <see cref="P:KGySoft.Collections.LockingCacheOptions.Capacity"/>.
            Set it to <see langword="true"/> if it is almost certain that the cache will be full when using it.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockingCacheOptions.Behavior">
            <summary>
            Gets or sets the cache behavior when cache is full and an element has to be removed.
            The cache is full, when the number of stored items reaches <see cref="P:KGySoft.Collections.LockingCacheOptions.Capacity"/>.
            Default value: <see cref="F:KGySoft.Collections.CacheBehavior.RemoveLeastRecentUsedElement"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockingCacheOptions.DisposeDroppedValues">
            <summary>
            Gets or sets whether dropped values are disposed if they implement <see cref="T:System.IDisposable"/>.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockingCacheOptions.ProtectItemLoader">
            <summary>
            Gets or sets whether the item loader delegate that is specified by the
            <see cref="O:KGySoft.Collections.ThreadSafeCacheFactory.Create"><![CDATA[ThreadSafeCacheFactory.Create<TKey, TValue>]]></see>
            methods is protected from invoking it concurrently.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <value><see langword="true"/> to protect the item loader delegate (it will not be called concurrently);
            <see langword="false"/> to allow the item loader delegate to be called concurrently.</value>
        </member>
        <member name="P:KGySoft.Collections.LockingCacheOptions.Expiration">
            <summary>
            Gets or sets an expiration time for the values to be stored in the cache. If <see langword="null"/>, then the values will not expire.
            <br/>Default value: <see langword="null"/>.
            <remarks>
            <para>Even if this property is <see langword="null"/>, values might be reloaded from time to time because if the cache is full (see <see cref="P:KGySoft.Collections.LockingCacheOptions.Capacity"/>)
            oldest or least recent used elements (see <see cref="P:KGySoft.Collections.LockingCacheOptions.Behavior"/>) are dropped from the cache.</para>
            <para>Depending on the targeted platform it is possible that values will not expire for at least 15 milliseconds.</para>
            </remarks>
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingCacheOptions.CreateInstance``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc/>
        </member>
        <member name="T:KGySoft.Collections.LockingCollection`1">
             <summary>
             Provides a simple wrapper for an <see cref="T:System.Collections.Generic.ICollection`1"/> where all members are thread-safe.
             This only means that the inner state of the wrapped collection remains always consistent and not that all of the multi-threading concerns can be ignored.
             </summary>
             <typeparam name="T">The type of the elements in the collection.</typeparam>
             <remarks>
             <note>Use this class only if you want to wrap a generic <see cref="T:System.Collections.Generic.ICollection`1"/> instance to make it thread-safe.
             If you want to use a thread-safe hash set optimized for concurrent operations consider to use the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class instead.</note>
             <para>Type safety means that all members of the underlying collection are accessed in a lock, which only provides that the collection remains consistent as long as it is accessed only by the members of this class.
             This does not solve every issue of multi-threading automatically. Consider the following example:
             <code lang="C#"><![CDATA[
             var asThreadSafe = new LockingCollection<MyClass>(myCollection);
            
             // Though both calls use locks it still can happen that two threads add the same item twice this way
             // because the lock is released between the two calls:
             if (!asThreadSafe.Contains(myItem))
                 asThreadSafe.Add(myItem);
             ]]></code></para>
             <para>For the situations above a lock can be requested also explicitly by the <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> method, which can be released by the <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> method.
             To release an explicitly requested lock the <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> method must be called the same times as the <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> method. The fixed version of the example above:
             <code lang="C#"><![CDATA[
             var asThreadSafe = new LockingCollection<MyClass>(myCollection);
            
             // This works well because the lock is not released between the two calls:
             asThreadSafe.Lock();
             try
             {
                 if (!asThreadSafe.Contains(myItem))
                     asThreadSafe.Add(myItem);
             }
             finally
             {
                 asThreadSafe.Unlock();
             }
             ]]></code></para>
             <para>To avoid confusion, the non-generic <see cref="T:System.Collections.ICollection"/> interface is not implemented by the <see cref="T:KGySoft.Collections.LockingCollection`1"/> class because it uses a different aspect of synchronization.</para>
             <para>The <see cref="M:KGySoft.Collections.LockingCollection`1.GetEnumerator">GetEnumerator</see> method creates a snapshot of the underlying collection so obtaining the enumerator has an O(n) cost on this class.</para>
             <para><note>Starting with .NET 4 a sort of concurrent collections appeared. While they provide good scalability for multiple concurrent readers by using separate locks for entries or for a set of entries,
             in many situations they perform worse than a simple locking collection, especially if the collection to lock uses a fast accessible storage (eg. an array) internally. It also may worth to mention that some members
             (such as the <c>Count</c> property) are surprisingly expensive operations on most concurrent collections as they traverse the inner storage and in the meantime they lock all entries while counting the elements.
             So it always depends on the concrete scenario whether a simple locking collection or a concurrent collection is more beneficial to use.</note>
             <note type="tip">To use a thread-safe hash set without wrapping any <see cref="T:System.Collections.Generic.ICollection`1"/> instance consider to use the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class instead.</note>
             </para>
             </remarks>
             <threadsafety instance="true"/>
             <seealso cref="T:System.Collections.Generic.ICollection`1" />
             <seealso cref="T:KGySoft.Collections.ThreadSafeHashSet`1" />
             <seealso cref="T:KGySoft.Collections.LockingList`1" />
             <seealso cref="T:KGySoft.Collections.LockingDictionary`2" />
        </member>
        <member name="P:KGySoft.Collections.LockingCollection`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:KGySoft.Collections.LockingCollection`1" />.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockingCollection`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:KGySoft.Collections.LockingCollection`1" /> is read-only.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.LockingCollection`1.InnerCollection">
            <summary>
            Gets the inner collection.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.LockingCollection`1"/> class with a <see cref="T:System.Collections.Generic.HashSet`1"/> inside.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.LockingCollection`1"/> class.
            </summary>
            <param name="collection">The collection to create a thread-safe wrapper for.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.Lock">
            <summary>
            Locks the access of the underlying collection from other threads until <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> is called as many times as this method was called. Needed to be called if
            multiple calls to the wrapped collection have to be combined without releasing the lock between each calls.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Collections.LockingCollection`1"/> class for details and some examples.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.Unlock">
            <summary>
            When called as many times as <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> was called previously, then unlocks the access of the underlying collection so other threads also can access it.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
            <remarks>
            <para>The enumeration represents a moment-in-time snapshot of the contents of the <see cref="T:KGySoft.Collections.LockingCollection`1"/>. It does not reflect any updates to the collection after <see cref="M:KGySoft.Collections.LockingCollection`1.GetEnumerator">GetEnumerator</see> was called.
            The enumerator is safe to use concurrently with reads from and writes to the collection.</para>
            <para>This method has an O(n) cost where n is the number of elements in the collection.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:KGySoft.Collections.LockingCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:KGySoft.Collections.LockingCollection`1"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.Clear">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.LockingCollection`1"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.LockingCollection`1" /> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.LockingCollection`1" />.</param>
            <returns><see langword="true"/> if <paramref name="item" /> is found in the <see cref="T:KGySoft.Collections.LockingCollection`1" />; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:KGySoft.Collections.LockingCollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <paramref name="arrayIndex"/>.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:KGySoft.Collections.LockingCollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingCollection`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:KGySoft.Collections.LockingCollection`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:KGySoft.Collections.LockingCollection`1"/>.</param>
            <returns><see langword="true"/> if <paramref name="item" /> was successfully removed from the <see cref="T:KGySoft.Collections.LockingCollection`1" />; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="item" /> is not found in the original <see cref="T:KGySoft.Collections.LockingCollection`1"/>.
            </returns>
        </member>
        <member name="T:KGySoft.Collections.LockingDictionary`2">
             <summary>
             Provides a simple wrapper for an <see cref="T:System.Collections.Generic.IDictionary`2"/> where all members are thread-safe.
             This only means that the inner state of the wrapped dictionary remains always consistent and not that all of the multi-threading concerns can be ignored.
             </summary>
             <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
             <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
             <remarks>
             <note>Use this class only if you want to wrap a generic <see cref="T:System.Collections.Generic.IDictionary`2"/> instance to make it thread-safe.
             If you want to use a thread-safe dictionary optimized for concurrent operations consider to use the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class instead.</note>
             <para>Type safety means that all members of the underlying collection are accessed in a lock, which only provides that the collection remains consistent as long as it is accessed only by the members of this class.
             This does not solve every issue of multi-threading automatically. Consider the following example:
             <code lang="C#"><![CDATA[
             var asThreadSafe = new LockingDictionary<MyKey, MyValue>(myDictionary);
            
             // Though both calls use locks it still can happen that two threads try to add the same key twice this way
             // because the lock is released between the two calls:
             if (!asThreadSafe.ContainsKey(myKey))
                 asThreadSafe.Add(myKey, myValue);
             ]]></code></para>
             <para>For the situations above a lock can be requested also explicitly by the <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> method, which can be released by the <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> method.
             To release an explicitly requested lock the <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> method must be called the same times as the <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> method. The fixed version of the example above:
             <code lang="C#"><![CDATA[
             var asThreadSafe = new LockingDictionary<MyClass>(myDictionary);
            
             // This works well because the lock is not released between the two calls:
             asThreadSafe.Lock();
             try
             {
                 if (!asThreadSafe.ContainsKey(myKey))
                     asThreadSafe.Add(myKey, myValue);
             }
             finally
             {
                 asThreadSafe.Unlock();
             }
             ]]></code></para>
             <para>To avoid confusion, the non-generic <see cref="T:System.Collections.IDictionary"/> interface is not implemented by the <see cref="T:KGySoft.Collections.LockingDictionary`2"/> class because it uses a different aspect of synchronization.</para>
             <para>The <see cref="M:KGySoft.Collections.LockingCollection`1.GetEnumerator">GetEnumerator</see> method and <see cref="P:KGySoft.Collections.LockingDictionary`2.Keys"/> and <see cref="P:KGySoft.Collections.LockingDictionary`2.Values"/> properties create a snapshot of the underlying collections so obtaining
             these members have an O(n) cost on this class.</para>
             <para><note>Starting with .NET 4 a sort of concurrent collections appeared. While they provide good scalability for multiple concurrent readers by using separate locks for entries or for a set of entries,
             in many situations they perform worse than a simple locking collection, especially if the collection to lock uses a fast accessible storage (eg. an array) internally. It also may worth to mention that some members
             (such as the <c>Count</c> property) are surprisingly expensive operations on most concurrent collections as they traverse the inner storage and in the meantime they lock all entries while counting the elements.
             So it always depends on the concrete scenario whether a simple locking collection or a concurrent collection is more beneficial to use.</note>
             <note type="tip"><list type="bullet">
             <item>To use a thread-safe dictionary without wrapping any <see cref="T:System.Collections.Generic.IDictionary`2"/> instance consider to use the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class instead.</item>
             <item>For a <see cref="T:KGySoft.Collections.Cache`2"/> use this class only if you want a thread-safe wrapper for all <see cref="T:System.Collections.Generic.IDictionary`2"/> members and if it is not a problem if the cache remains locked
             during the invocation of the item loader delegate passed to the appropriate <see cref="M:KGySoft.Collections.Cache`2.#ctor(System.Func{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">constructor</see>.
             Otherwise, it may worth to use an <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instead, which can be obtained by the <see cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">GetThreadSafeAccessor</see> method.</item>
             <item>To create a thread-safe <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance that fits the best for your needs use the members of the <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/> class.</item>
             </list></note>
             </para>
             </remarks>
             <threadsafety instance="true"/>
             <seealso cref="T:System.Collections.Generic.IDictionary`2" />
             <seealso cref="T:KGySoft.Collections.LockingCollection`1" />
             <seealso cref="T:KGySoft.Collections.LockingList`1" />
             <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/>
             <seealso cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>
        </member>
        <member name="P:KGySoft.Collections.LockingDictionary`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:KGySoft.Collections.LockingDictionary`2" />.
            </summary>
            <remarks>
            <para>The returned collection represents a moment-in-time snapshot of the keys of the <see cref="T:KGySoft.Collections.LockingDictionary`2"/>. It does not reflect any updates to the dictionary after <see cref="P:KGySoft.Collections.LockingDictionary`2.Keys"/> were obtained.
            The collection is safe to use concurrently with reads from and writes to the dictionary.</para>
            <para>This property has an O(n) cost where n is the number of elements in the dictionary.</para>
            <note>The enumerator of the returned collection supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.LockingDictionary`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values of the <see cref="T:KGySoft.Collections.LockingDictionary`2" />.
            </summary>
            <remarks>
            <para>The returned collection represents a moment-in-time snapshot of the values of the <see cref="T:KGySoft.Collections.LockingDictionary`2"/>. It does not reflect any updates to the dictionary after <see cref="P:KGySoft.Collections.LockingDictionary`2.Keys"/> were obtained.
            The collection is safe to use concurrently with reads from and writes to the dictionary.</para>
            <para>This property has an O(n) cost where n is the number of elements in the dictionary.</para>
            <note>The enumerator of the returned collection supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.LockingDictionary`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key of the element to get or set.</param>
            <returns>The element with the specified key.</returns>
        </member>
        <member name="M:KGySoft.Collections.LockingDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.LockingDictionary`2"/> class with a <see cref="T:System.Collections.Generic.Dictionary`2"/> inside.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.LockingDictionary`2"/> class.
            </summary>
            <param name="dictionary">The dictionary to create a thread-safe wrapper for.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.LockingDictionary`2" /> contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:KGySoft.Collections.LockingDictionary`2" />.</param>
            <returns><see langword="true" /> if the <see cref="T:KGySoft.Collections.LockingDictionary`2" /> contains an element with the key; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.Collections.LockingDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:KGySoft.Collections.LockingDictionary`2" />.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:KGySoft.Collections.LockingDictionary`2" />.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns><see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.
            This method also returns <see langword="false" /> if <paramref name="key" /> was not found in the original <see cref="T:KGySoft.Collections.LockingDictionary`2" />.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.LockingDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter.
            This parameter is passed uninitialized.</param>
            <returns><see langword="true" /> if the <see cref="T:KGySoft.Collections.LockingDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="T:KGySoft.Collections.LockingList`1">
             <summary>
             Provides a simple wrapper for an <see cref="T:System.Collections.Generic.IList`1"/> where all members are thread-safe.
             This only means that the inner state of the wrapped list remains always consistent and not that all of the multi-threading concerns can be ignored.
             </summary>
             <typeparam name="T">The type of the elements in the list.</typeparam>
             <remarks>
             <para>Type safety means that all members of the underlying collection are accessed in a lock, which only provides that the collection remains consistent as long as it is accessed only by the members of this class.
             This does not solve every issue of multi-threading automatically. Consider the following example:
             <code lang="C#"><![CDATA[
             var asThreadSafe = new LockingList<MyClass>(myList);
            
             // Though both calls use locks it still can happen that two threads tries to remove the only element
             // because the lock is released between the two calls:
             if (asThreadSafe.Count > 0)
                 asThreadSafe.RemoveAt(0);
             ]]></code></para>
             <para>For the situations above a lock can be requested also explicitly by the <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> method, which can be released by the <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> method.
             To release an explicitly requested lock the <see cref="M:KGySoft.Collections.LockingCollection`1.Unlock">Unlock</see> method must be called the same times as the <see cref="M:KGySoft.Collections.LockingCollection`1.Lock">Lock</see> method. The fixed version of the example above:
             <code lang="C#"><![CDATA[
             var asThreadSafe = new LockingList<MyClass>(myList);
            
             // This works well because the lock is not released between the two calls:
             asThreadSafe.Lock();
             try
             {
                 if (asThreadSafe.Count > 0)
                     asThreadSafe.RemoveAt(0);
             }
             finally
             {
                 asThreadSafe.Unlock();
             }
             ]]></code></para>
             <para>To avoid confusion, the non-generic <see cref="T:System.Collections.IList"/> interface is not implemented by the <see cref="T:KGySoft.Collections.LockingList`1"/> class because it uses a different aspect of synchronization.</para>
             <para>The <see cref="M:KGySoft.Collections.LockingCollection`1.GetEnumerator">GetEnumerator</see> method creates a snapshot of the underlying list so obtaining the enumerator has an O(n) cost on this class.</para>
             <para><note>Starting with .NET 4 a sort of concurrent collections appeared. While they provide good scalability for multiple concurrent readers by using separate locks for entries or for a set of entries,
             in many situations they perform worse than a simple locking collection, especially if the collection to lock uses a fast accessible storage (eg. an array) internally. It also may worth to mention that some members
             (such as the <c>Count</c> property) are surprisingly expensive operations on most concurrent collections as they traverse the inner storage and in the meantime they lock all entries while counting the elements.
             So it always depends on the concrete scenario whether a simple locking collection or a concurrent collection is more beneficial to use.</note></para>
             </remarks>
             <threadsafety instance="true"/>
             <seealso cref="T:System.Collections.Generic.IList`1" />
             <seealso cref="T:KGySoft.Collections.LockingCollection`1" />
             <seealso cref="T:KGySoft.Collections.LockingDictionary`2" />
        </member>
        <member name="P:KGySoft.Collections.LockingList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="M:KGySoft.Collections.LockingList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.LockingList`1"/> with a <see cref="T:System.Collections.Generic.List`1"/> inside.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.LockingList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.LockingList`1"/> class.
            </summary>
            <param name="list">The list to create a thread-safe wrapper for.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:KGySoft.Collections.LockingList`1" />.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.LockingList`1" />.</param>
            <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:KGySoft.Collections.LockingList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:KGySoft.Collections.LockingList`1" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:KGySoft.Collections.LockingList`1" />.</param>
        </member>
        <member name="M:KGySoft.Collections.LockingList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:KGySoft.Collections.LockingList`1" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1">
            <summary>
            Similar to <see cref="T:System.Collections.ObjectModel.Collection`1"/> but <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.IndexOf(`0)">IndexOf</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Contains(`0)">Contains</see> methods
            have O(1) access if the underlying collection is changed through only the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> class.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/>, then the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> class is tolerant with direct modifications of the underlying collection but
            when inconsistency is detected, the cost of <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.IndexOf(`0)">IndexOf</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Contains(`0)">Contains</see> methods can fall back to O(n)
            where n is the count of the elements in the collection.</para>
            <note type="warning">Do not store elements in a <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> that may change their hash code while they are added to the collection.
            Finding such elements may fail even if <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/>.</note>
            </remarks>
            <typeparam name="T"></typeparam>
            <seealso cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1" />
            <seealso cref="T:System.Collections.ObjectModel.Collection`1" />
        </member>
        <member name="F:KGySoft.Collections.ObjectModel.FastLookupCollection`1.itemToIndex">
            <summary>
            A lazy-initialized item-index cache. A negated index means that the item occurs multiple times so on remove the cache has to be invalidated.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency">
            <summary>
            Gets or sets whether consistency of the stored items should be checked when items are get or set in the collection.
            <br/>Default value: <see langword="false"/>, if the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> was initialized by the default constructor; otherwise, as it was specified.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/>, then the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> class is tolerant with direct modifications of the underlying collection but
            when inconsistency is detected, the cost of <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.IndexOf(`0)">IndexOf</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Contains(`0)">Contains</see> methods can fall back to O(n)
            where n is the count of the elements in the collection.</para>
            <note type="warning">Do not store elements in a <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> that may change their hash code while they are added to the collection.
            Finding such elements may fail even if <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.#ctor">
            <summary>
            Initializes an empty instance of the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> class  with a <see cref="T:KGySoft.Collections.CircularList`1"/> internally.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.#ctor(System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> class as a wrapper for the specified <paramref name="list"/>.
            </summary>
            <param name="list">The list that is wrapped by the new collection.</param>
            <param name="checkConsistency"><see langword="true"/> to keep checking consistency of the wrapped <paramref name="list"/> and the inner storage;
            <see langword="false"/> to not check whether the wrapped <paramref name="list"/> changed. It can be <see langword="false"/> if the wrapped list is not changed outside of this <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> instance. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.InnerListChanged">
            <summary>
            Invalidates the internally stored index mapping. Call if the wrapped list that has been passed to the constructor has been changed explicitly.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.GetItemIndex(`0)">
            <summary>
            Gets the zero-based index of the first of the specified <paramref name="item" /> within the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>. The value can be <see langword="null"/> for reference types.</param>
            <returns>
            The zero-based index of the found occurrence of <paramref name="item" /> within the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>, if found; otherwise, <c>-1</c>.
            </returns>
            <remarks>
            <para>In <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> this method has an O(n) cost for the first time or then the internal mapping has to be rebuilt (because,
            for example, <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/> and inconsistency is detected); otherwise, it has an O(1) cost.
            Inconsistency can happen if the underlying collection has been modified directly instead of accessing it only via this instance.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the <paramref name="item" /> at the specified <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.RemoveItemAt(System.Int32)">
            <summary>
            Removes the element at the specified <paramref name="index" /> from the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1" />.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.RemoveItem(`0)">
            <summary>
            Removes the first occurrence of <paramref name="item"/> from the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>.</param>
            <returns><see langword="true"/>, if an occurrence of <paramref name="item" /> was removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1" />.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.OnMapRebuilt">
            <summary>
            Called after the internal index map has been rebuilt either when inconsistency has been detected or when <see cref="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.InnerListChanged">InnerListChanged</see> has been called.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ObjectModel.VirtualCollection`1">
            <summary>
            Similar to <see cref="T:System.Collections.ObjectModel.Collection`1"/> but provides virtual members not just for writing an setting but also for getting elements
            such as <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItem(System.Int32)">GetItem</see>, <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItemIndex(`0)">GetItemIndex</see> and allows to override also some properties
            such as <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Count"/>, <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> and <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.CanSetItem"/>.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <seealso cref="T:System.Collections.Generic.IList`1" />
            <seealso cref="T:System.Collections.ObjectModel.Collection`1" />
        </member>
        <member name="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Count">
            <summary>
            Gets the number of elements actually contained in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation returns the <see cref="P:System.Collections.Generic.ICollection`1.Count"/> property of the underlying collection.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly">
            <summary>
            Gets whether the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1" /> is read-only. Affects the behavior of <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Add(`0)">Add</see>, <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Insert(System.Int32,`0)">Insert</see>,
            <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Remove(`0)">Remove</see>, <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveAt(System.Int32)">RemoveAt</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Clear">Clear</see> methods.
            <br/>The base implementation returns the <see cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/> property of the underlying collection.
            </summary>
            <seealso cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.CanSetItem"/>
        </member>
        <member name="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.CanSetItem">
            <summary>
            Gets whether an item can be set through the <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Item(System.Int32)">indexer</see>.
            <br/>The base implementation returns <see langword="true"/> if <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="false"/> or when the wrapped collection is a one dimensional zero based array of <typeparamref name="T"/>;
            otherwise, returns <see langword="false"/>.
            </summary>
            <seealso cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/>
        </member>
        <member name="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Items">
            <summary>
            Gets the wrapped underlying collection maintained by this <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified <paramref name="index"/>.
            <br/>When read, calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItem(System.Int32)">GetItem</see> method, and when set, calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.SetItem(System.Int32,`0)">SetItem</see> method.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero, or is equal to or greater than <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Count"/>.</exception>
            <exception cref="T:System.NotSupportedException">The value is set and <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.CanSetItem"/> returns <see langword="false"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.#ctor">
            <summary>
            Initializes an empty instance of the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> class with a <see cref="T:KGySoft.Collections.CircularList`1"/> internally.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> class as a wrapper for the specified <paramref name="list"/>.
            </summary>
            <param name="list">The list that is wrapped by the new collection.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Add(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.InsertItem(System.Int32,`0)">InsertItem</see> method.
            </summary>
            <param name="item">The object to add to the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> at the specified <paramref name="index"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.InsertItem(System.Int32,`0)">InsertItem</see> method.</summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero, or greater than <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Count"/>.</exception>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Remove(`0)">
            <summary>
            Removes one occurrence of a specific object from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveItem(`0)">RemoveItem</see> method.
            </summary>
            <param name="item">The object to remove from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.</param>
            <returns><see langword="true"/>, if an occurrence of <paramref name="item"/> was removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveItemAt(System.Int32)">RemoveItem</see> method.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="true"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero, or is equal to or greater than <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Count"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Clear">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.ClearItems">ClearItems</see> method.
            </summary>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.IndexOf(`0)">
            <summary>
            Searches for the specified object and returns the zero-based index of an occurrence within the entire <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItemIndex(`0)">GetItemIndex</see> method.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>. The value can be <see langword="null"/> for reference types.</param>
            <returns>The zero-based index of the found occurrence of <paramref name="item" /> within the entire <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>, if found; otherwise, <c>-1</c>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Contains(`0)">
            <summary>
            Determines whether an element is in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.ContainsItem(`0)">ContainsItem</see> method.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>. The value can be <see langword="null"/> for reference types.</param>
            <returns><see langword="true"/> if <paramref name="item" /> is found in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation returns the enumerator of the underlying collection.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> for the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.</returns>
            <remarks>
            <note>If the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> was instantiated by the default constructor, then the returned enumerator supports
            the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method; otherwise, it depends on the enumerator of the wrapped collection.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> to a compatible one-dimensional <see cref="T:System.Array"/>, starting at the specified <paramref name="arrayIndex"/> of the target <paramref name="array"/>.
            <br/>Calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItem(System.Int32)">GetItem</see> method for each index between zero and <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Count"/>, excluding upper bound.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0 equal to or greater than the length of <paramref name="array"/>.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source list is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItemIndex(`0)">
            <summary>
            Gets the zero-based index of an occurrence of the specified <paramref name="item"/> within the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation calls the <see cref="M:System.Collections.Generic.IList`1.IndexOf(`0)">IndexOf</see> method of the underlying collection.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>. The value can be <see langword="null"/> for reference types.</param>
            <returns>The zero-based index of the found occurrence of <paramref name="item" /> within the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>, if found; otherwise, <c>-1</c>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.ContainsItem(`0)">
            <summary>
            Gets whether the specified <paramref name="item"/> is in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation calls the <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItemIndex(`0)">GetItemIndex</see> method.
            </summary>
            <param name="item">The object to locate in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>. The value can be <see langword="null"/> for reference types.</param>
            <returns><see langword="true"/> if <paramref name="item" /> is found in the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItem(System.Int32)">
            <summary>
            Gets the element at the specified <paramref name="index"/>.
            <br/>The base implementation gets the element at the specified <paramref name="index"/> by calling the <see cref="P:System.Collections.Generic.IList`1.Item(System.Int32)">indexer</see> of the underlying collection.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified <paramref name="index"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the <paramref name="item"/> at the specified <paramref name="index"/>.
            <br/>The base implementation sets the <paramref name="item"/> in the underlying collection by its <see cref="P:System.Collections.Generic.IList`1.Item(System.Int32)">indexer</see>.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/> at the specified <paramref name="index"/>.
            <br/>The base implementation calls the <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)">Insert</see> method of the underlying collection.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveItemAt(System.Int32)">
            <summary>
            Removes the element at the specified <paramref name="index"/> from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation calls the <see cref="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)">RemoveAt</see> method of the underlying collection.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveItem(`0)">
            <summary>
            Removes one occurrence of a specific object from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation calls the overridable <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.GetItemIndex(`0)">GetItemIndex</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveItemAt(System.Int32)">RemoveItem</see> methods.
            </summary>
            <param name="item">The object to remove from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.</param>
            <returns><see langword="true"/>, if an occurrence of <paramref name="item"/> was removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.IsReadOnly"/> returns <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            <br/>The base implementation calls the <see cref="M:System.Collections.Generic.ICollection`1.Clear">Clear</see> method of the underlying collection.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ObjectModel.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Collections.ObjectModel"/> namespace contains classes that can be used as collections
            in the object model of a reusable library. You can use these classes when properties or methods return collections.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.StringKeyedDictionary`1">
            <summary>
            Represents a string keyed dictionary that can be queried also by <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            and <see cref="T:System.ReadOnlySpan`1"/> (in .NET Core 2.1/.NET Standard 2.1 and above) instances.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <remarks>
            <para>Being as a regular <see cref="T:System.Collections.Generic.IDictionary`2"/> implementation with <see cref="T:System.String">string</see> key,
            the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class can be populated by keys and values as any regular dictionary.
            However, as it implements also the <see cref="T:KGySoft.Collections.IStringKeyedDictionary`1"/> interface, it allows accessing its values
            by using <see cref="T:KGySoft.CoreLibraries.StringSegment"/> (supported on every platform) and <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see>
            (in .NET Core 2.1/.NET Standard 2.1 and above) instances.</para>
            <para>The <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class uses a custom hashing, which usually makes it faster
            than a regular <see cref="T:System.Collections.Generic.Dictionary`2"/> with <see cref="T:System.String">string</see> key.
            <note type="security">Without specifying a comparer, the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class
            does not use randomized hashing for keys no longer than 32 characters. If you want to want to expose a <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>
            to a public service, then make sure you use it with a randomized hash comparer (eg. with <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalRandomized"/>).</note></para>
            <para>Depending on the context, the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> can return either a value type or reference type enumerator.
            When used in a C# <see langword="foreach"/> statement directly, the public <see cref="T:KGySoft.Collections.StringKeyedDictionary`1.Enumerator"/> type is used, which is a value type
            (this behavior is similar to the regular <see cref="T:System.Collections.Generic.Dictionary`2"/> class). But when the enumerator is obtained via the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface
            (occurs when using LINQ or extension methods), then the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> returns a reference type to avoid boxing and to provide a better performance.</para>
            <para>To use custom string comparison you can pass a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance to the constructors. It allows string comparisons
            by <see cref="T:System.String">string</see>, <see cref="T:KGySoft.CoreLibraries.StringSegment"/> and <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> instances.
            By default, the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> uses case-sensitive ordinal comparison.
            <note>Please note that when using a non-ordinal comparison, then depending on the targeted platform there might occur new string allocations when using
            query members with <see cref="T:KGySoft.CoreLibraries.StringSegment"/> or <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> parameter values.
            See the properties and the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.Create(System.Globalization.CultureInfo,System.Boolean)"/> method of the <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> class for more details.</note></para>
            </remarks>
            <threadsafety instance="false"/>
            <seealso cref="T:KGySoft.Collections.IStringKeyedDictionary`1"/>
            <seealso cref="T:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1"/>
            <seealso cref="T:KGySoft.CoreLibraries.StringSegment"/>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.ReferenceEnumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.ReferenceEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.ReferenceEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="T:KGySoft.Collections.StringKeyedDictionary`1.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="F:KGySoft.Collections.StringKeyedDictionary`1.Entry.Next">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last.
            Deleted items use negative indices below -1. Last deleted item has index -2.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Count">
            <summary>
            Gets number of elements currently stored in this <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Keys">
            <summary>
            Gets the keys stored in the dictionary.
            </summary>
            <remarks>
            <para>The returned <see cref="T:System.Collections.Generic.ICollection`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.ICollection`1"/> refers back to the keys in the original <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> continue to be reflected in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</para>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Values">
            <summary>
            Gets the values stored in the dictionary.
            </summary>
            <remarks>
            <para>The returned <see cref="T:System.Collections.Generic.ICollection`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.ICollection`1"/> refers back to the values in the original <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> continue to be reflected in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</para>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Item(System.String)">
            <summary>
            Gets or sets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            The element with the specified <paramref name="key"/>.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.</exception>
            <remarks>
            <para>A key cannot be <see langword="null"/>, but a value can be, if the type of values in the list, <typeparamref name="TValue"/>, is a reference or <see cref="T:System.Nullable`1"/> type.</para>
            <para>If the <paramref name="key"/> is not found when a value is being retrieved, <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is thrown.
            If the key is not found when a value is being set, the key and value are added.</para>
            <para>You can also use this property to add new elements by setting the value of a key that does not exist in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>, for example:
            <code lang="C#">myDictionary["myNonexistentKey"] = myValue;</code>
            However, if the specified key already exists in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>, setting this property
            overwrites the old value. In contrast, the <see cref="M:KGySoft.Collections.StringKeyedDictionary`1.Add(System.String,`0)">Add</see> method throws an <see cref="T:System.ArgumentException"/>, when <paramref name="key"/> already exists in the collection.</para>
            <para>Getting or setting this property approaches an O(1) operation.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Item(KGySoft.CoreLibraries.StringSegment)">
            <inheritdoc cref="P:KGySoft.Collections.IStringKeyedDictionary`1.Item(KGySoft.CoreLibraries.StringSegment)"/>
        </member>
        <member name="P:KGySoft.Collections.StringKeyedDictionary`1.Item(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="P:KGySoft.Collections.IStringKeyedDictionary`1.Item(System.ReadOnlySpan{System.Char})"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class
            using ordinal comparison.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(KGySoft.CoreLibraries.StringSegmentComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class
            using the specified <paramref name="comparer"/>.
            </summary>
            <param name="comparer">A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance to use when comparing keys.
            When <see langword="null"/>, ordinal comparison will be used.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(System.Int32,KGySoft.CoreLibraries.StringSegmentComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class
            using the specified <paramref name="capacity"/> and <paramref name="comparer"/>.
            </summary>
            <param name="capacity">The initial capacity that the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> can contain.</param>
            <param name="comparer">A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance to use when comparing keys.
            When <see langword="null"/>, ordinal comparison will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class
            using the specified <paramref name="capacity"/> and an ordinal comparer that satisfies the specified parameters.
            </summary>
            <param name="capacity">The initial capacity that the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> can contain.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case when comparing keys; otherwise, <see langword="false"/>.</param>
            <param name="useRandomizedHash"><see langword="true"/> to use a comparer that generates randomized hash codes for any string length; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class
            that uses an ordinal comparer that satisfies the specified parameters.
            </summary>
            <param name="ignoreCase"><see langword="true"/> to ignore case when comparing keys; otherwise, <see langword="false"/>.</param>
            <param name="useRandomizedHash"><see langword="true"/> to use a comparer that generates randomized hash codes for any string length; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},KGySoft.CoreLibraries.StringSegmentComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class from the specified <paramref name="dictionary"/>
            using the specified <paramref name="comparer"/>.
            </summary>
            <param name="dictionary">The dictionary whose elements are added to the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.</param>
            <param name="comparer">A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance to use when comparing keys.
            When <see langword="null"/>, ordinal comparison will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}},KGySoft.CoreLibraries.StringSegmentComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class from the specified <paramref name="collection"/>
            using the specified <paramref name="comparer"/>.
            </summary>
            <param name="collection">The collection whose elements are added to the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.</param>
            <param name="comparer">A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance to use when comparing keys.
            When <see langword="null"/>, ordinal comparison will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> class from serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this deserialization.</param>
            <remarks><note type="inherit">If an inherited type serializes data, which may affect the hashes of the keys, then override
            the <see cref="M:KGySoft.Collections.StringKeyedDictionary`1.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">OnDeserialization</see> method and use that to restore the data of the derived instance.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.Add(System.String,`0)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference and <see cref="T:System.Nullable`1"/> types.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.</exception>
            <remarks>
            <para>A key cannot be <see langword="null"/>, but a value can be, if the type of values in the sorted list, <typeparamref name="TValue"/>, is a reference or <see cref="T:System.Nullable`1"/> type.</para>
            <para>You can also use the <see cref="P:KGySoft.Collections.StringKeyedDictionary`1.Item(System.String)">indexer</see> to add new elements by setting the value of a
            key that does not exist in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>. for example:
            <code lang="C#"><![CDATA[myCollection["myNonexistentKey"] = myValue;]]></code>
            However, if the specified key already exists in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>, setting the <see cref="P:KGySoft.Collections.StringKeyedDictionary`1.Item(System.String)">indexer</see>
            overwrites the old value. In contrast, the <see cref="M:KGySoft.Collections.StringKeyedDictionary`1.Add(System.String,`0)">Add</see> method does not modify existing elements.</para>
            <para>This method approaches an O(1) operation unless if insertion causes a resize, in which case the operation is O(n).</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.Remove(System.String)">
            <summary>
            Removes the value with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            </summary>
            <param name="key">Key of the item to remove.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>. This method also returns <see langword="false"/> if key was not found in the dictionary.</returns>
            <remarks><para>If the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> does not contain an element with the specified key, the dictionary remains unchanged. No exception is thrown.</para>
            <para>This method approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            </summary>
            <remarks>
            <para>The <see cref="P:KGySoft.Collections.StringKeyedDictionary`1.Count"/> property is set to 0, and references to other objects from elements of the collection are also released.</para>
            <para>This method is an O(1) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.TryGetValue(System.String,`0@)">
            <summary>
            Tries to gets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/>, if this dictionary contains an element with the specified key; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <remarks>
            <para>If the <paramref name="key"/> is not found, then the <paramref name="value"/> parameter gets the appropriate default value
            for the type <typeparamref name="TValue"/>; for example, 0 (zero) for integer types, <see langword="false"/> for Boolean types, and <see langword="null"/> for reference types.</para>
            <para>This method approaches an O(1) operation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.TryGetValue(KGySoft.CoreLibraries.StringSegment,`0@)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.TryGetValue(KGySoft.CoreLibraries.StringSegment,`0@)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.TryGetValue(System.ReadOnlySpan{System.Char},`0@)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.TryGetValue(System.ReadOnlySpan{System.Char},`0@)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault(System.String)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault(System.String)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault``1(System.String,``0)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.String,``0)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault``1(System.String,System.Func{``0})">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.String,System.Func{``0})"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault(KGySoft.CoreLibraries.StringSegment)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault(KGySoft.CoreLibraries.StringSegment)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,``0)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,``0)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,System.Func{``0})">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,System.Func{``0})"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault(System.ReadOnlySpan{System.Char})"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},``0)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},``0)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},System.Func{``0})">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},System.Func{``0})"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.ContainsKey(System.String)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> contains a specific key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.</returns>
            <remarks><para>This method approaches an O(1) operation.</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.ContainsKey(KGySoft.CoreLibraries.StringSegment)">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.ContainsKey(KGySoft.CoreLibraries.StringSegment)"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.ContainsKey(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:KGySoft.Collections.IStringKeyedDictionary`1.ContainsKey(System.ReadOnlySpan{System.Char})"/>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.ContainsValue(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> contains a specific value.
            </summary>
            <param name="value">The value to locate in the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            The value can be <see langword="null"/> for reference types.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> contains an element with the specified <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="TValue"/> is an <see langword="enum"/> type,
            or the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other <typeparamref name="TValue"/> types.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            </summary>
            <returns>
            An <see cref="T:KGySoft.Collections.StringKeyedDictionary`1.Enumerator"/> that can be used to iterate through the <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.
            </returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            In a derived class populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the additional data of the derived type needed to serialize the target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization.</param>
        </member>
        <member name="M:KGySoft.Collections.StringKeyedDictionary`1.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">
            <summary>
            In a derived class restores the state the deserialized instance.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeCacheFactory">
            <summary>
            Provides factory methods to create thread-safe cache instances as <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> implementations.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0},KGySoft.Collections.ThreadSafeCacheOptionsBase)"/> method for details.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0},KGySoft.Collections.ThreadSafeCacheOptionsBase)">
            <summary>
            Creates a thread safe cache instance that can be accessed as an <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance.
            </summary>
            <typeparam name="TKey">The type of the key in the cache.</typeparam>
            <typeparam name="TValue">The type of the value in the cache.</typeparam>
            <param name="itemLoader">A delegate for loading a value, which is invoked when a key is not present in the cache.</param>
            <param name="comparer">An equality comparer to be used for hashing and comparing keys. If <see langword="null"/>, then a default comparison is used.</param>
            <param name="options">The options for creating the cache. If <see langword="null"/>, then a default <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> instance will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance that can be used to read the underlying cache in a thread-safe manner.</returns>
            <remarks>
            <note type="tip">If <typeparamref name="TKey"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.
            Or, you can use <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalRandomized">StringSegmentComparer.OrdinalRandomized</see> to use a comparer with randomized hash also on
            platforms where default string hashing is not randomized (eg. .NET Framework 3.5).</note>
            <para>A cache is similar to a dictionary (in terms of using a fast, associative storage) but additionally provides capacity management and transparent access (meaning,
            all that is needed is to read the <see cref="P:KGySoft.Collections.IThreadSafeCacheAccessor`2.Item(`0)">indexer</see> of the returned <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance, and
            it is transparent for the consumer whether the returned item was returned from the cache or it was loaded by invoking the specified <paramref name="itemLoader"/>).</para>
            <para>If <paramref name="options"/> is <see langword="null"/>, then a lock-free cache instance will be created as if a <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> was used with its default settings.</para>
            <para>In <c>KGy SOFT Core Libraries</c> there are two predefined classes that can be used to create a thread-safe cache instance: <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> and <see cref="T:KGySoft.Collections.LockingCacheOptions"/>.</para>
            <note type="tip">
            <list type="bullet">
            <item><see cref="T:KGySoft.Collections.LockFreeCacheOptions"/>: Use this one if you want the fastest, well scalable solution and it is not a problem that the <paramref name="itemLoader"/> delegate might
            be called concurrently, or capacity management is not too strict (when cache is full, about the half of the elements are dropped at once). Though rarely, it may also happen
            that <paramref name="itemLoader"/> is invoked multiple times when accessing the same key consecutively and the first call occurred during an internal merge session.</item>
            <item><see cref="T:KGySoft.Collections.LockingCacheOptions"/>: Use this one if you need strict capacity management, you want to dispose the dropped-out values, you want to ensure that the oldest
            or least recent used element is dropped in the first place, you want to protect the <paramref name="itemLoader"/> delegate from calling it concurrently, or if you want
            to specify an expiration time period for the values. If elements are often dropped, then it also uses less memory than the lock-free implementation. Depending on the configuration
            the actual type of the returned instance may vary but in all cases an instance of the public <see cref="T:KGySoft.Collections.Cache`2"/> type will be wrapped internally.</item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},KGySoft.Collections.ThreadSafeCacheOptionsBase)">
            <summary>
            Creates a thread safe cache instance that can be accessed as an <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0},KGySoft.Collections.ThreadSafeCacheOptionsBase)"/> overload for details.
            </summary>
            <typeparam name="TKey">The type of the key in the cache.</typeparam>
            <typeparam name="TValue">The type of the value in the cache.</typeparam>
            <param name="itemLoader">A delegate for loading a value, which is invoked when a key is not present in the cache.</param>
            <param name="options">The options for creating the cache. If <see langword="null"/>, then a default <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> instance will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance that can be used to read the underlying cache in a thread-safe manner.</returns>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeCacheOptionsBase">
            <summary>
            Represents the options for a thread safe cache instance to be created by the <see cref="O:KGySoft.Collections.ThreadSafeCacheFactory.Create"><![CDATA[ThreadSafeCacheFactory.Create<TKey, TValue>]]></see> methods.
            You can use the <see cref="T:KGySoft.Collections.LockingCacheOptions"/> and <see cref="T:KGySoft.Collections.LockFreeCacheOptions"/> types as built-in implementations.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Collections.ThreadSafeCacheFactory.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0},KGySoft.Collections.ThreadSafeCacheOptionsBase)"/> method for details.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeCacheOptionsBase.CreateInstance``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates an <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance, whose settings are represented by this <see cref="T:KGySoft.Collections.ThreadSafeCacheOptionsBase"/> instance.
            </summary>
            <typeparam name="TKey">The type of the key in the cache.</typeparam>
            <typeparam name="TValue">The type of the value in the cache.</typeparam>
            <param name="itemLoader">A delegate that is invoked when an item is not present in the cache.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> instance to be used for comparing keys in the cache instance to create.
            When <see langword="null"/>, a default comparer will be used.</param>
            <returns>An <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance, whose settings are represented by this <see cref="T:KGySoft.Collections.ThreadSafeCacheOptionsBase"/> instance.</returns>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeDictionary`2">
            <summary>
            Implements a thread-safe dictionary, which can be a good alternative for <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> where it is not available (.NET Framework 3.5),
            or where <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> has a poorer performance.
            </summary>
            <typeparam name="TKey">Type of the keys stored in the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values stored in the dictionary.</typeparam>
            <remarks>
            <note type="tip">
            <list type="bullet">
            <item>If you would only use the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/> method, then consider to create a thread safe cache by the <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/> instead,
            which is much faster than both <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> and <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, and supports capacity management as well.</item>
            <item>If you want to wrap any <see cref="T:System.Collections.Generic.IDictionary`2"/> into a thread-safe wrapper without copying the actual items, then you can also use <see cref="T:KGySoft.Collections.LockingDictionary`2"/>.</item>
            </list></note>
            <para>The purpose of <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> is similar to <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> but its approach is somewhat different.
            The <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> uses a group of locks to perform modifications (their amount can be configured or depends on the number of CPU cores);
            on the other hand, <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> uses two separate internal storage: items with new keys are added to a temporary storage using a single lock,
            which might regularly be merged into a faster lock-free storage, depending on the value of the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.MergeInterval"/> property. Once the items are merged, their access
            (both read and write) becomes lock free. Even deleting and re-adding a value for the same key becomes faster after the key is merged into the lock-free storage.
            <note>Therefore, <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> is not always a good alternative of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            If new keys are continuously added, then always a shared lock is used, in which case <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> might perform better, unless you need to use
            some members, which are very slow in <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> (see the table below). If the newly added elements are regularly removed,
            make sure the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys"/> property is <see langword="false"/>; otherwise, the already merged keys are not removed from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>
            even if they are deleted or when you call the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Clear">Clear</see> method. To remove even the merged keys you must call the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Reset">Reset</see> method,
            or to remove the deleted keys only you can explicitly call the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TrimExcess">TrimExcess</see> method.</note></para>
            <h2>Comparison with <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/></h2>
            <para><strong>When to use</strong>&#160;<see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>:
            <list type="bullet">
            <item>If it is known that a fixed set of keys will be used. <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> is fast if the already added keys are updated,
            or even deleted and re-added with any value. In this case consider to set the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys"/> to <see langword="true"/>, so it is not checked whether
            a cleanup should be performed due to many deleted items.</item>
            <item>If you access mainly existing keys by the <see cref="O:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate">AddOrUpdate</see> methods,
            which are separate try get/add/update operations at <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> but are optimized at <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> to avoid
            multiple lookups.</item>
            <item>If it is needed to access <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Count"/>, enumerate the items or <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/>/<see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Values"/>, or you need to call <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.ToArray">ToArray</see>,
            which are particularly slow in case of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</item>
            <item>If it is expected that there will be many hash collisions.</item>
            <item>If the dictionary is needed to be serialized.</item>
            </list></para>
            <para><strong>Performance comparison</strong> with <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> (default concurrency level depends on <see cref="P:System.Environment.ProcessorCount"/>):
            <list type="table">
            <listheader><term>Member(s) or operation</term><term><see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/></term><term><see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, concurrency level = 2</term><term><see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, concurrency level = 8</term></listheader>
            <item><term><see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Count">Count</see></term><term>Fastest</term><term>5.01x slower</term><term>530.44x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">TryAdd</see> (10 million new keys, sequential)</term><term>1.07x slower</term><term>Fastest</term><term>1.25x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">TryAdd</see> (10 million new keys, parallel)</term><term>1.02x slower</term><term>Fastest</term><term>1.53x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">TryGetValue</see> (no collisions, <typeparamref name="TKey"/> is <see cref="T:System.Int32">int</see>)</term><term>1.55x slower</term><term>Fastest</term><term>Fastest</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">TryGetValue</see> (no collisions, <typeparamref name="TKey"/> is <see cref="T:System.String">string</see>)</term><term>Fastest</term><term>1.26x slower</term><term>1.26x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">TryGetValue</see> (many key collisions)</term><term>Fastest</term><term>1.92x slower</term><term>2.01x slower</term></item>
            <item><term><see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Item(`0)">Indexer</see> set (sequential, <typeparamref name="TKey"/> is <see cref="T:System.Int32">int</see>)</term><term>Fastest</term><term>1.07x slower</term><term>1.07x slower</term></item>
            <item><term><see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Item(`0)">Indexer</see> set (parallel, <typeparamref name="TKey"/> is <see cref="T:System.Int32">int</see>)</term><term>Fastest</term><term>2.03x slower</term><term>1.01x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryUpdate(`0,`1,`1)">TryUpdate</see> (sequential)</term><term>Fastest</term><term>1.21x slower</term><term>1.17x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryUpdate(`0,`1,`1)">TryUpdate</see> (parallel)</term><term>Fastest</term><term>4.02x slower</term><term>1.27x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryRemove(`0)">TryRemove</see> + <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">TryAdd</see> (same key, sequential)</term><term>Fastest</term><term>1.12x slower</term><term>1.16x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryRemove(`0)">TryRemove</see> + <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">TryAdd</see> (same key, parallel)</term><term>Fastest</term><term>2.53x slower</term><term>2.43x slower</term></item>
            <item><term>Enumerating items</term><term>Fastest</term><term>2.87x slower</term><term>262.45x slower</term></item>
            <item><term>Enumerating <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/></term><term>Fastest</term><term>117.92x slower</term><term>368.11x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.ToArray">ToArray</see></term><term>1.69x slower</term><term>Fastest</term><term>2.12x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">AddOrUpdate</see> (random existing keys, sequential)</term><term>Fastest</term><term>3.35x slower</term><term>3.16x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">AddOrUpdate</see> (random existing keys, parallel)</term><term>Fastest</term><term>9.74x slower</term><term>2.27x slower</term></item>
            <item><term><see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd(`0,`1)">GetOrAdd</see> (random existing keys)</term><term>1.11x slower</term><term>Fastest</term><term>Fastest</term></item>
            </list>
            <note type="tip">If <typeparamref name="TKey"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the constructor for even better performance.
            Or, you can use <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalRandomized">StringSegmentComparer.OrdinalRandomized</see> to use a comparer with randomized hash also on
            platforms where default string hashing is not randomized (eg. .NET Framework 3.5).</note></para>
            <para><strong>Incompatibilities</strong> with <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>:
            <list type="bullet">
            <item>Constructor signatures are different</item>
            <item>The <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/> and <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Values"/> property of <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> return wrappers for the current keys and values
            (enumerating the same instance again and again may yield different items), whereas <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> returns a snapshot for these properties.</item>
            <item>The <see cref="P:System.Collections.ICollection.SyncRoot"/> property of <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/> and <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Values"/> throw a <see cref="T:System.NotSupportedException"/> just like for their
            owner <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> instance. In contrast, in case of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> only the dictionary itself throws an exception
            when accessing the <see cref="P:System.Collections.ICollection.SyncRoot"/>, whereas its keys and values don't.</item>
            </list></para>
            <para><strong>Incompatibilities</strong> with <see cref="T:System.Collections.Generic.Dictionary`2"/>:
            <list type="bullet">
            <item>Constructor signatures are different, though due to default parameters they are compile-compatible.</item>
            <item>The <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> does not have an <see cref="M:System.Collections.Generic.Dictionary`2.EnsureCapacity(System.Int32)">EnsureCapacity</see> method.</item>
            <item>The <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">GetObjectData</see> and <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">OnDeserialization</see> methods are protected rather than public.</item>
            <item>The enumerators of the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/> and <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Values"/> properties do not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</item>
            <item>The <see cref="P:System.Collections.ICollection.SyncRoot"/> property of <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/> and <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Values"/> as well as for the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>
            itself throws a <see cref="T:System.NotSupportedException"/>.</item>
            </list></para>
            </remarks>
            <threadsafety instance="true"/>
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/>
            <seealso cref="T:KGySoft.Collections.LockingDictionary`2"/>
            <seealso cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeDictionary`2.fixedSizeStorage">
            <summary>
            Values here are accessed without locking.
            Once a new key is added, it is never removed anymore even for deleted entries.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeDictionary`2.expandableStorage">
            <summary>
            A temporary storage for new values. It is regularly merged with fixedSizeStorage into a new fixed size instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.Count">
            <summary>
            Gets the number of elements contained in this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.IsEmpty">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> is empty.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys">
            <summary>
            Gets or sets whether keys of entries that have already been merged into the faster lock-free storage are preserved even when their value is removed.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>If the possible number of keys in this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> is known to be a limited value, then this property
            can be set to <see langword="true"/>, so once the values have been merged into the faster lock-free storage, their entry is not removed anymore even if the
            corresponding value is deleted. This ensures that removing and re-adding a value with the same key again and again remains a lock-free operation.
            <note>Do not set this property to <see langword="true"/>, if the number of the possibly added keys is not limited.</note></para>
            <para>This property can be set to <see langword="true"/> even if keys are never removed so it is not checked before a merge operation whether
            the amount of deleted items exceeds a specific limit.</para>
            <para>If this property is <see langword="true"/>, then the already merged keys are not removed even when calling the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Clear">Clear</see> method.
            The memory of the deleted entries can be freed by explicitly calling the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TrimExcess">TrimExcess</see> method,
            whereas to remove all allocated entries you can call the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Reset">Reset</see> method.</para>
            <para>Even if this property is <see langword="false"/>, the removed keys are not dropped immediately. Unused keys are removed during a merge operation and only
            when their number exceeds a specific limit. You can call the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TrimExcess">TrimExcess</see> method to force removing unused keys on demand.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.MergeInterval">
            <summary>
            Gets or sets the minimum lifetime for the temporarily created internal locking storage when adding new keys to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            <br/>Default value: 100 milliseconds.
            </summary>
            <remarks>
            <para>When adding items with new keys, they will be put in a temporary locking storage first.
            Whenever the locking storage is accessed, it will be checked whether the specified time interval has been expired since its creation. If so, then
            it will be merged with the previous content of the fast non-locking storage into a new one.
            If new keys are typically added together, rarely or periodically, then it is recommended to set some small positive value (up to a few seconds).</para>
            <para>Even if the value of this property is <see cref="F:System.TimeSpan.Zero">TimeSpan.Zero</see>, adding new items are not necessarily merged immediately
            to the fast-accessing storage. Depending on the targeted platform a minimum 15 ms delay is possible. Setting <see cref="F:System.TimeSpan.Zero">TimeSpan.Zero</see>
            is not recommended though, unless new items are almost never added at the same time.</para>
            <para>When the value of this property is negative (eg. <see cref="F:System.Threading.Timeout.InfiniteTimeSpan">Timeout.InfiniteTimeSpan</see>), then the locking storage is not merged
            automatically with the lock-free storage. You still can call the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.EnsureMerged">EnsureMerged</see> method to perform a merge explicitly.</para>
            <para>This property is ignored if a value is accessed in the fast-accessing storage including removing and adding values of keys that have already been merged to the lock-free storage.</para>
            <note>Some operations (such as enumerating the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> or its <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys"/> and <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Values"/>,
            calling the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.ToArray">ToArray</see> or the <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)">ICollection.CopyTo</see> implementations) as well as serializing the dictionary may trigger a merging
            operation regardless the value of this property.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.Keys">
            <summary>
            Gets a collection reflecting the keys stored in this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <remarks>
            <para>The returned <see cref="T:System.Collections.Generic.ICollection`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.ICollection`1"/> refers back to the keys in the original <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> continue to be reflected in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</para>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.Values">
            <summary>
            Gets a collection reflecting the values stored in this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <remarks>
            <para>The returned <see cref="T:System.Collections.Generic.ICollection`1"/> is not a static copy; instead, the <see cref="T:System.Collections.Generic.ICollection`1"/> refers back to the values in the original <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            Therefore, changes to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> continue to be reflected in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</para>
            <para>Retrieving the value of this property is an O(1) operation.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> that is used to determine equality of keys for this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns>The value of the specified <paramref name="key"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> does not exist in the collection.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class that is empty
            and uses the default comparer and <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/> hashing strategy.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.#ctor(System.Int32,KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class that is empty
            and uses the default comparer and the specified hashing <paramref name="strategy"/>.
            </summary>
            <param name="capacity">Specifies the initial minimum capacity of the internal temporal storage for values with new keys.
            If 0, then a default capacity is used.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class that is empty
            and uses the specified <paramref name="comparer"/> and hashing <paramref name="strategy"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
            <remarks>
            <note type="tip">If <typeparamref name="TKey"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class that is empty
            and uses the specified <paramref name="comparer"/> and hashing <paramref name="strategy"/>.
            </summary>
            <param name="capacity">Specifies the initial minimum capacity of the internal temporal storage for values with new keys.
            If 0, then a default capacity is used.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
            <remarks>
            <note type="tip">If <typeparamref name="TKey"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0},KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class from the specified <paramref name="collection"/>
            and uses the specified <paramref name="comparer"/> and hashing <paramref name="strategy"/>.
            </summary>
            <param name="collection">The collection whose elements are coped to the new <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> key types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
            <remarks>
            <note type="tip">If <typeparamref name="TKey"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class from serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this deserialization.</param>
            <remarks><note type="inherit">If an inherited type serializes data, which may affect the hashes of the keys, then override
            the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">OnDeserialization</see> method and use that to restore the data of the derived instance.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference types.</param>
            <remarks>
            <para>If the <paramref name="key"/> of element already exists in the cache, this method throws an exception.
            In contrast, using the setter of the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Item(`0)">indexer</see> property replaces the old value with the new one.</para>
            <para>If multiple values are added to this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> concurrently, then you should use
            the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">TryAdd</see> method instead, which simply returns <see langword="false"/> if the <paramref name="key"/>
            to add already exists in the dictionary.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="key"/> already exists in the cache.</exception>
            <seealso cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Item(`0)"/>
            <seealso cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)"/>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add the specified <paramref name="key"/> and <paramref name="value"/> to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be <see langword="null"/> for reference types.</param>
            <returns><see langword="true"/> if <paramref name="key"/> and <paramref name="value"/> was added to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> successfully;
            <see langword="false"/> if the key already exists.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <seealso cref="O:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd">GetOrAdd</seealso>
            <seealso cref="O:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate">AddOrUpdate</seealso>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value associated with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <returns><see langword="true"/> if the key was found in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>; otherwise, <see langword="false"/>.</returns>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <seealso cref="P:KGySoft.Collections.ThreadSafeDictionary`2.Item(`0)"/>
            <seealso cref="O:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd">GetOrAdd</seealso>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> contains an element with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key to locate in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.ContainsValue(`1)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> contains an element with the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value to locate in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> contains an element with the specified <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method determines equality using the <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see> when <typeparamref name="TValue"/> is an <see langword="enum"/> type,
            or the default equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other <typeparamref name="TValue"/> types.</para>
            <para>This method performs a linear search; therefore, this method is an O(n) operation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TryRemove(`0)">
            <summary>
            Tries to remove the value with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <param name="key">Key of the item to remove.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.Remove(`0)">
            <summary>
            Tries to remove the value with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            This method just calls the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.TryRemove(`0)">TryRemove</see> method. It exists just for providing compatibility with the <see cref="T:System.Collections.Generic.Dictionary`2"/> type.
            </summary>
            <param name="key">Key of the item to remove.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TryRemove(`0,`1@)">
            <summary>
            Tries to remove and return the <paramref name="value"/> with the specified <paramref name="key"/> from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <param name="key">Key of the item to remove.</param>
            <param name="value">When this method returns, contains the value removed from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>,
            or the default value of the <typeparamref name="TValue"/> type if <paramref name="key"/> does not exist.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TryRemove(`0,`1)">
            <summary>
            Tries to remove the item from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> that has the specified <paramref name="key"/> and <paramref name="value"/>.
            </summary>
            <param name="key">The key of the item to remove.</param>
            <param name="value">The value of the item to remove.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.Clear">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys"/> is <see langword="true"/>, or when the amount of removed items does not exceed a limit, then
            This method is an O(n) operation where n is the number of elements present in the inner lock-free storage. Otherwise,
            this method calls the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Reset">Reset</see> method, which frees up all the allocated entries.</para>
            <note>Note that if <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys"/> is <see langword="true"/>, then though this method removes all values from
            the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, it never removes the keys that are already merged into the faster lock-free storage.
            This ensures that adding a new value with an already used key will always be a fast, lock-free operation.
            To remove all keys and values use the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Reset">Reset</see> method instead.</note>
            </remarks>
            <seealso cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Reset"/>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.Reset">
            <summary>
            Removes all keys and values from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Clear">Clear</see> method for details.
            </summary>
            <seealso cref="M:KGySoft.Collections.ThreadSafeDictionary`2.Clear"/>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TryUpdate(`0,`1,`1)">
            <summary>
            Updates the value associated with <paramref name="key"/> to <paramref name="newValue"/>
            if the existing value with <paramref name="key"/> is equal to <paramref name="originalValue"/>.
            </summary>
            <param name="key">The key of the item to replace.</param>
            <param name="newValue">The replacement value of <paramref name="key"/> if its value equals to <paramref name="originalValue"/>.</param>
            <param name="originalValue">The expected original value of the stored item with the associated <paramref name="key"/>.</param>
            <returns><see langword="true"/> if the value with <paramref name="key"/> was equal to <paramref name="originalValue"/>
            and was replaced with <paramref name="newValue"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate(`0,`1,`1)">
            <summary>
            Adds or updates a key/value pair in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> based on whether the specified <paramref name="key"/> already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValue">The value to be added for an absent key.</param>
            <param name="updateValue">The value to be set for an existing key.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either <paramref name="addValue"/> (if the key was absent)
            or <paramref name="updateValue"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> if the <paramref name="key"/> does not already exist,
            or updates a key/value pair in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> by using the specified <paramref name="updateValueFactory"/> if the <paramref name="key"/> already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValue">The value to be added for an absent key.</param>
            <param name="updateValueFactory">A delegate used to generate a new value for an existing key based on the key's existing value.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either <paramref name="addValue"/> (if the key was absent)
            or the result of <paramref name="updateValueFactory"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> or <paramref name="updateValueFactory"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Uses the specified delegates to add a key/value pair to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> if the <paramref name="key"/> does not already exist,
            or to update a key/value pair in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> if the <paramref name="key"/> already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValueFactory">A delegate used to generate a value for an absent key.</param>
            <param name="updateValueFactory">A delegate used to generate a new value for an existing key based on the key's existing value.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either the result of <paramref name="addValueFactory"/> (if the key was absent)
            or the result of <paramref name="updateValueFactory"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/>, <paramref name="addValueFactory"/> or <paramref name="updateValueFactory"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)">
            <summary>
            Uses the specified delegates to add a key/value pair to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> if the <paramref name="key"/> does not already exist,
            or to update a key/value pair in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> if the <paramref name="key"/> already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into <paramref name="addValueFactory"/> and <paramref name="updateValueFactory"/>.</typeparam>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValueFactory">A delegate used to generate a value for an absent key.</param>
            <param name="updateValueFactory">A delegate used to generate a new value for an existing key based on the key's existing value.</param>
            <param name="factoryArgument">An argument to pass into <paramref name="addValueFactory"/> and <paramref name="updateValueFactory"/>.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either the result of <paramref name="addValueFactory"/> (if the key was absent)
            or the result of <paramref name="updateValueFactory"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/>, <paramref name="addValueFactory"/> or <paramref name="updateValueFactory"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> if the key does not already exist, and returns either the added or the existing value.
            </summary>
            <param name="key">The key of the element to add or whose value should be returned.</param>
            <param name="addValue">The value to be added, if the key does not already exist.</param>
            <returns>The value for the key. This will be either the existing value for the <paramref name="key"/> if the key is already in the dictionary,
            or the specified <paramref name="addValue"/> if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> by using the specified <paramref name="addValueFactory"/>
            if the key does not already exist, and returns either the added or the existing value.
            </summary>
            <param name="key">The key of the element to add or whose value should be returned.</param>
            <param name="addValueFactory">The delegate to be used to generate the value, if the key does not already exist.</param>
            <returns>The value for the key. This will be either the existing value for the <paramref name="key"/> if the key is already in the dictionary,
            or the result of the specified <paramref name="addValueFactory"/> if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> or <paramref name="addValueFactory"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> by using the specified <paramref name="addValueFactory"/>
            if the key does not already exist, and returns either the added or the existing value.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into <paramref name="addValueFactory"/>.</typeparam>
            <param name="key">The key of the element to add or whose value should be returned.</param>
            <param name="addValueFactory">The delegate to be used to generate the value, if the key does not already exist.</param>
            <param name="factoryArgument">An argument to pass into <paramref name="addValueFactory"/>.</param>
            <returns>The value for the key. This will be either the existing value for the <paramref name="key"/> if the key is already in the dictionary,
            or the result of the specified <paramref name="addValueFactory"/> if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> or <paramref name="addValueFactory"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.EnsureMerged">
            <summary>
            Ensures that all elements in this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> are merged into the faster lock-free storage.
            <br/>See the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.MergeInterval"/> property for details.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TrimExcess">
            <summary>
            Forces to perform a merge while removing all possibly allocated but already deleted entries from the lock-free storage,
            even if the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys"/> property is <see langword="true"/>.
            <br/>See the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Collections.ThreadSafeDictionary`2.PreserveMergedKeys"/> property for details.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the keys and values of this <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            </returns>
            <remarks>
            <para>The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary; however, it does not represent a moment-in-time snapshot of the dictionary.
            The contents exposed through the enumerator may contain modifications made to the dictionary after <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.GetEnumerator">GetEnumerator</see> was called.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.ToArray">
            <summary>
            Copies the key and value pairs stored in the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of key and value pairs copied from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            In a derived class populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the additional data of the derived type needed to serialize the target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization.</param>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">
            <summary>
            In a derived class restores the state the deserialized instance.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage">
            <summary>
            Represents a lock-free fixed size thread safe dictionary that supports updating values in a thread-safe manner,
            though adding new values is not supported. Removing and re-setting keys are supported though, which is also thread-safe.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.Entry.Value">
            <summary>
            A reference to the actual value that can be accessed by volatile read. Value is null if the item is deleted.
            If the inner value can be overwritten atomically, then the reference is replaced only on delete/restore.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.Entry.Next">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last.
            In this collection this field is practically read-only. Deleted items are indicated by a null Value.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.TryInsertInternal(`0,`1,System.UInt32,KGySoft.Collections.DictionaryInsertion)">
            <summary>
            Tries to insert a value. Returns null if key not found. Adding succeeds only if a key was deleted previously.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.TryReplaceInternal(`0,`1,`1,System.UInt32)">
            <summary>
            Tries to replace a value. Returns null if key not found.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.TryInitialize(KGySoft.Collections.ThreadSafeDictionary{`0,`1}.FixedSizeStorage,KGySoft.Collections.ThreadSafeDictionary{`0,`1}.TempStorage)">
            <summary>
            Similar to <see cref="M:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.Initialize(KGySoft.Collections.ThreadSafeDictionary{`0,`1}.FixedSizeStorage,KGySoft.Collections.ThreadSafeDictionary{`0,`1}.TempStorage)"/> but tries to skip deleted entries.
            Might fail if elements have been added/removed to other during the process.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.FixedSizeStorage.GetBucketIndex(System.UInt32)">
            <summary>
            An if in a non-virtual method is still faster than calling an abstract method, a delegate or even a C# 9 function pointer
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeDictionary`2.TempStorage">
            <summary>
            When instantiated, always has a preallocated storage.
            Not thread-safe so the consumer must do the locking when calling the internal members.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeDictionary`2.TempStorage.Entry.Next">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last.
            Deleted items use negative indices below -1. Last deleted item has index -2.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeDictionary`2.TempStorage.GetBucketIndex(System.UInt32)">
            <summary>
            An if in a non-virtual method is still faster than calling an abstract method, a delegate or even a C# 9 function pointer
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeHashSet`1">
            <summary>
            Implements a thread-safe hash set, which has similar characteristics to <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>.
            It can be a good alternative for <see cref="T:System.Collections.Generic.HashSet`1"/>, <see cref="T:KGySoft.Collections.LockingCollection`1"/>, or when one would use
            a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> with ignored values.
            </summary>
            <typeparam name="T">Type of the items stored in the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.</typeparam>
            <remarks>
            <note type="tip">If you want to wrap any <see cref="T:System.Collections.Generic.ICollection`1"/> into a thread-safe wrapper without copying the actual items, then you can also use <see cref="T:KGySoft.Collections.LockingCollection`1"/>.</note>
            <para><see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> uses a very similar approach to <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>. It uses two separate
            internal storage: new items are added to a temporary storage using a single lock, which might regularly be merged into a faster lock-free storage,
            depending on the value of the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.MergeInterval"/> property. Once the items are merged, their access
            (both read and write) becomes lock free. Even deleting and re-adding an item becomes faster after it has been merged into the lock-free storage.
            <note>Therefore, <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> is not always a good alternative of <see cref="T:KGySoft.Collections.LockingCollection`1"/>,
            or even a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> with ignored values. If new items are continuously added, then always a shared lock is used,
            in which case <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> might perform better, unless you need to use
            some members, which are very slow in <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> (see the performance comparison table at the <strong>Remarks</strong>
            section of the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class). If the newly added elements are regularly removed, make sure
            the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems"/> property is <see langword="false"/>; otherwise, the already merged items are just marked deleted when removed from
            the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> or when you call the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Clear">Clear</see> method. To remove even the merged items you must call
            the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Reset">Reset</see> method, or to remove the deleted items only you can explicitly call the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.TrimExcess">TrimExcess</see> method.</note></para>
            <h2>Comparison with other thread-safe collections.</h2>
            <para><strong>When to prefer</strong>&#160;<see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> over <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>:
            <list type="bullet">
            <item>If you would use only the keys, without any value.</item>
            <item>If it is known that a fixed number of items will be used, or <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Contains(`0)">Contains</see> will be used much more often than <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Add(`0)">Add</see>,
            in which case <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> may become mainly lock-free.</item>
            <item>If the same set of items are deleted and re-added again and again. In this case consider to set the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems"/>
            to <see langword="true"/>, so it is not checked whether a cleanup should be performed due to many deleted items.</item>
            <item>If it is needed to access <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.Count"/>, enumerate the items or you need to call <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.ToArray">ToArray</see>,
            which are particularly slow in case of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</item>
            <item>If it is expected that there will be many hash collisions.</item>
            <item>If the collection is needed to be serialized.</item>
            </list>
            <note type="tip">If <typeparamref name="T"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the constructor for even better performance.
            Or, you can use <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalRandomized">StringSegmentComparer.OrdinalRandomized</see> to use a comparer with randomized hash also on
            platforms where default string hashing is not randomized (eg. .NET Framework 3.5).</note></para>
            <para><strong>When to prefer</strong>&#160;<see cref="T:KGySoft.Collections.LockingCollection`1"/> over <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>:
            <list type="bullet">
            <item>If you just need a wrapper for an already existing <see cref="T:System.Collections.Generic.ICollection`1"/> without copying the actual items.</item>
            <item>If you just need a simple thread-safe solution without additional allocations (unless if you enumerate the collection)
            and it's not a problem if it cannot scale well for high concurrency.</item>
            </list></para>
            <para><strong>Incompatibilities</strong> with <see cref="T:System.Collections.Generic.HashSet`1"/>:
            <list type="bullet">
            <item>Some of the constructors have different parameters.</item>
            <item><see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> does not implement the <see cref="T:System.Collections.Generic.ISet`1"/> interface because most of its members
            make little sense when the instance is used concurrently.</item>
            <item>It has no public <c>CopyTo</c> methods. The <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)">ICollection&lt;T>.CopyTo</see> method
            is implemented explicitly, though it is not recommended to use it because when elements are added or removed during the operation
            you cannot tell how many elements were actually copied. Use the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.ToArray">ToArray</see> method instead, which works in all circumstances.</item>
            </list></para>
            </remarks>
            <threadsafety instance="true"/>
            <seealso cref="T:KGySoft.Collections.LockingCollection`1"/>
            <seealso cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeHashSet`1.fixedSizeStorage">
            <summary>
            Items here are accessed without locking.
            Once a new item is added, it is never removed anymore even when they are deleted
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeHashSet`1.expandableStorage">
            <summary>
            A temporary storage for new values. It is regularly merged with fixedSizeStorage into a new fixed size instance.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeHashSet`1.Count">
            <summary>
            Gets the number of elements contained in this <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeHashSet`1.IsEmpty">
            <summary>
            Gets whether this <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> is empty.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems">
            <summary>
            Gets or sets whether items that have already been merged into the faster lock-free storage are preserved even when they are deleted.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>If the possible number of items in this <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> is known to be a limited value, then this property
            can be set to <see langword="true"/>, so once the items have been merged into the faster lock-free storage, their entry is not removed anymore even if they
            are deleted. This ensures that removing and re-adding an item again and again remains a lock-free operation.
            <note>Do not set this property to <see langword="true"/>, if the number of the possibly added items is not limited.</note></para>
            <para>This property can be set to <see langword="true"/> even if items are never removed so it is not checked before a merge operation whether
            the amount of deleted items exceeds a specific limit.</para>
            <para>If this property is <see langword="true"/>, then the already merged items are not removed even when calling the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Clear">Clear</see> method.
            The memory of the deleted entries can be freed by explicitly calling the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.TrimExcess">TrimExcess</see> method,
            whereas to remove all allocated entries you can call the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Reset">Reset</see> method.</para>
            <para>Even if this property is <see langword="false"/>, the removed items are not dropped immediately. Unused items are removed during a merge operation and only
            when their number exceeds a specific limit. You can call the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.TrimExcess">TrimExcess</see> method to force removing unused items on demand.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeHashSet`1.MergeInterval">
            <summary>
            Gets or sets the minimum lifetime for the temporarily created internal locking storage when adding new items to the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            <br/>Default value: 100 milliseconds.
            </summary>
            <remarks>
            <para>When adding new items, they will be put in a temporary locking storage first.
            Whenever the locking storage is accessed, it will be checked whether the specified time interval has been expired since its creation. If so, then
            it will be merged with the previous content of the fast non-locking storage into a new one.
            If new items are typically added together, rarely or periodically, then it is recommended to set some small positive value (up to a few seconds).</para>
            <para>Even if the value of this property is <see cref="F:System.TimeSpan.Zero">TimeSpan.Zero</see>, adding new items are not necessarily merged immediately
            to the fast-accessing storage. Depending on the targeted platform a minimum 15 ms delay is possible. Setting <see cref="F:System.TimeSpan.Zero">TimeSpan.Zero</see>
            is not recommended though, unless new items are almost never added at the same time.</para>
            <para>When the value of this property is negative (eg. <see cref="F:System.Threading.Timeout.InfiniteTimeSpan">Timeout.InfiniteTimeSpan</see>), then the locking storage is not merged
            automatically with the lock-free storage. You still can call the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.EnsureMerged">EnsureMerged</see> method to perform a merge explicitly.</para>
            <para>This property is ignored if an item is accessed in the fast-accessing storage including removing and adding items that have already been merged to the lock-free storage.</para>
            <note>Some operations (such as enumerating the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>, calling the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.ToArray">ToArray</see>
            or the <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)">ICollection.CopyTo</see> implementations) as well as serialization may trigger a merging operation
            regardless the value of this property.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.ThreadSafeHashSet`1.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> that is used to determine equality of items for this <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class that is empty
            and uses the default comparer and <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/> hashing strategy.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.#ctor(System.Int32,KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class that is empty
            and uses the default comparer and the specified hashing <paramref name="strategy"/>.
            </summary>
            <param name="capacity">Specifies the initial minimum capacity of the internal temporal storage for new items.
            If 0, then a default capacity is used.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class that is empty
            and uses the specified <paramref name="comparer"/> and hashing <paramref name="strategy"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing items. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> item types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
            <remarks>
            <note type="tip">If <typeparamref name="T"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class that is empty
            and uses the specified <paramref name="comparer"/> and hashing <paramref name="strategy"/>.
            </summary>
            <param name="capacity">Specifies the initial minimum capacity of the internal temporal storage for new items.
            If 0, then a default capacity is used.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing items. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> item types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
            <remarks>
            <note type="tip">If <typeparamref name="T"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0},KGySoft.Collections.HashingStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class from the specified <paramref name="collection"/>
            and uses the specified <paramref name="comparer"/> and hashing <paramref name="strategy"/>.
            </summary>
            <param name="collection">The collection whose elements are coped to the new <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing items. When <see langword="null"/>, <see cref="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">EnumComparer&lt;TEnum&gt;.Comparer</see>
            will be used for <see langword="enum"/> item types, and <see cref="P:System.Collections.Generic.EqualityComparer`1.Default">EqualityComparer&lt;T&gt;.Default</see> for other types. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="strategy">The hashing strategy to be used in the created <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Collections.HashingStrategy.Auto"/>.</param>
            <remarks>
            <note type="tip">If <typeparamref name="T"/> is <see cref="T:System.String">string</see> and it is safe to use a non-randomized string comparer,
            then you can pass <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">StringSegmentComparer.Ordinal</see> to the <paramref name="comparer"/> parameter for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> class from serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this deserialization.</param>
            <remarks><note type="inherit">If an inherited type serializes data, which may affect the hashes of the keys, then override
            the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">OnDeserialization</see> method and use that to restore the data of the derived instance.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.Add(`0)">
            <summary>
            Adds the specified <paramref name="item"/> to the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns><see langword="true"/> if <paramref name="item"/> was added to the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>;
            <see langword="false"/> if the element is already present judged by the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.Comparer"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.TryGetValue(`0,`0@)">
            <summary>
            Tries to get the actual stored item for the specified <paramref name="equalValue"/> in the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            It can be useful to obtain the actually stored reference when the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.Comparer"/> can consider different instances equal.
            </summary>
            <returns><see langword="true"/> if an item equal to <paramref name="equalValue"/> was found in the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>; otherwise, <see langword="false"/>.</returns>
            <param name="equalValue">The item to search for.</param>
            <param name="actualValue">When this method returns, the actually stored value, if the <paramref name="equalValue"/> is present in
            the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> judged by the current <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.Comparer"/>; otherwise, the default value for the type <typeparamref name="T"/>. This parameter is passed uninitialized.</param>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> contains the specified <paramref name="item"/>.
            </summary>
            <param name="item">The element to locate in the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> contains the specified <paramref name="item"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.Remove(`0)">
            <summary>
            Tries to remove the specified <paramref name="item"/> from the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </summary>
            <param name="item">The element to remove.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.Clear">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems"/> is <see langword="true"/>, or when the amount of removed items does not exceed a limit, then
            This method is an O(n) operation where n is the number of elements present in the inner lock-free storage. Otherwise,
            this method calls the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Reset">Reset</see> method, which frees up all the allocated entries.</para>
            <note>Note that if <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems"/> is <see langword="true"/>, then though this method marks all items deleted in
            the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>, it never actually removes the items that are already merged into the faster lock-free storage.
            This ensures that re-adding a previously removed item will always be a fast, lock-free operation.
            To actually remove all items use the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Reset">Reset</see> method instead.</note>
            </remarks>
            <seealso cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Reset"/>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.Reset">
            <summary>
            Removes all items from the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Clear">Clear</see> method for details.
            </summary>
            <seealso cref="M:KGySoft.Collections.ThreadSafeHashSet`1.Clear"/>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.EnsureMerged">
            <summary>
            Ensures that all elements in this <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> are merged into the faster lock-free storage.
            <br/>See the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.MergeInterval"/> property for details.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.TrimExcess">
            <summary>
            Forces to perform a merge while removing all possibly allocated but already deleted entries from the lock-free storage,
            even if the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems"/> property is <see langword="true"/>.
            <br/>See the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Collections.ThreadSafeHashSet`1.PreserveMergedItems"/> property for details.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the items of this <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.
            </returns>
            <remarks>
            <para>The returned enumerator is safe to use concurrently with reads and writes to the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>; however,
            it does not represent a moment-in-time snapshot. The contents exposed through the enumerator may contain modifications made to the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>
            after <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.GetEnumerator">GetEnumerator</see> was called.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.ToArray">
            <summary>
            Copies the items stored in the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of items copied from the <see cref="T:KGySoft.Collections.ThreadSafeHashSet`1"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            In a derived class populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the additional data of the derived type needed to serialize the target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization.</param>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.OnDeserialization(System.Runtime.Serialization.SerializationInfo)">
            <summary>
            In a derived class restores the state the deserialized instance.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that stores the data.</param>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage">
            <summary>
            Represents a lock-free fixed size thread safe collection that supports updating values in a thread-safe manner,
            though adding new items is not supported. Removing and re-setting items are supported though, which is also thread-safe.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.Entry.Next">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last.
            In this collection this field is practically read-only. Deleted items are indicated by the <see cref="F:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.Entry.IsDeleted"/> field.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.Entry.IsDeleted">
            <summary>
            Cannot be a bool because there is no Interlocked.Exchange for bool but the size is the same anyway due to the alignment.
            Not a volatile field because from constructor no volatile write is needed so using Volatile.Read/Write when needed.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.TryAddInternal(`0,System.UInt32)">
            <summary>
            Tries to insert an item. Returns null if no entry found for item. Adding succeeds only if the item was deleted previously.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.TryInitialize(KGySoft.Collections.ThreadSafeHashSet{`0}.FixedSizeStorage,KGySoft.Collections.ThreadSafeHashSet{`0}.TempStorage)">
            <summary>
            Similar to <see cref="M:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.Initialize(KGySoft.Collections.ThreadSafeHashSet{`0}.FixedSizeStorage,KGySoft.Collections.ThreadSafeHashSet{`0}.TempStorage)"/> but tries to skip deleted entries.
            Might fail if elements have been added/removed to other during the process.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.FixedSizeStorage.GetBucketIndex(System.UInt32)">
            <summary>
            An if in a non-virtual method is still faster than calling an abstract method, a delegate or even a C# 9 function pointer
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ThreadSafeHashSet`1.TempStorage">
            <summary>
            When instantiated, always has a preallocated storage.
            Not thread-safe so the consumer must do the locking when calling the internal members.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.ThreadSafeHashSet`1.TempStorage.Entry.Next">
            <summary>
            Zero-based index of a chained item in the current bucket or -1 if last.
            Deleted items use negative indices below -1. Last deleted item has index -2.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ThreadSafeHashSet`1.TempStorage.GetBucketIndex(System.UInt32)">
            <summary>
            An if in a non-virtual method is still faster than calling an abstract method, a delegate or even a C# 9 function pointer
            </summary>
        </member>
        <member name="T:KGySoft.Collections.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Collections"/> namespace contains generic collections.
            Some of them are fully compatible with already existing collections in the .NET Framework but provide better performance in several cases (such as <see cref="T:KGySoft.Collections.CircularList`1"/>, <see cref="T:KGySoft.Collections.CircularSortedList`2"/>
            or <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>), while others provide new functionality, such as <see cref="T:KGySoft.Collections.Cache`2"/> or <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/>.
            <br/>See also <see cref="N:KGySoft.ComponentModel">KGySoft.ComponentModel</see> and <see cref="N:KGySoft.Collections.ObjectModel">KGySoft.Collections.ObjectModel</see> namespaces for some further collections
            such as <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> or <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.CacheBehavior">
            <summary>
            Possible behaviors of <see cref="T:KGySoft.Collections.Cache`2"/> when the cache store is full and an element has to be removed.
            </summary>
            <seealso cref="T:KGySoft.Collections.Cache`2"/>
            <seealso cref="M:KGySoft.Collections.Cache`2.Touch(`0)"/>
            <seealso cref="P:KGySoft.Collections.Cache`2.Capacity"/>
        </member>
        <member name="F:KGySoft.Collections.CacheBehavior.RemoveOldestElement">
            <summary>
            <para>Represents an element removal strategy for a <see cref="T:KGySoft.Collections.Cache`2"/> instance,
            where the oldest (firstly stored) element will be removed when a new element has to be stored and the
            cache is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>).</para>
            <para>This is the suggested behavior when loading a non-cached element is very fast, or when firstly added elements are typically not retrieved again,
            or when cache is never full.</para>
            <para>With this strategy element access is slightly faster than in case of <see cref="F:KGySoft.Collections.CacheBehavior.RemoveLeastRecentUsedElement"/> because no extra administration is required.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Collections.CacheBehavior.RemoveLeastRecentUsedElement">
            <summary>
            <para>Represents an element removal strategy for a <see cref="T:KGySoft.Collections.Cache`2"/> instance,
            where the least recent used element will be removed when a new element has to be stored and the
            cache is full (that is, when <see cref="P:KGySoft.Collections.Cache`2.Count"/> reaches <see cref="P:KGySoft.Collections.Cache`2.Capacity"/>).</para>
            <para>This is the suggested behavior when loading a non-cached element is slow, the cache is often full, and there are elements that are
            typically accessed more often than the others. This is the default behavior when a <see cref="T:KGySoft.Collections.Cache`2"/> instance is instantiated.</para>
            <para>With this strategy element is access is slightly slower than in case of <see cref="F:KGySoft.Collections.CacheBehavior.RemoveOldestElement"/> because
            whenever an element is accessed, it is renewed in the evaluation order. (See also the <see cref="M:KGySoft.Collections.Cache`2.Touch(`0)">Touch</see>. method)</para>
            </summary>
        </member>
        <member name="T:KGySoft.Collections.HashingStrategy">
            <summary>
            Represents a hashing strategy for some hash-based dictionaries and caches.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.HashingStrategy.Auto">
            <summary>
            The hashing strategy is determined by the type of the key in the storage.
            For <see cref="T:System.String">string</see> keys and sealed key types without an overloaded <see cref="M:System.Object.GetHashCode">GetHashCode</see>
            the <see cref="F:KGySoft.Collections.HashingStrategy.And"/> hashing strategy will be used, while for any other key types the <see cref="F:KGySoft.Collections.HashingStrategy.Modulo"/> hashing strategy will be used.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.HashingStrategy.Modulo">
            <summary>
            Represents the modulo division hashing strategy. This is quite robust even for poor <see cref="M:System.Object.GetHashCode">GetHashCode</see> implementations
            but is a bit slower than the bitwise AND hashing strategy.
            </summary>
        </member>
        <member name="F:KGySoft.Collections.HashingStrategy.And">
            <summary>
            Represents the bitwise AND hashing strategy. While the hashing itself is very fast, this solution is quite sensitive for
            poorer <see cref="M:System.Object.GetHashCode">GetHashCode</see> implementations that may cause many key collisions, which may end up
            in a poorer performance.
            </summary>
        </member>
        <member name="T:KGySoft.Collections.ICache">
            <summary>
            Provides a non-generic access to the <see cref="T:KGySoft.Collections.Cache`2"/> class.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ICache.Capacity">
            <summary>
            Gets or sets the capacity of the cache. If new value is smaller than elements count (value of the <see cref="P:System.Collections.ICollection.Count"/> property),
            then old or least used elements (depending on <see cref="P:KGySoft.Collections.ICache.Behavior"/>) will be removed from the <see cref="T:KGySoft.Collections.ICache"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ICache.Behavior">
            <summary>
            Gets or sets the cache behavior when cache is full and an element has to be removed.
            The cache is full, when <see cref="P:System.Collections.ICollection.Count"/> reaches the <see cref="P:KGySoft.Collections.ICache.Capacity"/>.
            </summary>
            <seealso cref="T:KGySoft.Collections.CacheBehavior"/>
        </member>
        <member name="P:KGySoft.Collections.ICache.EnsureCapacity">
            <summary>
            Gets or sets whether adding the first item to the cache or resetting <see cref="P:KGySoft.Collections.ICache.Capacity"/> on a non-empty cache should
            allocate memory for all cache entries.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ICache.Touch(System.Object)">
            <summary>
            Renews the value with the specified <paramref name="key"/> in the evaluation order.
            </summary>
            <param name="key">The key of the item to renew.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="key"/> does not exist in the <see cref="T:KGySoft.Collections.ICache"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ICache.RefreshValue(System.Object)">
            <summary>
            Refreshes the value in the cache even if it was already loaded.
            </summary>
            <param name="key">The key of the item to refresh.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ICache.GetValueUncached(System.Object)">
            <summary>
            Reloads the value into the cache even if it was already loaded using the item loader that was passed to the constructor.
            </summary>
            <param name="key">The key of the item to reload.</param>
            <returns>Loaded value</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ICache.Reset">
            <summary>
            Clears the cache and resets statistics.
            </summary>
        </member>
        <member name="M:KGySoft.Collections.ICache.GetStatistics">
            <summary>
            Gets statistics of the cache.
            </summary>
            <returns>An <see cref="T:KGySoft.Collections.ICacheStatistics"/> instance that provides statistical information about the <see cref="T:KGySoft.Collections.ICache"/> instance.</returns>
        </member>
        <member name="T:KGySoft.Collections.ICacheStatistics">
            <summary>
            Represents cache statistics retrieved by <see cref="M:KGySoft.Collections.Cache`2.GetStatistics"/>.
            </summary>
            <seealso cref="T:KGySoft.Collections.Cache`2"/>
        </member>
        <member name="P:KGySoft.Collections.ICacheStatistics.Reads">
            <summary>
            Gets number of cache reads.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ICacheStatistics.Writes">
            <summary>
            Gets number of cache writes.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ICacheStatistics.Deletes">
            <summary>
            Gets number of cache deletes.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ICacheStatistics.Hits">
            <summary>
            Gets number of cache hits.
            </summary>
        </member>
        <member name="P:KGySoft.Collections.ICacheStatistics.HitRate">
            <summary>
            Gets the hit rate of the cache
            </summary>
        </member>
        <member name="T:KGySoft.Collections.IStringKeyedDictionary`1">
            <summary>
            Represents an <see cref="T:System.Collections.Generic.IDictionary`2"/> with <see cref="T:System.String">string</see> key
            that can be queried also by <see cref="T:KGySoft.CoreLibraries.StringSegment"/> and <see cref="T:System.ReadOnlySpan`1"/>
            (in .NET Core 2.1/.NET Standard 2.1 and above) instances.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <seealso cref="T:System.String" />
        </member>
        <member name="P:KGySoft.Collections.IStringKeyedDictionary`1.Item(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Gets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            The element with the specified <paramref name="key"/>.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key"/> is not found.</exception>
        </member>
        <member name="P:KGySoft.Collections.IStringKeyedDictionary`1.Item(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            The element with the specified <paramref name="key"/>.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key"/> is not found.</exception>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.ContainsKey(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Determines whether this instance contains an element with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/>, if the dictionary contains an element with the <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key to locate.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see>.</exception>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.ContainsKey(System.ReadOnlySpan{System.Char})">
            <summary>
            Determines whether this instance contains an element with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/>, if the dictionary contains an element with the <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key to locate.</param>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.TryGetValue(KGySoft.CoreLibraries.StringSegment,`0@)">
            <summary>
            Tries to get the <paramref name="value"/> associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see>.</exception>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.TryGetValue(System.ReadOnlySpan{System.Char},`0@)">
            <summary>
            Tries to get the <paramref name="value"/> associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault(System.String)">
            <summary>
            Tries to get the value from the dictionary for the given <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.String,``0)">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValue"/> parameter can have a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type
            is not compatible with <typeparamref name="TActualValue"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.String,System.Func{``0})">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValueFactory"/> can return an instance of a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Tries to get the value from the dictionary for the given <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,``0)">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValue"/> parameter can have a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type
            is not compatible with <typeparamref name="TActualValue"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,System.Func{``0})">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValueFactory"/> can return an instance of a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault(System.ReadOnlySpan{System.Char})">
            <summary>
            Tries to get the value from the dictionary for the given <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the dictionary.</returns>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},``0)">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValue"/> parameter can have a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type
            is not compatible with <typeparamref name="TActualValue"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},System.Func{``0})">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValueFactory"/> can return an instance of a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the dictionary.</returns>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="T:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1">
            <summary>
            Represents an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> with <see cref="T:System.String">string</see> key
            that can be queried also by <see cref="T:KGySoft.CoreLibraries.StringSegment"/> and <see cref="T:System.ReadOnlySpan`1"/>
            (in .NET Core 2.1/.NET Standard 2.1 and above) instances.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <remarks>
            <note>This type is not available in .NET 4.0 and lover versions.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.Item(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Gets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            The element with the specified <paramref name="key"/>.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key"/> is not found.</exception>
        </member>
        <member name="P:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.Item(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the value associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            The element with the specified <paramref name="key"/>.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key"/> is not found.</exception>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.ContainsKey(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Determines whether this instance contains an element with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/>, if the dictionary contains an element with the <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key to locate.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see>.</exception>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.ContainsKey(System.ReadOnlySpan{System.Char})">
            <summary>
            Determines whether this instance contains an element with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/>, if the dictionary contains an element with the <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key to locate.</param>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.TryGetValue(KGySoft.CoreLibraries.StringSegment,`0@)">
            <summary>
            Tries to get the <paramref name="value"/> associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see>.</exception>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.TryGetValue(System.ReadOnlySpan{System.Char},`0@)">
            <summary>
            Tries to get the <paramref name="value"/> associated with the specified <paramref name="key"/>.
            </summary>
            <returns>
            <see langword="true"/> if the dictionary contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false"/>.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the <paramref name="key"/> is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault(System.String)">
            <summary>
            Tries to get the value from the dictionary for the given <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault``1(System.String,``0)">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValue"/> parameter can have a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type
            is not compatible with <typeparamref name="TActualValue"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault``1(System.String,System.Func{``0})">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValueFactory"/> can return an instance of a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Tries to get the value from the dictionary for the given <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,``0)">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValue"/> parameter can have a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type
            is not compatible with <typeparamref name="TActualValue"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault``1(KGySoft.CoreLibraries.StringSegment,System.Func{``0})">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValueFactory"/> can return an instance of a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the dictionary.</returns>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault(System.ReadOnlySpan{System.Char})">
            <summary>
            Tries to get the value from the dictionary for the given <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the dictionary.</returns>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},``0)">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValue"/> parameter can have a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type
            is not compatible with <typeparamref name="TActualValue"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.Collections.IStringKeyedReadOnlyDictionary`1.GetValueOrDefault``1(System.ReadOnlySpan{System.Char},System.Func{``0})">
            <summary>
            Tries to get the typed value from the dictionary for the given <paramref name="key"/>.
            The <paramref name="defaultValueFactory"/> can return an instance of a more specific type than <typeparamref name="TValue"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the dictionary.</returns>
            <remarks><note>This member is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="T:KGySoft.Collections.ISupportsRangeCollection`1">
            <summary>
            Represents a collection that supports the <see cref="M:KGySoft.Collections.ISupportsRangeCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">AddRange</see> method.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <seealso cref="T:System.Collections.Generic.ICollection`1" />
            <seealso cref="T:System.Collections.Generic.IReadOnlyCollection`1" />
            <seealso cref="T:KGySoft.Collections.CircularList`1" />
        </member>
        <member name="M:KGySoft.Collections.ISupportsRangeCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a <paramref name="collection"/> to this <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/>.
            </summary>
            <param name="collection">The collection to add to the <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> must not be <see langword="null"/>.</exception>
        </member>
        <member name="T:KGySoft.Collections.ISupportsRangeList`1">
            <summary>
            Represents a list that supports range operations.
            </summary>
            <typeparam name="T">The type of the elements in the list.</typeparam>
            <seealso cref="T:KGySoft.Collections.ISupportsRangeCollection`1" />
            <seealso cref="T:System.Collections.Generic.IList`1" />
            <seealso cref="T:System.Collections.Generic.IReadOnlyList`1" />
            <seealso cref="T:KGySoft.Collections.CircularList`1" />
        </member>
        <member name="M:KGySoft.Collections.ISupportsRangeList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a <paramref name="collection"/> into this <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="collection">The collection to insert into the list.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> must not be <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Collections.ISupportsRangeList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes <paramref name="count"/> amount of items from this <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            <br/>-or-
            <br/><paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> and <paramref name="count"/> do not denote a valid range of elements in the list.</exception>
        </member>
        <member name="M:KGySoft.Collections.ISupportsRangeList`1.ReplaceRange(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes <paramref name="count"/> amount of items from this <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> at the specified <paramref name="index"/>, and
            inserts the specified <paramref name="collection"/> at the same position. The number of elements in <paramref name="collection"/> can be different from the amount of removed items.
            </summary>
            <param name="index">The zero-based index of the first item to remove and also the index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="count">The number of items to remove.</param>
            <param name="collection">The collection to insert into the list.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> must not be <see langword="null"/>.</exception>
            <remarks>
            <para>If the length of the <see cref="T:KGySoft.Collections.CircularList`1"/> is n and the length of the collection to insert is m, then replacement at the first or last position has O(m) cost.</para>
            <para>If the elements to remove and to add have the same size, then the cost is O(m) at any position.</para>
            <para>If capacity increase is needed (considering actual list size), or when the replacement of different amount of elements to remove and insert is performed in the middle of the <see cref="T:KGySoft.Collections.CircularList`1"/>, the cost is O(Max(n, m)), and in practice no more than n/2 elements are moved.</para>
            </remarks>
        </member>
        <member name="T:KGySoft.Collections.IThreadSafeCacheAccessor`2">
            <summary>
            Represents a thread-safe accessor for a cache, which provides a read-only indexer to access values.
            An instance can be created by the <see cref="O:KGySoft.Collections.ThreadSafeCacheFactory.Create">Create</see> methods of the <see cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/> class,
            or if you have a <see cref="T:KGySoft.Collections.Cache`2"/> instance, you can retrieve a thread-safe accessor for it by the <see cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">GetThreadSafeAccessor</see> method.
            </summary>
            <typeparam name="TKey">The type of the key in the cache.</typeparam>
            <typeparam name="TValue">The type of the value in the cache.</typeparam>
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/>
            <seealso cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)"/>
        </member>
        <member name="P:KGySoft.Collections.IThreadSafeCacheAccessor`2.Item(`0)">
            <summary>
            Gets the value associated with the specified <paramref name="key"/>.
            If a value does not exist in the underlying cache, then the loader delegate will be invoked,
            which was specified when this <see cref="T:KGySoft.Collections.IThreadSafeCacheAccessor`2"/> instance was created.
            </summary>
            <param name="key">The key of the value to be retrieved.</param>
            <returns>The value of the corresponding <paramref name="key"/>.</returns>
            <seealso cref="T:KGySoft.Collections.ThreadSafeCacheFactory"/>
            <seealso cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)"/>
        </member>
        <member name="T:KGySoft.ComponentModel.EditableObjectBase">
            <summary>
            Represents an object with editing capabilities by adding <see cref="T:KGySoft.ComponentModel.ICanEdit"/> implementation to the <see cref="T:KGySoft.ComponentModel.PersistableObjectBase"/> class.
            Starting an edit session saves a snapshot of the stored properties, which can be either applied or reverted.
            Saving and restoring properties works for properties set through the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> implementation and the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">ObservableObjectBase.Set</see> method.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.ICanEdit" />
            <seealso cref="T:System.ComponentModel.IEditableObject" />
            <seealso cref="T:KGySoft.ComponentModel.ObservableObjectBase"/>
            <seealso cref="T:KGySoft.ComponentModel.PersistableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.UndoableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ValidatingObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ModelBase" />
            <remarks>
            <para>An object derived from <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> is able to save a snapshot of its properties (the ones, which are set through the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> implementation
            or the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">ObservableObjectBase.Set</see> method).</para>
            <para>A new snapshot can be saved by the <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> method. This can be called by a UI before starting the editing.</para>
            <para>Call the <see cref="M:KGySoft.ComponentModel.EditableObjectBase.CommitLastEdit">CommitLastEdit</see> method to apply the changes since the last <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> call.</para>
            <para>Call the <see cref="M:KGySoft.ComponentModel.EditableObjectBase.RevertLastEdit">RevertLastEdit</see> method to discard the changes since the last <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> call.</para>
            <para>The editing sessions can be nested by calling <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> method multiple times. The number of the <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> calls without
            a corresponding <see cref="M:KGySoft.ComponentModel.EditableObjectBase.CommitLastEdit">CommitLastEdit</see> or <see cref="M:KGySoft.ComponentModel.EditableObjectBase.RevertLastEdit">RevertLastEdit</see> call is indicated by the <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditLevel"/> property.</para>
            <para>By calling the <see cref="M:KGySoft.ComponentModel.EditableObjectBase.TryCommitAllEdits">TryCommitAllEdits</see> and <see cref="M:KGySoft.ComponentModel.EditableObjectBase.TryRevertAllEdits">TryRevertAllEdits</see> methods all of the previous <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see>
            calls can be applied or discarded, respectively. These methods return a <see cref="T:System.Boolean">bool</see> value indicating whether any action occurred.</para>
            <para><note>When it is needed to be determined whether a type has editing capabilities use the <see cref="T:KGySoft.ComponentModel.ICanEdit"/> interface instead the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> type
            because other editable types, such as the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class are not necessarily derived from the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> class.
            See also the class diagram of the business object base classes of the <c>KGySoft.CoreLibraries</c> assembly:</note>
            <img src="../Help/Images/ComponentModel_BusinessObjects.png" alt="Class diagram of business object base classes"/></para>
            <para><strong>Differences from <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/></strong>:
            <br/>Both <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> and <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> can revert changes; however, the aspects of these classes are different.
            <list type="bullet">
            <item>An undoable class (which implements <see cref="T:KGySoft.ComponentModel.ICanUndo"/> or <see cref="T:KGySoft.ComponentModel.ICanUndoRedo"/> interfaces such as <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/>) is able to undo (or redo) any changes made so far either step-by-step or in a single step.</item>
            <item>On the other hand, an editable class (which implements <see cref="T:KGySoft.ComponentModel.ICanEdit"/> such as <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/>) is able to start editing sessions by saving a snapshot of its current state, which states are committable and revertible.</item>
            <item>Undo and editing features are independent from each other and a class is allowed to implement both (like the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class).</item>
            </list>
            </para>
            <para><strong><see cref="T:System.ComponentModel.IEditableObject"/> support</strong>:
            <br/><see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> implements also the <see cref="T:System.ComponentModel.IEditableObject">System.ComponentModel.IEditableObject</see> interface, which is the standard way in .NET to support editing.
            Several controls of different UI frameworks automatically call its members if an object, which implements it, is bound to a grid control, for example. However, some frameworks (such as Windows Forms) do not always
            call the begin/end operations the same times, which can cause problems. To handle this, you can override the <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> property in your class to adjust the editing behavior via the <see cref="T:System.ComponentModel.IEditableObject"/> interface.
            If not overridden, the <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting"/>, which works in most cases.
            <br/>This is how the <see cref="T:System.ComponentModel.IEditableObject"/> members are mapped in the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> class:
            <list type="bullet">
            <item><see cref="M:System.ComponentModel.IEditableObject.BeginEdit">IEditableObject.BeginEdit</see>:
            <list type="bullet">
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.Disabled"/>, then the call is ignored.</item>
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting"/>, then <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> is called only if <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditLevel"/> returns 0; otherwise, the call is ignored.</item>
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.AllowNesting"/>, then <see cref="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">BeginNewEdit</see> is called.</item>
            </list>
            </item>
            <item><see cref="M:System.ComponentModel.IEditableObject.EndEdit">IEditableObject.EndEdit</see>:
            <list type="bullet">
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.Disabled"/>, then the call is ignored.</item>
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting"/>, then <see cref="M:KGySoft.ComponentModel.EditableObjectBase.TryCommitAllEdits">TryCommitAllEdits</see> is called.</item>
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.AllowNesting"/>, then <see cref="M:KGySoft.ComponentModel.EditableObjectBase.CommitLastEdit">CommitLastEdit</see> is called.</item>
            </list>
            </item>
            <item><see cref="M:System.ComponentModel.IEditableObject.CancelEdit">IEditableObject.CancelEdit</see>:
            <list type="bullet">
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.Disabled"/>, then the call is ignored.</item>
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting"/>, then <see cref="M:KGySoft.ComponentModel.EditableObjectBase.TryRevertAllEdits">TryRevertAllEdits</see> is called.</item>
            <item>If <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior"/> returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.AllowNesting"/>, then <see cref="M:KGySoft.ComponentModel.EditableObjectBase.RevertLastEdit">RevertLastEdit</see> is called.</item>
            </list>
            </item>
            </list>
            </para>
            <note type="implement">For an example see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            The same applies also for the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> class in terms of implementation.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.EditableObjectBase.EditLevel">
            <inheritdoc />
        </member>
        <member name="P:KGySoft.ComponentModel.EditableObjectBase.EditableObjectBehavior">
            <summary>
            Gets how the object should behave if treated as an <see cref="T:System.ComponentModel.IEditableObject"/>.
            <br/>The base implementation returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting"/>.
            </summary>
            <remarks>
            <note>To see how this affects the editing behavior see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> class.</note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.EditableObjectBehavior"/>
            <seealso cref="T:System.ComponentModel.IEditableObject"/>
        </member>
        <member name="M:KGySoft.ComponentModel.EditableObjectBase.BeginNewEdit">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.EditableObjectBase.CommitLastEdit">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.EditableObjectBase.RevertLastEdit">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.EditableObjectBase.TryCommitAllEdits">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.EditableObjectBase.TryRevertAllEdits">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.EditableObjectBase.AffectsModifiedState(System.String)">
            <summary>
            Gets whether the change of the specified <paramref name="propertyName" /> affects the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property.
            <br />The <see cref="T:KGySoft.ComponentModel.EditableObjectBase" /> implementation excludes the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> and <see cref="P:KGySoft.ComponentModel.EditableObjectBase.EditLevel"/> properties.
            </summary>
            <param name="propertyName">Name of the changed property.</param>
            <returns><see langword="true"/> if changing of the specified <paramref name="propertyName" /> affects the value of the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.ModelBase">
            <summary>
            Provides a base object for model classes or business objects, which can validate their state, have undo/redo capability and can support committable/revertible editing.
            </summary>
            <remarks>
            <note>This class unifies the capabilities of <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/>, <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> and <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> classes.
            If you don't need all of these features you can pick one of these classes as a base class for your business objects. If you need none of these features but only raising events about property changes
            you can use the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> or <see cref="T:KGySoft.ComponentModel.PersistableObjectBase"/> classes.
            See also the class diagram of the business object base classes of the <c>KGySoft.CoreLibraries</c> assembly:</note>
            <img src="../Help/Images/ComponentModel_BusinessObjects.png" alt="Class diagram of business object base classes"/>
            <para><strong>Differences from <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/></strong>:
            <list type="bullet">
            <item>When deriving from <see cref="T:KGySoft.ComponentModel.ModelBase"/>, overriding <see cref="M:KGySoft.ComponentModel.ModelBase.DoValidation">DoValidation</see> method is not mandatory.
            By default, <see cref="M:KGySoft.ComponentModel.ModelBase.DoValidation">DoValidation</see> returns an empty <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> instance.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/> class for an example about how to validate properties by overriding the <see cref="M:KGySoft.ComponentModel.ModelBase.DoValidation">DoValidation</see> method.</item>
            <item>The <see cref="T:KGySoft.ComponentModel.ModelBase"/> implements the <see cref="T:KGySoft.ComponentModel.ICanUndo"/> and <see cref="T:System.ComponentModel.IRevertibleChangeTracking"/> interfaces to support undo/redo functionality.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> class for details about the undo/redo feature. The same applies also for the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class.</item>
            <item>The <see cref="T:KGySoft.ComponentModel.ModelBase"/> implements the <see cref="T:KGySoft.ComponentModel.ICanEdit"/> and <see cref="T:System.ComponentModel.IEditableObject"/> interfaces to support object editing.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> class for details about object editing. The same applies also for the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class.</item>
            </list>
            </para>
            <para>Though undo/redo and object editing are independent features, the undo history is cleared when an editing session is reverted by the <see cref="M:KGySoft.ComponentModel.ModelBase.RevertLastEdit">RevertLastEdit</see> or <see cref="M:KGySoft.ComponentModel.ModelBase.TryRevertAllEdits">TryRevertAllEdits</see>
            methods to avoid confusion.</para>
            <note type="implement">
            <para>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class for an example about how to define properties in a derived class.</para>
            <para>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/> class for an example about how to validate properties in a derived class.</para>
            </note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.ValidatingObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ICanUndo" />
            <seealso cref="T:KGySoft.ComponentModel.ICanUndoRedo" />
            <seealso cref="T:System.ComponentModel.IRevertibleChangeTracking" />
            <seealso cref="T:KGySoft.ComponentModel.ICanEdit" />
            <seealso cref="T:System.ComponentModel.IEditableObject" />
        </member>
        <member name="P:KGySoft.ComponentModel.ModelBase.CanUndo">
            <inheritdoc />
        </member>
        <member name="P:KGySoft.ComponentModel.ModelBase.CanRedo">
            <inheritdoc />
        </member>
        <member name="P:KGySoft.ComponentModel.ModelBase.EditLevel">
            <inheritdoc />
        </member>
        <member name="P:KGySoft.ComponentModel.ModelBase.UndoCapacity">
            <summary>
            Gets or sets the undo capacity.
            <br/>Default value: <c>20</c>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> must be greater or equal to 0.</exception>
        </member>
        <member name="P:KGySoft.ComponentModel.ModelBase.EditableObjectBehavior">
            <summary>
            Gets how the object should behave if treated as an <see cref="T:System.ComponentModel.IEditableObject"/>.
            <br/>The base implementation returns <see cref="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting"/>.
            </summary>
            <remarks>
            <note>To see how this affects the editing behavior see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> class, which applies also for the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class.</note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.EditableObjectBehavior"/>
            <seealso cref="T:System.ComponentModel.IEditableObject"/>
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.TryUndo">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.UndoAll">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.ClearUndoHistory">
            <summary>
            Clears the undo/redo history without performing any undo.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.TryRedo">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.RedoAll">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.BeginNewEdit">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.CommitLastEdit">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.RevertLastEdit">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.TryCommitAllEdits">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.TryRevertAllEdits">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.AffectsModifiedState(System.String)">
            <summary>
            Gets whether the change of the specified <paramref name="propertyName" /> affects the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property.
            <br />The <see cref="T:KGySoft.ComponentModel.ModelBase" /> implementation excludes the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/>, <see cref="P:KGySoft.ComponentModel.ModelBase.EditLevel"/>, <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/>,
            <see cref="P:KGySoft.ComponentModel.ModelBase.UndoCapacity"/>, <see cref="P:KGySoft.ComponentModel.ModelBase.CanUndo"/> and <see cref="P:KGySoft.ComponentModel.ModelBase.CanRedo"/> properties.
            </summary>
            <param name="propertyName">Name of the changed property.</param>
            <returns><see langword="true"/> if changing of the specified <paramref name="propertyName" /> affects the value of the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.DoValidation">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.ModelBase.OnPropertyChanged(KGySoft.ComponentModel.PropertyChangedExtendedEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:KGySoft.ComponentModel.ObservableObjectBase">
             <summary>
             Provides a base class for component model classes, which can notify their consumer about property changes.
             </summary>
             <remarks>
             <para>Implementers can use the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(``0,System.String)">Get</see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">Set</see> methods in the property accessors to manage event raising automatically.</para>
             <para>Consumers can subscribe the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event to get notification about the property changes.</para>
             <para>Accessing properties can be fine tuned by overriding the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">CanGetProperty</see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">CanSetProperty</see> methods. By default they allow
             accessing the instance properties in the implementer class.
             <note type="inherit">Do not use <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">CanGetProperty</see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">CanSetProperty</see> methods for property validation.
             To be able to validate property values consider to use the <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/> or <see cref="T:KGySoft.ComponentModel.ModelBase"/> classes.</note>
             </para>
             <example>
             The following example shows a possible implementation of a derived class.
             <code lang="C#"><![CDATA[
             public class MyModel : ObservableObjectBase
             {
                 // A simple integer property (with zero default value). Until the property is set no value is stored internally.
                 public int IntProperty { get => Get<int>(); set => Set(value); }
            
                 // An int property with a specified default value. Until the property is set the default will be returned.
                 public int IntPropertyCustomDefault { get => Get(-1); set => Set(value); }
            
                 // If the default value is a complex one, which should not be evaluated each time you can provide a factory for it:
                 // When this property is read for the first time without setting it before, the provided delegate will be invoked
                 // and the returned default value is stored without triggering the PropertyChanged event.
                 public MyComplexType ComplexProperty { get => Get(() => new MyComplexType()); set => Set(value); }
             
                 // You can use regular properties to prevent raising the events and not to store the value in the internal storage.
                 // The OnPropertyChanged method still can be called explicitly to raise the PropertyChanged event.
                 public int UntrackedProperty { get; set; }
             }
             ]]></code>
             </example>
             </remarks>
             <threadsafety instance="true" static="true"/>
             <seealso cref="T:System.ComponentModel.INotifyPropertyChanged" />
             <seealso cref="T:KGySoft.ComponentModel.PersistableObjectBase" />
             <seealso cref="T:KGySoft.ComponentModel.UndoableObjectBase" />
             <seealso cref="T:KGySoft.ComponentModel.EditableObjectBase" />
             <seealso cref="T:KGySoft.ComponentModel.ValidatingObjectBase" />
             <seealso cref="T:KGySoft.ComponentModel.ModelBase" />
        </member>
        <member name="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged">
            <summary>
            Occurs when a property value changed. The actual type of the event argument is <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/>.
            </summary>
            <remarks>
            <note>The <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event uses the <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/> delegate in order to consumers, which rely on the conventional property
            changed notifications can use it in a compatible way. To get the old and new values in an event handler you can cast the argument to <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/>
            or call the <see cref="M:KGySoft.ComponentModel.PropertyChangedEventArgsExtensions.TryGetOldPropertyValue(System.ComponentModel.PropertyChangedEventArgs,System.Object@)">TryGetOldPropertyValue</see> and <see cref="M:KGySoft.ComponentModel.PropertyChangedEventArgsExtensions.TryGetNewPropertyValue(System.ComponentModel.PropertyChangedEventArgs,System.Object@)">TryGetNewPropertyValue</see> extension methods on it.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableObjectBase.MissingProperty">
            <summary>
            Represents the value of a missing property value. Can be returned in <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> by the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event
            if the stored value of the property has just been created and had no previous value, or when a property has been removed from the inner storage.
            </summary>
            <remarks><note>Reading the property when it has no value may return a default value or can cause to recreate a value.</note></remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified">
            <summary>
            Gets whether this instance has been modified.
            Modified state can be set by the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.SetModified(System.Boolean)">SetModified</see> method.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableObjectBase.IsDisposed">
            <summary>
            Gets whether this instance has already been disposed.
            </summary>
            <remarks>
            <para>Properties accessed by the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(``0,System.String)"><![CDATA[Get<T>]]></see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">Set</see> methods
            throw an <see cref="T:System.ObjectDisposedException"/> when this property returns <see langword="true"/>.</para>
            <para>If the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Dispose(System.Boolean)"/> method is overridden and you need to dispose properties accessed by
            the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(``0,System.String)"><![CDATA[Get<T>]]></see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">Set</see> methods
            check this property first to prevent the <see cref="T:System.ObjectDisposedException"/>.</para>
            <note>The change of this property is not observable. When an <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> instance is disposed
            all subscribers of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event are removed.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.SetModified(System.Boolean)">
            <summary>
            Sets the modified state of this <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> instance represented by the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> property.
            </summary>
            <param name="value"><see langword="true"/> to mark the object as modified; <see langword="false"/> to mark it unmodified.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.Clone(System.Boolean)">
            <summary>
            Creates a new object that is a copy of the current instance.
            <br/>The base implementation clones the internal property storage, the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property and if <paramref name="clonePropertyChanged"/> is <see langword="true"/>, then also the subscribers of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event.
            </summary>
            <param name="clonePropertyChanged"><see langword="true"/> to clone also the subscribers of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.Dispose">
            <summary>
            Releases the resources held by this instance.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(System.Func{``0},System.String)">
            <summary>
            Gets the value of a property, or - if it was not set before -, then creates its initial value.
            The created initial value will be stored in the internal property storage without triggering the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event.
            For constant or simple expressions, or to return a default value for a non-existing property without storing it internally use the other <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(``0,System.String)">Get</see> overload.
            <br/>For an example, see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="createInitialValue">A delegate, which creates the initial value if the property does not exist. If <see langword="null"/>,
            then an exception is thrown for an uninitialized property.</param>
            <param name="propertyName">The name of the property to get. This parameter is optional.
            <br/>Default value: The name of the caller member.</param>
            <returns>The value of the property, or the created initial value returned by the <paramref name="createInitialValue"/> parameter.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="propertyName"/> cannot be retrieved.
            <br/>-or-
            <br/>The stored value of the property is not compatible with <typeparamref name="T"/>.
            <br/>-or-
            <br/><paramref name="propertyName"/> value does not exist and <paramref name="createInitialValue"/> is <see langword="null"/>.
            <br/>-or-
            <br/>The created default value of the property cannot be set.
            <br/>-or-
            <br/><see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">CanGetProperty</see> is not overridden and <paramref name="propertyName"/> is not an actual instance property in this instance.
            </exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(``0,System.String)">
            <summary>
            Gets the value of a property or <paramref name="defaultValue"/> if no value is stored for it. No new value will be stored
            if the property does not exist. If the default initial value is too complex and should not be evaluated every time when the property is get,
            or to throw an exception for an uninitialized property use the other <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(System.Func{``0},System.String)">Get</see> overload.
            <br/>For an example, see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="defaultValue">The value to return if property does not exist. This parameter is optional.
            <br/>Default value: The default value of <typeparamref name="T"/> type.</param>
            <param name="propertyName">The name of the property to get. This parameter is optional.
            <br/>Default value: The name of the caller member.</param>
            <returns>The value of the property, or the specified <paramref name="defaultValue"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="propertyName"/> cannot be retrieved.
            <br/>-or-
            <br/><see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">CanGetProperty</see> is not overridden and <paramref name="propertyName"/> is not an actual instance property in this instance.
            </exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">
            <summary>
            Sets the value of a property.
            <br/>For an example, see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            </summary>
            <param name="value">The value to set.</param>
            <param name="invokeChangedEvent">If <see langword="true"/>, and the <paramref name="value"/> is different from the previously stored value, then invokes the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event.</param>
            <param name="propertyName">Name of the property to set. This parameter is optional.
            <br/>Default value: The name of the caller member.</param>
            <returns><see langword="true"/> if property has been set (change occurred); otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="propertyName"/> cannot be set.
            <br/>-or-
            <br/><see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">CanSetProperty</see> is not overridden and <paramref name="propertyName"/> is not an actual instance property in this instance, or <paramref name="value"/> is not compatible with the property type.
            </exception>
            <remarks>
            <para>If a property is redefined in a derived class with a different type, or a type has multiple indexers with different types,
            the this method may throw an <see cref="T:System.InvalidOperationException"/>. Overriding the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">CanSetProperty</see> method can solve this issue
            but it may lead to further errors if multiple properties use the same key in the inner storage.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.ResetProperty(System.String,System.Boolean)">
            <summary>
            Resets the property of the specified name, meaning, it will be removed from the underlying storage so the getter methods will return the default value again.
            </summary>
            <param name="propertyName">The name of the property to reset.</param>
            <param name="invokeChangedEvent"><see langword="true"/> to allow raising the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event; otherwise, <see langword="false"/>.</param>
            <returns><see langword="true"/> if property has been reset (it existed previously); otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">
            <summary>
            Gets whether the specified property can be retrieved.
            <br/>The base implementation allows to get the actual instance properties in this instance.
            </summary>
            <param name="propertyName">Name of the property to get.</param>
            <returns><see langword="true"/>, if the specified property can be retrieved; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">
            <summary>
            Gets whether the specified property can be set.
            <br/>The base implementation allows to set the actual instance properties in this instance if the specified <paramref name="value"/> is compatible with the property type.
            </summary>
            <param name="propertyName">Name of the property to set.</param>
            <param name="value">The property value to set.</param>
            <returns><see langword="true"/>, if the specified property can be set; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.SuspendChangedEvent">
            <summary>
            Suspends the raising of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event until <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.ResumeChangedEvent">ResumeChangeEvents</see>
            method is called. Supports nested calls.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.ResumeChangedEvent">
            <summary>
            Resumes the raising of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event suspended by the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.SuspendChangedEvent">SuspendChangeEvents</see> method.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.AffectsModifiedState(System.String)">
            <summary>
            Gets whether the change of the specified <paramref name="propertyName"/> affects the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> property.
            <br/>The <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> implementation excludes the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> property itself.
            </summary>
            <param name="propertyName">Name of the changed property.</param>
            <returns><see langword="true"/> if changing of the specified <paramref name="propertyName"/> affects the value of the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> property; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.Dispose(System.Boolean)">
            <summary>
            Releases the resources held by this instance.
            <br/>The base implementation removes the subscribers of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event and clears the property storage.
            If the overridden method disposes properties accessed by the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Get``1(``0,System.String)"><![CDATA[Get<T>]]></see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">Set</see> methods,
            then check the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsDisposed"/> property first and call the base method as the last step to prevent <see cref="T:System.ObjectDisposedException"/>.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableObjectBase.OnPropertyChanged(KGySoft.ComponentModel.PropertyChangedExtendedEventArgs)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event.
            </summary>
            <param name="e">The <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs" /> instance containing the event data.</param>
        </member>
        <member name="T:KGySoft.ComponentModel.PersistableObjectBase">
            <summary>
            Provides a base class for component model classes, which provide a public access to their internal property storage located in the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> base class
            by implementing also the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> interface.
            <br/>For details see the <strong>Remarks</strong> section.
            </summary>
            <remarks>
            <para>The class should be cast to <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> to access the property storage and allow to manipulate the properties by name.
            All of the actually stored values can be read and restored by the <see cref="M:KGySoft.ComponentModel.IPersistableObject.GetProperties">GetProperties</see> and
            <see cref="M:KGySoft.ComponentModel.IPersistableObject.SetProperties(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">SetProperties</see> methods.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> also provides some concurrent-proof operations if the instance is accessed from multiple threads. See the <see cref="M:KGySoft.ComponentModel.IPersistableObject.TryGetPropertyValue(System.String,System.Object@)">TryGetPropertyValue</see>,
            <see cref="M:KGySoft.ComponentModel.IPersistableObject.GetPropertyOrDefault``1(System.String,``0)">GetPropertyOrDefault</see> and <see cref="M:KGySoft.ComponentModel.IPersistableObject.TryReplaceProperty(System.String,System.Object,System.Object,System.Boolean)">TryReplaceProperty</see> methods.</para>
            <note type="implement">For an example see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            The same applies also for the <see cref="T:KGySoft.ComponentModel.PersistableObjectBase"/> class in terms of implementation.</note>
            </remarks>
            <threadsafety instance="true"/>
            <seealso cref="T:KGySoft.ComponentModel.IPersistableObject" />
            <seealso cref="T:KGySoft.ComponentModel.ObservableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.UndoableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.EditableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ValidatingObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ModelBase" />
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableHelper.ApplyStep(KGySoft.Collections.CircularList{System.Collections.Generic.KeyValuePair{System.String,KGySoft.ComponentModel.UndoableHelper.UndoEntry}},System.String,KGySoft.Collections.CircularList{System.Collections.Generic.KeyValuePair{System.String,KGySoft.ComponentModel.UndoableHelper.UndoEntry}},System.String)">
            <summary>
            Applying 1 undo/redo step and raising Can... events if necessary.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableHelper.ApplyAll(KGySoft.Collections.CircularList{System.Collections.Generic.KeyValuePair{System.String,KGySoft.ComponentModel.UndoableHelper.UndoEntry}},System.String,KGySoft.Collections.CircularList{System.Collections.Generic.KeyValuePair{System.String,KGySoft.ComponentModel.UndoableHelper.UndoEntry}},System.String)">
            <summary>
            Applying all undo/redo steps.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.UndoableObjectBase">
            <summary>
            Represents an object with step-by-step undo/redo capabilities by adding <see cref="T:KGySoft.ComponentModel.ICanUndoRedo"/> implementation to the <see cref="T:KGySoft.ComponentModel.PersistableObjectBase"/> class.
            Undoing and redoing works for properties set through the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> implementation and the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">ObservableObjectBase.Set</see> method.
            </summary>
            <remarks>
            <para>An object derived from <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> continuously tracks the property changes of properties, which are set through the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> implementation
            and the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.Set(System.Object,System.Boolean,System.String)">ObservableObjectBase.Set</see> method.
            <note>When it is needed to be determined whether a type has undo/redo capability use the <see cref="T:KGySoft.ComponentModel.ICanUndo"/> or <see cref="T:KGySoft.ComponentModel.ICanUndoRedo"/> interfaces instead the <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> type
            because other undoable types, such as the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class are not necessarily derived from the <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> class.
            See also the class diagram of the business object base classes of the <c>KGySoft.CoreLibraries</c> assembly:</note>
            <img src="../Help/Images/ComponentModel_BusinessObjects.png" alt="Class diagram of business object base classes"/></para>
            <para><strong>Differences from <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/></strong>:
            <br/>Both <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> and <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/> can revert changes; however, the aspects of these classes are different.
            <list type="bullet">
            <item>An undoable class (which implements <see cref="T:KGySoft.ComponentModel.ICanUndo"/> or <see cref="T:KGySoft.ComponentModel.ICanUndoRedo"/> interfaces such as <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/>) is able to undo (or redo) any changes made so far either step-by-step or in a single step.</item>
            <item>On the other hand, an editable class (which implements <see cref="T:KGySoft.ComponentModel.ICanEdit"/> such as <see cref="T:KGySoft.ComponentModel.EditableObjectBase"/>) is able to start editing sessions by saving a snapshot of its current state, which states are committable and revertible.</item>
            <item>Undo and editing features are independent from each other and a class is allowed to implement both (like the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class).</item>
            </list>
            </para>
            <para><strong><see cref="T:System.ComponentModel.IRevertibleChangeTracking"/> support</strong>:
            <br/><see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> implements also the <see cref="T:System.ComponentModel.IRevertibleChangeTracking">System.ComponentModel.IRevertibleChangeTracking</see> interface, which is the standard way in .NET to support undoing.
            <br/>This is how the <see cref="T:System.ComponentModel.IRevertibleChangeTracking"/> members are mapped in the <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> class:
            <list type="bullet">
            <item><see cref="P:System.ComponentModel.IChangeTracking.IsChanged">IChangeTracking.IsChanged</see>: Returns <see cref="P:KGySoft.ComponentModel.UndoableObjectBase.CanUndo"/>.</item>
            <item><see cref="M:System.ComponentModel.IChangeTracking.AcceptChanges">IChangeTracking.AcceptChanges</see>: Calls <see cref="M:KGySoft.ComponentModel.UndoableObjectBase.ClearUndoHistory">ClearUndoHistory</see>.</item>
            <item><see cref="M:System.ComponentModel.IRevertibleChangeTracking.RejectChanges">IRevertibleChangeTracking.RejectChanges</see>: Calls <see cref="M:KGySoft.ComponentModel.UndoableObjectBase.UndoAll">UndoAll</see>.</item>
            </list>
            </para>
            <para><strong><see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> vs. <see cref="P:KGySoft.ComponentModel.UndoableObjectBase.CanUndo">CanUndo</see></strong>:
            <list type="bullet">
            <item>The <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/> property reflects the object's "dirty" state, meaning, it has been changed since the initialization or last save.
            The modified state can be cleared by the <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.SetModified(System.Boolean)">SetModified</see> method. Clearing the modified state (eg. on saving the object) does not affect the undo capabilities, though.</item>
            <item>The <see cref="P:KGySoft.ComponentModel.UndoableObjectBase.CanUndo"/> property tells whether there are any steps to undo. On saving an object the modified state can be cleared and still there can be undoable steps. And vice versa, undoing all steps will not clear the modified state.</item>
            </list>
            </para>
            <note type="implement">For an example see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            The same applies also for the <see cref="T:KGySoft.ComponentModel.UndoableObjectBase"/> class in terms of implementation.</note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.ICanUndo" />
            <seealso cref="T:KGySoft.ComponentModel.ICanUndoRedo" />
            <seealso cref="T:System.ComponentModel.IRevertibleChangeTracking" />
            <seealso cref="T:KGySoft.ComponentModel.ObservableObjectBase"/>
            <seealso cref="T:KGySoft.ComponentModel.PersistableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.EditableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ValidatingObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ModelBase" />
        </member>
        <member name="P:KGySoft.ComponentModel.UndoableObjectBase.CanUndo">
            <inheritdoc />
        </member>
        <member name="P:KGySoft.ComponentModel.UndoableObjectBase.CanRedo">
            <inheritdoc />
        </member>
        <member name="P:KGySoft.ComponentModel.UndoableObjectBase.UndoCapacity">
            <summary>
            Gets or sets the undo capacity.
            <br/>Default value: <c>20</c>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> must be greater or equal to 0.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.TryUndo">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.UndoAll">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.ClearUndoHistory">
            <summary>
            Clears the undo/redo history without performing any undo.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.TryRedo">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.RedoAll">
            <inheritdoc />
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.AffectsModifiedState(System.String)">
            <summary>
            Gets whether the change of the specified <paramref name="propertyName" /> affects the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property.
            <br />The <see cref="T:KGySoft.ComponentModel.UndoableObjectBase" /> implementation excludes the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/>, <see cref="P:KGySoft.ComponentModel.UndoableObjectBase.UndoCapacity"/>,
            <see cref="P:KGySoft.ComponentModel.UndoableObjectBase.CanUndo"/> and <see cref="P:KGySoft.ComponentModel.UndoableObjectBase.CanRedo"/> properties.
            </summary>
            <param name="propertyName">Name of the changed property.</param>
            <returns><see langword="true"/> if changing of the specified <paramref name="propertyName" /> affects the value of the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.UndoableObjectBase.OnPropertyChanged(KGySoft.ComponentModel.PropertyChangedExtendedEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:KGySoft.ComponentModel.ValidatingObjectBase">
            <summary>
            Represents an object with validating capabilities by adding <see cref="T:KGySoft.ComponentModel.IValidatingObject"/> implementation to the <see cref="T:KGySoft.ComponentModel.PersistableObjectBase"/> class.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.IValidatingObject" />
            <seealso cref="T:System.ComponentModel.IDataErrorInfo" />
            <seealso cref="T:KGySoft.ComponentModel.ObservableObjectBase"/>
            <seealso cref="T:KGySoft.ComponentModel.PersistableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.UndoableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.EditableObjectBase" />
            <seealso cref="T:KGySoft.ComponentModel.ModelBase" />
            <remarks>
            <para>In a derived class the <see cref="M:KGySoft.ComponentModel.ValidatingObjectBase.DoValidation">DoValidation</see> method must be overridden.</para>
            <para>Validation is automatically performed when the <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/> or <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> property is accessed or when the object is accessed by the standard <see cref="T:System.ComponentModel.IDataErrorInfo"/> interface.</para>
            <para><see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/> returns <see langword="true"/> if <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> does not contain any entries with <see cref="F:KGySoft.ComponentModel.ValidationSeverity.Error"/> severity.</para>
            <para><strong>Differences between <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">CanGetProperty</see>/<see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">CanSetProperty</see> methods and <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/>/<see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> properties</strong>:
            <list type="bullet">
            <item>When <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanGetProperty(System.String)">CanGetProperty</see> and <see cref="M:KGySoft.ComponentModel.ObservableObjectBase.CanSetProperty(System.String,System.Object)">CanSetProperty</see> methods return <see langword="false"/>, then an exception will be thrown
            when the property is get or set via the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> and <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> members. Do not use these methods for business validation. Instead, they can be used to prevent accessing an unknown property
            or when a property is tried to be set by a value of invalid type.</item>
            <item>On the other hand, <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/> and <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> properties can be used to indicate whether an object contains problematic values. For every issue a severity level (see <see cref="T:KGySoft.ComponentModel.ValidationSeverity"/>) and
            a corresponding message can be assigned. These can be displayed by a UI, for example.</item>
            </list>
            </para>
            <para><strong><see cref="T:System.ComponentModel.IDataErrorInfo"/> support</strong>:
            <br/><see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/> implements also the <see cref="T:System.ComponentModel.IDataErrorInfo">System.ComponentModel.IDataErrorInfo</see> interface, which is the oldest standard way in .NET to support validation, therefore it is
            supported by most frameworks. <see cref="T:System.ComponentModel.IDataErrorInfo"/> is able to report errors only, so if warnings and validation infos should also be displayed by a UI, then the object should be accessed via the <see cref="T:KGySoft.ComponentModel.IValidatingObject"/> interface.</para>
            <example>
            The following example shows how to implement property validation:
            <code lang="C#"><![CDATA[
            public class MyModel : ValidatingObjectBase
            {
                public int Id { get => Get<int>(); set => Set(value); }
                
                public string Name { get => Get<string>(); set => Set(value); }
                
                protected override ValidationResultsCollection DoValidation()
                {
                    var result = new ValidationResultsCollection();
            
                    // info
                    if (Id == 0)
                        result.AddInfo(nameof(Id), "This will be considered as a new object when saved");
                        // or: result.Add(new ValidationResult(nameof(Id), "This will be considered as a new object when saved", ValidationSeverity.Information));
            
                    // warning
                    if (Id < 0)
                        result.AddWarning(nameof(Id), $"{nameof(Id)} is recommended to be greater or equal to 0.");
            
                    // error
                    if (String.IsNullOrEmpty(Name))
                        result.AddError(nameof(Name), $"{nameof(Name)} must not be null or empty.");
            
                    return result;
                }
            }
            ]]></code>
            </example>
            <note type="implement">For another example see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ObservableObjectBase"/> class.
            The same applies also for the <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/> class regarding the ways of defining properties in a derived class.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid">
            <summary>
            Gets whether this instance is valid. That is, if <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> property does not return any entries where
            the value of <see cref="P:KGySoft.ComponentModel.ValidationResult.Severity"/> is <see cref="F:KGySoft.ComponentModel.ValidationSeverity.Error"/>.
            </summary>
            <value><see langword="true"/> if this instance is valid; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults">
            <summary>
            Gets the validation results for this instance.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidatingObjectBase.Validate">
            <summary>
            Forces calling the <see cref="M:KGySoft.ComponentModel.ValidatingObjectBase.DoValidation">DoValidation</see> method and updates the <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> and <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/> properties.
            </summary>
            <returns>A <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection" /> instance containing the validation results.</returns>
            <remarks>
            <note>Normally you don't need to call this method because the <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/> and <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/>
            properties are automatically re-evaluated when they are accessed and the object has been changed since last validation.
            Explicit validation can be useful when not every change that affects validation triggers the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged"/> event.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidatingObjectBase.DoValidation">
            <summary>
            Performs the validation on this instance and returns the validation results. Must not return <see langword="null"/>.
            </summary>
            <returns>A <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection" /> instance containing the validation results.</returns>
            <remarks>
            <note>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ValidatingObjectBase"/> class for an example.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidatingObjectBase.AffectsModifiedState(System.String)">
            <summary>
            Gets whether the change of the specified <paramref name="propertyName" /> affects the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property.
            <br />The <see cref="T:KGySoft.ComponentModel.EditableObjectBase" /> implementation excludes the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified"/>, <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.IsValid"/> and <see cref="P:KGySoft.ComponentModel.ValidatingObjectBase.ValidationResults"/> properties.
            </summary>
            <param name="propertyName">Name of the changed property.</param>
            <returns><see langword="true"/> if changing of the specified <paramref name="propertyName" /> affects the value of the <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.IsModified" /> property; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidatingObjectBase.OnPropertyChanged(KGySoft.ComponentModel.PropertyChangedExtendedEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:KGySoft.ComponentModel.ValidationResult">
            <summary>
            Represents a validation entry in a <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResult.PropertyName">
            <summary>
            Gets the name of the property for this <see cref="T:KGySoft.ComponentModel.ValidationResult"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResult.Message">
            <summary>
            Gets the message for this <see cref="T:KGySoft.ComponentModel.ValidationResult"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResult.Severity">
            <summary>
            Gets the severity of this <see cref="T:KGySoft.ComponentModel.ValidationResult"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResult.#ctor(System.String,System.String,KGySoft.ComponentModel.ValidationSeverity)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.ValidationResult"/> class.
            </summary>
            <param name="propertyName">Name of the property to which this <see cref="T:KGySoft.ComponentModel.ValidationResult"/> belongs.</param>
            <param name="message">The message of this <see cref="T:KGySoft.ComponentModel.ValidationResult"/>.</param>
            <param name="severity">The severity of the <see cref="T:KGySoft.ComponentModel.ValidationResult"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.ComponentModel.ValidationSeverity.Error"/>.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResult.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResult.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResult.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.ValidationResultsCollection">
            <summary>
            Represents a collection of <see cref="T:KGySoft.ComponentModel.ValidationResult"/> entries.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.ValidationResultsCollection.Empty">
            <summary>
            Gets an empty, immutable <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>. This field is read-only.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.Errors">
            <summary>
            Gets a read-only <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> containing <see cref="T:KGySoft.ComponentModel.ValidationResult"/> entries with <see cref="F:KGySoft.ComponentModel.ValidationSeverity.Error"/> severities.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.Warnings">
            <summary>
            Gets the validation results denoting a warning.= as a read-only <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.Infos">
            <summary>
            Gets the validation results denoting an information.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.HasErrors">
            <summary>
            Gets whether this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> has errors.
            </summary>
            <value><see langword="true"/> if this instance has errors; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.HasWarnings">
            <summary>
            Gets whether this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> has warnings.
            </summary>
            <value><see langword="true"/> if this instance has warnings; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.HasInfos">
            <summary>
            Gets whether this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> has information entries.
            </summary>
            <value><see langword="true"/> if this instance has information entries; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.Message">
            <summary>
            Gets a single combined <see cref="T:System.String"/> that contains all messages in this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.Item(System.String)">
            <summary>
            Gets the validation results for the specified <paramref name="propertyName"/>.
            </summary>
            <param name="propertyName">Name of the property to get the validation results.</param>
        </member>
        <member name="P:KGySoft.ComponentModel.ValidationResultsCollection.Item(System.String,System.Nullable{KGySoft.ComponentModel.ValidationSeverity})">
            <summary>
            Gets the validation results for the specified <paramref name="propertyName"/> and <paramref name="severity"/>.
            </summary>
            <param name="propertyName">Name of the property to get the validation results.</param>
            <param name="severity">The severity of the validation results to get. Specify <see langword="null"/> to get results of any severities.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.AddError(System.String,System.String)">
            <summary>
            Adds an error to this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="message">The error message.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> instance is read-only and cannot be modified.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.AddWarning(System.String,System.String)">
            <summary>
            Adds a warning to this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="message">The warning message.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> instance is read-only and cannot be modified.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.AddInfo(System.String,System.String)">
            <summary>
            Adds an information to this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/>.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="message">The information message.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> instance is read-only and cannot be modified.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.TryGetFirstWithHighestSeverity(System.String)">
            <summary>
            Gets the first <see cref="T:KGySoft.ComponentModel.ValidationResult"/> with highest severity, optionally using the specified <paramref name="propertyName"/>,
            or <see langword="null"/>, if no such <see cref="T:KGySoft.ComponentModel.ValidationResult"/> exists.
            </summary>
            <param name="propertyName">An optional property name to get the result for a specific property, or <see langword="null"/> to get the
            highest severity <see cref="T:KGySoft.ComponentModel.ValidationResult"/> for any property.</param>
            <returns>The first <see cref="T:KGySoft.ComponentModel.ValidationResult"/> with highest severity using the specified <paramref name="propertyName"/>, or <see langword="null"/>,
            if no such <see cref="T:KGySoft.ComponentModel.ValidationResult"/> exists.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.ToString">
            <summary>
            Gets the string representation of this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection"/> instance.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.InsertItem(System.Int32,KGySoft.ComponentModel.ValidationResult)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> cannot be <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.SetItem(System.Int32,KGySoft.ComponentModel.ValidationResult)">
            <summary>
            Replaces the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> cannot be <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.ValidationResultsCollection.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.ComponentModel.ValidationResultsCollection" />.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.EditableObjectBehavior">
            <summary>
            Represents the behavior of an <see cref="T:KGySoft.ComponentModel.ICanEdit"/> implementation when it is treated as an <see cref="T:System.ComponentModel.IEditableObject"/>.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.EditableObjectBehavior.Disabled">
            <summary>
            <see cref="T:System.ComponentModel.IEditableObject"/> methods are ignored, the object must be used as an <see cref="T:KGySoft.ComponentModel.ICanEdit"/> implementation to utilize editing features.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.EditableObjectBehavior.DisableNesting">
            <summary>
            <see cref="M:System.ComponentModel.IEditableObject.EndEdit">IEditableObject.EndEdit</see> and <see cref="M:System.ComponentModel.IEditableObject.CancelEdit">IEditableObject.CancelEdit</see> calls ignore possible multiple
            <see cref="M:System.ComponentModel.IEditableObject.BeginEdit">IEditableObject.BeginEdit</see> calls and commit/revert all of the previous changes.
            <see cref="P:KGySoft.ComponentModel.ICanEdit.EditLevel"/> will be 0 after an <see cref="M:System.ComponentModel.IEditableObject.EndEdit">IEditableObject.EndEdit</see> or <see cref="M:System.ComponentModel.IEditableObject.CancelEdit">IEditableObject.CancelEdit</see> call.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.EditableObjectBehavior.AllowNesting">
            <summary>
            Number of <see cref="M:System.ComponentModel.IEditableObject.EndEdit">IEditableObject.EndEdit</see> and <see cref="M:System.ComponentModel.IEditableObject.CancelEdit">IEditableObject.CancelEdit</see> calls must equal to previous <see cref="M:System.ComponentModel.IEditableObject.BeginEdit">IEditableObject.BeginEdit</see> calls;
            otherwise, an <see cref="T:System.InvalidOperationException"/> will be thrown.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ValidationSeverity">
            <summary>
            Represents the severity level of a <see cref="T:KGySoft.ComponentModel.ValidationResult"/>.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.ValidationSeverity.Information">
            <summary>
            Represents the information severity level.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.ValidationSeverity.Warning">
            <summary>
            Represents the warning severity level.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.ValidationSeverity.Error">
            <summary>
            Represents the error severity level.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.AddingNewEventArgs`1">
            <summary>Provides data for the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"><![CDATA[FastBindingList<T>.AddingNew]]></see> event.</summary>
            <typeparam name="T">The type of the element to add.</typeparam>
        </member>
        <member name="P:KGySoft.ComponentModel.AddingNewEventArgs`1.NewObject">
            <summary>
            Gets or sets the object to be added to the binding list. If <see langword="null"/>,
            then a new instance of <typeparamref name="T"/> is tried to be created automatically.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs">
            <summary>
            Represents a <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> with property value. The actual type of the event argument of the <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged">ObservableObjectBase.PropertyChanged</see> event is
            <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/>.
            </summary>
            <seealso cref="T:System.ComponentModel.PropertyChangedEventArgs" />
            <remarks><note>The <see cref="E:KGySoft.ComponentModel.ObservableObjectBase.PropertyChanged">ObservableObjectBase.PropertyChanged</see> event uses the <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/> delegate in order to consumers, which rely on the conventional property
            changed notifications can use it in a compatible way. To get the old value in an event handler you can cast the argument to <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/>
            or call the <see cref="M:KGySoft.ComponentModel.PropertyChangedEventArgsExtensions.TryGetOldPropertyValue(System.ComponentModel.PropertyChangedEventArgs,System.Object@)">TryGetOldPropertyValue</see> extension method on it.</note></remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs.OldValue">
            <summary>
            Gets the property value before the change or <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.MissingProperty"/> if no previous value was stored for the property before the change.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs.NewValue">
            <summary>
            Gets the property value after the change or <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.MissingProperty"/> if the property has just been reset and there is no stored value for it.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs.#ctor(System.Object,System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> class.
            </summary>
            <param name="oldValue">The property value before the change.</param>
            <param name="newValue">The property value after the change.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:KGySoft.ComponentModel.PropertyChangedEventArgsExtensions">
            <summary>
            Extension methods for the <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.PropertyChangedEventArgsExtensions.TryGetOldPropertyValue(System.ComponentModel.PropertyChangedEventArgs,System.Object@)">
            <summary>
            If the specified event <paramref name="args"/> is a <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> instance, then gets the property value before the change.
            </summary>
            <param name="args">The <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
            <param name="oldValue">If the specified event <paramref name="args"/> is a <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> instance, then the property value before the change; otherwise, <see langword="null"/>.</param>
            <returns><see langword="true"/> if the specified event <paramref name="args"/> is a <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> instance; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.PropertyChangedEventArgsExtensions.TryGetNewPropertyValue(System.ComponentModel.PropertyChangedEventArgs,System.Object@)">
            <summary>
            If the specified event <paramref name="args"/> is a <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> instance, then gets the property value after the change.
            </summary>
            <param name="args">The <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
            <param name="newValue">If the specified event <paramref name="args"/> is a <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> instance, then the property value after the change; otherwise, <see langword="null"/>.</param>
            <returns><see langword="true"/> if the specified event <paramref name="args"/> is a <see cref="T:KGySoft.ComponentModel.PropertyChangedExtendedEventArgs"/> instance; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.ICanEdit">
            <summary>
            Represents an object with nested committable and revertible editing capability.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.EditableObjectBase" />
        </member>
        <member name="P:KGySoft.ComponentModel.ICanEdit.EditLevel">
            <summary>
            Gets the editing level. That is, the number of <see cref="M:KGySoft.ComponentModel.ICanEdit.BeginNewEdit">BeginNewEdit</see> calls without corresponding <see cref="M:KGySoft.ComponentModel.ICanEdit.CommitLastEdit">CommitLastEdit</see> or <see cref="M:KGySoft.ComponentModel.ICanEdit.RevertLastEdit">RevertLastEdit</see> calls.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanEdit.BeginNewEdit">
            <summary>
            Begins a new level of committable/revertible editing session on the object.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanEdit.CommitLastEdit">
            <summary>
            Commits all changes since the last <see cref="M:KGySoft.ComponentModel.ICanEdit.BeginNewEdit">BeginNewEdit</see> call.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanEdit.RevertLastEdit">
            <summary>
            Discards all changes since the last <see cref="M:KGySoft.ComponentModel.ICanEdit.BeginNewEdit">BeginNewEdit</see> call.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanEdit.TryCommitAllEdits">
            <summary>
            Commits all changes of all editing levels.
            </summary>
            <returns><see langword="true"/> if <see cref="P:KGySoft.ComponentModel.ICanEdit.EditLevel"/> was greater than 0 before the call; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanEdit.TryRevertAllEdits">
            <summary>
            Reverts all changes of all editing levels.
            </summary>
            <returns><see langword="true"/> if <see cref="P:KGySoft.ComponentModel.ICanEdit.EditLevel"/> was greater than 0 before the call; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.ICanUndo">
            <summary>
            Represents an object with undo capability.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICanUndo.CanUndo">
            <summary>
            Gets whether there are changes to undo.
            </summary>
            <value><see langword="true"/>, if there are changes to undo; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanUndo.TryUndo">
            <summary>
            Tries to perform one undo step.
            </summary>
            <returns><see langword="true"/>, if one step is successfully undone; otherwise, <see langword="false"/>.
            The result can be <see langword="false"/> if <see cref="P:KGySoft.ComponentModel.ICanUndo.CanUndo"/> was <see langword="false"/> or when the stored steps are inconsistent with the current property values.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanUndo.UndoAll">
            <summary>
            Undoes all possible undo steps.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanUndo.ClearUndoHistory">
            <summary>
            Clears the undo history without performing any undo.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ICanUndoRedo">
            <summary>
            Represents an object with undo and redo capability.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.ICanUndo" />
        </member>
        <member name="P:KGySoft.ComponentModel.ICanUndoRedo.CanRedo">
            <summary>
            Gets whether there are changes to redo.
            </summary>
            <value><see langword="true"/>, if there are changes to redo; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanUndoRedo.TryRedo">
            <summary>
            Tries to perform one redo step.
            </summary>
            <returns><see langword="true"/>, if one step is successfully redone; otherwise, <see langword="false"/>.
            The result can be <see langword="false"/> if <see cref="P:KGySoft.ComponentModel.ICanUndoRedo.CanRedo"/> was <see langword="false"/> or when the stored steps are inconsistent with the current property values.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICanUndoRedo.RedoAll">
            <summary>
            Redoes all possible redo steps.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.IPersistableObject">
            <summary>
            Represents an object that can store its own properties and is able to notify its consumer about property changes.
            </summary>
            <seealso cref="T:System.ComponentModel.INotifyPropertyChanged" />
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.TryGetPropertyValue(System.String,System.Object@)">
            <summary>
            Tries to get the specified property from the inner storage.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="value">Returns the value of the property if it could be found in the inner storage. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/> if the property exists in the inner storage; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.CanGetProperty(System.String)">
            <summary>
            Gets whether the specified property can be retrieved.
            If returns <see langword="false"/>, then <see cref="M:KGySoft.ComponentModel.IPersistableObject.GetPropertyOrDefault``1(System.String,``0)">GetPropertyOrDefault</see>, <see cref="M:KGySoft.ComponentModel.IPersistableObject.ReplaceProperties(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">ReplaceProperties</see>
            and <see cref="M:KGySoft.ComponentModel.IPersistableObject.TryReplaceProperty(System.String,System.Object,System.Object,System.Boolean)">TryReplaceProperty</see> methods throw an <see cref="T:System.InvalidOperationException"/> for the specified <paramref name="propertyName"/>.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <returns><see langword="true"/>, if the specified property can be retrieved; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.CanSetProperty(System.String,System.Object)">
            <summary>
            Gets whether the specified property can be set.
            If returns <see langword="false"/>, then <see cref="M:KGySoft.ComponentModel.IPersistableObject.SetProperty(System.String,System.Object,System.Boolean)">SetProperty</see>, <see cref="M:KGySoft.ComponentModel.IPersistableObject.SetProperties(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">SetProperties</see>, <see cref="M:KGySoft.ComponentModel.IPersistableObject.ReplaceProperties(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">ReplaceProperties</see>
            and <see cref="M:KGySoft.ComponentModel.IPersistableObject.TryReplaceProperty(System.String,System.Object,System.Object,System.Boolean)">TryReplaceProperty</see> methods throw an <see cref="T:System.InvalidOperationException"/> for the specified <paramref name="propertyName"/>.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="value">The property value to set.</param>
            <returns><see langword="true"/>, if the specified property can be set; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.GetPropertyOrDefault``1(System.String,``0)">
            <summary>
            Gets the specified property if it exists in the inner storage and has a compatibly type with <typeparamref name="T"/>; otherwise, returns <paramref name="defaultValue"/>.
            </summary>
            <typeparam name="T">Type of the property to return.</typeparam>
            <param name="propertyName">The name of the property to get.</param>
            <param name="defaultValue">The default value to return if property does not exist or has an incompatible type with <typeparamref name="T"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="T"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="T"/>.</param>
            <returns>The found property value or <paramref name="defaultValue"/> if <paramref name="propertyName"/> was not found in this <see cref="T:KGySoft.ComponentModel.IPersistableObject"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Cannot get the property.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.SetProperty(System.String,System.Object,System.Boolean)">
            <summary>
            Sets the property to specified <paramref name="value"/>.
            </summary>
            <param name="propertyName">The name of the property to set.</param>
            <param name="value">The value to set.</param>
            <param name="triggerChangedEvent"><see langword="true"/> to allow raising the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if property has been set (change occurred); otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Cannot set the property.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.ResetProperty(System.String,System.Boolean)">
            <summary>
            Resets the property of the specified <paramref name="propertyName"/>, meaning, it will be removed from the underlying storage so the property getters will return the default value again and <see cref="M:KGySoft.ComponentModel.IPersistableObject.TryGetPropertyValue(System.String,System.Object@)">TryGetPropertyValue</see> will return <see langword="false"/>.
            </summary>
            <param name="propertyName">The name of the property to reset.</param>
            <param name="triggerChangedEvent"><see langword="true"/> to allow raising the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if property has been reset (it existed previously); otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.GetProperties">
            <summary>
            Gets a copy of the stored properties.
            </summary>
            <returns>A copy of the stored properties.</returns>
            <exception cref="T:System.InvalidOperationException">A property cannot be retrieved.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.SetProperties(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Sets the provided <paramref name="properties"/> in the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/>. The new set of properties will be merged with the existing ones.
            </summary>
            <param name="properties">The properties to set.</param>
            <param name="triggerChangedEvent"><see langword="true"/> to allow raising the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <exception cref="T:System.InvalidOperationException">A property cannot be set.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.ReplaceProperties(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Replaces the properties of the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/> with the provided new <paramref name="properties"/>. If contains less entries than the actually stored entries, then the difference will be removed from the <see cref="T:KGySoft.ComponentModel.IPersistableObject"/>.
            </summary>
            <param name="properties">The new properties to set.</param>
            <param name="triggerChangedEvent"><see langword="true"/> to allow raising the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <exception cref="T:System.InvalidOperationException">A property cannot be set.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.IPersistableObject.TryReplaceProperty(System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            Tries to the replace a property value. The replacement will succeed if the currently stored value equals to <paramref name="originalValue"/>.
            Non-existing value can be represented by <see cref="P:KGySoft.ComponentModel.ObservableObjectBase.MissingProperty"/> so the method supports also "try remove" and "try add" functionality.
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="originalValue">The original value.</param>
            <param name="newValue">The new value.</param>
            <param name="triggerChangedEvent"><see langword="true"/> to allow raising the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event; otherwise, <see langword="false"/>.</param>
            <returns><see langword="true"/> if the originally stored value equals <paramref name="originalValue"/> and the replacement was successful (even if <paramref name="originalValue"/> equals <paramref name="newValue"/>); otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Cannot get or set the property.</exception>
        </member>
        <member name="T:KGySoft.ComponentModel.IValidatingObject">
            <summary>
            Represents an object that can be validated.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.IValidatingObject.IsValid">
            <summary>
            Gets whether this instance is valid. That is, if the <see cref="P:KGySoft.ComponentModel.IValidatingObject.ValidationResults"/> property does not return any entry where
            the <see cref="P:KGySoft.ComponentModel.ValidationResult.Severity"/> property is <see cref="F:KGySoft.ComponentModel.ValidationSeverity.Error"/>.
            </summary>
            <value><see langword="true"/> if this instance is valid; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:KGySoft.ComponentModel.IValidatingObject.ValidationResults">
            <summary>
            Gets the validation results for this instance.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.FastBindingList`1">
            <summary>
            Provides a generic list that is able to notify its consumer about changes and supports data binding.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <remarks>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> is mainly compatible with <see cref="T:System.ComponentModel.BindingList`1"/> but has a better performance than that because element lookup
            in <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> is an O(1) operation. In contrast, element lookup in <see cref="T:System.ComponentModel.BindingList`1"/> is an O(n) operation, which makes
            <see cref="M:System.ComponentModel.BindingList`1.AddNew"><![CDATA[BindingList<T>.AddNew]]></see> and <see cref="E:System.ComponentModel.BindingList`1.ListChanged"><![CDATA[BindingList<T>.ListChanged]]></see> invocation (when an element is changed)
            slow because they call the <see cref="M:System.Collections.ObjectModel.Collection`1.IndexOf(`0)"><![CDATA[Collection{T}.IndexOf]]></see> method to determine the position of the added or changed element.</note>
            <h2>Comparison with <see cref="T:System.ComponentModel.BindingList`1"/></h2>
            <para><strong>Incompatibility</strong> with <see cref="T:System.ComponentModel.BindingList`1"/>:
            <list type="bullet">
            <item><see cref="T:System.ComponentModel.BindingList`1"/> is derived from <see cref="T:System.Collections.ObjectModel.Collection`1"/>, whereas <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> is derived from <see cref="T:KGySoft.Collections.ObjectModel.FastLookupCollection`1"/>, which is derived from <see cref="T:KGySoft.Collections.ObjectModel.VirtualCollection`1"/>.
            Both types implement the <see cref="T:System.Collections.Generic.IList`1"/> interface though.</item>
            <item><see cref="E:System.ComponentModel.BindingList`1.AddingNew"><![CDATA[BindingList<T>.AddingNew]]></see> event has <see cref="T:System.ComponentModel.AddingNewEventHandler"/> type, which uses <see cref="T:System.ComponentModel.AddingNewEventArgs"/>,
            whereas in <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event has <see cref="T:System.EventHandler`1"/> type where <em>TEventArgs</em> is <see cref="T:KGySoft.ComponentModel.AddingNewEventArgs`1"/>. The main difference between the two event arguments
            that the latter is generic.</item>
            <item>In <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> the <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowRemove"/> property is initialized to <see langword="false"/> if the wrapped list is read-only.
            <br/>In contrast, in <see cref="T:System.ComponentModel.BindingList`1"/> this property is <see langword="true"/> by default.</item>
            <item>In <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> the <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew"/> property is initialized to <see langword="false"/> if the wrapped list is read-only, or when <typeparamref name="T"/> is not a value type and has no parameterless constructor.
            The return value of <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew"/> does not change when <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event is subscribed and setting <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew"/> does not reset the list.
            <br/>In contrast, in <see cref="T:System.ComponentModel.BindingList`1"/> this property is <see langword="false"/> if <typeparamref name="T"/> is not a primitive type and has no public parameterless constructor.
            However, return value of <see cref="P:System.ComponentModel.BindingList`1.AllowNew"><![CDATA[BindingList<T>.AllowNew]]></see> can change when <see cref="E:System.ComponentModel.BindingList`1.AddingNew"><![CDATA[BindingList<T>.AddingNew]]></see> event is subscribed,
            and setting the <see cref="P:System.ComponentModel.BindingList`1.AllowNew"><![CDATA[BindingList<T>.AllowNew]]></see> property resets the list.</item>
            <item>Calling <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> throws <see cref="T:System.InvalidOperationException"/> if <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew"/> is <see langword="false"/>.</item>
            <item>Calling <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Remove(`0)">Remove</see> or <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Clear">Clear</see> throws <see cref="T:System.InvalidOperationException"/> if <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowRemove"/> is <see langword="false"/>.</item>
            <item><see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNewCore">AddNewCore</see> returns <typeparamref name="T"/> instead of <see cref="T:System.Object">object</see>.</item>
            <item>If <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNewCore">AddNewCore</see> is called for a <typeparamref name="T"/> type, which cannot be instantiated automatically and the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event is not subscribed or returns <see langword="null"/>,
            then an <see cref="T:System.InvalidOperationException"/> will be thrown. In contrast, <see cref="M:System.ComponentModel.BindingList`1.AddNewCore"><![CDATA[BindingList<T>.AddNewCore]]></see> can throw an <see cref="T:System.InvalidCastException"/> or <see cref="T:System.NotSupportedException"/>.</item>
            <item><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> might not work properly if items can change their hash code while they are added to the collection.</item>
            </list>
            <note type="warning">Do not store elements in a <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> that may change their hash code while they are added to the collection.
            Finding such elements may fail even if <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/>. If hash code is derived from some identifier property or field, you can prepare
            a <typeparamref name="T"/> instance by overriding the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNewCore">AddNewCore</see> method or by subscribing the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event
            to make <see cref="M:System.ComponentModel.IBindingList.AddNew">IBindingList.AddNew</see> implementation work properly.</note> 
            </para>
            <para><strong>New features and improvements</strong> compared to <see cref="T:System.ComponentModel.BindingList`1"/>:
            <list type="bullet">
            <item><term>Disposable</term><description>The <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> implements the <see cref="T:System.IDisposable"/> interface. When an instance is disposed, then both
            incoming and outgoing event subscriptions (self events and <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the elements) are removed.
            The <see cref="P:KGySoft.ComponentModel.FastBindingList`1.DisposeBehavior"/> property determines how to handle the possibly disposable wrapped collection and the items when disposing
            this <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> instance. After disposing accessing the public members may throw <see cref="T:System.ObjectDisposedException"/>.</description></item>
            <item><term>Overridable properties</term><description>In <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> the <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew"/>, <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowRemove"/>, <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowEdit"/>
            and <see cref="P:KGySoft.ComponentModel.FastBindingList`1.RaiseListChangedEvents"/> properties are virtual.</description></item>
            <item><term>Find support</term><description>In <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> the <see cref="M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)">IBindingList.Find</see> method is supported.
            In <see cref="T:System.ComponentModel.BindingList`1"/> this throws a <see cref="T:System.NotSupportedException"/>.</description></item>
            <item><term>Public members for finding and sorting</term><description><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> offers several public <see cref="O:KGySoft.ComponentModel.FastBindingList`1.Find">Find</see>
            and <see cref="O:KGySoft.ComponentModel.FastBindingList`1.ApplySort">ApplySort</see> overloads. <see cref="M:KGySoft.ComponentModel.FastBindingList`1.RemoveSort">RemoveSort</see> method and <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/>/<see cref="P:KGySoft.ComponentModel.FastBindingList`1.SortProperty"/> properties are also public instead of explicit interface implementations.</description></item>
            <item><term>New virtual members</term><description><see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddIndexCore(System.ComponentModel.PropertyDescriptor)">AddIndexCore</see> and <see cref="M:KGySoft.ComponentModel.FastBindingList`1.RemoveIndexCore(System.ComponentModel.PropertyDescriptor)">RemoveIndexCore</see> methods can be overridden to implement <see cref="M:System.ComponentModel.IBindingList.AddIndex(System.ComponentModel.PropertyDescriptor)">IBindingList.AddIndex</see> and <see cref="M:System.ComponentModel.IBindingList.RemoveIndex(System.ComponentModel.PropertyDescriptor)">IBindingList.RemoveIndex</see> calls.</description></item>
            </list>
            </para>
            <note type="tip"><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> does not implement sorting. See the derived <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class for an <see cref="T:System.ComponentModel.IBindingList"/> implementation with sorting support.</note>
            </remarks>
        </member>
        <member name="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew">
            <summary>
            Occurs when a new item is added to the list by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.
            </summary>
            <remarks>
            By handling this event a custom item creation of <typeparamref name="T"/> can be provided.
            </remarks>
        </member>
        <member name="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged">
            <summary>
            Occurs when the list or an item in the list changes.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew">
            <summary>
            Gets or sets whether new items can be added to the list by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.
            <br/>Default value: <see langword="true"/> if the wrapped list is not read-only and <typeparamref name="T"/> is a value type or has a parameterless constructor; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.AllowEdit">
            <summary>
            Gets or sets whether item properties can be edited in the list.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.AllowRemove">
            <summary>
            Gets or sets whether items can be removed from the list by the <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Remove(`0)">Remove</see>, <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveAt(System.Int32)">RemoveAt</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Clear">Clear</see> methods.
            <br/>Default value: <see langword="true"/> if the wrapped list is not read-only; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted">
            <summary>
            Gets whether the items in the list are sorted.
            </summary>
            <remarks>
            <para>This property returns the value of the overridable <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSortedCore"/> property.</para>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> returns always <see langword="false"/> for this property. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.SortProperty">
            <summary>
            Gets a <see cref="T:System.ComponentModel.PropertyDescriptor" /> that is being used for sorting. Returns <see langword="null"/> if the list is not sorted or
            when it is sorted by the values of <typeparamref name="T"/> rather than by one of its properties.
            </summary>
            <remarks>
            <para>This property returns the value of the overridable <see cref="P:KGySoft.ComponentModel.FastBindingList`1.SortPropertyCore"/> property.</para>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> returns always <see langword="null"/> for this property. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.RaiseListChangedEvents">
            <summary>
            Gets or sets whether adding or removing items within the list raises <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> events.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.DisposeBehavior">
            <summary>
            Specifies the strategy for treating the wrapped <see cref="P:KGySoft.Collections.ObjectModel.VirtualCollection`1.Items"/> and the added values when this instance is disposed.
            <br/>Default value: <see cref="F:KGySoft.ComponentModel.BindingListDisposeBehavior.DisposeCollection"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.PropertyDescriptors">
            <summary>
            Gets the property descriptors of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.SupportsChangeNotificationCore">
            <summary>
            Gets whether <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> events are enabled.
            <br/>The base implementation returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSearchingCore">
            <summary>
            Gets whether the list supports searching.
            <br/>The base implementation returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSortingCore">
            <summary>
            Gets whether the list supports sorting.
            <br/>The base implementation returns <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.IsSortedCore">
            <summary>
            Gets whether the list is sorted.
            <br/>The base implementation returns <see langword="false"/>.
            </summary>
            <remarks>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> returns always <see langword="false"/> for this property. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.SortPropertyCore">
            <summary>
            Gets the property descriptor that is used for sorting the list if sorting, or <see langword="null"/> if the list is not sorted or
            when it is sorted by the values of <typeparamref name="T"/> rather than by one of its properties.
            <br/>The base implementation returns <see langword="null"/>.
            </summary>
            <remarks>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> returns always <see langword="null"/> for this property. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.FastBindingList`1.SortDirectionCore">
            <summary>
            Gets the direction of the sort.
            <br/>The base implementation returns <see cref="F:System.ComponentModel.ListSortDirection.Ascending"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> class with a <see cref="T:KGySoft.Collections.CircularList`1"/> internally.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> class with the specified <paramref name="list"/>.
            </summary>
            <param name="list">An <see cref="T:System.Collections.Generic.IList`1" /> of items to be contained in the <see cref="T:KGySoft.ComponentModel.FastBindingList`1" />.</param>
            <remarks>
            <note>Do not wrap another <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> as their events are not captured by the <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> class.
            To capture and generate events for both wrapped and self list operations use <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> instead.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">
            <summary>
            Adds a new item to the collection.
            </summary>
            <returns>The item added to the list.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowNew"/> property returns <see langword="false"/>
            <br/>-or-
            <br/><see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> is not subscribed or returned <see langword="null"/>, and <typeparamref name="T"/> is not a value type
            or has no parameterless constructor.</exception>
            <remarks>
            <para>To customize the behavior either subscribe the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event or override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNewCore">AddNewCore</see> method in a derived class.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ApplySort(System.ComponentModel.ListSortDirection)">
            <summary>
            Sorts the list by the values of <typeparamref name="T"/> rather than one of its properties based on the specified <paramref name="direction"/>.
            </summary>
            <param name="direction">The desired direction of the sort.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSortingCore"/> returns <see langword="false"/>.</exception>
            <remarks>
            <para>To customize the behavior override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">ApplySortCore</see> method in a derived class.</para>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> throws a <see cref="T:System.NotSupportedException"/> for this method. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            Sorts the list based on the specified <paramref name="property"/> and <paramref name="direction"/>.
            </summary>
            <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor"/> instance to sort by.</param>
            <param name="direction">The desired direction of the sort.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSortingCore"/> returns <see langword="false"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="property"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="property"/> is not a property of <typeparamref name="T"/>.</exception>
            <remarks>
            <para>To customize the behavior override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">ApplySortCore</see> method in a derived class.</para>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> throws a <see cref="T:System.NotSupportedException"/> for this method. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            <note>In this overload <paramref name="property"/> cannot be <see langword="null"/>. To sort by the values of <typeparamref name="T"/> rather than one of its properties use the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.ApplySort(System.ComponentModel.ListSortDirection)"/> overload.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ApplySort(System.String,System.ComponentModel.ListSortDirection)">
            <summary>
            Sorts the list based on the specified <paramref name="propertyName"/> and <paramref name="direction"/>.
            </summary>
            <param name="propertyName">A property name of <typeparamref name="T"/> to sort by.</param>
            <param name="direction">The desired direction of the sort.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSortingCore"/> returns <see langword="false"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> has no corresponding <see cref="T:System.ComponentModel.PropertyDescriptor"/> in <typeparamref name="T"/>.</exception>
            <remarks>
            <para>To customize the behavior override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">ApplySortCore</see> method in a derived class.</para>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> throws a <see cref="T:System.NotSupportedException"/> for this method. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            <note>In this overload a property must be specified. To sort by the values of <typeparamref name="T"/> rather than one of its properties use the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.ApplySort(System.ComponentModel.ListSortDirection)"/> overload.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.RemoveSort">
            <summary>
            Removes any sort applied by the <see cref="O:KGySoft.ComponentModel.FastBindingList`1.ApplySort">ApplySort</see> overloads.
            </summary>
            <remarks>
            <remarks>
            <para>To customize the behavior override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.RemoveSortCore">RemoveSortCore</see> method in a derived class.</para>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> throws a <see cref="T:System.NotSupportedException"/> for this method. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.Find(System.ComponentModel.PropertyDescriptor,System.Object)">
            <summary>
            Searches for the index of the item that has the specified property descriptor with the specified value.
            </summary>
            <param name="property">The <see cref="T:System.ComponentModel.PropertyDescriptor" /> to search on.</param>
            <param name="key">The value of the <paramref name="property" /> parameter to search for.</param>
            <returns>The zero-based index of the item that matches the property descriptor and contains the specified value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="property"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="property"/> is not a property of <typeparamref name="T"/>.</exception>
            <remarks>
            <para>To customize the behavior override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.FindCore(System.ComponentModel.PropertyDescriptor,System.Object)">FindCore</see> method in a derived class.</para>
            <note><paramref name="property"/> cannot be <see langword="null"/>. To search by the whole value of <typeparamref name="T"/> rather than by one of its properties
            use the <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.IndexOf(`0)">IndexOf</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.Find(System.String,System.Object)">
            <summary>
            Searches for the index of the item that has the specified property descriptor with the specified value.
            </summary>
            <param name="propertyName">A property name of <typeparamref name="T"/> to search on.</param>
            <param name="key">The value of the specified property to search for.</param>
            <returns>The zero-based index of the item that matches the property descriptor and contains the specified value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="propertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyName"/> has no corresponding <see cref="T:System.ComponentModel.PropertyDescriptor"/> in <typeparamref name="T"/>.</exception>
            <remarks>
            <para>To customize the behavior override the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.FindCore(System.ComponentModel.PropertyDescriptor,System.Object)">FindCore</see> method in a derived class.</para>
            <note><paramref name="propertyName"/> cannot be <see langword="null"/>. To search by the whole value of <typeparamref name="T"/> rather than by one of its properties
            use the <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.IndexOf(`0)">IndexOf</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.Dispose">
            <summary>
            Releases the list and removes both incoming and outgoing subscriptions.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.CancelNew(System.Int32)">
            <summary>
            Discards a pending new item added by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.
            </summary>
            <param name="itemIndex">The index of the item that was previously added to the collection.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.EndNew(System.Int32)">
            <summary>
            Commits a pending new item added by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.
            </summary>
            <param name="itemIndex">The index of the item that was previously added to the collection.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ResetBindings">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ResetItem(System.Int32)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/> at the specified <paramref name="position"/>.
            </summary>
            <param name="position">A zero-based index of the item to be reset.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.OnAddingNew(KGySoft.ComponentModel.AddingNewEventArgs{`0})">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew" /> event.
            </summary>
            <param name="e">The <see cref="T:KGySoft.ComponentModel.AddingNewEventArgs`1" /> instance containing the event data.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.AddNewCore">
            <summary>
            Adds a new item to the collection.
            </summary>
            <returns>The item that was added to the collection.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> is not subscribed or returned <see langword="null"/>, and <typeparamref name="T"/> is not a value type
            or has no parameterless constructor.</exception>
            <remarks>
            <para>This is the overridable implementation of the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method. The base implementation raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event. If it is not
            handled or returns <see langword="null"/>, then tries to create a new instance of <typeparamref name="T"/> and adds it to the end of the list.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            If overridden in a derived class, sorts the items of the list.
            <br/>The base implementation throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor"/> that specifies the property to sort on. If <see langword="null"/>, then the list will be sorted
            by the values of <typeparamref name="T"/> rather than one of its properties.</param>
            <param name="direction">The desired direction of the sort.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSortingCore"/> returns <see langword="false"/>.</exception>
            <remarks>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> throws a <see cref="T:System.NotSupportedException"/> for this method. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.RemoveSortCore">
            <summary>
            Removes any sort applied by the <see cref="O:KGySoft.ComponentModel.FastBindingList`1.ApplySort">ApplySort</see> overloads.
            <br/>The base implementation throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <exception cref="T:System.NotSupportedException"><see cref="P:KGySoft.ComponentModel.FastBindingList`1.SupportsSortingCore"/> returns <see langword="false"/>.</exception>
            <remarks>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> throws a <see cref="T:System.NotSupportedException"/> for this method. Use the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> to be able to use sorting.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.FindCore(System.ComponentModel.PropertyDescriptor,System.Object)">
            <summary>
            Searches for the index of the item that has the specified property descriptor with the specified value.
            <br/>The base implementation performs a linear search on the items.
            </summary>
            <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor"/> that specifies the property to search for.</param>
            <param name="key">The value of <paramref name="property"/> to match.</param>
            <returns>The zero-based index of the item that matches the property descriptor and contains the specified value.</returns>
            <remarks>
            <note><see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> performs a linear search for this method, therefore has an O(n) cost, where n is the number of elements in the list.
            <br/><see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> is able to perform a binary search if <paramref name="property"/> equals <see cref="P:KGySoft.ComponentModel.FastBindingList`1.SortProperty"/>, in which case the cost of this method is O(log n).</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.AddIndexCore(System.ComponentModel.PropertyDescriptor)">
            <summary>
            If overridden in a derived class, adds the <see cref="P:KGySoft.ComponentModel.FastBindingList`1.PropertyDescriptors"/> to the indices used for searching.
            <br/>The base implementation does nothing.
            </summary>
            <param name="property">The property to add to the indices used for searching.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.RemoveIndexCore(System.ComponentModel.PropertyDescriptor)">
            <summary>
            If overridden in a derived class, removes the <see cref="P:KGySoft.ComponentModel.FastBindingList`1.PropertyDescriptors"/> from the indices used for searching.
            <br/>The base implementation does nothing.
            </summary>
            <param name="property">The property to remove from the indices used for searching.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.GetItem(System.Int32)">
            <summary>
            Gets the element at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified <paramref name="index"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the <paramref name="item" /> at the specified <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
            <remarks>
            <para>After the item is set, <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/> is raised indicating the index of the item that was set.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.ComponentModel.FastBindingList`1" /> at the specified <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
            <remarks>
            <para><see cref="M:KGySoft.ComponentModel.FastBindingList`1.InsertItem(System.Int32,`0)">InsertItem</see> performs the following operations:
            <list type="number">
            <item>Calls <see cref="M:KGySoft.ComponentModel.FastBindingList`1.EndNew(System.Int32)">EndNew</see> to commit the last possible uncommitted item added by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.</item>
            <item>Inserts the item at the specified index.</item>
            <item>Raises a <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/> indicating the index of the item that was inserted.</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.RemoveItemAt(System.Int32)">
            <summary>
            Removes the element at the specified <paramref name="index" /> from the <see cref="T:KGySoft.ComponentModel.FastBindingList`1" />.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.ComponentModel.FastBindingList`1.AllowRemove"/> is <see langword="false"/> and the item to remove is not an uncommitted one added by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.</exception>
            <remarks>
            <para>This method raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemDeleted"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/>.
            </summary>
            <remarks>
            <para>This method raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.OnMapRebuilt">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.ComponentModel.FastBindingList`1.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.EndNew">
            <summary>
            Commits a pending new item of any position added by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged" /> event.
            </summary>
            <param name="e">The <see cref="T:System.ComponentModel.ListChangedEventArgs" /> instance containing the event data.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FastBindingList`1.ItemPropertyChanged(`0,System.Int32,System.ComponentModel.PropertyDescriptor)">
            <summary>
            Called when an item contained in the <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> changes. Can be used if the binding list is sorted or uses indices.
            <br/>The base implementation does nothing.
            </summary>
            <param name="item">The changed item.</param>
            <param name="itemIndex">Index of the item determined by the virtual <see cref="M:KGySoft.Collections.ObjectModel.FastLookupCollection`1.GetItemIndex(`0)">GetItemIndex</see> method.</param>
            <param name="property">The descriptor of the changed property.</param>
        </member>
        <member name="T:KGySoft.ComponentModel.ItemComparer">
            <summary>
            Helper class for providing sort logic for the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class.
            Not a nested private class because the code is identical for all types of the enclosing class.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ItemGenericComparer`1">
            <summary>
            Helper class for providing sort logic for the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class.
            Not a nested private class because it has a different type parameter than the parent class, whose type parameter is irrelevant here.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ObservableBindingList`1">
            <summary>
            Provides a class that combines the features of an <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> and <see cref="T:System.ComponentModel.BindingList`1"/>. Unlike <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>, can raise the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event also when a property
            of a contained element changes.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <seealso cref="T:System.Collections.ObjectModel.ObservableCollection`1" />
            <seealso cref="T:System.ComponentModel.IBindingList" />
            <remarks>
            <note>In NET Framework 3.5 this class is not available because it would require to reference <c>System.WindowsBase.dll</c>.</note>
            <para>The <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> can be used in any environment where either <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> (mainly <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>) types are supported.</para>
            <para>If initialized by another <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> implementations, the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> will capture and delegate also the events of the inner collections.</para>
            <para>If the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> is initialized by the default constructor it will use a <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> inside.</para>
            <note type="tip">In an environment, which supports only the <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> interface but not the other, <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> can be used as a bridge between the two worlds.
            For example, by passing an <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> to the constructor, it will be able to be accessed as an <see cref="T:System.ComponentModel.IBindingList"/> implementation, and vice-versa: by wrapping an <see cref="T:System.ComponentModel.IBindingList"/> instance
            (such as <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> or <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>), it can be used as an <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> implementation by the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> class.</note>
            <para><strong>Differences</strong> to the <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> class:
            <list type="bullet">
            <item>The <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.PropertyChanged"/> event is raised also for a sort of additional properties, such as <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowNew"/>, <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowEdit"/>, <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowRemove"/>, <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseCollectionChangedEvents"/>,
            <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents"/> and <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseListChangedEvents"/>.</item>
            <item>If <typeparamref name="T"/> implements <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event can be raised even for property changes of the contained elements.
            This behavior can be adjusted by the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents"/> property.</item>
            <item>There is no constructor that accepts an <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance. Instead, an instance of <see cref="T:System.Collections.Generic.IList`1"/> must be provided.</item>
            <item>When the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> is initialized by another <see cref="T:System.Collections.Generic.IList`1"/>, then the passed instance will be wrapped rather than just copying the elements.
            Therefore the changes performed on the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> will be reflected also in the wrapped list.
            <br/>In contrast, passing any collection to an <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> will copy the items in a new <see cref="T:System.Collections.Generic.List`1"/> to be used inside the <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.</item>
            <item>In <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">OnCollectionChanged</see> method simply raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event without calling <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.BlockReentrancy">BlockReentrancy</see>,
            which is rather called explicitly whenever it is needed.</item>
            <item>In <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> the <see cref="M:System.Collections.ObjectModel.Collection`1.Add(`0)">Add</see>, <see cref="M:System.Collections.ObjectModel.Collection`1.Insert(System.Int32,`0)">Insert</see>, <see cref="M:System.Collections.ObjectModel.Collection`1.Remove(`0)">Remove</see>, <see cref="M:System.Collections.ObjectModel.Collection`1.RemoveAt(System.Int32)">RemoveAt</see>,
            <see cref="M:System.Collections.ObjectModel.Collection`1.Clear">Clear</see> and <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.Move(System.Int32,System.Int32)">Move</see> methods, and the setter of the <see cref="P:System.Collections.ObjectModel.Collection`1.Items">Items</see> property can throw a <see cref="T:System.NotSupportedException"/> if the wrapped collection is read-only.</item>
            </list>
            </para>
            <para><strong>Differences</strong> to the <see cref="T:System.ComponentModel.BindingList`1"/> class:
            <list type="bullet">
            <item>In case of multiple subscribers of the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> events reentrant changes during the event invocation is protected similarly to the <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> class.
            However, the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.BlockReentrancy">BlockReentrancy</see> method is not called from the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.OnListChanged(System.ComponentModel.ListChangedEventArgs)">OnListChanged</see> and <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">OnCollectionChanged</see> methods. Instead, it should be called
            explicitly when raising any or both of these events.</item>
            <item>If the initializer collection that is passed to the constructor is an <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> implementation, then changes performed directly on the wrapped collection are
            also captured and delegated to the self events.</item>
            <item>Accessing the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> through the <see cref="T:System.ComponentModel.IBindingList"/>, <see cref="T:System.ComponentModel.ICancelAddNew"/> and <see cref="T:System.ComponentModel.IRaiseItemChangedEvents"/> interfaces are in some aspects different from a regular
            <see cref="T:System.ComponentModel.BindingList`1"/>. Their implementation is as follows:
            <list type="definition">
            <item><term><see cref="T:System.ComponentModel.IBindingList"/></term><description>
            <list type="bullet">
            <item><see cref="M:System.ComponentModel.IBindingList.AddNew">AddNew</see>:
            <list type="bullet">
            <item>If <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowNew"/> returns <see langword="false"/>, then an <see cref="T:System.InvalidOperationException"/> will be thrown.</item>
            <item>Otherwise, if the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then its <see cref="M:System.ComponentModel.IBindingList.AddNew">AddNew</see> implementation will be called.</item>
            <item>Otherwise, if <typeparamref name="T"/> is a value type or has a parameterless constructor, then a new item of <typeparamref name="T"/> is created and added to the list.</item>
            <item>Otherwise, an <see cref="T:System.InvalidOperationException"/> will be thrown.</item>
            </list></item>
            <item><see cref="P:System.ComponentModel.IBindingList.AllowNew"/>:
            <list type="bullet">
            <item>Returns <see langword="false"/> if the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, and its <see cref="P:System.ComponentModel.IBindingList.AllowNew"/> returns <see langword="false"/>.</item>
            <item>Otherwise, returns the lastly set value. Or, if was never set, returns <see langword="true"/> if <typeparamref name="T"/> is a value type or has a parameterless constructor, and the underlying collection is not read-only.</item>
            </list></item>
            <item><see cref="P:System.ComponentModel.IBindingList.AllowEdit"/> and <see cref="P:System.ComponentModel.IBindingList.AllowRemove"/>:
            <list type="bullet">
            <item>Both return <see langword="false"/> if the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, and its <see cref="P:System.ComponentModel.IBindingList.AllowEdit"/>/<see cref="P:System.ComponentModel.IBindingList.AllowRemove"/> return <see langword="false"/>.</item>
            <item>Otherwise, they return the lastly set value. Or, if they were never set, they return <see langword="true"/> if the underlying collection is not read-only.</item>
            </list></item>
            <item><see cref="P:System.ComponentModel.IBindingList.SupportsChangeNotification"/>: returns always <see langword="true"/>.</item>
            <item><see cref="P:System.ComponentModel.IBindingList.SupportsSearching"/>, <see cref="P:System.ComponentModel.IBindingList.SupportsSorting"/> and <see cref="P:System.ComponentModel.IBindingList.IsSorted"/>: If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then the values of the underlying
            properties are returned; otherwise, they all return <see langword="false"/>.</item>
            <item><see cref="P:System.ComponentModel.IBindingList.SortProperty"/>: If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then the value of the underlying property is returned; otherwise, returns <see langword="null"/>.</item>
            <item><see cref="P:System.ComponentModel.IBindingList.SortDirection"/>: If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then the value of the underlying property is returned; otherwise, returns <see cref="F:System.ComponentModel.ListSortDirection.Ascending"/>.</item>
            <item><see cref="M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)">Find</see>, <see cref="M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">ApplySort</see> and <see cref="M:System.ComponentModel.IBindingList.RemoveSort">RemoveSort</see>: If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then their
            underlying implementation is called; otherwise, they all throw <see cref="T:System.NotSupportedException"/>.</item>
            <item><see cref="M:System.ComponentModel.IBindingList.AddIndex(System.ComponentModel.PropertyDescriptor)">AddIndex</see> and <see cref="M:System.ComponentModel.IBindingList.RemoveIndex(System.ComponentModel.PropertyDescriptor)">RemoveIndex</see>: If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then their
            underlying implementation is called; otherwise, they do nothing.</item>
            </list>
            </description></item>
            <item><term><see cref="T:System.ComponentModel.ICancelAddNew"/></term><description>
            <list type="bullet">
            <item><see cref="M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)">EndNew</see>: If the underlying list implements <see cref="T:System.ComponentModel.ICancelAddNew"/>, then the underlying implementation is called; otherwise, commits the last pending new item added by
            the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.</item>
            <item><see cref="M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)">CancelNew</see>: If the underlying list implements <see cref="T:System.ComponentModel.ICancelAddNew"/>, then the underlying implementation is called; otherwise, discards the last pending new item added by
            the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.</item>
            </list>
            </description></item>
            <item><term><see cref="T:System.ComponentModel.IRaiseItemChangedEvents"/></term><description>Returns the value of the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents"/>, which is a settable property. See the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents"/> property for more details.</description></item>
            </list>
            </item>
            </list>
            </para>
            <para><strong><see cref="T:System.IDisposable"/> support</strong>:
            <br/>The <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> implements the <see cref="T:System.IDisposable"/> interface. When an instance is disposed, then both
            incoming and outgoing event subscriptions (self events and <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the elements) are removed. If the wrapped collection passed
            to the constructor is disposable, then it will also be disposed. After disposing accessing the public members may throw <see cref="T:System.ObjectDisposedException"/>.</para>
            </remarks>
        </member>
        <member name="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged">
            <summary>
            Occurs when the list or an item in the list changes.
            </summary>
            <remarks>
            <para>This event also occurs if the underlying collection that was passed to the constructor implements the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> or <see cref="T:System.ComponentModel.IBindingList"/> interfaces and an inner
            <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> or <see cref="E:System.ComponentModel.IBindingList.ListChanged"/> event is captured.</para>
            <para>Raising this event can be disabled and enabled by the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseListChangedEvents"/> property.</para>
            <para>Raising this event for item property changes can be disabled and enabled by the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents"/> property.</para>
            </remarks>
        </member>
        <member name="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged">
            <summary>
            Occurs when the list or an item in the list changes.
            </summary>
            <remarks>
            <para>This event also occurs if the underlying collection that was passed to the constructor implements the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> or <see cref="T:System.ComponentModel.IBindingList"/> interfaces and an inner
            <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> or <see cref="E:System.ComponentModel.IBindingList.ListChanged"/> event is captured.</para>
            <para>Raising this event can be disabled and enabled by the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseCollectionChangedEvents"/> property.</para>
            <note>In <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> this event can also be raised if a property of an element changed.
            <br/>In contrast, <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> does not raise this event in such case.
            <br/>Raising this event for item property changes can be disabled and enabled by the <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents"/> property.
            </note>
            </remarks>
        </member>
        <member name="E:KGySoft.ComponentModel.ObservableBindingList`1.PropertyChanged">
            <summary>
            Occurs when a property value changes. Occurs also when the elements in the list changes, in which case the value of the <see cref="P:System.ComponentModel.PropertyChangedEventArgs.PropertyName"/> will be <c>Item[]</c>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseItemChangedEvents">
            <summary>
            Gets or sets whether <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> events are invoked with
            <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/>/<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/> change type when a property of an item changes.
            <br/>If <typeparamref name="T"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then this property returns <see langword="false"/>.
            Otherwise, the default value is <see langword="true"/>.
            </summary>
            <remarks>
            <para>Setting this property to <see langword="false"/> can result in better performance if the underlying list has a poor lookup performance.
            <note>If the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> is initialized by its default constructor, then the element lookup has O(1) cost.</note>
            </para>
            <para>This property returns always <see langword="false"/> if <typeparamref name="T"/> does not implement the <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface.</para>
            <para><see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> is invoked only if <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseListChangedEvents"/> is <see langword="true"/>; and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> is raised only
            if <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseCollectionChangedEvents"/> is <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowNew">
            <summary>
            Gets or sets whether new items can be added to the list by the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.
            <br/>If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/> and its <see cref="P:System.ComponentModel.IBindingList.AllowNew"/> returns <see langword="false"/>, then this property returns also <see langword="false"/>.
            Otherwise, the default value is <see langword="true"/> if the wrapped list is not read-only and <typeparamref name="T"/> is a value type or has a parameterless constructor; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowEdit">
            <summary>
            Gets or sets whether item properties can be edited in the list.
            <br/>If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/> and its <see cref="P:System.ComponentModel.IBindingList.AllowEdit"/> returns <see langword="false"/>, then this property returns also <see langword="false"/>.
            Otherwise, the default value is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowRemove">
            <summary>
            Gets or sets whether items can be removed from the list by the <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Remove(`0)">Remove</see>, <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.RemoveAt(System.Int32)">RemoveAt</see> and <see cref="M:KGySoft.Collections.ObjectModel.VirtualCollection`1.Clear">Clear</see> methods.
            <br/>If the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/> and its <see cref="P:System.ComponentModel.IBindingList.AllowRemove"/> returns <see langword="false"/>, then this property returns also <see langword="false"/>.
            Otherwise, the default value is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseListChangedEvents">
            <summary>
            Gets or sets whether adding or removing items within the list raises <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> events.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.RaiseCollectionChangedEvents">
            <summary>
            Gets or sets whether adding or removing items within the list raises <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> events.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ObservableBindingList`1.PropertyDescriptors">
            <summary>
            Gets the property descriptors of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> class with a <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> internally.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> class with the specified <paramref name="list"/>.
            </summary>
            <param name="list">An <see cref="T:System.Collections.Generic.IList`1" /> of items to be contained in the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1" />.</param>
            <remarks>
            <para>The <paramref name="list"/> will be wrapped by the new <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> instance. Changes performed on the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> will be reflected in the
            wrapped <paramref name="list"/> as well.</para>
            <para>If the wrapped <paramref name="list"/> implements the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> or <see cref="T:System.ComponentModel.IBindingList"/> interface, then their <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> and
            <see cref="E:System.ComponentModel.IBindingList.ListChanged"/> events will be captured and raised as self <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> events.</para>
            <note type="tip">In an environment, which supports only the <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> interface but not the other, <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> can be used as a bridge between the two worlds.
            For example, by passing an <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> to the constructor, it will be able to be accessed as an <see cref="T:System.ComponentModel.IBindingList"/> implementation, and vice-versa: by wrapping an <see cref="T:System.ComponentModel.IBindingList"/> instance
            (such as <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> or <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>), it can be used as an <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> implementation by the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.Dispose">
            <summary>
            Releases the list and removes both incoming and outgoing subscriptions.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">
            <summary>
            Adds a new item to the collection.
            </summary>
            <returns>The item added to the list.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowNew"/> property returns <see langword="false"/>
            <br/>-or-
            <br/>The underlying collection could not add the new item, and <typeparamref name="T"/> is not a value type or has no parameterless constructor.</exception>
            <remarks>
            <para>If <see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowNew"/> returns <see langword="false"/>, then an <see cref="T:System.InvalidOperationException"/> will be thrown.</para>
            <para>Otherwise, if the underlying list implements <see cref="T:System.ComponentModel.IBindingList"/>, then its <see cref="M:System.ComponentModel.IBindingList.AddNew">AddNew</see> implementation will be called.</para>
            <para>Otherwise, if <typeparamref name="T"/> is a value type or has a parameterless constructor, then a new item of <typeparamref name="T"/> is created and added to the list.</para>
            <para>Otherwise, an <see cref="T:System.InvalidOperationException"/> will be thrown.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.CancelNew(System.Int32)">
            <summary>
            Discards a pending new item added by the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.
            </summary>
            <param name="itemIndex">The index of the item that was previously added to the collection.</param>
            <remarks>
            <para>If the underlying list implements <see cref="T:System.ComponentModel.ICancelAddNew"/>, then the underlying implementation is called; otherwise, discards the last pending new item added by
            the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.EndNew(System.Int32)">
            <summary>
            Commits a pending new item added by the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.
            </summary>
            <param name="itemIndex">The index of the item that was previously added to the collection.</param>
            <remarks>
            <para>If the underlying list implements <see cref="T:System.ComponentModel.ICancelAddNew"/>, then the underlying implementation is called; otherwise, commits the last pending new item added by
            the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.Move(System.Int32,System.Int32)">
            <summary>
            Moves the item at the specified index to a new location in the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/>.
            </summary>
            <param name="oldIndex">The zero-based index specifying the location of the item to be moved.</param>
            <param name="newIndex">The zero-based index specifying the new location of the item.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.ResetBindings">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset"/>
            and the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.ResetItem(System.Int32)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/>
            and the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>
            at the specified <paramref name="position"/>.
            </summary>
            <param name="position">A zero-based index of the item to be reset.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the <paramref name="item" /> at the specified <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
            <remarks>
            <para>After the item is set, <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/>
            and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/> are raised indicating the index of the item that was set.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1" /> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
            <remarks>
            <para><see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.InsertItem(System.Int32,`0)">InsertItem</see> performs the following operations:
            <list type="number">
            <item>Calls <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.EndNew(System.Int32)">EndNew</see> to commit the last possible uncommitted item added by the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.</item>
            <item>Inserts the item at the specified index.</item>
            <item>Raises a <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/>
            and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> indicating the index of the item that was inserted.</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.RemoveItem(System.Int32)">
            <summary>
            Removes the element at the specified <paramref name="index" /> from the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1" />.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.ComponentModel.ObservableBindingList`1.AllowRemove"/> is <see langword="false"/> and the item to remove is not an uncommitted one added by the <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.AddNew">AddNew</see> method.</exception>
            <remarks>
            <para>This method raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemDeleted"/>
            and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/>.
            </summary>
            <remarks>
            <para>This method raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset"/>
            and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.MoveItem(System.Int32,System.Int32)">
            <summary>
            Moves the item at the specified index to a new location in the <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/>.
            </summary>
            <param name="oldIndex">The zero-based index specifying the location of the item to be moved.</param>
            <param name="newIndex">The zero-based index specifying the new location of the item.</param>
            <remarks>
            <para>This method raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemMoved"/>
            and <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event of type <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.PropertyChanged" /> event.
            </summary>
            <param name="e">The <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> instance containing the event data.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> event.
            </summary>
            <param name="e">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> instance containing the event data.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Raises the <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged" /> event.
            </summary>
            <param name="e">The <see cref="T:System.ComponentModel.ListChangedEventArgs" /> instance containing the event data.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.BlockReentrancy">
            <summary>
            Disallows reentrant attempts to change this collection.
            </summary>
            <returns>An <see cref="T:System.IDisposable"/> instance that can be used to create a block of protected scope.</returns>
            <remarks>
            Typical usage is to wrap event invocations with a <see langword="using"/> scope:
            <code lang="C#">
            using (BlockReentrancy())
            {
                OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
            }
            </code>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ObservableBindingList`1.CheckReentrancy">
            <summary>
            Checks for reentrant attempts to change this collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The result of a previous <see cref="M:KGySoft.ComponentModel.ObservableBindingList`1.BlockReentrancy">BlockReentrancy</see> call was not disposed yet.
            Typically, this means there are additional attempts to change this collection during a <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.CollectionChanged"/> or <see cref="E:KGySoft.ComponentModel.ObservableBindingList`1.ListChanged"/> event.</exception>
        </member>
        <member name="T:KGySoft.ComponentModel.SortableBindingList`1">
            <summary>
            Provides a sortable generic list that is able to notify its consumer about changes and supports data binding.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <remarks>
            <note>Due to performance reasons the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class is derived from <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> and not from <see cref="T:System.ComponentModel.BindingList`1"/>.
            <br/>See also the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> class for the differences compared to the <see cref="T:System.ComponentModel.BindingList`1"/> class.</note>
            <para>The <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class provides a sortable view for the wrapped list specified in the constructor.</para>
            <para>To sort the list the <see cref="O:KGySoft.ComponentModel.FastBindingList`1.ApplySort">ApplySort</see> overloads can be used. As sorting is supported via the standard <see cref="T:System.ComponentModel.IBindingList"/> interface,
            binding a <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> instance to UI controls (eg. to a grid) enables sorting automatically in several GUI frameworks.</para>
            <note>Sorting does not change the order of the elements in the wrapped underlying collection. When items are added while <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/> returns <see langword="true"/>, then new items are added
            to the end of the underlying list.</note>
            <note type="warning">Do not store elements in a <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> that may change their hash code while they are added to the collection.
            Finding such elements may fail even if <see cref="P:KGySoft.Collections.ObjectModel.FastLookupCollection`1.CheckConsistency"/> is <see langword="true"/>. If hash code is derived from some identifier property or field, you can prepare
            a <typeparamref name="T"/> instance by overriding the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNewCore">AddNewCore</see> method or by subscribing the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.AddingNew"/> event
            to make <see cref="M:System.ComponentModel.IBindingList.AddNew">IBindingList.AddNew</see> implementation work properly.</note> 
            </remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.SortableBindingList`1.SortOnChange">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> should be immediately re-sorted when an item changes or a new item is added.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks><para>Setting this property to <see langword="true"/> may cause re-sorting the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> immediately.</para></remarks>
        </member>
        <member name="P:KGySoft.ComponentModel.SortableBindingList`1.SortDirection">
            <summary>
            Gets or sets the direction of the sort. Returns <see langword="null"/>, if the list is not sorted
            (that is, when <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/> returns <see langword="false"/>).
            Setting <see langword="null"/> removes sorting. To change also the <see cref="P:KGySoft.ComponentModel.FastBindingList`1.SortProperty"/>
            call the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)"/> method instead.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.SortableBindingList`1.SupportsSortingCore">
            <summary>
            Gets whether the list supports sorting.
            <br/>The <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.SortableBindingList`1.IsSortedCore">
            <summary>
            Gets whether the list is sorted.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.SortableBindingList`1.SortPropertyCore">
            <summary>
            Gets the property descriptor that is used for sorting the list if sorting, or <see langword="null"/> if the list is not sorted or
            when it is sorted by the values of <typeparamref name="T"/> rather than by one of its properties.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.SortableBindingList`1.SortDirectionCore">
            <summary>
            Gets the direction of the sort.
            <br/>If the list is not sorted (that is, when <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/> returns <see langword="false"/>), this property returns <see cref="F:System.ComponentModel.ListSortDirection.Ascending"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class with a <see cref="T:KGySoft.Collections.CircularList`1"/> internally.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class with the specified <paramref name="list"/>.
            </summary>
            <param name="list">An <see cref="T:System.Collections.Generic.IList`1" /> of items to be contained in the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1" />.</param>
            <remarks>
            <note>Do not wrap another <see cref="T:System.ComponentModel.IBindingList"/> or <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> as their events are not captured by the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> class.
            To capture and generate events for both wrapped and self list operations use <see cref="T:KGySoft.ComponentModel.ObservableBindingList`1"/> instead.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.InnerListChanged">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.CancelNew(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.EndNew(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> for the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>.</returns>
            <remarks>
            <para>If the list is sorted (that is, when <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/> returns <see langword="true"/>), then the items are returned in the sorted order. Otherwise, the items are returned
            in the order as they are stored in the wrapped underlying collection.</para>
            <note>If the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/> is sorted, or it was instantiated by the default constructor, then the returned enumerator supports
            the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method; otherwise, it depends on the enumerator of the wrapped collection.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            Sorts the items of the list.
            </summary>
            <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> that specifies the property to sort on. If <see langword="null" />, then the list will be sorted
            by the values of <typeparamref name="T" /> rather than one of its properties.</param>
            <param name="direction">The desired direction of the sort.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="direction"/> is not of the supported values.</exception>
            <remarks>
            <para>The sorting does not change the order of the items in the wrapped underlying collection.</para>
            <para>If <paramref name="property"/> is not <see langword="null"/>, then finding an item by the <see cref="O:KGySoft.ComponentModel.FastBindingList`1.Find">Find</see> overloads on the same property
            will be also faster.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.RemoveSortCore">
            <summary>
            Removes any sort applied by the <see cref="M:KGySoft.ComponentModel.SortableBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">ApplySortCore</see> method.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.FindCore(System.ComponentModel.PropertyDescriptor,System.Object)">
            <summary>
            Searches for the index of the item that has the specified property descriptor with the specified value.
            </summary>
            <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> that specifies the property to search for.</param>
            <param name="key">The value of <paramref name="property" /> to match.</param>
            <returns>The zero-based index of the item that matches the property descriptor and contains the specified value.</returns>
            <remarks>
            <para>If <paramref name="property"/> equals <see cref="P:KGySoft.ComponentModel.FastBindingList`1.SortProperty"/>, then a binary search is performed, in which case the cost of this method is O(log n) where n is the count of elements in the list.</para>
            <para>In any other cases a linear search is performed, in which case the cost of this method is O(n).</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.GetItemIndex(`0)">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.GetItem(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the <paramref name="item" /> at the specified <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
            <remarks>
            <para><see cref="M:KGySoft.ComponentModel.SortableBindingList`1.SetItem(System.Int32,`0)">SetItem</see> performs the following operations:
            <list type="number">
            <item>Raises a <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/> indicating the index of the item that was set.</item>
            <item>If both <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/> and <see cref="P:KGySoft.ComponentModel.SortableBindingList`1.SortOnChange"/> properties are <see langword="true"/> and the position of the new item would break the sort order, then a new sort is immediately applied,
            which raises a <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset"/>.</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1" /> at the specified <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
            <remarks>
            <para><see cref="M:KGySoft.ComponentModel.SortableBindingList`1.InsertItem(System.Int32,`0)">InsertItem</see> performs the following operations:
            <list type="number">
            <item>Calls <see cref="M:KGySoft.ComponentModel.SortableBindingList`1.EndNew(System.Int32)">EndNew</see> to commit the last possible uncommitted item added by the <see cref="M:KGySoft.ComponentModel.FastBindingList`1.AddNew">AddNew</see> method.</item>
            <item>Inserts the item at the specified index.</item>
            <item>Raises a <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemChanged"/> indicating the index of the item that was inserted.</item>
            <item>If both <see cref="P:KGySoft.ComponentModel.FastBindingList`1.IsSorted"/> and <see cref="P:KGySoft.ComponentModel.SortableBindingList`1.SortOnChange"/> properties are <see langword="true"/> and the position of the new item would break the sort order, then a new sort is immediately applied,
            which raises a <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset"/>.</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.RemoveItemAt(System.Int32)">
            <summary>
            Removes the element at the specified <paramref name="index" /> from the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1" />.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <remarks>
            <para>This method raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged"/> event of type <see cref="F:System.ComponentModel.ListChangedType.ItemDeleted"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.RemoveItem(`0)">
            <summary>
            Removes the first occurrence of <paramref name="item"/> from the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>.</param>
            <returns><see langword="true"/>, if an occurrence of <paramref name="item" /> was removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.ComponentModel.SortableBindingList`1"/>.
            </summary>
            <remarks>
            This method raises the <see cref="E:KGySoft.ComponentModel.FastBindingList`1.ListChanged" /> event of type <see cref="F:System.ComponentModel.ListChangedType.Reset" />.
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:KGySoft.ComponentModel.SortableBindingList`1.EndNew">
            <inheritdoc/>
        </member>
        <member name="T:KGySoft.ComponentModel.BindingListDisposeBehavior">
            <summary>
            Represents disposing strategy for the wrapped collection and elements when a <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> instance is disposed.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.BindingListDisposeBehavior.DisposeCollection">
            <summary>
            Indicates that the wrapped collection should be disposed if it implements the <see cref="T:System.IDisposable"/> interface.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.BindingListDisposeBehavior.DisposeCollectionAndItems">
            <summary>
            Indicates that the wrapped collection and the items should be disposed if they implement the <see cref="T:System.IDisposable"/> interface.
            Elements are never disposed when they are overwritten or removed, only when the parent <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> is disposed.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.BindingListDisposeBehavior.KeepAlive">
            <summary>
            Indicates that neither the wrapped collection nor the items should be disposed when the parent <see cref="T:KGySoft.ComponentModel.FastBindingList`1"/> is disposed,
            in which case only the event subscriptions are removed.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.CommandBinding.SubscriptionInfo`1">
            <summary>
            To provide a matching signature for any event handler.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.CommandBindingsCollection">
            <summary>
            Represents a collection of command bindings. If a component or control uses events, then this class can be used
            to create and hold the event bindings, regardless of any used technology. When this class is disposed, all of the
            internally subscribed events will be released at once. Removed and replaced bindings will also be disposed.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandBinding" />
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add(KGySoft.ComponentModel.ICommand,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Creates a binding for a <paramref name="command"/> without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <param name="command">The command to bind.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="disposeCommand"><see langword="true"/> to dispose the possibly disposable <paramref name="command"/> when the returned <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> is disposed; <see langword="false"/> to keep the <paramref name="command"/> alive when the returned <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> is disposed.
            Use <see langword="true"/> only if the command will not be re-used elsewhere. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the <paramref name="command"/> invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add(KGySoft.ComponentModel.ICommand,System.Object,System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Object[])">
            <summary>
            Creates a binding for a <paramref name="command"/> using the specified <paramref name="source"/>, <paramref name="eventName"/> and <paramref name="targets"/> as well as the optionally provided initial state of the binding.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <param name="command">The command to bind.</param>
            <param name="source">The source, which can trigger the command. Can be a <see cref="T:System.Type"/> for static events.</param>
            <param name="eventName">The name of the event on the <paramref name="source"/> that can trigger the command.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="targets">Zero or more targets for the binding.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/> and to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add(KGySoft.ComponentModel.ICommand,System.Object,System.String,System.Object[])">
            <summary>
            Creates a binding for a <paramref name="command"/> using the specified <paramref name="source"/>, <paramref name="eventName"/> and <paramref name="targets"/>.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <param name="command">The command to bind.</param>
            <param name="source">The source, which can trigger the command. Can be a <see cref="T:System.Type"/> for static events.</param>
            <param name="eventName">The name of the event on the <paramref name="source"/> that can trigger the command.</param>
            <param name="targets">Zero or more targets for the binding.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddPropertyBinding(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddPropertyBinding(System.Object,System.String,System.String,System.Func{System.Object,System.Object},System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="targets"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names and <paramref name="format"/>parameters.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddSynchronizedPropertyBinding(System.Object,System.String,System.String,System.Boolean,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            The target properties will be set using the <see cref="T:System.Threading.SynchronizationContext"/> of the thread on which this method was called.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="awaitCompletion"><see langword="true"/> to block the thread of the triggering event until setting a target property is completed; otherwise, <see langword="false"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddSynchronizedPropertyBinding(System.Object,System.String,System.String,System.Func{System.Object,System.Object},System.Boolean,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            The target properties will be set using the <see cref="T:System.Threading.SynchronizationContext"/> of the thread on which this method was called.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="targets"/>.</param>
            <param name="awaitCompletion"><see langword="true"/> to block the thread of the triggering event until setting a target property is completed; otherwise, <see langword="false"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names and <paramref name="format"/>parameters.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddTwoWayPropertyBinding(System.Object,System.String,System.Object,System.String,System.Func{System.Object,System.Object},System.Func{System.Object,System.Object})">
            <summary>
            Creates a pair of special bindings for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>
            and <paramref name="target"/>, which allow to update the specified <paramref name="targetPropertyName"/> and <paramref name="sourcePropertyName"/> in both directions when any of them changes.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the <paramref name="source"/> property, whose change is observed.</param>
            <param name="target">The target object, whose property specified by the <paramref name="targetPropertyName"/> parameter is observed.</param>
            <param name="targetPropertyName">The name of the <paramref name="target"/> property, whose change is observed. If <see langword="null"/>,
            then it is considered as the same as <paramref name="sourcePropertyName"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="target"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="parse">If not <see langword="null"/>, then can be used to parse the value to be set in the <paramref name="source"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The created <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instances that have been added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="target"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> or <paramref name="target"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddPropertyChangedHandlerBinding(System.ComponentModel.INotifyPropertyChanged,System.Action,System.String[])">
            <summary>
            Creates a special command binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>
            that invokes the specified <paramref name="handler"/> only when the changed property is among the specified <paramref name="propertyNames"/>.
            </summary>
            <param name="source">The source object, whose <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event is observed.</param>
            <param name="handler">The delegate to be invoked when the changed property is among the specified <paramref name="propertyNames"/>.</param>
            <param name="propertyNames">The property names, whose change invoke the specified <paramref name="handler"/>.</param>
            <returns>The created <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance that has been added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="propertyNames"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyNames"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.AddPropertyChangedHandlerBinding(System.ComponentModel.INotifyPropertyChanged,System.Action{System.String},System.String[])">
            <summary>
            Creates a special command binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>
            that invokes the specified <paramref name="handler"/> only when the changed property is among the specified <paramref name="propertyNames"/>.
            </summary>
            <param name="source">The source object, whose <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event is observed.</param>
            <param name="handler">The delegate to be invoked when the changed property is among the specified <paramref name="propertyNames"/>. Its parameter is the name of the changed property.</param>
            <param name="propertyNames">The property names, whose change invoke the specified <paramref name="handler"/>.</param>
            <returns>The created <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance that has been added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="propertyNames"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyNames"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add(System.Action{KGySoft.ComponentModel.ICommandState},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SimpleCommand"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add(System.Action,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SimpleCommand"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``1(System.Action{KGySoft.ComponentModel.ICommandState,``0},System.Func{``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SimpleCommand`1"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``1(System.Action{``0},System.Func{``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SimpleCommand`1"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``1(System.Action{KGySoft.ComponentModel.ICommandSource{``0},KGySoft.ComponentModel.ICommandState},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``1(System.Action{KGySoft.ComponentModel.ICommandSource{``0}},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``2(System.Action{KGySoft.ComponentModel.ICommandSource{``0},KGySoft.ComponentModel.ICommandState,``1},System.Func{``1},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`2"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``2(System.Action{KGySoft.ComponentModel.ICommandSource{``0},``1},System.Func{``1},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`2"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``1(System.Action{KGySoft.ComponentModel.ICommandState,``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.TargetedCommand`1"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``1(System.Action{``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.TargetedCommand`1"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``2(System.Action{KGySoft.ComponentModel.ICommandState,``0,``1},System.Func{``1},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.TargetedCommand`2"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``2(System.Action{``0,``1},System.Func{``1},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.TargetedCommand`2"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``2(System.Action{KGySoft.ComponentModel.ICommandSource{``0},KGySoft.ComponentModel.ICommandState,``1},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``2(System.Action{KGySoft.ComponentModel.ICommandSource{``0},``1},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``3(System.Action{KGySoft.ComponentModel.ICommandSource{``0},KGySoft.ComponentModel.ICommandState,``1,``2},System.Func{``2},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Add``3(System.Action{KGySoft.ComponentModel.ICommandSource{``0},``1,``2},System.Func{``2},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a binding with an internally created disposable <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3"/> for the specified <paramref name="callback"/>
            without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            The created binding will be added to this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <typeparam name="TTarget">The type of the targets of the command binding.</typeparam>
            <typeparam name="TEventArgs">The type of the event argument of the source events.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <param name="callback">The delegate to create the command from.</param>
            <param name="getParam">The delegate that returns the command parameter value for the <paramref name="callback"/> delegate when the command is executed.</param>
            <param name="initialState">The initial state of the binding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the command invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Dispose">
            <summary>
            Releases every binding in this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.InsertItem(System.Int32,KGySoft.ComponentModel.ICommandBinding)">
            <summary>
            Inserts a binding into the <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection" /> at the specified <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The binding to insert.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.SetItem(System.Int32,KGySoft.ComponentModel.ICommandBinding)">
            <summary>
            Replaces the binding at the specified index. The overridden binding will be disposed.
            </summary>
            <param name="index">The zero-based index of the binding to replace.</param>
            <param name="item">The binding to insert at the specified index.</param>
            <exception cref="T:System.ArgumentNullException">item</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.RemoveItemAt(System.Int32)">
            <summary>
            Removes the binding at the specified <paramref name="index"/> of the <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection" />.
            The removed binding will be disposed.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection" />.
            The removed bindings will be disposed.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandBindingsCollection.Dispose(System.Boolean)">
            <summary>
            Releases every binding in this <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to explicit disposing, <see langword="false"/> if finalizing the object.</param>
        </member>
        <member name="T:KGySoft.ComponentModel.CommandState">
            <summary>
            Represents the states of a command for a specific command binding.
            <br/>See the <see cref="T:KGySoft.ComponentModel.ICommandState"/> interface for details and the <strong>Remarks</strong> section of <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for some examples.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandState" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandStateUpdater" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandBinding" />
        </member>
        <member name="E:KGySoft.ComponentModel.CommandState.PropertyChanged">
            <summary>
            Occurs when a state entry value changes.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.CommandState.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:KGySoft.ComponentModel.CommandState" />.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.CommandState.Enabled">
            <summary>
            Gets or sets whether the command is enabled in the current binding.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <value><see langword="true"/> if the command enabled and can be executed; otherwise, <see langword="false" />.</value>
        </member>
        <member name="P:KGySoft.ComponentModel.CommandState.AsDynamic">
            <summary>
            Gets the state as a dynamic object so the states can be set by simple property setting syntax.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.CommandState.Item(System.String)">
            <summary>
            Gets or sets the state value with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key of the state value to get or set.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.CommandState"/> class from an initial configuration if provided.
            </summary>
            <param name="initialConfiguration">The initial configuration to use for initializing this <see cref="T:KGySoft.ComponentModel.CommandState"/> instance. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <exception cref="T:System.ArgumentException"><paramref name="initialConfiguration"/> contains a non-<see cref="T:System.Boolean">bool</see>&#160;<c>Enabled</c> entry.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.</returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.ContainsKey(System.String)">
            <summary>
            Determines whether the <see cref="T:KGySoft.ComponentModel.CommandState" /> contains an element with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key to locate in the <see cref="T:KGySoft.ComponentModel.CommandState" />.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.ComponentModel.CommandState" /> contains an element with the key; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.Add(System.String,System.Object)">
            <summary>
            Adds a state element with the provided key and value to the <see cref="T:KGySoft.ComponentModel.CommandState" />.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentException">An item with the same key has already been added</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.TryGetValue(System.String,System.Object@)">
            <summary>
            Gets the state element associated with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified <paramref name="key"/>, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/> if the <see cref="T:KGySoft.ComponentModel.CommandState"/> contains an element with the specified <paramref name="key"/>; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>
            Sets the <paramref name="value"/> of a state specified by the <see cref="P:System.Dynamic.SetMemberBinder.Name"/> property.
            </summary>
            <param name="binder">Provides information about the object that called the dynamic operation.</param>
            <param name="value">The value of the state to set.</param>
            <returns>This method always return <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.CommandState.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>
            Gets the state element associated with the specified <see cref="P:System.Dynamic.GetMemberBinder.Name"/>.
            </summary>
            <param name="binder">Provides information about the object that called the dynamic operation.</param>
            <param name="result">The value associated with the specified <see cref="P:System.Dynamic.GetMemberBinder.Name"/>.</param>
            <returns>This method always return <see langword="true"/>.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.NullStateUpdater">
            <summary>
            Provides an updater, which does not synchronize command state changes to any command source.
            Adding this updater to a <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> ensures that no other updater will be called, which are added after the <see cref="T:KGySoft.ComponentModel.NullStateUpdater"/>.
            You can add this updater to a <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> first to disable any other possibly added updater.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.ICommandStateUpdater" />
        </member>
        <member name="P:KGySoft.ComponentModel.NullStateUpdater.Updater">
            <summary>
            Gets a <see cref="T:KGySoft.ComponentModel.NullStateUpdater"/> instance.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.PropertyCommandStateUpdater">
            <summary>
            Provides an updater for the <see cref="T:KGySoft.ComponentModel.ICommandState"/> entries, which treats state entries as properties on the command sources.
            When a state entry in the <see cref="T:KGySoft.ComponentModel.ICommandState"/> changes, this updater tries to set the properties of the same name on the bound sources.
            For example, if a command represents a UI action bound to a menu item or a button (or both), then changing the <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/>
            property changes the <c>Enabled</c> property of the bound sources as well. You can adjust the text, shortcuts, associated image, checked state, etc. of
            the sources similarly.
            </summary>
            <remarks>
            <para>A state updater can be added to a binding by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater,System.Boolean)">ICommandBinding.AddStateUpdater</see> method.</para>
            <para>If a state entry does not represent an existing property on a source, there will no error occur.</para>
            <para>The updater considers both <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> properties and reflection instance properties.</para>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.ICommandStateUpdater" />
        </member>
        <member name="P:KGySoft.ComponentModel.PropertyCommandStateUpdater.Updater">
            <summary>
            Gets the <see cref="T:KGySoft.ComponentModel.PropertyCommandStateUpdater"/> instance.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.SimpleCommand">
            <summary>
            Represents a non-parameterized command, which is unaware of its triggering sources and has no bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <seealso cref="T:KGySoft.ComponentModel.ICommand"/>
            <seealso cref="T:KGySoft.ComponentModel.SimpleCommand`1"/>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand.#ctor(System.Action{KGySoft.ComponentModel.ICommandState})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SimpleCommand"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SimpleCommand"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.SimpleCommand`1">
            <summary>
            Represents a parameterized command, which is unaware of its triggering sources and has no bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand"/>
            <seealso cref="T:KGySoft.ComponentModel.SimpleCommand"/>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand`1.#ctor(System.Action{KGySoft.ComponentModel.ICommandState,`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SimpleCommand`1"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand`1.#ctor(System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SimpleCommand`1"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand`1.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SimpleCommand`1.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.SourceAwareCommand`1">
            <summary>
            Represents a non-parameterized command, which is aware of its triggering sources and has no bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TEventArgs">The type of the event arguments of the triggering event.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand"/>
            <seealso cref="T:KGySoft.ComponentModel.SourceAwareCommand`2"/>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`1.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},KGySoft.ComponentModel.ICommandState})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`1.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`1.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`1.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.SourceAwareCommand`2">
            <summary>
            Represents a parameterized command, which is aware of its triggering sources and has no bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TEventArgs">The type of the event arguments of the triggering event.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`2.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},KGySoft.ComponentModel.ICommandState,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`2"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`2.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`2"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`2.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareCommand`2.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2">
            <summary>
            Represents a non-parameterized command, which is aware of its triggering sources and has one or more bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TEventArgs">The type of the event arguments of the triggering event.</typeparam>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand"/>
            <seealso cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3"/>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`2.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},KGySoft.ComponentModel.ICommandState,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`2.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`2.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`2.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3">
            <summary>
            Represents a parameterized command, which is aware of its triggering sources and has one or more bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TEventArgs">The type of the event arguments of the triggering event.</typeparam>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`3.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},KGySoft.ComponentModel.ICommandState,`1,`2})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`3.#ctor(System.Action{KGySoft.ComponentModel.ICommandSource{`0},`1,`2})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`3.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.SourceAwareTargetedCommand`3.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.TargetedCommand`1">
            <summary>
            Represents a non-parameterized command, which is unaware of its triggering sources and has one or more bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand"/>
            <seealso cref="T:KGySoft.ComponentModel.TargetedCommand`2"/>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`1.#ctor(System.Action{KGySoft.ComponentModel.ICommandState,`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.TargetedCommand`1"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`1.#ctor(System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.TargetedCommand`1"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`1.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`1.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.TargetedCommand`2">
            <summary>
            Represents parameterized a command, which is unaware of its triggering sources and has one or more bound targets.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <typeparam name="TParam">The type of the command parameter.</typeparam>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.TargetedCommand`1"/>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`2.#ctor(System.Action{KGySoft.ComponentModel.ICommandState,`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.TargetedCommand`2"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`2.#ctor(System.Action{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.ComponentModel.TargetedCommand`2"/> class.
            </summary>
            <param name="callback">A delegate to invoke when the command is triggered.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`2.Dispose">
            <summary>
            Releases the delegate passed to the constructor. Should be called if the callback is an instance method, which holds references to other objects.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.TargetedCommand`2.ToString">
            <summary>Returns a string that represents the current command.</summary>
            <returns>A string that represents the current command.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.CommandBindingErrorContext">
            <summary>
            Represents the context of the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Error">ICommandBinding.Error</see> event.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.CommandBindingErrorContext.CommandExecute">
            <summary>
            Indicates that the error occurred while invoking the <see cref="M:KGySoft.ComponentModel.ICommand.Execute(KGySoft.ComponentModel.ICommandSource,KGySoft.ComponentModel.ICommandState,System.Object,System.Object)">ICommand.Execute</see> method.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.CommandBindingErrorContext.ExecutingEvent">
            <summary>
            Indicates that the error occurred while invoking the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Executing">ICommandBinding.Executing</see> event.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.CommandBindingErrorContext.ExecutedEvent">
            <summary>
            Indicates that the error occurred while invoking the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Executed">ICommandBinding.Executed</see> event.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.CommandBindingErrorContext.EvaluateParameter">
            <summary>
            Indicates that the error occurred while invoking the delegate specified in
            the <see cref="M:KGySoft.ComponentModel.ICommandBinding.WithParameter(System.Func{System.Object})">ICommandBinding.WithParameter</see> method.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.CommandBindingErrorContext.EvaluateTarget">
            <summary>
            Indicates that the error occurred while invoking the delegate specified in
            the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see> method.
            </summary>
        </member>
        <member name="F:KGySoft.ComponentModel.CommandBindingErrorContext.UpdateState">
            <summary>
            Indicates that the error occurred while updating the command source by
            the <see cref="M:KGySoft.ComponentModel.ICommandStateUpdater.TryUpdateState(System.Object,System.String,System.Object)">ICommandStateUpdater.TryUpdateState</see> method.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.CommandBindingErrorEventArgs">
            <summary>
            Provides data for the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Error">ICommandBinding.Error</see> event.
            </summary>
            <seealso cref="T:System.ComponentModel.HandledEventArgs" />
        </member>
        <member name="P:KGySoft.ComponentModel.CommandBindingErrorEventArgs.Context">
            <summary>
            Gets the context of the error.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.CommandBindingErrorEventArgs.Error">
            <summary>
            Gets the <see cref="T:System.Exception"/> occurred while attempting to execute the binding.
            You can set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            suppress the error. Critical exceptions (<see cref="T:System.OutOfMemoryException"/>, <see cref="T:System.StackOverflowException"/>)
            cannot be handled by the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Error">ICommandBinding.Error</see> event.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ExecuteCommandEventArgs">
            <summary>
            Provides data for the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Executing">ICommandBinding.Executing</see>
            and <see cref="E:KGySoft.ComponentModel.ICommandBinding.Executed">ICommandBinding.Executed</see> events.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ExecuteCommandEventArgs.Source">
            <summary>
            Gets the triggering source of the <see cref="T:KGySoft.ComponentModel.ICommand"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ExecuteCommandEventArgs.State">
            <summary>
            Gets the state of the <see cref="T:KGySoft.ComponentModel.ICommand"/>. Setting the <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/> property
            from the <see cref="E:KGySoft.ComponentModel.ICommandBinding.Executing"/> event affects the actual execution.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.Command">
            <summary>
            Contains extension methods for the <see cref="T:KGySoft.ComponentModel.ICommand"/> and <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> types as well as a couple of property binding creation methods for any object.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateBinding(KGySoft.ComponentModel.ICommand,System.Object,System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Object[])">
            <summary>
            Creates a binding for a <paramref name="command"/> using the specified <paramref name="source"/>, <paramref name="eventName"/> and <paramref name="targets"/> as well as the optionally provided initial state of the binding.
            </summary>
            <param name="command">The command to bind.</param>
            <param name="source">The source, which can trigger the command. Can be a <see cref="T:System.Type"/> for static events.</param>
            <param name="eventName">The name of the event on the <paramref name="source"/> that can trigger the command.</param>
            <param name="initialState">The initial state of the binding.</param>
            <param name="targets">Zero or more targets for the binding.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/> and to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateBinding(KGySoft.ComponentModel.ICommand,System.Object,System.String,System.Object[])">
            <summary>
            Creates a binding for a <paramref name="command"/> using the specified <paramref name="source"/>, <paramref name="eventName"/> and <paramref name="targets"/>.
            </summary>
            <param name="command">The command to bind.</param>
            <param name="source">The source, which can trigger the command. Can be a <see cref="T:System.Type"/> for static events.</param>
            <param name="eventName">The name of the event on the <paramref name="source"/> that can trigger the command.</param>
            <param name="targets">Zero or more targets for the binding.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateBinding(KGySoft.ComponentModel.ICommand,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Creates a binding for a <paramref name="command"/> without any sources and targets. At least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">ICommandBinding.AddSource</see> method to make the command invokable.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">ICommandBinding.AddTarget</see> method.
            </summary>
            <param name="command">The command to bind.</param>
            <param name="initialState">The initial state of the binding.</param>
            <param name="disposeCommand"><see langword="true"/> to dispose the possibly disposable <paramref name="command"/> when the returned <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> is disposed; <see langword="false"/> to keep the <paramref name="command"/> alive when the returned <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> is disposed.
            Use <see langword="true"/> only if the command will not be re-used elsewhere. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, whose <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> is initialized by the provided <paramref name="initialState"/>.
            To make the <paramref name="command"/> invokable by this binding, at least one source must be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">AddSource</see> method on the result.
            Targets can be added by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">AddTarget</see> method on the result.
            </returns>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreatePropertyBinding(System.ComponentModel.INotifyPropertyChanged,System.String,System.String,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreatePropertyBinding(System.ComponentModel.INotifyPropertyChanged,System.String,System.String,System.Func{System.Object,System.Object},System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="targets"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names and <paramref name="format"/>parameters.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreatePropertyBinding(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreatePropertyBinding(System.Object,System.String,System.String,System.Func{System.Object,System.Object},System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="targets"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names and <paramref name="format"/>parameters.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateSynchronizedPropertyBinding(System.ComponentModel.INotifyPropertyChanged,System.String,System.String,System.Boolean,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            The target properties will be set using the <see cref="T:System.Threading.SynchronizationContext"/> of the thread on which this method was called.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="awaitCompletion"><see langword="true"/> to block the thread of the triggering event until setting a target property is completed; otherwise, <see langword="false"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateSynchronizedPropertyBinding(System.ComponentModel.INotifyPropertyChanged,System.String,System.String,System.Func{System.Object,System.Object},System.Boolean,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            The target properties will be set using the <see cref="T:System.Threading.SynchronizationContext"/> of the thread on which this method was called.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="targets"/>.</param>
            <param name="awaitCompletion"><see langword="true"/> to block the thread of the triggering event until setting a target property is completed; otherwise, <see langword="false"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names and <paramref name="format"/>parameters.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateSynchronizedPropertyBinding(System.Object,System.String,System.String,System.Boolean,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            The target properties will be set using the <see cref="T:System.Threading.SynchronizationContext"/> of the thread on which this method was called.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="awaitCompletion"><see langword="true"/> to block the thread of the triggering event until setting a target property is completed; otherwise, <see langword="false"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateSynchronizedPropertyBinding(System.Object,System.String,System.String,System.Func{System.Object,System.Object},System.Boolean,System.Object[])">
            <summary>
            Creates a special binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>, which allows to update the
            specified <paramref name="targetPropertyName"/> in the <paramref name="targets"/>, when the property of <paramref name="sourcePropertyName"/> changes in the <paramref name="source"/>.
            The target properties will be set using the <see cref="T:System.Threading.SynchronizationContext"/> of the thread on which this method was called.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the property, whose change is observed.</param>
            <param name="targetPropertyName">The name of the property in the target object(s).</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="targets"/>.</param>
            <param name="awaitCompletion"><see langword="true"/> to block the thread of the triggering event until setting a target property is completed; otherwise, <see langword="false"/>.</param>
            <param name="targets">The targets to be updated. If the concrete instances to update have to be returned when the change occurs use the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">ICommandBinding.AddTarget</see>
            method on the result <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</param>
            <returns>An <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance, to which the specified <paramref name="source"/> and <paramref name="targets"/> are bound.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="targetPropertyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
            <remarks>
            <para>This method uses a prepared command internally, which is bound to the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/> object.
            Or, when <paramref name="source"/> does not implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, then an event of name <paramref name="sourcePropertyName"/> postfixed by <c>Changed</c> should exist on the <paramref name="source"/> object.</para>
            <para>The <see cref="T:KGySoft.ComponentModel.ICommandState"/>, which is created for the underlying command contains the specified property names and <paramref name="format"/>parameters.
            Do not remove these state entries; otherwise, the command will throw an <see cref="T:System.InvalidOperationException"/> when executed.</para>
            <para>The property with <paramref name="targetPropertyName"/> will be set in the specified <paramref name="targets"/> immediately when this method is called.
            The targets, which are added later by the <see cref="O:KGySoft.ComponentModel.ICommandBinding.AddTarget">ICommandBinding.AddTarget</see> methods, are set only when the
            <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event occurs on the <paramref name="source"/> object.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateTwoWayPropertyBinding(System.ComponentModel.INotifyPropertyChanged,System.String,System.ComponentModel.INotifyPropertyChanged,System.String,System.Func{System.Object,System.Object},System.Func{System.Object,System.Object})">
            <summary>
            Creates a pair of special bindings for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>
            and <paramref name="target"/>, which allow to update the specified <paramref name="targetPropertyName"/> and <paramref name="sourcePropertyName"/> in both directions when any of them changes.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the <paramref name="source"/> property, whose change is observed.</param>
            <param name="target">The target object, whose property specified by the <paramref name="targetPropertyName"/> parameter is observed.</param>
            <param name="targetPropertyName">The name of the <paramref name="target"/> property, whose change is observed. If <see langword="null"/>,
            then it is considered as the same as <paramref name="sourcePropertyName"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="target"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="parse">If not <see langword="null"/>, then can be used to parse the value to be set in the <paramref name="source"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The created pair of <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instances.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="target"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> or <paramref name="target"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreateTwoWayPropertyBinding(System.Object,System.String,System.Object,System.String,System.Func{System.Object,System.Object},System.Func{System.Object,System.Object})">
            <summary>
            Creates a pair of special bindings for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> or <c><paramref name="sourcePropertyName"/>Changed</c> event of the specified <paramref name="source"/>
            and <paramref name="target"/>, which allow to update the specified <paramref name="targetPropertyName"/> and <paramref name="sourcePropertyName"/> in both directions when any of them changes.
            </summary>
            <param name="source">The source object, whose property specified by the <paramref name="sourcePropertyName"/> parameter is observed.</param>
            <param name="sourcePropertyName">The name of the <paramref name="source"/> property, whose change is observed.</param>
            <param name="target">The target object, whose property specified by the <paramref name="targetPropertyName"/> parameter is observed.</param>
            <param name="targetPropertyName">The name of the <paramref name="target"/> property, whose change is observed. If <see langword="null"/>,
            then it is considered as the same as <paramref name="sourcePropertyName"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="format">If not <see langword="null"/>, then can be used to format the value to be set in the <paramref name="target"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="parse">If not <see langword="null"/>, then can be used to parse the value to be set in the <paramref name="source"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The created pair of <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instances.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/>, <paramref name="sourcePropertyName"/> or <paramref name="target"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> or <paramref name="target"/> is neither an <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> implementation nor has a <c><paramref name="sourcePropertyName"/>Changed</c> event.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreatePropertyChangedHandlerBinding(System.ComponentModel.INotifyPropertyChanged,System.Action,System.String[])">
            <summary>
            Creates a special command binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>
            that invokes the specified <paramref name="handler"/> only when the changed property is among the specified <paramref name="propertyNames"/>.
            </summary>
            <param name="source">The source object, whose <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event is observed.</param>
            <param name="handler">The delegate to be invoked when the changed property is among the specified <paramref name="propertyNames"/>.</param>
            <param name="propertyNames">The property names, whose change invoke the specified <paramref name="handler"/>.</param>
            <returns>The created <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="propertyNames"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyNames"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.ComponentModel.Command.CreatePropertyChangedHandlerBinding(System.ComponentModel.INotifyPropertyChanged,System.Action{System.String},System.String[])">
            <summary>
            Creates a special command binding for the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event of the specified <paramref name="source"/>
            that invokes the specified <paramref name="handler"/> only when the changed property is among the specified <paramref name="propertyNames"/>.
            </summary>
            <param name="source">The source object, whose <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event is observed.</param>
            <param name="handler">The delegate to be invoked when the changed property is among the specified <paramref name="propertyNames"/>. Its parameter is the name of the changed property.</param>
            <param name="propertyNames">The property names, whose change invoke the specified <paramref name="handler"/>.</param>
            <returns>The created <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="propertyNames"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="propertyNames"/> is empty.</exception>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommand">
             <summary>
             Represents a command, which can be used to create a binding between an event of one or more sources and zero or more target objects. Can be used easily to bind
             events with targets with any technology.
             </summary>
             <remarks>
             <para>Unlike the <see cref="T:System.Windows.Input.ICommand">System.Windows.Input.ICommand</see> type, this <see cref="T:KGySoft.ComponentModel.ICommand"/> represents a stateless
             command so the implementations are best to be accessed via static members. The command states (such as <c>Enabled</c> or any other status) belong to
             the created binding represented by the <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> interface and can be accessed by the <see cref="P:KGySoft.ComponentModel.ICommandBinding.State">ICommandBinding.State</see> property,
             which returns an <see cref="T:KGySoft.ComponentModel.ICommandState"/> instance.</para>
             <para>To implement a command by using a delegate you can also choose one of the four pairs of predefined classes: <see cref="T:KGySoft.ComponentModel.SimpleCommand"/>/<see cref="T:KGySoft.ComponentModel.SimpleCommand`1"/>,
             <see cref="T:KGySoft.ComponentModel.TargetedCommand`1"/>/<see cref="T:KGySoft.ComponentModel.TargetedCommand`2"/>, <see cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/>/<see cref="T:KGySoft.ComponentModel.SourceAwareCommand`2"/>
             and <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/>/<see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`3"/> depending whether the command is parameterized,
             targets specific objects and behaves differently based on the source's state or event arguments.</para>
             <para>A binding can be created by the <see cref="O:KGySoft.ComponentModel.Command.CreateBinding">Commands.CreateBinding</see> methods or by the <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/> class.
             When a binding or a collection of bindings are disposed all of the event subscriptions are released, which makes the cleanup really simple.</para>
             <example>
             <note type="tip"><list type="bullet">
             <item>Try also <a href="https://dotnetfiddle.net/7b0lFq" target="_blank">online</a>.</item>
             <item>For a more detailed step-by-step guide see the <strong>Command Binding</strong> section at
             the <a href="https://kgysoft.net/corelibraries#command-binding" target="_blank">Project Site</a>.</item>
             </list></note>
             <para>The following examples demonstrate how to define different kind of commands:
             <code lang="C#"><![CDATA[
             public static partial class MyCommands
             {
                 // A simple command with no target and ignored source: (assumes we have an ExitCode state)
                 public static ICommand CloseApplicationCommand =>
                     new SimpleCommand(state => Environment.Exit((int)state["ExitCode"])); // or: .Exit(state.AsDynamic.ExitCode)
             
                 // A source aware command, which can access the source object and the triggering event data
                 public static ICommand LogMouseCommand =>
                     new SourceAwareCommand<MouseEventArgs>(source => Debug.WriteLine($"Mouse coordinates: {source.EventArgs.X}; {source.EventArgs.Y}"));
             
                 // A targeted command (also demonstrates how to change the command state of another command):
                 public static ICommand ToggleCommandEnabled =>
                     new TargetedCommand<ICommandState>((state, targetState) => targetState.Enabled = !targetState.Enabled);
             
                 // A source aware targeted command:
                 public static ICommand ProcessKeysCommand => new SourceAwareTargetedCommand<KeyEventArgs, Control>(OnProcessKeysCommand);
             
                 private static void OnProcessKeysCommand(ICommandSource<KeyEventArgs> source, Control target)
                 {
                     // do something with target by source.EventArgs
                 }
             }]]></code></para>
             <para>And a binding for a command can be created in an application, with any kind of UI, which uses events, or even without any UI: only event sources are needed.
             <code lang="C#"><![CDATA[
             public class MyView : SomeViewBaseWithEvents // base can be a Window in WPF or a Form in WindowsForms or simply any component with events.
             {
                 private ICommandBinding exitBinding;
             
                 private CommandBindingsCollection commandBindings = new CommandBindingsCollection();
             
                 public MyView()
                 {
                     // ...some initialization of our View...
             
                     // Simplest case: using the CreateBinding extension on ICommand.
                     // Below we assume we have a menu item with a Click event.
                     // We set also the initial status. By adding the property state updater the
                     // states will be applied on the source as properties.
                     exitBinding = MyCommands.CloseApplicationCommand.CreateBinding(
                         new Dictionary<string, object>
                         {
                             { "Text", "Exit Application" },
                             { "ShortcutKeys", Keys.Alt | Keys.F4 },
                             { "ExitCode", 0 },
                         })
                        .AddStateUpdater(PropertyCommandStateUpdater.Updater)
                        .AddSource(menuItemExit, "Click");
             
                     // If we add the created bindings to a CommandBindingsCollection, then all of them can be disposed at once by disposing the collection.
                     commandBindings.Add(exitBinding);
             
                     // We can create a binding by the Add methods of the collection, too:
                     // As we added the property state updater to the exitBinding the menuItemExit.Enabled property will reflect the command state.
                     var toggleEnabledBinding = commandBindings.Add(MyCommands.ToggleCommandEnabledCommand, buttonToggle, "Click", exitBinding.State);
             
                     // The line above can be written by a more descriptive fluent syntax (and that's how multiple sources can be added):
                     var toggleEnabledBinding = commandBindings.Add(MyCommands.ToggleCommandEnabledCommand)
                         .AddSource(buttonToggle, nameof(Button.Click))
                         .AddTarget(exitBinding.State);
             
                     // If we set the state of a binding with a property updater it will be applied for all sources (only if a matching property exists):
                     exitBinding.State["Text"] = "A new text for the exit command";
             
                     // Or as dynamic:
                     toggleEnabledBinding.State.AsDynamic.Text = "A new text for the exit command";
                 }
             
                 protected override Dispose(bool disposing)
                 {
                      // disposing a CommandBindingsCollection will release all of the internal event subscriptions at once
                     if (disposing)
                         commandBindings.Dispose();
             
                     base.Dispose(disposing);
                 }
             }]]></code></para>
             <para>
             Commands can also have parameter, which is evaluated whenever the command is triggered:
             <code lang="C#"><![CDATA[
             // A parameterized and targeted command:
             public static ICommand SetBackColorCommand =>
                 new TargetedCommand<Control, Color>((target, value) => target.BackColor = value);
            
             // [...]
             
             // The parameter is evaluated only once whenever the command is triggered but SetBackColorCommand
             // will be invoked three times (once for each target) with the same parameter value.
             // It is recommended to specify the parameter callback before adding any sources to avoid the possible
             // issues if there is any chance that the source can be triggered before completing the initialization.
             commandBindings.Add(MyCommands.SetBackColorCommand)
                 .WithParameter(() => GetSomeColor(myViewModel.Severity)) // specifying a callback to return a parameter value
                 .AddSource(myViewModel, nameof(myViewModel.SeverityChanged)) // whatever source event
                 .AddTarget(this)
                 .AddTarget(panelInfo) // now multiple targets will be set by the same parameter
                 .AddTarget(buttonDoSomething);]]></code></para>
             </example>
             </remarks>
             <seealso cref="T:KGySoft.ComponentModel.ICommandBinding"/>
             <seealso cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/>
             <seealso cref="T:KGySoft.ComponentModel.ICommandState"/>
             <seealso cref="T:KGySoft.ComponentModel.SimpleCommand"/>
             <seealso cref="T:KGySoft.ComponentModel.TargetedCommand`1"/>
             <seealso cref="T:KGySoft.ComponentModel.SourceAwareCommand`1"/>
             <seealso cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommand.Execute(KGySoft.ComponentModel.ICommandSource,KGySoft.ComponentModel.ICommandState,System.Object,System.Object)">
            <summary>
            Executes the command invoked by the specified <paramref name="source"/> for the specified <paramref name="target"/>.
            </summary>
            <param name="source">An <see cref="T:KGySoft.ComponentModel.ICommandSource"/> object containing information about the source of the command.</param>
            <param name="state">An <see cref="T:KGySoft.ComponentModel.ICommandState"/> instance containing the state of the current command binding. The state can be changed during the execution.</param>
            <param name="target">The target of the execution. Can be <see langword="null"/> if the binding has no targets.
            If the command binding has multiple targets the <see cref="M:KGySoft.ComponentModel.ICommand.Execute(KGySoft.ComponentModel.ICommandSource,KGySoft.ComponentModel.ICommandState,System.Object,System.Object)">Execute</see> method will be invoked multiple times.</param>
            <param name="parameter">The parameter of the command. Can be <see langword="null"/> if the binding has no parameter.
            Evaluated once per triggering the command. Even if the binding has multiple targets the <see cref="M:KGySoft.ComponentModel.ICommand.Execute(KGySoft.ComponentModel.ICommandSource,KGySoft.ComponentModel.ICommandState,System.Object,System.Object)">Execute</see> method
            is invoked with the same <paramref name="parameter"/> value for each target.</param>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommandBinding">
            <summary>
            Represents a binding for a command.
            </summary>
            <remarks>
            <para>Whereas an <see cref="T:KGySoft.ComponentModel.ICommand"/> is a static logic without state, the created binding is a dynamic entity: it has a state,
            which can store variable elements (see <see cref="T:KGySoft.ComponentModel.ICommandState"/>), and has sources and targets, which can be added and removed
            during the lifetime of the binding.</para>
            <para>The binding should be disposed when it is not used anymore so it releases the events it used internally. If more bindings are used it is recommended
            to create them by a <see cref="T:KGySoft.ComponentModel.CommandBindingsCollection"/> instance so when it is disposed it releases all of the added bindings at once.</para>
            <note type="tip">See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.</note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandState" />
            <seealso cref="T:KGySoft.ComponentModel.CommandBindingsCollection" />
        </member>
        <member name="E:KGySoft.ComponentModel.ICommandBinding.Executing">
            <summary>
            Occurs when the associated <see cref="T:KGySoft.ComponentModel.ICommand"/> is about to be executed.
            Command states, including the <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/> state still can be adjusted here.
            </summary>
        </member>
        <member name="E:KGySoft.ComponentModel.ICommandBinding.Executed">
            <summary>
            Occurs when the associated <see cref="T:KGySoft.ComponentModel.ICommand"/> has been executed.
            </summary>
        </member>
        <member name="E:KGySoft.ComponentModel.ICommandBinding.Error">
            <summary>
            Occurs when an exception is thrown during the command execution.
            The <see cref="P:KGySoft.ComponentModel.CommandBindingErrorEventArgs.Error"/> property returns the <see cref="T:System.Exception"/>,
            which is about to be thrown, and the <see cref="P:KGySoft.ComponentModel.CommandBindingErrorEventArgs.Context"/> property gets a hint about
            the source of the error. You can set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            suppress the error, but critical exceptions (<see cref="T:System.OutOfMemoryException"/>, <see cref="T:System.StackOverflowException"/>) cannot be handled by this event.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandBinding.State">
            <summary>
            Gets the managed set of states of this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance. Whenever a new source is added or an entry of
            the returned <see cref="T:KGySoft.ComponentModel.ICommandState"/> is changed, and at least one <see cref="T:KGySoft.ComponentModel.ICommandStateUpdater"/> is added to this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/>,
            then the entries are applied for all of the sources of the binding.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommandState"/> interface for details.
            </summary>
            <value>
            An <see cref="T:KGySoft.ComponentModel.ICommandState"/> instance that represents the managed states of the binding. Can be also used as a dynamic object
            to set and get state entries as properties.
            </value>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandBinding.Sources">
            <summary>
            Gets a copy of the sources of this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> along with the bound event names.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandBinding.Targets">
            <summary>
            Gets a copy of the targets of this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandBinding.StateUpdaters">
            <summary>
            Gets a copy of the state updaters of this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/>.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandBinding.IsDisposed">
            <summary>
            Gets whether this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance is disposed.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.AddSource(System.Object,System.String)">
            <summary>
            Adds a source to this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance. For static events pass a <see cref="T:System.Type"/> as <paramref name="source"/>.
            If state updaters were added to the binding by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater,System.Boolean)">AddStateUpdater</see> method, then the <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> entries will be applied to the new source.
            At least one source has to be added to the binding to be able to invoke the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/>.
            </summary>
            <param name="source">The new source to add. Can be a <see cref="T:System.Type"/> for static events.</param>
            <param name="eventName">The name of the event on the source, which will trigger the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/>.</param>
            <returns>This <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance to provide fluent initialization.</returns>
            <seealso cref="T:KGySoft.ComponentModel.ICommand"/>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Object)">
            <summary>
            Adds the target to this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance. The underlying <see cref="T:KGySoft.ComponentModel.ICommand"/> will be invoked for each added target.
            If no targets are added the command will be invoked with a <see langword="null"/> target.
            </summary>
            <param name="target">The target of the command to add. If the command is a <see cref="T:KGySoft.ComponentModel.TargetedCommand`1"/> or <see cref="T:KGySoft.ComponentModel.SourceAwareTargetedCommand`2"/>,
            then the type of <paramref name="target"/> must match <em>TTarget</em>.</param>
            <returns>This <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance to provide fluent initialization.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.AddTarget(System.Func{System.Object})">
            <summary>
            Adds a target getter function to this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance. Whenever the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/> executes it will evaluate the specified getter delegate.
            </summary>
            <param name="getTarget">A function, which returns the target when the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/> is executed.</param>
            <returns>This <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance to provide fluent initialization.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.AddStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater,System.Boolean)">
            <summary>
            Adds a state updater to the binding. If at least one updater is added, then changing the entries of the <see cref="P:KGySoft.ComponentModel.ICommandBinding.State"/> property will be applied on all added sources.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommandStateUpdater"/> interface for details.
            </summary>
            <param name="updater">The updater to add.</param>
            <param name="updateSources"><see langword="true"/> to update the sources immediately; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>This <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance to provide fluent initialization.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.WithParameter(System.Func{System.Object})">
            <summary>
            Specifies a callback to obtain the command parameter value for the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/>.
            It is evaluated once whenever a source event is triggered. If this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> has multiple targets,
            the <see cref="M:KGySoft.ComponentModel.ICommand.Execute(KGySoft.ComponentModel.ICommandSource,KGySoft.ComponentModel.ICommandState,System.Object,System.Object)">ICommand.Execute</see> method is invoked with the same parameter value for each target.
            </summary>
            <param name="getParameterValue">A function, which returns the parameter value before the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/> is executed.</param>
            <returns>This <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance to provide fluent initialization.</returns>
            <remarks>
            <note>Calling the <see cref="M:KGySoft.ComponentModel.ICommandBinding.WithParameter(System.Func{System.Object})">WithParameter</see> method multiple times on the same <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance
            just overwrites the lastly set callback function. To use more parameter values the function should return a compound type such as an array or tuple.</note>
            <note type="tip">It is recommended to specify the parameter callback before adding any sources to avoid the possible
            issues if there is any chance that the source can be triggered before completing the initialization.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.RemoveSource(System.Object)">
            <summary>
            Removes the specified <paramref name="source"/> from this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance. The used events of the removed source will be released.
            </summary>
            <param name="source">The source to remove.</param>
            <returns><see langword="true"/>, if the source was successfully removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.RemoveTarget(System.Object)">
            <summary>
            Removes the specified <paramref name="target"/> from this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/> instance.
            </summary>
            <param name="target">The target to remove.</param>
            <returns><see langword="true"/>, if the target was successfully removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.RemoveStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater)">
            <summary>
            Removes the specified state updater. The removed updater will not be disposed.
            </summary>
            <param name="updater">The updater to remove.</param>
            <returns><see langword="true"/>, if the updater was successfully removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandBinding.InvokeCommand(System.Object,System.String,System.EventArgs,System.Object)">
            <summary>
            Invokes the underlying <see cref="T:KGySoft.ComponentModel.ICommand"/> for all of the added targets using the specified source, event name, event arguments and parameters.
            </summary>
            <param name="source">The source. It is not checked whether the source is actually added to this <see cref="T:KGySoft.ComponentModel.ICommandBinding"/>. Can be a <see cref="T:System.Type"/> for static events.</param>
            <param name="eventName">Name of the event. It is not checked whether this is en existing event.</param>
            <param name="eventArgs">The <see cref="T:System.EventArgs"/> instance containing the event data.</param>
            <param name="parameter">The parameter value to be passed to the invoked command. A possible previous <see cref="M:KGySoft.ComponentModel.ICommandBinding.WithParameter(System.Func{System.Object})">WithParameter</see> call
            is ignored when calling this method. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommandSource">
            <summary>
            Represents source information about the command.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandSource.Source">
            <summary>
            Gets the source of the invocation, which is the object that triggered the event.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandSource.TriggeringEvent">
            <summary>
            Gets the triggering event of the source object.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandSource.EventArgs">
            <summary>
            Gets the <see cref="T:System.EventArgs"/> instance containing the event data.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommandSource`1">
            <summary>
            Represents source information about the command.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.
            </summary>
            <typeparam name="TEventArgs">The type of the event arguments of the source event.</typeparam>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandSource`1.EventArgs">
            <summary>
            Gets a <typeparamref name="TEventArgs"/> instance containing the event data.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommandState">
            <summary>
            Represents the states of a command for a specific command binding. When a state value is set (eg. <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/>) it can be applied for all of the
            command sources. By default, no application occurs but this can be overridden if an <see cref="T:KGySoft.ComponentModel.ICommandStateUpdater"/> is added to the binding by the
            <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater,System.Boolean)">ICommandBinding.AddStateUpdater</see> method.
            For example, if the command sources are UI elements (eg. a button and a menu item), then the <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/>
            or any arbitrary state (eg. text, image, shortcut, etc.) can be applied to the sources as properties.
            </summary>
            <remarks>
            <para>The <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/> state, which is also predefined as a property, has a special function. By setting the <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/> property
            the execution of the command can be disabled or enabled.</para>
            <para>If a binding has no updaters, then the states are not synchronized back to the sources.</para>
            <para>A state updater can be added to a binding by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater,System.Boolean)">ICommandBinding.AddStateUpdater</see> method.
            Multiple updaters can be added so if the first one cannot apply a state entry, then the second one will be used as a fallback and so on.</para>
            <para>If state entries represent properties on the source you can add the <see cref="T:KGySoft.ComponentModel.PropertyCommandStateUpdater"/> to the <see cref="T:KGySoft.ComponentModel.ICommandBinding"/>
            so changing the <c>Enabled</c>, <c>Text</c>, <c>Image</c>, <c>Shortcut</c>, etc. state entries will change the same properties on the command sources as well.</para>
            <note type="tip">See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.</note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandStateUpdater" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandBinding" />
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandState.Enabled">
            <summary>
            Gets or sets whether the command is enabled in the current binding.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <value><see langword="true"/> if the command enabled and can be executed; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="P:KGySoft.ComponentModel.ICommandState.AsDynamic">
            <summary>
            Gets the state as a dynamic object so the states can be set by simple property setting syntax.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommandStateUpdater">
            <summary>
            Represents an updater for the <see cref="T:KGySoft.ComponentModel.ICommandState"/> entries that apply the state values on the command source instances.
            For example, if the command source is a UI element such as a button or menu item, then the <see cref="P:KGySoft.ComponentModel.ICommandState.Enabled"/> property
            or any arbitrary state (eg. text, image, shortcut, etc.) can be applied to the sources.
            </summary>
            <remarks>
            <para>If a binding has no updaters, then the states are not synchronized back to the sources.</para>
            <para>A state updater can be added to a binding by the <see cref="M:KGySoft.ComponentModel.ICommandBinding.AddStateUpdater(KGySoft.ComponentModel.ICommandStateUpdater,System.Boolean)">ICommandBinding.AddStateUpdater</see> method.
            Multiple updaters can be added so if the first one cannot apply a state entry, then the second one will be used as a fallback and so on.</para>
            <para>If state entries represent properties on the source use can add the <see cref="T:KGySoft.ComponentModel.PropertyCommandStateUpdater"/> to the <see cref="T:KGySoft.ComponentModel.ICommandBinding"/>.</para>
            <para>If you want to seal the falling back logic of the updaters you can use the <see cref="T:KGySoft.ComponentModel.NullStateUpdater"/> after the last updater you want to allow to work.
            If the <see cref="T:KGySoft.ComponentModel.NullStateUpdater"/> is the first added updater, then synchronization of the states will be completely disabled even if other updaters are chained.</para>
            <note type="tip">See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples about commands.</note>
            </remarks>
            <seealso cref="T:KGySoft.ComponentModel.ICommand" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandState" />
            <seealso cref="T:KGySoft.ComponentModel.ICommandBinding" />
        </member>
        <member name="M:KGySoft.ComponentModel.ICommandStateUpdater.TryUpdateState(System.Object,System.String,System.Object)">
            <summary>
            Tries to apply the specified state on the command source. If returns <see langword="false"/>, then the possible chained other updaters can
            try to update the state.
            </summary>
            <param name="commandSource">The command source, whose state should be applied.</param>
            <param name="stateName">Name of the state. The default updater handles it as a property on the <paramref name="commandSource"/>.</param>
            <param name="value">The new value of the state to be applied.</param>
            <returns><see langword="true"/> if the state was applied successfully; <see langword="false"/> if other possibly chained updaters or the
            default updater can try to apply the new state.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.ICommand`1">
            <summary>
            This interface exists just because in <see cref="T:KGySoft.ComponentModel.CommandBinding"/> we already create a strongly typed delegate for EventArgs
            so we can re-use this strongly typed nature in source aware commands.
            </summary>
            <typeparam name="TEventArgs">The type of the event arguments.</typeparam>
        </member>
        <member name="T:KGySoft.ComponentModel.BinaryTypeConverter">
            <summary>
            Provides a type converter to convert any <see cref="T:System.Object"/> to and from base64 encoded <see cref="T:System.String"/> or <see cref="T:System.Array">byte array</see> representations.
            </summary>
            <seealso cref="T:System.ComponentModel.TypeConverter" />
        </member>
        <member name="M:KGySoft.ComponentModel.BinaryTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type, using the specified context.
            </summary>
            <param name="context">In this type converter this parameter is ignored.</param>
            <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Array">byte[]</see> types.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.BinaryTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name="context">In this type converter this parameter is ignored.</param>
            <param name="sourceType">A <see cref="T:System.Type" /> that represents the type you want to convert from.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Array">byte[]</see> types.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.BinaryTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Object" /> to convert.</param>
            <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Array">byte[]</see> types.</param>
            <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.BinaryTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to its original type.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">The <see cref="T:System.Globalization.CultureInfo" /> to use as the current culture. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Object"/> to convert.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Array">byte[]</see> types.</param>
            <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.EncodingConverter">
            <summary>
            Provides a type converter to convert <see cref="T:System.Text.Encoding"/> instances to and from <see cref="T:System.String"/> or <see cref="T:System.Int32"/> representations.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.EncodingConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Int32"/> types.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.EncodingConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Text.Encoding" /> instance to convert.</param>
            <param name="destinationType">The <see cref="T:System.Type" /> to convert the <paramref name="value" /> parameter to.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Int32"/> types.</param>
            <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.EncodingConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="sourceType">A <see cref="T:System.Type" /> that represents the type you want to convert from.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Int32"/> types.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.EncodingConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Object" /> to convert.
            This type converter supports <see cref="T:System.String"/> and <see cref="T:System.Int32"/> types.</param>
            <returns>An <see cref="T:System.Text.Encoding" /> instance that represents the converted value.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.EncodingConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Returns whether this object supports a standard set of values that can be picked from a list, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <returns>This method always returns <see langword="true" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.EncodingConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Returns a collection of standard values for the data type this type converter is designed for when provided with a format context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <returns>A <see cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection" /> that holds a standard set of valid values.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.FlagsEnumConverter">
            <summary>
            By extending the <see cref="T:System.ComponentModel.EnumConverter"/>, this class provides a type converter for flags <see cref="T:System.Enum"/> instances (not necessarily but typically marked by <see cref="T:System.FlagsAttribute"/>) by providing <see cref="T:System.Boolean"/> properties for each flags in the specific <see cref="T:System.Enum"/> type.
            </summary>
        </member>
        <member name="T:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor">
            <summary>
            Represents an enumeration flag as a <see cref="T:System.Boolean"/> property.
            </summary>
        </member>
        <member name="P:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.Attributes">
            <summary>
            Gets the collection of attributes for this member.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.#ctor(System.Type,System.String,System.UInt64,System.UInt64,System.Reflection.FieldInfo,System.Attribute[],System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Creates an instance of the enumeration field descriptor class.
            </summary>
            <param name="componentType">The type of the enumeration.</param>
            <param name="name">The name of the <see langword="enum"/> flag field.</param>
            <param name="flagValue">The value of the <see langword="enum"/> flag.</param>
            <param name="context">The current context or <see langword="null"/> if no context exists.</param>
            <param name="defaultValue">The default value of the <see langword="enum"/> instance specified by the <see cref="T:System.ComponentModel.DefaultValueAttribute"/> of its property or <see langword="null"/>.</param>
            <param name="valueField">The underlying value field of the <see langword="enum"/> type.</param>
            <param name="attributes">Custom attributes of the <see langword="enum"/> flag field.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.GetValue(System.Object)">
            <summary>
            Retrieves the value of the <see cref="T:System.Enum"/> flag.
            </summary>
            <param name="component">The <see cref="T:System.Enum"/> instance to retrieve the flag value for.</param>
            <returns><see langword="true"/> if the enumeration field is included to the enumeration; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value of the <see cref="T:System.Enum"/> flag.
            </summary>
            <param name="component">The <see cref="T:System.Enum"/> instance whose flag is about to be set.</param>
            <param name="value">The <see cref="T:System.Boolean"/> value of the flag to set.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.ShouldSerializeValue(System.Object)">
            <summary>
            Returns whether the value of this property can persist.
            </summary>
            <param name="component">The <see cref="T:System.Enum"/> instance with the property that is to be examined for persistence.</param>
            <returns><see langword="true"/> if the value of the property can persist; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.ResetValue(System.Object)">
            <summary>
            Resets the value for this property of the component.
            </summary>
            <param name="component">The <see cref="T:System.Enum"/> instance with the property value to be reset.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.CanResetValue(System.Object)">
            <summary>
            Returns whether resetting the component changes the value of the component.
            </summary>
            <param name="component">The <see cref="T:System.Enum"/> instance to test for reset capability.</param>
            <returns><see langword="true"/> if resetting the component changes the value of the component; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.EnumFlagDescriptor.GetDefaultValue">
            <summary>
            Retrieves the default value of the <see langword="enum"/> flag.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.#ctor(System.Type)">
            <summary>
            Creates an instance of the <see cref="T:KGySoft.ComponentModel.FlagsEnumConverter"/> class.
            </summary>
            <param name="type">The type of the enumeration.</param>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])">
            <summary>
            Retrieves the property descriptors for the enumeration fields.
            These property descriptors will be used by the property grid
            to show separate enumeration fields.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. If specified, will be used to determine the <see cref="T:System.ComponentModel.DefaultValueAttribute"/> of
            the converted <see langword="enum"/>, and to set the <see langword="enum"/> property of the container instance if one of the flags are set.</param>
            <param name="value">The <see cref="T:System.Enum" /> instance to get the flags for.</param>
            <param name="attributes">An array of type <see cref="T:System.Attribute"/> that is used as a filter. In this method this parameter is ignored.</param>
            <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> with the flags of the <see cref="T:System.Enum"/> type designated by <paramref name="value"/> as <see cref="T:System.Boolean"/> properties.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Returns whether this object supports properties, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this method this parameter is ignored.</param>
            <returns>This method always returns <see langword="true" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.FlagsEnumConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Gets whether this object supports a standard set of values that can be picked from a list using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this method this parameter is ignored.</param>
            <returns>This method always returns <see langword="false" />.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.StringSegmentConverter">
            <summary>
            Provides a type converter to convert <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances to and from <see cref="T:System.String">string</see>.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.StringSegmentConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.StringSegmentConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment" /> instance to convert.</param>
            <param name="destinationType">The <see cref="T:System.Type" /> to convert the <paramref name="value" /> parameter to.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.StringSegmentConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="sourceType">A <see cref="T:System.Type" /> that represents the type you want to convert from.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.StringSegmentConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Object" /> to convert.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment" /> instance that represents the converted value.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.VersionConverter">
            <summary>
            Provides a type converter to convert <see cref="T:System.Version"/> instances to and from their <see cref="T:System.String"/> representation.
            </summary>
        </member>
        <member name="M:KGySoft.ComponentModel.VersionConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.VersionConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Version" /> instance to convert.</param>
            <param name="destinationType">The <see cref="T:System.Type" /> to convert the <paramref name="value" /> parameter to.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.VersionConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="sourceType">A <see cref="T:System.Type" /> that represents the type you want to convert from.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns><see langword="true"/> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.ComponentModel.VersionConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. In this converter this parameter is ignored.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. In this converter this parameter is ignored.</param>
            <param name="value">The <see cref="T:System.Object" /> to convert.
            This type converter supports <see cref="T:System.String"/> type only.</param>
            <returns>A <see cref="T:System.Version" /> instance that represents the converted value.</returns>
        </member>
        <member name="T:KGySoft.ComponentModel.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.ComponentModel"/> namespace contains <see cref="T:System.ComponentModel.TypeConverter"/> implementations for several types as well
            as base classes for different kind of business object models (such as the <see cref="T:KGySoft.ComponentModel.ModelBase"/> class), and types for command binding,
            which provide a technology-agnostic approach for binding events to commands (see <see cref="T:KGySoft.ComponentModel.ICommand"/> interface for details and examples).
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.Enum`1">
            <summary>
            Generic helper class for the <see cref="T:System.Enum"/> class. Provides high performance solutions
            for already existing functionality in the <see cref="T:System.Enum"/> class along with some additional features.
            </summary>
            <typeparam name="TEnum">The type of the enumeration. Must be an <see cref="T:System.Enum"/> type.</typeparam>
            <remarks>
            <note type="tip">Try also <a href="https://dotnetfiddle.net/xNTnLE" target="_blank">online</a>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetValues">
            <summary>
            Retrieves the array of the values of the constants in enumeration <typeparamref name="TEnum"/>.
            </summary>
            <returns>An array of the values of the constants in <typeparamref name="TEnum"/>.
            The elements of the array are sorted by the binary values of the enumeration constants.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetNames">
            <summary>
            Retrieves the array of the values of the constants in enumeration <typeparamref name="TEnum"/>.
            </summary>
            <returns>An array of the values of the constants in <typeparamref name="TEnum"/>.
            The elements of the array are in the same order as in case of the result of the <see cref="M:KGySoft.CoreLibraries.Enum`1.GetValues">GetValues</see> method.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetName(`0)">
            <summary>
            Retrieves the name of the constant in the specified enumeration that has the specified <paramref name="value"/>.
            </summary>
            <param name="value">The <see langword="enum"/> value whose name is required.</param>
            <returns>A string containing the name of the enumerated <paramref name="value"/>, or <see langword="null"/> if no such constant is found.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetName(System.Int64)">
            <summary>
            Retrieves the name of the constant in the specified enumeration that has the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value of the required field.</param>
            <returns>A string containing the name of the enumerated <paramref name="value"/>, or <see langword="null"/> if no such constant is found.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetName(System.UInt64)">
            <summary>
            Retrieves the name of the constant in the specified enumeration that has the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value of the required field.</param>
            <returns>A string containing the name of the enumerated <paramref name="value"/>, or <see langword="null"/> if no such constant is found.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsDefined(`0)">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a defined field that equals <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsDefined(System.String)">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value representing a field name in the enumeration.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a defined field whose name equals <paramref name="value"/> (search is case-sensitive); otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsDefined(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> value representing a field name in the enumeration.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a defined field whose name equals <paramref name="value"/> (search is case-sensitive); otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsDefined(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value representing a field name in the enumeration.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a defined field whose name equals <paramref name="value"/> (search is case-sensitive); otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsDefined(System.Int64)">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/> as a field value.
            </summary>
            <param name="value">A numeric value representing a field value in the enumeration.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a field whose value that equals <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsDefined(System.UInt64)">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/> as a field value.
            </summary>
            <param name="value">A numeric value representing a field value in the enumeration.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a field whose value that equals <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrDefault(`0,`0)">
            <summary>
            Returns <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns><paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrDefault(System.String,`0)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined. The search is case-sensitive.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value representing a field name in the enumeration.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrDefault(KGySoft.CoreLibraries.StringSegment,`0)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined. The search is case-sensitive.
            </summary>
            <param name="value">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> value representing a field name in the enumeration.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrDefault(System.ReadOnlySpan{System.Char},`0)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined. The search is case-sensitive.
            </summary>
            <param name="value">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value representing a field name in the enumeration.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrDefault(System.Int64,`0)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in the enumeration;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined.
            </summary>
            <param name="value">A numeric value representing a field value in the enumeration.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrDefault(System.UInt64,`0)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in the enumeration;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined.
            </summary>
            <param name="value">A numeric value representing a field value in the enumeration.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrNull(`0)">
            <summary>
            Returns <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>; otherwise, returns <see langword="null"/>.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value.</param>
            <returns><paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrNull(System.String)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <see langword="null"/>. The search is case-sensitive.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value representing a field name in the enumeration.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <see langword="null"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrNull(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <see langword="null"/>. The search is case-sensitive.
            </summary>
            <param name="value">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> value representing a field name in the enumeration.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <see langword="null"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrNull(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <see langword="null"/>. The search is case-sensitive.
            </summary>
            <param name="value">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value representing a field name in the enumeration.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrNull(System.Int64)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <see langword="null"/>.
            </summary>
            <param name="value">A numeric value representing a field value in the enumeration.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetDefinedOrNull(System.UInt64)">
            <summary>
            Returns the <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <see langword="null"/>.
            </summary>
            <param name="value">A numeric value representing a field value in the enumeration.</param>
            <returns>The <typeparamref name="TEnum"/> value associated with <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.HasFlag(`0,`0)">
            <summary>
            Gets whether the bits that are set in the <paramref name="flags"/> parameter are set in the specified <paramref name="value"/>.
            </summary>
            <param name="value">An enumeration value of <typeparamref name="TEnum"/> type.</param>
            <param name="flags">A flags <see langword="enum"/> value, whose flags should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/> and whether all bits that are set are defined in the <typeparamref name="TEnum"/> type.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is zero, or when the bits that are set in <paramref name="flags"/> are set in <paramref name="value"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.HasFlag(`0,System.Int64)">
            <summary>
            Gets whether the bits that are set in the <paramref name="flags"/> parameter are set in the specified <paramref name="value"/>.
            </summary>
            <param name="value">An enumeration value of <typeparamref name="TEnum"/> type.</param>
            <param name="flags">An integer value, whose flags should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/> and whether all bits that are set are defined in the <typeparamref name="TEnum"/> type.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is zero, or when the bits that are set in <paramref name="flags"/> are set in <paramref name="value"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.HasFlag(`0,System.UInt64)">
            <summary>
            Gets whether the bits that are set in the <paramref name="flags"/> parameter are set in the specified <paramref name="value"/>.
            </summary>
            <param name="value">An enumeration value of <typeparamref name="TEnum"/> type.</param>
            <param name="flags">An unsigned integer value, whose flags should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/> and whether all bits that are set are defined in the <typeparamref name="TEnum"/> type.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is zero, or when the bits that are set in <paramref name="flags"/> are set in <paramref name="value"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsSingleFlag(`0)">
            <summary>
            Gets whether only a single bit is set in <paramref name="value"/>. It is not checked, whether this flag is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if only a single bit is set in <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsSingleFlag(System.Int64)">
            <summary>
            Gets whether only a single bit is set in <paramref name="value"/>. It is not checked, whether this flag is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if <paramref name="value"/> falls into the range of <typeparamref name="TEnum"/> range
            and only a single bit is set in <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.IsSingleFlag(System.UInt64)">
            <summary>
            Gets whether only a single bit is set in <paramref name="value"/>. It is not checked, whether this flag is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if <paramref name="value"/> falls into the range of <typeparamref name="TEnum"/> range
            and only a single bit is set in <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetFlagsCount(`0)">
            <summary>
            Gets the number of bits set in <paramref name="value"/>.
            It is not checked, whether all flags are defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns>The number of bits set in <paramref name="value"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetFlagsCount(System.Int64)">
            <summary>
            Gets the number of bits set in <paramref name="value"/> or <c>-1</c> if <paramref name="value"/> does not fall into the range of <typeparamref name="TEnum"/>.
            It is not checked, whether all flags are defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns>The number of bits set in <paramref name="value"/>, or <c>-1</c> if <paramref name="value"/> does not fall into the range of <typeparamref name="TEnum"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetFlagsCount(System.UInt64)">
            <summary>
            Gets the number of bits set in <paramref name="value"/> or <c>-1</c> if <paramref name="value"/> does not fall into the range of <typeparamref name="TEnum"/>.
            It is not checked, whether all flags are defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns>The number of bits set in <paramref name="value"/>, or <c>-1</c> if <paramref name="value"/> does not fall into the range of <typeparamref name="TEnum"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.AllFlagsDefined(`0)">
            <summary>
            Gets whether every single bit value in <paramref name="flags"/> are defined in the <typeparamref name="TEnum"/> type,
            or, when <paramref name="flags"/> is zero, it is checked whether zero is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="flags">A flags <see langword="enum"/> value, whose bits should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/>.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is a zero value and zero is defined,
            or if <paramref name="flags"/> is nonzero and its every bit has a defined name.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.AllFlagsDefined(System.Int64)">
            <summary>
            Gets whether every single bit value in <paramref name="flags"/> are defined in the <typeparamref name="TEnum"/> type,
            or, when <paramref name="flags"/> is zero, it is checked whether zero is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="flags">An integer value, whose bits should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/>.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is a zero value and zero is defined,
            or if <paramref name="flags"/> is nonzero and its every bit has a defined name.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.AllFlagsDefined(System.UInt64)">
            <summary>
            Gets whether every single bit value in <paramref name="flags"/> are defined in the <typeparamref name="TEnum"/> type,
            or, when <paramref name="flags"/> is zero, it is checked whether zero is defined in <typeparamref name="TEnum"/>.
            </summary>
            <param name="flags">An unsigned integer value, whose bits should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/>.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is a zero value and zero is defined,
            or if <paramref name="flags"/> is nonzero and its every bit has a defined name.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetFlagsMask">
            <summary>
            Gets a <typeparamref name="TEnum"/> value where all defined single flag values are set. 
            </summary>
            <returns>A <typeparamref name="TEnum"/> value where all defined single flag values are set. </returns>
            <remarks>
            <para>Flag values are the ones whose binary representation contains only a single bit.</para>
            <para>It is not checked whether <typeparamref name="TEnum"/> is really marked by <see cref="T:System.FlagsAttribute"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetFlags">
            <summary>
            Gets the defined flags in <typeparamref name="TEnum"/>, where each flags are returned as distinct values.
            </summary>
            <returns>A lazy-enumerated <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance containing each flags of <typeparamref name="TEnum"/> as distinct values.</returns>
            <remarks>
            <para>Flag values are the ones whose binary representation contains only a single bit.</para>
            <para>It is not checked whether <typeparamref name="TEnum"/> is really marked by <see cref="T:System.FlagsAttribute"/>.</para>
            <para>Flags with the same values but different names are returned only once.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.GetFlags(`0,System.Boolean)">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> enumeration of <paramref name="flags"/>,
            where each flags are returned as distinct values.
            </summary>
            <param name="flags">A flags <see langword="enum"/> value, whose flags should be returned. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/>.</param>
            <param name="onlyDefinedValues"><see langword="true"/> to return only flags that are defined in <typeparamref name="TEnum"/>;
            <see langword="false"/> to return also undefined flags. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A lazy-enumerated <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance containing each flags of <paramref name="flags"/> as distinct values.</returns>
            <remarks>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.ClearCaches">
            <summary>
            Clears caches associated with <typeparamref name="TEnum"/> enumeration.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.ToString(`0,KGySoft.CoreLibraries.EnumFormattingOptions,System.String)">
            <summary>
            Returns the <see cref="T:System.String"/> representation of the given <see langword="enum"/> value specified in the <paramref name="value"/> parameter.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value that has to be converted to <see cref="T:System.String"/>.</param>
            <param name="format">The formatting options.</param>
            <param name="separator">Separator in case of flags formatting. If <see langword="null"/> or is empty, then comma-space (<c>, </c>) separator is used. This parameter is optional.
            <br/>Default value: <c>, </c>.</param>
            <returns>The string representation of <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="format"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.ToString(`0)">
            <summary>
            Returns the <see cref="T:System.String"/> representation of the given <see langword="enum"/> value specified in the <paramref name="value"/> parameter.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value that has to be converted to <see cref="T:System.String"/>.</param>
            <returns>The string representation of <paramref name="value"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.ToString(`0,System.String)">
            <summary>
            Returns the <see cref="T:System.String"/> representation of the given <see langword="enum"/> value specified in the <paramref name="value"/> parameter.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value that has to be converted to <see cref="T:System.String"/>.</param>
            <param name="separator">Separator in case of flags formatting. If <see langword="null"/> or is empty, then comma-space (<c>, </c>) separator is used.</param>
            <returns>The string representation of <paramref name="value"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryFormat(`0,System.Span{System.Char},System.Int32@,KGySoft.CoreLibraries.EnumFormattingOptions,System.ReadOnlySpan{System.Char})">
            <summary>
            Tries to format the <paramref name="value"/> of the current <typeparamref name="TEnum"/> instance into the provided span of characters.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value to be formatted.</param>
            <param name="destination">The target span of characters of the formatted value.</param>
            <param name="charsWritten">When this method returns, the number of characters that were written in <paramref name="destination"/>.</param>
            <param name="format">The formatting options. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.EnumFormattingOptions.Auto"/>.</param>
            <param name="separator">A span containing the separator in case of flags formatting. If empty, then comma-space (<c>, </c>) separator is used. This parameter is optional.
            <br/>Default value: <see cref="P:System.Span`1.Empty"><![CDATA[Span<char>.Empty]]></see>.</param>
            <returns><see langword="true"/>, if the formatting was successful; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryFormat(`0,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char})">
            <summary>
            Tries to format the <paramref name="value"/> of the current <typeparamref name="TEnum"/> instance
            into the provided span of characters using <see cref="F:KGySoft.CoreLibraries.EnumFormattingOptions.Auto"/> formatting options.
            </summary>
            <param name="value">A <typeparamref name="TEnum"/> value to be formatted.</param>
            <param name="destination">The target span of characters of the formatted value.</param>
            <param name="charsWritten">When this method returns, the number of characters that were written in <paramref name="destination"/>.</param>
            <param name="separator">A span containing the separator in case of flags formatting. If empty, then comma-space (<c>, </c>) separator is used.</param>
            <returns><see langword="true"/>, if the formatting was successful; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.String,System.String,System.Boolean,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The <see cref="T:System.String">string</see> representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specifies the separator among the values. If <see langword="null"/> or is empty, then comma (<c>,</c>) separator is used.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.String">string</see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.String,System.Boolean,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The <see cref="T:System.String">string</see> representation of the enumerated value or values to parse.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.String">string</see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.String,System.String,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The <see cref="T:System.String">string</see> representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specifies the separator among the values. If <see langword="null"/> or is empty, then comma (<c>,</c>) separator is used.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.String">string</see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.String,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The <see cref="T:System.String">string</see> representation of the enumerated value or values to parse.</param>
            <param name="result"><see langword="null"/> if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.String">string</see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.Parse(System.String,System.String,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            </summary>
            <param name="value">The <see cref="T:System.String">string</see> representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specified the separator among the values. If <see langword="null"/> or is empty, then comma (<c>,</c>) separator is used. This parameter is optional.
            <br/>Default value: <c>,</c></param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The parsed <see langword="enum"/> value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be parsed as <typeparamref name="TEnum"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.Parse(System.String,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            </summary>
            <param name="value">The <see cref="T:System.String">string</see> representation of the enumerated value or values to parse.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <returns>The parsed <see langword="enum"/> value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be parsed as <typeparamref name="TEnum"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment,System.Boolean,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specifies the separator among the values. If <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/> or <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, then comma (<c>,</c>) separator is used.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(KGySoft.CoreLibraries.StringSegment,System.Boolean,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specifies the separator among the values. If <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/> or <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, then comma (<c>,</c>) separator is used.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(KGySoft.CoreLibraries.StringSegment,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.Parse(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specified the separator among the values. If <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/> or <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, then comma (<c>,</c>) separator is used. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The parsed <see langword="enum"/> value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be parsed as <typeparamref name="TEnum"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.Parse(KGySoft.CoreLibraries.StringSegment,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <returns>The parsed <see langword="enum"/> value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see cref="F:KGySoft.CoreLibraries.StringSegment.Null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be parsed as <typeparamref name="TEnum"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Boolean,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specifies the separator among the values. If empty, then comma (<c>,</c>) separator is used.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.ReadOnlySpan{System.Char},System.Boolean,`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specifies the separator among the values. If empty, then comma (<c>,</c>) separator is used.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.TryParse(System.ReadOnlySpan{System.Char},`0@)">
            <summary>
            Tries to convert the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            In case of success the return value is <see langword="true"/> and parsed <see langword="enum"/> is returned in <paramref name="result"/> parameter.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="result">Returns the default value of <typeparamref name="TEnum"/>, if return value is <see langword="false"/>; otherwise, the parsed <see langword="enum"/> value.</param>
            <returns><see langword="false"/> if the <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> in <paramref name="value"/> parameter cannot be parsed as <typeparamref name="TEnum"/>; otherwise, <see langword="true"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.Parse(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="separator">In case of more values specified the separator among the values. If empty, then comma (<c>,</c>) separator is used. This parameter is optional.
            <br/>Default value: <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see></param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The parsed <see langword="enum"/> value.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be parsed as <typeparamref name="TEnum"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Enum`1.Parse(System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more enumerated values to an equivalent enumerated object.
            </summary>
            <param name="value">The string representation of the enumerated value or values to parse.</param>
            <param name="ignoreCase">If <see langword="true"/>, ignores case; otherwise, regards case.</param>
            <returns>The parsed <see langword="enum"/> value.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be parsed as <typeparamref name="TEnum"/>.</exception>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumComparer`1">
            <summary>
            Provides an efficient <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation for <see cref="T:System.Enum"/> types.
            Can be used for example in <see cref="T:System.Collections.Generic.Dictionary`2"/>, <see cref="T:System.Collections.Generic.SortedList`2"/> or <see cref="T:KGySoft.Collections.Cache`2"/> instances with <see langword="enum"/> key,
            or as a comparer for <see cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"><![CDATA[List<T>.Sort(IComparer<T>)]]></see> method to sort <see langword="enum"/> elements.
            </summary>
            <typeparam name="TEnum">The type of the enumeration. Must be an <see cref="T:System.Enum"/> type.</typeparam>
            <remarks>
            Using dictionaries with <see langword="enum"/> key and finding elements in an <see langword="enum"/> array works without using <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/>, too.
            But unlike <see cref="T:System.Int32"/> or the other possible underlying types, <see langword="enum"/> types does not implement the generic <see cref="T:System.IEquatable`1"/> and
            <see cref="T:System.IComparable`1"/> interfaces. This causes that using an <see langword="enum"/> as key in a dictionary, for example, can be very ineffective (depends on the used framework, see the note below)
            due to heavy boxing and unboxing to and from <see cref="T:System.Object"/> type. This comparer generates the type specific <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)"><![CDATA[IEqualityComparer<TEnum>.Equals]]></see>,
            <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"><![CDATA[IEqualityComparer<T>.GetHashCode]]></see> and <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"><![CDATA[IComparer<T>.Compare]]></see> methods for any <see langword="enum"/> type.
            <note>
            The optimization of <see cref="T:System.Collections.Generic.EqualityComparer`1"/> and <see cref="T:System.Collections.Generic.Comparer`1"/> instances for <see langword="enum"/> types may differ in different target frameworks.
            <list type="bullet">
            <item>In .NET Framework 3.5 and earlier versions they are not optimized at all.</item>
            <item>In .NET 4.0 Framework <see cref="T:System.Collections.Generic.EqualityComparer`1"/> was optimized for <see cref="T:System.Int32"/>-based <see langword="enum"/>s. (Every .NET 4.0 assembly is executed on the latest 4.x runtime though, so this is might be relevant
            only on Windows XP where no newer than the 4.0 runtime can be installed.)</item>
            <item>In latest .NET 4.x Framework versions <see cref="T:System.Collections.Generic.EqualityComparer`1"/> is optimized for any <see langword="enum"/> type but <see cref="T:System.Collections.Generic.Comparer`1"/> is not.</item>
            <item>In .NET Core both <see cref="T:System.Collections.Generic.EqualityComparer`1"/> and <see cref="T:System.Collections.Generic.Comparer`1"/> are optimized for any <see langword="enum"/> types
            so the performance benefit of using <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/> in .NET Core is negligible.</item>
            </list>
            </note>
            <note>In .NET Standard 2.0 building dynamic assembly is not supported so the .NET Standard 2.0 version falls back to use <see cref="T:System.Collections.Generic.EqualityComparer`1"/> and <see cref="T:System.Collections.Generic.Comparer`1"/> classes.</note>
            </remarks>
            <example>
            Example for initializing of a <see cref="T:System.Collections.Generic.Dictionary`2"/> with <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/>:
            <code lang="C#">
            <![CDATA[Dictionary<MyEnum, string> myDict = new Dictionary<MyEnum, string>(EnumComparer<MyEnum>.Comparer);]]>
            </code>
            </example>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumComparer`1.SerializationUnityHolder">
            <summary>
            This class is needed in order not to serialize the generated type.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumComparer`1.FallbackEnumComparer">
            <summary>
            A fallback comparer that uses the standard <see cref="T:System.Collections.Generic.EqualityComparer`1"/> and <see cref="T:System.Collections.Generic.Comparer`1"/>
            classes for comparisons and dynamic delegates for conversions.
            This class can be used from .NET Standard 2.0 and partially trusted domains.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.FallbackEnumComparer.GenerateToEnum">
            <summary>
            return (TEnum)value;
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.FallbackEnumComparer.GenerateToUInt64">
            <summary><![CDATA[
            return (ulong)value & sizeMask;
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.FallbackEnumComparer.GenerateToInt64">
            <summary>
            return (long)value;
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.EnumComparer`1.Comparer">
            <summary>
            Gets the comparer instance for <typeparamref name="TEnum"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.#ctor">
            <summary>
            Protected constructor to prevent direct instantiation.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <paramref name="obj"/> is the same type of <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/> as the current instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether two <typeparamref name="TEnum"/> instances are equal.
            </summary>
            <returns>
            <see langword="true"/> if the specified values are equal; otherwise, <see langword="false"/>.
            </returns>
            <param name="x">The first <typeparamref name="TEnum"/> value to compare.</param>
            <param name="y">The second <typeparamref name="TEnum"/> value to compare.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified <typeparamref name="TEnum"/> instance.
            </summary>
            <returns>
            A hash code for the specified <typeparamref name="TEnum"/> instance.
            </returns>
            <param name="obj">The <typeparamref name="TEnum"/> for which a hash code is to be returned.</param>
            <remarks>Returned hash code is not necessarily equals with own hash code of an <see langword="enum"/> value but provides a fast and well-spread value.</remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.Compare(`0,`0)">
            <summary>
            Compares two <typeparamref name="TEnum"/> instances and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <returns>
            <list type="table">
            <listheader><term>Value</term>&#160;<description>Condition</description></listheader>
            <item><term>Less than zero</term>&#160;<description><paramref name="x"/> is less than <paramref name="y"/>.</description></item>
            <item><term>Zero</term>&#160;<description><paramref name="x"/> equals <paramref name="y"/>.</description></item>
            <item><term>Greater than zero</term>&#160;<description><paramref name="x"/> is greater than <paramref name="y"/>.</description></item>
            </list>
            </returns>
            <param name="x">The first <typeparamref name="TEnum"/> instance to compare.</param>
            <param name="y">The second <typeparamref name="TEnum"/> instance to compare.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.ToEnum(System.UInt64)">
            <summary>
            Converts an <see cref="T:System.UInt64">ulong</see> value to <typeparamref name="TEnum"/>.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>The <typeparamref name="TEnum"/> representation of <paramref name="value"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.ToUInt64(`0)">
            <summary>
            Converts a <typeparamref name="TEnum"/> value to <see cref="T:System.UInt64">ulong</see>.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>The <see cref="T:System.UInt64">ulong</see> representation of <typeparamref name="TEnum"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparer`1.ToInt64(`0)">
            <summary>
            Converts a <typeparamref name="TEnum"/> value to <see cref="T:System.Int64">long</see>.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>The <see cref="T:System.Int64">ulong</see> representation of <typeparamref name="TEnum"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumComparerBuilder">
            <summary>
            A class, which can generate <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/> implementations.
            <br/>This class is a replacement of the old RecompILer logic and can be used also for .NET Core/Standard platforms.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumComparerBuilder.comparers">
            <summary>
            Key: Enum underlying type.
            Value: A <![CDATA[DynamicEnumComparer<TEnum>]]> generic type definition using the matching size and sign.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GetComparer``1">
            <summary>
            Gets an <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/> implementation.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.BuildGenericComparer(System.Type)">
            <summary><![CDATA[
            [Serializable] public sealed class DynamicEnumComparer<TEnum> : EnumComparer<TEnum> where TEnum : struct, Enum
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateDynamicEnumComparerCtor(System.Reflection.Emit.TypeBuilder)">
            <summary><![CDATA[
            public DynamicEnumComparer() : base()
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateEquals(System.Reflection.Emit.TypeBuilder,System.Type)">
            <summary><![CDATA[
            public override bool Equals(TEnum x, TEnum y) => x == y;
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateGetHashCode(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary><![CDATA[
            public override int GetHashCode(TEnum obj) =>
            #if sizeof(TEnum) == 64
                (int)((long)obj ^ ((long)obj >> 32));
            #else
                (int)obj;
            #endif
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateCompare(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary><![CDATA[
            public override int Compare(TEnum x, TEnum y) => ((underlyingType)x).CompareTo((underlyingType)y);
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateToEnum(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary><![CDATA[
            protected override TEnum ToEnum(ulong value) => (TEnum)value;
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateToUInt64(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary><![CDATA[
            protected override ulong ToUInt64(TEnum value) => (ulong)value & sizeMask;
            ]]></summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumComparerBuilder.GenerateToInt64(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary><![CDATA[
            protected override long ToInt64(TEnum value) => (long)value;
            ]]></summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.FastRandom">
            <summary>
            Represents a pseudo random number generator, which is functionally compatible
            with the <see cref="T:System.Random"/> class but is significantly faster than that.
            For cryptographically secure random numbers use the <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> class instead.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.FastRandom"/> class using a random seed value.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> class using the specified <paramref name="seed"/> value.
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> class using the specified <paramref name="seed"/> value.
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.</param>
            <exception cref="T:System.ArgumentException"><paramref name="seed"/> is <see cref="F:System.Guid.Empty"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.SampleInt32">
            <summary>
            Returns a random <see cref="T:System.Int32"/> can have any value.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to <see cref="F:System.Int32.MinValue">Int32.MinValue</see> and less or equal to <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</returns>
            <remarks>
            <para>Similarly to the <see cref="M:KGySoft.CoreLibraries.FastRandom.Next">Next</see> and <see cref="M:KGySoft.CoreLibraries.FastRandom.NextInt32">NextInt32</see> methods this one returns an <see cref="T:System.Int32"/> value; however, the result can be negative and
            the maximum possible value can be <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</para>
            <para>The <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt32(System.Random)">RandomExtensions.SampleInt32(Random)</see> extension method has the same functionality
            but it is faster to call this one directly.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextInt32">
            <summary>
            Returns a non-negative random 32-bit integer that is less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</returns>
            <remarks>
            <note type="caution">Starting with version 6.0.0 the behavior of this method has been changed to be conform with the behavior
            of the <see cref="!:Random.NextInt64()">Random.NextInt64</see> method introduced in .NET 6.0 so it returns the same range as the <see cref="M:KGySoft.CoreLibraries.FastRandom.Next"/> method.
            Use the <see cref="M:KGySoft.CoreLibraries.FastRandom.SampleInt32">SampleInt32</see> method to obtain any <see cref="T:System.Int32"/> value.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.Next">
            <summary>
            Returns a non-negative random 32-bit integer that is less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>. </returns>
            <remarks>
            <note>This method just calls the <see cref="M:KGySoft.CoreLibraries.FastRandom.NextInt32">NextInt32</see> method.
            You can call directly the non-virtual <see cref="M:KGySoft.CoreLibraries.FastRandom.NextInt32">NextInt32</see> method for a slightly better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.Next(System.Int32)">
            <summary>
            Returns a non-negative random 32-bit integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. <paramref name="maxValue" /> must be greater than or equal to 0.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random 32-bit integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. <paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.SampleInt64">
            <summary>
            Returns a random <see cref="T:System.Int64"/> can have any value.
            </summary>
            <returns>A 64-bit signed integer that is greater than or equal to <see cref="F:System.Int64.MinValue">Int64.MinValue</see> and less or equal to <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</returns>
            <remarks>
            <para>Similarly to the <see cref="M:KGySoft.CoreLibraries.FastRandom.NextInt64">NextInt64</see> method this one returns an <see cref="T:System.Int64"/> value; however, the result can be negative and
            the maximum possible value can be <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</para>
            <para>The <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt64(System.Random)">RandomExtensions.SampleInt64(Random)</see> extension method has the same functionality
            but it is faster to call this one directly.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextInt64">
            <summary>
            Returns a non-negative random 64-bit integer that is less than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.
            </summary>
            <returns>A 64-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</returns>
            <remarks>
            <note type="caution">Starting with version 6.0.0 the behavior of this method has been changed to be conform with the behavior
            of the <see cref="!:Random.NextInt64()">Random.NextInt64</see> method introduced in .NET 6.0 so it returns the same range.
            Use the <see cref="M:KGySoft.CoreLibraries.FastRandom.SampleInt64">SampleInt64</see> method to obtain any <see cref="T:System.Int64"/> value.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextInt64(System.Int64)">
            <summary>
            Returns a non-negative random 64-bit integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. <paramref name="maxValue" /> must be greater than or equal to 0.</param>
            <returns>A 64-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextInt64(System.Int64,System.Int64)">
            <summary>
            Returns a random 64-bit integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. <paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</param>
            <returns>A 64-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextDouble">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextSingle">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>A single-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">An array of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextBytes(System.Span{System.Byte})">
            <summary>
            Fills the elements of the specified <paramref name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Span`1"/> of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextUInt32">
            <summary>
            Returns a random 32-bit unsigned integer that is less than <see cref="F:System.UInt32.MaxValue">UInt32.MaxValue</see>.
            </summary>
            <returns>A 32-bit unsigned integer that is greater than or equal to 0 and less than <see cref="F:System.UInt32.MaxValue">UInt32.MaxValue</see>.</returns>
            <remarks>
            <note type="caution">Starting with version 6.0.0 the behavior of this method has been changed to be conform with the behavior of the <see cref="M:KGySoft.CoreLibraries.FastRandom.NextInt64"/>
            method introduced in .NET 6.0. Cast the result of the <see cref="M:KGySoft.CoreLibraries.FastRandom.SampleInt32">SampleInt32</see> method to obtain any <see cref="T:System.UInt32"/> value.</note>
            <para>Unlike the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt32(System.Random)">RandomExtensions.NextUInt32(Random)</see> extension method, this one always returns
            values less than <see cref="F:System.UInt32.MaxValue">UInt32.MaxValue</see>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.NextUInt64">
            <summary>
            Returns a random 64-bit unsigned integer that is less than <see cref="F:System.UInt64.MaxValue">UInt64.MaxValue</see>.
            </summary>
            <returns>A 64-bit unsigned integer that is greater than or equal to 0 and less than <see cref="F:System.UInt64.MaxValue">UInt64.MaxValue</see>.</returns>
            <remarks>
            <note type="caution">Starting with version 6.0.0 the behavior of this method has been changed to be conform with the behavior of the <see cref="M:KGySoft.CoreLibraries.FastRandom.NextInt64"/>
            method introduced in .NET 6.0. Cast the result of the <see cref="M:KGySoft.CoreLibraries.FastRandom.SampleInt64">SampleInt64</see> method to obtain any <see cref="T:System.UInt64"/> value.</note>
            <para>Unlike the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt64(System.Random)">RandomExtensions.NextUInt64(Random)</see> extension method, this one always returns
            values less than <see cref="F:System.UInt64.MaxValue">UInt64.MaxValue</see>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FastRandom.Sample">
            <summary>
            Returns a random floating-point number between 0.0 and 1.0.
            </summary>
            <returns>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.Files">
            <summary>
            Contains file-related methods.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.CreateWithPath(System.String)">
            <summary>
            Creates or overwrites a file of the specified <paramref name="path"/> along with possibly non-existing parent directories.
            </summary>
            <param name="path">The name of the file to be created with path.</param>
            <returns>The created <see cref="T:System.IO.FileStream"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.TryCreateWithPath(System.String,System.Boolean)">
            <summary>
            Tries to create a file of the specified <paramref name="path"/> along with possibly non-existing parent directories.
            </summary>
            <param name="path">The name of the file to be created with path.</param>
            <param name="overwriteIfExists"><see langword="true"/> to allow an already existing file to be overwritten; otherwise, <see langword="false"/>.</param>
            <returns>A <see cref="T:System.IO.FileStream"/> instance if the file could be created or overwritten; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.CanCreate(System.String,System.Boolean)">
            <summary>
            Checks whether a file can be created with given name.
            </summary>
            <param name="fileName">The name of the file to test.</param>
            <param name="canOverwrite">When <see langword="false"/>, then file will not be overwritten if already exists and the result will be <see langword="false"/>.
            When <see langword="true"/>, then the already existing file will be overwritten and deleted. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName"/> is <see langword="null"/>.</exception>
            <returns><see langword="true"/>, if <paramref name="fileName"/> can be created; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.GetNextFileName(System.String,System.String)">
            <summary>
            Returns <paramref name="path"/> if a file with specified name does not exist yet.
            Otherwise, returns the first non-existing file name with a number postfix.
            </summary>
            <param name="path">Full path of the file to check.</param>
            <param name="postfixSeparator">A postfix between the file name and the numbering. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>Returns <paramref name="path"/>, if that is a non-existing file name. Returns <see langword="null"/>, if <paramref name="path"/> denotes a root directory.
            Otherwise, returns a non-existing file name with a number postfix in the file name part (the extension will not be changed).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.GetRelativePath(System.String,System.String,System.Boolean)">
            <summary>
            Gets the relative path to <paramref name="target" /> from the <paramref name="baseDirectory" />.
            </summary>
            <param name="target">The target file or directory name. Can be either an absolute path or a relative one to current directory.</param>
            <param name="baseDirectory">The base directory to which the relative <paramref name="target" /> path should be determined.</param>
            <param name="isCaseSensitive"><see langword="true"/> to perform a case-sensitive comparison;
            <see langword="false"/> to perform a case-insensitive comparison.</param>
            <returns>The relative path of <paramref name="target" /> from <paramref name="baseDirectory" />, or the absolute path of <paramref name="target" /> if there is no relative path between them.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> or <paramref name="baseDirectory"/> is <see langword="null"/>.</exception>
            <returns>The relative path to <paramref name="target" /> from the <paramref name="baseDirectory" />.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.GetRelativePath(System.String,System.String)">
            <summary>
            Gets the relative path to <paramref name="target" /> from the <paramref name="baseDirectory" />.
            This overload performs a case insensitive comparison.
            </summary>
            <param name="target">The target file or directory name. Can be either an absolute path or a relative one to current directory.</param>
            <param name="baseDirectory">The base directory to which the relative <paramref name="target" /> path should be determined.</param>
            <returns>The relative path of <paramref name="target" /> from <paramref name="baseDirectory" />, or the absolute path of <paramref name="target" /> if there is no relative path between them.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> or <paramref name="baseDirectory"/> is <see langword="null"/>.</exception>
            <returns>The relative path to <paramref name="target" /> from the <paramref name="baseDirectory" />.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.IsWildcardMatch(System.String,System.String)">
            <summary>
            Returns whether a wildcarded pattern matches a file name.
            </summary>
            <param name="pattern">The pattern that may contain wildcards (<c>*</c>, <c>?</c>).</param>
            <param name="fileName">The file name to test.</param>
            <returns><see langword="true"/>, when <paramref name="fileName"/> matches <paramref name="pattern"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pattern"/> or <paramref name="fileName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.Files.GetExecutingPath">
            <summary>
            Gets the real full path of the directory, where the executing application resides.
            </summary>
            <returns>The full path of the directory where the executing application resides.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.HiResTimer">
            <summary>
            Represents a high resolution timer that allows precise timing even with sub-milliseconds intervals.
            The timer executes on a separated high priority thread.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.HiResTimer.tickFrequency">
            <summary>
            The number of ticks per one millisecond.
            </summary>
        </member>
        <member name="E:KGySoft.CoreLibraries.HiResTimer.Elapsed">
            <summary>
            Occurs when the <see cref="P:KGySoft.CoreLibraries.HiResTimer.Interval"/> elapses.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.HiResTimer.Interval">
            <summary>
            Gets or sets the interval, in milliseconds, before <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event is triggered.
            Fractional values are allowed, too. When zero, the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event is triggered as often as possible.
            <br/>Default value: <c>1.0</c>, if initialized by the default constructor; otherwise, as specified in the constructor.
            </summary>
            <value>
            The interval in milliseconds. For example, <c>1000</c> represents one second and <c>0.001</c> represents one microsecond.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is negative or <see cref="F:System.Single.NaN"/>.</exception>
            <remarks>
            <note>Please note that if <see cref="P:KGySoft.CoreLibraries.HiResTimer.Interval"/> is smaller than <c>16</c>, then the timer may consume much CPU when running.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.HiResTimer.IgnoreElapsedThreshold">
            <summary>
            Gets or sets a threshold value, in milliseconds, to ignore an <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event (and thus trying to catch up the timer)
            if the next invoke is late by the given value. Value must not be zero but fractions are allowed.
            <br/>Default value: <c>+∞</c>.
            </summary>
            <remarks>
            <note>
            If the value of this property is too low (smaller than the execution time of the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event), it may
            cause that the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event is never triggered again.
            </note>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is zero or negative or <see cref="F:System.Single.NaN"/>.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.HiResTimer.Enabled">
            <summary>
            Gets or sets whether the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event should be triggered.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <value>
            <see langword="true"/> if enabled; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="M:KGySoft.CoreLibraries.HiResTimer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.HiResTimer"/> class with 1ms interval.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.HiResTimer.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.HiResTimer"/> class with a specified <paramref name="interval"/>.
            </summary>
            <param name="interval">The time, in milliseconds, between events. Value must be non-negative. Fractional values are allowed.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="interval"/> is negative or <see cref="F:System.Single.NaN"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.HiResTimer.Start">
            <summary>
            Starts raising the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event by enabling the timer.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.HiResTimer.Stop">
            <summary>
            Stops raising the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed"/> event by disabling the timer.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.HiResTimer.ExecuteTimer">
            <summary>
            The timer loop on a dedicated thread.
            Works like an inverse SpinWait in terms of sleeping/spinning strategy: while SpinWait spins for short periods in the beginning and then starts to sleep,
            this timer sleeps more often in the beginning (if there is enough time), and starts to spin just before triggering the next event.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.MutableString">
            <summary>
            Similar to Span{char} but can be used in any platform.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.MutableString.#ctor(System.Char*,System.Int32)">
            <summary>
            Should be initialized from a fixed or stack allocated pointer.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.ReferenceEqualityComparer">
            <summary>
            Forces objects to be compared by reference.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.ReferenceEqualityComparer`1">
            <summary>
            Forces objects to be compared by reference.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringSegment">
             <summary>
             Represents a segment of a <see cref="T:System.String">string</see>. This type is similar to <see cref="T:System.ReadOnlyMemory`1"><![CDATA[ReadOnlyMemory<char>]]></see>/<see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see>
             but <see cref="T:KGySoft.CoreLibraries.StringSegment"/> can be used on all platforms in the same way and is optimized for some dedicated string operations.
             <br/>To create an instance use the <see cref="O:KGySoft.CoreLibraries.StringExtensions.AsSegment">AsSegment</see> extension method overloads or just cast a string instance to <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
             </summary>
             <remarks>
             <para>To create a <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance from a string you can use the implicit conversion, or the <see cref="O:KGySoft.CoreLibraries.StringExtensions.AsSegment">AsSegment</see> extension methods.</para>
             <para>To convert a <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance to <see cref="T:System.String">string</see> use an explicit cast or the <see cref="M:KGySoft.CoreLibraries.StringSegment.ToString">ToString</see> method.</para>
             <note>The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type <em>may</em> outperform <see cref="T:System.String">string</see> in scenarios when usual string splitting/trimming operations would allocate long strings.
             <br/>See a live example with performance test <a href="https://dotnetfiddle.net/Byk0YM" target="_blank">here</a>.</note>
             <para>Depending on the used platform some members of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type may allocate a new string.
             The affected members are:
             <list type="bullet">
             <item><see cref="M:KGySoft.CoreLibraries.StringSegment.GetHashCode(System.StringComparison)"/>: if comparison is not <see cref="F:System.StringComparison.Ordinal"/> or <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>.</item>
             <item><see cref="O:KGySoft.CoreLibraries.StringSegment.IndexOf">IndexOf</see> overloads with <see cref="T:KGySoft.CoreLibraries.StringSegment"/> and <see cref="T:System.StringComparison"/> parameter: if comparison is not <see cref="F:System.StringComparison.Ordinal"/>.</item>
             <item><see cref="O:KGySoft.CoreLibraries.StringSegment.LastIndexOf">LastIndexOf</see> overloads with <see cref="T:KGySoft.CoreLibraries.StringSegment"/> parameter: affects all comparisons.</item>
             </list>
             <note>On .NET Core 3.0 and newer platforms none of the members above allocate a new string.
             On .NET Standard 2.1/.NET Core 2.1 and newer platforms the <see cref="O:KGySoft.CoreLibraries.StringSegment.IndexOf">IndexOf</see> overloads are not affected.</note></para>
             <para>As opposed to the <see cref="T:System.String"/> class, the default comparison strategy in <see cref="T:KGySoft.CoreLibraries.StringSegment"/> members is <see cref="F:System.StringComparison.Ordinal"/>.</para>
             <example>
             <para>The following example demonstrates how to use the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type:
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.CoreLibraries;
             
             class Example
             {
                 public static void Main()
                 {
                     // Assignment works from string
                     StringSegment segment = "Some string literal";
             
                     // Or by extension methods:
                     segment = "Some string literal".AsSegment(); // "Some string literal"
                     segment = "Some string literal".AsSegment(0, 4); // "Some"
                     segment = "Some string literal".AsSegment(5, 6); // "string"
             
                     // Null assignment: all the following lines have the same effect:
                     segment = default(StringSegment); // the fastest way
                     segment = StringSegment.Null; // the recommended way
                     segment = null; // the cleanest way - same as segment = ((string)null).AsSegment()
             
                     // Null check (remember, StringSegment is a value type with null semantics):
                     bool isNull = segment == null; // the cleanest way - same as segment.Equals(((string)null).AsSegment())
                     isNull = segment.IsNull; // the fastest and recommended way - same as segment.UnderlyingString == null
             
                     // Slicing:
                     segment = "Some string literal";
                     Console.WriteLine(segment.Substring(0, 4)); // "Some"
                     Console.WriteLine(segment.Substring(5)); // "string literal"
                     Console.WriteLine(segment.Split(' ').Count); // 3
                     Console.WriteLine(segment.Split(' ')[2]); // "literal"
             
                     // Slicing operations do not allocate new strings:
                     StringSegment subsegment = segment.Substring(5);
                     subsegment = segment[5..]; // Range indexer is also supported
                     Console.WriteLine(subsegment); // "string literal"
                     Console.WriteLine(subsegment.UnderlyingString); // "Some string literal"
            
                     // As StringSegment can be implicitly converted to ReadOnlySpan<char> it can be passed
                     // to many already existing API accepting spans (in .NET Core 2.1/.NET Standard 2.1 and above):
                     int parsedResult = Int32.Parse("Value=42".AsSegment().Split('=')[1]);
                 }
             }]]></code></para>
             <para>The following example demonstrates a possible usage of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type:
             <note type="tip">Try the extended example with performance comparison <a href="https://dotnetfiddle.net/Byk0YM" target="_blank">online</a>.</note>
             <code lang="C#"><![CDATA[
             /**************************************************************
              * This example retrieves values from multiline text like this:
              * Key1=Value1;Value2
              * Key2=SingleValue
              * See a working example here: https://dotnetfiddle.net/Byk0YM
              **************************************************************/
             // The original way:
             public static string[] ByString(string content, string key)
             {
                 // getting all lines, filtering the first empty line
                 string[] nonEmptyLines = content.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            
                 foreach (string line in nonEmptyLines)
                 {
                     // Separating key from values. We can use count: 2 because we split at the first '=' only.
                     string[] keyValues = line.Split(new[] { '=' }, count: 2);
            
                     // Removing white spaces and returning values if the key matches
                     if (keyValues[0].TrimStart() == key)
                         return keyValues[1].Split(';');
                 }
            
                 // key not found
                 return null;
             }
            
             // The StringSegment way: almost the same code as above
             public static IList<StringSegment> ByStringSegment(string content, string key)
             {
                 // getting all lines, filtering the first empty line
                 IList<StringSegment> nonEmptyLines = content.AsSegment().Split(Environment.NewLine, removeEmptyEntries: true);
            
                 foreach (StringSegment line in nonEmptyLines)
                 {
                     // Separating key from values. We can use maxLength: 2 because we split at the first '=' only.
                     IList<StringSegment> keyValues = line.Split('=', maxLength: 2);
            
                     // Removing white spaces and returning values if the key matches
                     if (keyValues[0].TrimStart() == key)
                         return keyValues[1].Split(';');
                 }
            
                 // key not found
                 return null;
             }
            
             // An alternative StringSegment way: uses Split only if we need all segments or we can limit max counts.
             public static IList<StringSegment> ByStringSegmentAlternative(string content, string key)
             {
                 StringSegment rest = content; // same as content.AsSegment()
                 while (!rest.IsNull)
                 {
                     // Advancing to the next line (StringSegment is immutable but the extension uses ref this parameter)
                     StringSegment line = rest.ReadLine(); // or ReadToSeparator(Environment.NewLine, "\r", "\n")
                     if (line.Length == 0)
                         continue;
             
                     // Separating key from values. We can use maxLength: 2 because we split at the first '=' only.
                     IList<StringSegment> keyValues = line.Split('=', maxLength: 2);
             
                     // Removing white spaces and returning values if the key matches
                     if (keyValues[0].TrimStart() == key)
                         return keyValues[1].Split(';');
                 }
             
                 // key not found
                 return null;
             }]]></code>
             </para>
             </example>
             </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.op_Equality(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances have the same value.
            </summary>
            <param name="a">The left argument of the equality check.</param>
            <param name="b">The right argument of the equality check.</param>
            <returns>The result of the equality check.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.op_Inequality(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances have different values.
            </summary>
            <param name="a">The left argument of the inequality check.</param>
            <param name="b">The right argument of the inequality check.</param>
            <returns>The result of the inequality check.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Equals(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment,System.StringComparison)">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances have the same value
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="a">The first <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare.</param>
            <param name="b">The second <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns><see langword="true"/> if the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Compare(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment,System.StringComparison)">
            <summary>
            Compares two specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances using the specified <paramref name="comparison"/>,
            and returns an integer that indicates their relative position in the sort order.
            </summary>
            <param name="a">The first string to compare.</param>
            <param name="b">The second string to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>A 32-bit signed integer that indicates the lexical relationship between the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Compare(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Compares two specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, ignoring or honoring their case, and using the specified <paramref name="culture"/>,
            and returns an integer that indicates their relative position in the sort order.
            </summary>
            <param name="a">The first string to compare.</param>
            <param name="b">The second string to compare.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case during the comparison; otherwise, <see langword="false"/>.</param>
            <param name="culture">An object that supplies culture-specific comparison information.
            if <see langword="null"/>, then <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see> will be used.</param>
            <returns>A 32-bit signed integer that indicates the lexical relationship between the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Equals(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance to compare with this instance.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Equals(System.String)">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance to compare with this instance.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object">object</see> is equal to this instance.
            </summary>
            <param name="obj">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> or <see cref="T:System.String">string</see> object to compare with this instance.</param>
            <returns><see langword="true"/> if the specified object is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.CompareTo(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Compares this instance to the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> using ordinal comparison, and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="other">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare with this instance.</param>
            <returns>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="other"/> parameter.</returns>
            <remarks><note>Unlike the <see cref="M:System.String.CompareTo(System.String)">String.CompareTo</see> method, this one performs an ordinal comparison.
            Use the <see cref="O:KGySoft.CoreLibraries.StringSegment.Compare">Compare</see> methods to perform a custom comparison.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.CompareTo(System.Object)">
            <summary>
            Compares this instance to the specified object using ordinal comparison, and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="obj">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> or <see cref="T:System.String">string</see> object to compare with this instance.</param>
            <returns>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="obj"/> parameter.</returns>
            <remarks><note>Unlike the <see cref="M:System.String.CompareTo(System.Object)">String.CompareTo</see> method, this one performs an ordinal comparison.
            Use the <see cref="O:KGySoft.CoreLibraries.StringSegment.Compare">Compare</see> methods to perform a custom comparison.</note></remarks>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringSegment.Enumerator">
            <summary>
            Enumerates the characters of a <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.Enumerator.Current">
            <summary>
            Gets the character at the current position of the <see cref="T:KGySoft.CoreLibraries.StringSegment.Enumerator"/>.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Enumerator.MoveNext">
            <summary>
            Advances the <see cref="T:KGySoft.CoreLibraries.StringSegment.Enumerator"/> to the next character of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next character; <see langword="false"/> if the enumerator has passed the end of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Enumerator.Reset">
            <summary>
            Sets the <see cref="T:KGySoft.CoreLibraries.StringSegment.Enumerator"/> to its initial position, which is before the first character in the <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringSegment.Empty">
            <summary>
            Represents the empty <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This field is read-only.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringSegment.Null">
            <summary>
            Represents the <see langword="null"/>&#160;<see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This field is read-only.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.Length">
            <summary>
            Gets the length of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.UnderlyingString">
            <summary>
            Gets the underlying string of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.Offset">
            <summary>
            Gets the offset, which denotes the start position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> within the <see cref="P:KGySoft.CoreLibraries.StringSegment.UnderlyingString"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.IsNull">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance was created from a <see langword="null"/>&#160;<see cref="T:System.String">string</see>.
            <br/>Please note that the <see cref="M:KGySoft.CoreLibraries.StringSegment.ToString">ToString</see> method returns <see langword="null"/> when this property returns <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.IsNullOrEmpty">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance represents an empty segment or was created from a <see langword="null"/>&#160;<see cref="T:System.String">string</see>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.IsNullOrWhiteSpace">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance represents a <see langword="null"/> or empty <see cref="T:System.String">string</see>, or contains only whitespace characters.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.AsSpan">
            <summary>
            Returns the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance as a <see cref="T:System.ReadOnlySpan`1"/> of characters.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.AsMemory">
            <summary>
            Returns the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance as a <see cref="T:System.ReadOnlyMemory`1"/> of characters.
            </summary>
            <remarks><note>This member is available in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.Item(System.Int32)">
            <summary>
            Gets the character at the specified position in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="index">The index of the character to obtain.</param>
            <returns>The character at the specified position in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegment.Item(System.Range)">
            <summary>
            Gets the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> from this instance that represents the substring of the specified <paramref name="range"/>.
            </summary>
            <param name="range">The range to get.</param>
            <returns>The subsegment of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance with the specified <paramref name="range"/>.</returns>
            <remarks><note>This member is available in .NET Core 3.0/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.op_Implicit(System.String)~KGySoft.CoreLibraries.StringSegment">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String">string</see> to <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="s">The string to be converted to a <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>
            A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance that represents the original string.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.op_Explicit(KGySoft.CoreLibraries.StringSegment)~System.String">
            <summary>
            Performs an explicit conversion from <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to <see cref="T:System.String">string</see>.
            </summary>
            <param name="stringSegment">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to be converted to a string.</param>
            <returns>
            A <see cref="T:System.String">string</see> instance that represents the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.op_Implicit(KGySoft.CoreLibraries.StringSegment)~System.ReadOnlySpan{System.Char}">
            <summary>
            Performs an implicit conversion from <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see>.
            </summary>
            <param name="stringSegment">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to be converted to a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> instance that represents the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.GetHashCode">
            <summary>
            Returns a hash code for this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.GetHashCode(System.StringComparison)">
            <summary>
            Returns the hash code for this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> using the specified <paramref name="comparison"/>.
            </summary>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies the way of generating the hash code.</param>
            <returns>A 32-bit signed integer hash code.</returns>
            <remarks>
            <para>If <paramref name="comparison"/> is <see cref="F:System.StringComparison.Ordinal"/> or <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>, then no new string allocation occurs on any platforms.</para>
            <para>If <paramref name="comparison"/> is culture dependent (including the invariant culture), then depending on the targeted platform a new string allocation may occur.
            The .NET Core 3.0 and newer builds do not allocate a new string with any <paramref name="comparison"/> values.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.ToString">
            <summary>
            Gets a <see cref="T:System.String">string</see> that is represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, or <see langword="null"/>, if
            this instance represents a <see langword="null"/>&#160;<see cref="T:System.String">string</see>. That is, when the <see cref="P:KGySoft.CoreLibraries.StringSegment.IsNull"/> property returns <see langword="true"/>.
            </summary>
            <returns>
            A <see cref="T:System.String">string</see> that is represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, or <see langword="null"/>, if
            this instance was created from a <see langword="null"/>&#160;<see cref="T:System.String">string</see>.
            </returns>
            <returns>
            <note>As opposed to the usual <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.tostring#notes-to-inheritors" target="_blank">ToString guidelines</a>
            this method can return <see cref="F:System.String.Empty">String.Empty</see> or even <see langword="null"/>.</note>
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> characters.
            </summary>
            <returns>An <see cref="T:KGySoft.CoreLibraries.StringSegment.Enumerator"/> instance that can be used to iterate though the characters of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
            <remarks>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.String)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using ordinal comparison.
            </summary>
            <param name="value">The string to seek.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is 0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>, <paramref name="count"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.String,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is 0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using ordinal comparison.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is 0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(KGySoft.CoreLibraries.StringSegment,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>, <paramref name="count"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(KGySoft.CoreLibraries.StringSegment,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(KGySoft.CoreLibraries.StringSegment,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is 0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="count"/> values.
            </summary>
            <param name="value">The character to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.Char,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>.
            </summary>
            <param name="value">The character to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.Char)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="value">The character to seek.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using ordinal comparison.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is 0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.ReadOnlySpan{System.Char},System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>, <paramref name="count"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.ReadOnlySpan{System.Char},System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOf(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Gets the zero-based index of the first occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is 0.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>, <paramref name="count"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is the smaller of <paramref name="startIndex"/> and the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is the smaller of <paramref name="startIndex"/> and the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.String,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to seek.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not.
            If value is <see cref="F:System.String.Empty"/>, the return value is the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(KGySoft.CoreLibraries.StringSegment,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>, <paramref name="count"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is the smaller of <paramref name="startIndex"/> and the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(KGySoft.CoreLibraries.StringSegment,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is the smaller of <paramref name="startIndex"/> and the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(KGySoft.CoreLibraries.StringSegment,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to seek.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:KGySoft.CoreLibraries.StringSegment"/> is found, or -1 if it is not.
            If value is <see cref="F:KGySoft.CoreLibraries.StringSegment.Empty"/>, the return value is the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="count"/> values.
            </summary>
            <param name="value">The character to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.Char,System.Int32)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>.
            </summary>
            <param name="value">The character to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.Char)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="value">The character to seek.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.ReadOnlySpan{System.Char},System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/>, <paramref name="count"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is the smaller of <paramref name="startIndex"/> and the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
            <remarks>
            <para>If <paramref name="comparison"/> is <see cref="F:System.StringComparison.Ordinal"/>, then no new string allocation occurs on any platforms.</para>
            <para>If <paramref name="comparison"/> is other than <see cref="F:System.StringComparison.Ordinal"/>, then depending on the targeted platform a new string allocation may occur.
            The .NET Core 3.0 and newer builds do not allocate a new string with any <paramref name="comparison"/> values.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.ReadOnlySpan{System.Char},System.Int32,System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="startIndex"/> and <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is the smaller of <paramref name="startIndex"/> and the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOf(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Gets the zero-based index of the last occurrence of the specified <paramref name="value"/> in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to seek.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specified the rules for the search. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns>The zero-based index position of <paramref name="value"/> if that <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> is found, or -1 if it is not.
            If value is <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see>, the return value is the last index position of this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> of any character in the specified array
            using the specified <paramref name="startIndex"/> and <paramref name="count"/> values.
            </summary>
            <param name="values">The character values to search.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <returns>The zero-based index position of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> where any character in the specified array was found; otherwise, -1.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOfAny(System.Char[],System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> of any character in the specified array
            using the specified <paramref name="startIndex"/>.
            </summary>
            <param name="values">The character values to search.</param>
            <param name="startIndex">The search starting position.</param>
            <returns>The zero-based index position of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> where any character in the specified array was found; otherwise, -1.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.IndexOfAny(System.Char[])">
            <summary>
            Gets the zero-based index of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> of any character in the specified array.
            </summary>
            <param name="values">The character values to search.</param>
            <returns>The zero-based index position of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> where any character in the specified array was found; otherwise, -1.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the last occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> of any character in the specified array
            using the specified <paramref name="startIndex"/> and <paramref name="count"/> values.
            </summary>
            <param name="values">The character values to search.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <returns>The zero-based index position of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> where any character in the specified array was found; otherwise, -1.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOfAny(System.Char[],System.Int32)">
            <summary>
            Gets the zero-based index of the last occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> of any character in the specified array
            using the specified <paramref name="startIndex"/>.
            </summary>
            <param name="values">The character values to search.</param>
            <param name="startIndex">The search starting position.</param>
            <returns>The zero-based index position of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> where any character in the specified array was found; otherwise, -1.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.LastIndexOfAny(System.Char[])">
            <summary>
            Gets the zero-based index of the last occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> of any character in the specified array.
            </summary>
            <param name="values">The character values to search.</param>
            <returns>The zero-based index position of the first occurrence in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> where any character in the specified array was found; otherwise, -1.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.StartsWith(System.String,System.StringComparison)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance starts with the specified <paramref name="value"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The string to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> begins with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.StartsWith(KGySoft.CoreLibraries.StringSegment,System.StringComparison)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance starts with the specified <paramref name="value"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> begins with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.StartsWith(System.Char)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance starts with the specified <paramref name="value"/>.
            </summary>
            <param name="value">The character to compare.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> begins with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.StartsWith(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance starts with the specified <paramref name="value"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> begins with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.EndsWith(KGySoft.CoreLibraries.StringSegment,System.StringComparison)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance ends with the specified <paramref name="value"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> ends with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.EndsWith(System.Char)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance ends with the specified <paramref name="value"/>.
            </summary>
            <param name="value">The character to compare.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> ends with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.EndsWith(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Gets whether this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance ends with the specified <paramref name="value"/>
            using the specified <paramref name="comparison"/>.
            </summary>
            <param name="value">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to compare.</param>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value that specifies how to perform the comparison. This parameter is optional.
            <br/>Default value: <see cref="F:System.StringComparison.Ordinal"/>.</param>
            <returns><see langword="true"/> if this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> ends with <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.GetNextSegment(KGySoft.CoreLibraries.StringSegment@)">
            <summary>
            Reads until next whitespace.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Trim">
            <summary>
            Removes all leading and trailing white-space characters from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all white-space
            characters are removed from the start and end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimStart">
            <summary>
            Removes all the leading white-space characters from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all white-space
            characters are removed from the start of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimEnd">
            <summary>
            Removes all the trailing white-space characters from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all white-space
            characters are removed from the end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Trim(System.Char)">
            <summary>
            Removes all leading and trailing instances of a character from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChar">The character to remove.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all instances
            of the <paramref name="trimChar"/> character are removed from the start and end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimStart(System.Char)">
            <summary>
            Removes all leading instances of a character from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChar">The character to remove.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all instances
            of the <paramref name="trimChar"/> character are removed from the start of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimEnd(System.Char)">
            <summary>
            Removes all trailing instances of a character from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChar">The character to remove.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all instances
            of the <paramref name="trimChar"/> character are removed from the end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Trim(System.Char[])">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChars">The characters to remove. If <see langword="null"/> or empty, then whitespace characters will be removed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all occurrences of the characters
            in the <paramref name="trimChars"/> parameter are removed from the start and end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimStart(System.Char[])">
            <summary>
            Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChars">The characters to remove. If <see langword="null"/> or empty, then whitespace characters will be removed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all occurrences of the characters
            in the <paramref name="trimChars"/> parameter are removed from the start of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimEnd(System.Char[])">
            <summary>
            Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChars">The characters to remove. If <see langword="null"/> or empty, then whitespace characters will be removed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all occurrences of the characters
            in the <paramref name="trimChars"/> parameter are removed from the end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Trim(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChars">The characters to remove. If empty, then whitespace characters will be removed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all occurrences of the characters
            in the <paramref name="trimChars"/> parameter are removed from the start and end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChars">The characters to remove. If empty, then whitespace characters will be removed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all occurrences of the characters
            in the <paramref name="trimChars"/> parameter are removed from the start of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.TrimEnd(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="trimChars">The characters to remove. If empty, then whitespace characters will be removed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that represents the string that remains after all occurrences of the characters
            in the <paramref name="trimChars"/> parameter are removed from the end of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Substring(System.Int32,System.Int32)">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, which represents a substring of the current instance with the specified <paramref name="startIndex"/> and <paramref name="length"/>.
            </summary>
            <param name="startIndex">The offset that points to the first character of the returned segment.</param>
            <param name="length">The desired length of the returned segment.</param>
            <returns>The subsegment of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance with the specified <paramref name="startIndex"/> and <paramref name="length"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Substring(System.Int32)">
            <summary>
            Gets a new <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, which represents a substring of the current instance with the specified <paramref name="startIndex"/>.
            </summary>
            <param name="startIndex">The offset that points to the first character of the returned segment.</param>
            <returns>The subsegment of the current <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance with the specified <paramref name="startIndex"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            This overload uses the whitespace characters as separators. Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToWhiteSpace(KGySoft.CoreLibraries.StringSegment@)">ReadToWhiteSpace</see> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by whitespace characters.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            This overload uses the whitespace characters as separators. Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToWhiteSpace(KGySoft.CoreLibraries.StringSegment@)">ReadToWhiteSpace</see> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by whitespace characters.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.Char,System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char)"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A character that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.Char,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char)"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A character that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.Char[],System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of characters that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.Char[],KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of characters that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.Char[])">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of characters that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(KGySoft.CoreLibraries.StringSegment,System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment)"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or empty, then no splitting will occur.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment)"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or empty, then no splitting will occur.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(KGySoft.CoreLibraries.StringSegment[],System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators. If contains only <see langword="null"/> or empty elements, then no splitting will occur.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(KGySoft.CoreLibraries.StringSegment[],KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators. If contains only <see langword="null"/> or empty elements, then no splitting will occur.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(KGySoft.CoreLibraries.StringSegment[])">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators. If contains only <see langword="null"/> or empty elements, then no splitting will occur.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.String,System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String)"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A string that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or empty, then no splitting will occur.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.String,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String)"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A string that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or empty, then no splitting will occur.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.String[],System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of strings that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators. If contains only <see langword="null"/> or empty elements, then no splitting will occur.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.String[],KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of strings that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators. If contains only <see langword="null"/> or empty elements, then no splitting will occur.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.String[])">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String[])"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separators">An array of strings that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If <see langword="null"/> or contains no elements,
            then the split operation will use whitespace separators. If contains only <see langword="null"/> or empty elements, then no splitting will occur.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separators"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.ReadOnlySpan{System.Char},System.Nullable{System.Int32},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances of no more than <paramref name="maxLength"/> segments, without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.ReadOnlySpan{System.Char})"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If empty, then no splitting will occur.</param>
            <param name="maxLength">The maximum number of segments to return. If <see langword="null"/>, then the whole string is processed represented by this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegment.Split(System.ReadOnlySpan{System.Char},KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Splits this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance into a collection of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances without allocating new strings.
            Alternatively, you can use the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.ReadOnlySpan{System.Char})"/> extension method.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type for details and some examples.
            </summary>
            <param name="separator">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that delimits the segments in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/>. If empty, then no splitting will occur.</param>
            <param name="options">A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value that specifies whether to trim segments and remove empty entries.</param>
            <returns>A list of <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances, whose elements contain the substrings in this <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that are
            delimited by <paramref name="separator"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringSegmentComparer">
            <summary>
            Represents a string comparison operation that uses specific case and culture-based or ordinal comparison rules
            allowing comparing strings by <see cref="T:System.String">string</see>, <see cref="T:KGySoft.CoreLibraries.StringSegment"/> and <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> instances.
            <br/>See the static properties for more details.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-sensitive ordinal string comparison.
            <br/>The methods of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance can be called with <see cref="T:System.String">string</see>, <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            and <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> parameter values, which will not allocate new strings on any platform.
            </summary>
            <remarks>
            <note>The comparer returned by this property does not generate randomized hash codes for strings no longer than 32 characters (and for longer strings it is platform-dependent).
            Use the <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalRandomized"/> property to get a comparer with randomized hash for any lengths on all platforms.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalIgnoreCase">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-insensitive ordinal string comparison.
            <br/>The methods of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance can be called with <see cref="T:System.String">string</see>, <see cref="T:KGySoft.CoreLibraries.StringSegment"/>
            and <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> parameter values, which will not allocate new strings on any platform.
            </summary>
            <remarks>
            <note>The comparer returned by this property does not generate randomized hash codes for strings no longer than 32 characters (and for longer strings it is platform-dependent).
            Use the <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalIgnoreCaseRandomized"/> property to get a comparer with randomized hash for any lengths on all platforms.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.InvariantCulture">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-sensitive string comparison using the word comparison rules of the invariant culture.
            <br/>Depending on the targeted platform, the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)"/> method might allocate a new string.
            In .NET Core 3.0 and above none of the members of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> will allocate new strings.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.InvariantCultureIgnoreCase">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-insensitive string comparison using the word comparison rules of the invariant culture.
            <br/>Depending on the targeted platform, the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)"/> method might allocate a new string.
            In .NET Core 3.0 and above none of the members of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> will allocate new strings.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.CurrentCulture">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-sensitive string comparison using the word comparison rules of the current culture.
            <br/>Depending on the targeted platform, the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)"/> method might allocate a new string.
            In .NET Core 3.0 and above none of the members of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> will allocate new strings.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.CurrentCultureIgnoreCase">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs case-insensitive string comparisons using the word comparison rules of the current culture.
            <br/>Depending on the targeted platform, the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)"/> method might allocate a new string.
            In .NET Core 3.0 and above none of the members of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> will allocate new strings.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalRandomized">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-sensitive ordinal string comparison. The returned comparer is functionally equivalent
            with <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.Ordinal"/> but it ensures that the hash code of a specific string is stable only within the same process and <see cref="T:System.AppDomain"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalIgnoreCaseRandomized">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs a case-insensitive ordinal string comparison. The returned comparer is functionally equivalent
            with <see cref="P:KGySoft.CoreLibraries.StringSegmentComparer.OrdinalIgnoreCase"/> but it ensures that the hash code of a specific string is stable only within the same process and <see cref="T:System.AppDomain"/>.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.FromComparison(System.StringComparison)">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance based on the specified <paramref name="comparison"/>.
            <br/>Please note that the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> may allocate new strings in some cases. See the description of the properties for more details.
            </summary>
            <param name="comparison">A <see cref="T:System.StringComparison"/> value from which a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> is about to be obtained.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> instance representing the equivalent value of the specified <paramref name="comparison"/> instance.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Creates a <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that compares strings according to the rules of a specified <paramref name="culture"/>.
            <br/>Please note that the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> may allocate new strings in some cases when targeting older frameworks.
            See the <strong>Remarks</strong> section for details.
            </summary>
            <param name="culture">A culture whose linguistic rules are used to perform a comparison.</param>
            <param name="ignoreCase"><see langword="true"/> to specify that comparison operations be case-insensitive;
            <see langword="false"/> to specify that comparison operations be case-sensitive.</param>
            <returns>A new <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> object that performs string comparisons according to the comparison rules used by
            the <paramref name="culture"/> parameter and the case rule specified by the <paramref name="ignoreCase"/> parameter.</returns>
            <remarks>
            <para>If <paramref name="culture"/> is either the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> or the <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>,
            then depending on the targeted platform, the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)"/> and <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(System.ReadOnlySpan{System.Char})"/> methods might allocate a new string.
            In .NET Core 3.0 and above none of the members of the returned <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> will allocate new strings.</para>
            <para>If <paramref name="culture"/> is any <see cref="T:System.Globalization.CultureInfo"/> other than the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> and <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>,
            then depending on the targeted platform, the <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)"/>, <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(System.ReadOnlySpan{System.Char})"/>, <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})"/>
            and <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.Compare(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})"/> methods might allocate a new string. In .NET Core 3.0 and above
            none of the members with <see cref="T:KGySoft.CoreLibraries.StringSegment"/> parameters will allocate new strings. And methods with <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> parameters
            (<see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})"/> and <see cref="M:KGySoft.CoreLibraries.StringSegmentComparer.Compare(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})"/>) can avoid allocating strings when targeting .NET 5.0 or higher.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Equals(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment)">
            <summary>
            When overridden in a derived class, indicates whether two <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances are equal.
            </summary>
            <param name="x">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare to <paramref name="y"/>.</param>
            <param name="y">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare to <paramref name="x"/>.</param>
            <returns><see langword="true"/> if <paramref name="x"/> and <paramref name="y"/> are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            When overridden in a derived class, gets the hash code for the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.
            </summary>
            <param name="obj">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to get the hash code for.</param>
            <returns>
            A hash code for the <see cref="T:KGySoft.CoreLibraries.StringSegment"/>, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Compare(KGySoft.CoreLibraries.StringSegment,KGySoft.CoreLibraries.StringSegment)">
            <summary>
            When overridden in a derived class, compares two <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instances and returns an indication of their relative sort order.
            </summary>
            <param name="x">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare to <paramref name="y"/>.</param>
            <param name="y">A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to compare to <paramref name="x"/>.</param>
            <returns>
            A signed integer that indicates the relative order of <paramref name="x" /> and <paramref name="y" />.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Equals(System.String,System.String)">
            <summary>
            When overridden in a derived class, indicates whether two <see cref="T:System.String">string</see> instances are equal.
            </summary>
            <param name="x">A <see cref="T:System.String">string</see> to compare to <paramref name="y"/>.</param>
            <param name="y">A <see cref="T:System.String">string</see> to compare to <paramref name="x"/>.</param>
            <returns><see langword="true"/> if <paramref name="x"/> and <paramref name="y"/> are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(System.String)">
            <summary>
            When overridden in a derived class, gets the hash code for the specified <see cref="T:System.String">string</see>.
            </summary>
            <param name="obj">The <see cref="T:System.String">string</see> to get the hash code for.</param>
            <returns>
            A hash code for the <see cref="T:System.String">string</see>, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Compare(System.String,System.String)">
            <summary>
            When overridden in a derived class, compares two <see cref="T:System.String">string</see> instances and returns an indication of their relative sort order.
            </summary>
            <param name="x">A <see cref="T:System.String">string</see> to compare to <paramref name="y"/>.</param>
            <param name="y">A <see cref="T:System.String">string</see> to compare to <paramref name="x"/>.</param>
            <returns>
            A signed integer that indicates the relative order of <paramref name="x" /> and <paramref name="y" />.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Equals(System.Object,System.Object)">
            <summary>
            When overridden in a derived class, indicates whether two objects are equal.
            </summary>
            <param name="x">An object to compare to <paramref name="y"/>.</param>
            <param name="y">An object to compare to <paramref name="x"/>.</param>
            <returns><see langword="true"/> if <paramref name="x"/> and <paramref name="y"/> refer to the same object, or <paramref name="x"/> and <paramref name="y"/> are both
            the same type of object and those objects are equal, or both <paramref name="x"/> and <paramref name="y"/> are <see langword="null"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(System.Object)">
            <summary>
            When overridden in a derived class, gets the hash code for the specified object.
            </summary>
            <param name="obj">An object.</param>
            <returns>
            A 32-bit signed hash code calculated from the value of the <paramref name="obj"/> parameter.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Compare(System.Object,System.Object)">
            <summary>
            When overridden in a derived class, compares two objects and returns an indication of their relative sort order.
            </summary>
            <param name="x">An object to compare to <paramref name="y"/>.</param>
            <param name="y">An object to compare to <paramref name="x"/>.</param>
            <returns>
            A signed integer that indicates the relative order of <paramref name="x" /> and <paramref name="y" />.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            When overridden in a derived class, indicates whether two <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> instances are equal.
            </summary>
            <param name="x">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to compare to <paramref name="y"/>.</param>
            <param name="y">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to compare to <paramref name="x"/>.</param>
            <returns><see langword="true"/> if <paramref name="x"/> and <paramref name="y"/> are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.GetHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            When overridden in a derived class, gets the hash code for the specified <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see>.
            </summary>
            <param name="obj">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to get the hash code for.</param>
            <returns>
            A hash code for the <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see>, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentComparer.Compare(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            When overridden in a derived class, compares two <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> instances and returns an indication of their relative sort order.
            </summary>
            <param name="x">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to compare to <paramref name="y"/>.</param>
            <param name="y">A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to compare to <paramref name="x"/>.</param>
            <returns>
            A signed integer that indicates the relative order of <paramref name="x" /> and <paramref name="y" />.
            </returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringSegmentInternal">
            <summary>
            Similar to Memory/ArraySegment/ReadOnlySpan{char} but this is mutable, can be used in any platform and is optimized
            for quite a few special operations.
            NOTE: This struct is actually the same as the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> struct before making it public.
            The original file history belongs to the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> struct.
            The reintroduction occurred because this has a better performance but it cannot be readonly, which could be confusing as a public API
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentInternal.Slice(System.Int32,System.Int32)">
            <summary>
            Similar to <see cref="M:KGySoft.CoreLibraries.StringSegmentInternal.Substring(System.Int32,System.Int32)"/> but mutates self instance.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentInternal.Slice(System.Int32)">
            <summary>
            Similar to <see cref="M:KGySoft.CoreLibraries.StringSegmentInternal.Substring(System.Int32)"/> but mutates self instance.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.ThreadSafeRandom">
            <summary>
            Represents a thread-safe wrapper for random number generators.
            You can use the static <see cref="O:KGySoft.CoreLibraries.ThreadSafeRandom.Create">Create</see> methods to create a customized instance
            (eg. you can wrap a <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> instance to generate cryptographically safe random numbers in a thread-safe way),
            or just use the static <see cref="P:KGySoft.CoreLibraries.ThreadSafeRandom.Instance"/> property for a fast shared instance (which uses <see cref="T:KGySoft.CoreLibraries.FastRandom"/> internally).
            </summary>
            <seealso cref="T:System.Random" />
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.ThreadSafeRandomDefault.NextBytes(System.Span{System.Byte})">
            <summary>
            Fills the elements of the specified <paramref name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Span`1"/> of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.ThreadSafeRandomWrapper.NextBytes(System.Span{System.Byte})">
            <summary>
            Fills the elements of the specified <paramref name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Span`1"/> of bytes to contain random numbers.</param>
        </member>
        <member name="P:KGySoft.CoreLibraries.ThreadSafeRandom.Instance">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance that can be used from any threads concurrently.
            </summary>
            <remarks>
            <note>This property returns a <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance, which generates pseudo random numbers using <see cref="T:KGySoft.CoreLibraries.FastRandom"/> internally.
            To produce cryptographically secure random numbers use the <see cref="M:KGySoft.CoreLibraries.ThreadSafeRandom.Create(System.Func{System.Random})"/> method instead, and initialize it by a delegate,
            which returns <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> instances.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> class, using a random seed value.
            It is practically the same as using the <see cref="P:KGySoft.CoreLibraries.ThreadSafeRandom.Instance"/> property.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> class using the specified <paramref name="seed"/> value.
            It is practically the same as using the <see cref="M:KGySoft.CoreLibraries.ThreadSafeRandom.Create(System.Int32)"/> method.
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Create(System.Int32)">
            <summary>
            Creates a <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance using the specified <paramref name="seed"/> value.
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance using the specified <paramref name="seed"/> value.</returns>
            <remarks>
            <para>Make sure the created instance is disposed if it is not used anymore.</para>
            <note>Please note that two generated sequences can be different even with the same starting <paramref name="seed"/> if the created instance is accessed from different threads.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Create(System.Func{System.Random})">
            <summary>
            Creates a <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance using the specified <paramref name="factory"/> in each thread the result is accessed from.
            </summary>
            <param name="factory">A delegate that will be invoked once in each thread the created instance is used from.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance using the specified <paramref name="factory"/> in each thread the result is accessed from.</returns>
            <remarks>
            <para>Make sure the created instance is disposed if it is not used anymore even if the created instances are not disposable.</para>
            <para>Disposing the created instance disposes also the <see cref="T:System.Random"/> instances created by the <paramref name="factory"/> if the created <see cref="T:System.Random"/> instances are disposable.</para>
            <note>If <paramref name="factory"/> creates a pseudo random number generator, then in order not to produce the same sequence from the different threads make sure the <paramref name="factory"/> method creates instances with different seeds.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Next">
            <summary>
            Returns a non-negative random 32-bit integer that is less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>. </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Next(System.Int32)">
            <summary>
            Returns a non-negative random 32-bit integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. <paramref name="maxValue" /> must be greater than or equal to 0.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random 32-bit integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. <paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextInt64">
            <summary>
            Returns a non-negative random 64-bit integer that is less than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.
            </summary>
            <returns>A 64-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextInt64(System.Int64)">
            <summary>
            Returns a non-negative random 64-bit integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. <paramref name="maxValue" /> must be greater than or equal to 0.</param>
            <returns>A 64-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextInt64(System.Int64,System.Int64)">
            <summary>
            Returns a random 64-bit integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. <paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</param>
            <returns>A 64-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextDouble">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>
            A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextSingle">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>
            A single-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">An array of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.NextBytes(System.Span{System.Byte})">
            <summary>
            Fills the elements of the specified <paramref name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Span`1"/> of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Dispose">
            <summary>
            Disposes this <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Sample">
            <summary>
            Returns a random floating-point number between 0.0 and 1.0.
            </summary>
            <returns>
            A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ThreadSafeRandom.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.CoreLibraries.ThreadSafeRandom"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.CoreLibraries.ThreadSafeRandom.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="T:KGySoft.CoreLibraries.TimeHelper">
            <summary>
            A helper class to get a time stamp faster than UtcNow if possible on current platform.
            NOTE: Do not use if 15 ms accuracy is not enough!
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.CoreLibraries"/> namespace contains general library classes. Some of them are just additions to
            the standard .NET classes providing better performance, such as the generic <see cref="T:KGySoft.CoreLibraries.Enum`1"/> and <see cref="T:KGySoft.CoreLibraries.FastRandom"/> classes.
            Some others provide new functionality, such as the <see cref="T:KGySoft.CoreLibraries.HiResTimer"/> class.
            Additionally, contains extensions to numerous types including <see cref="T:System.Enum"/>, <see cref="T:System.Type"/>, <see cref="T:System.Random"/>, <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            and many other.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumFormattingOptions">
            <summary>
            Formatting options for the <see cref="M:KGySoft.CoreLibraries.Enum`1.ToString(`0,KGySoft.CoreLibraries.EnumFormattingOptions,System.String)"><![CDATA[Enum<TEnum>.ToString(TEnum, EnumFormattingOptions, string)]]></see> method.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumFormattingOptions.Auto">
            <summary>
            Provides a similar formatting to the <see cref="M:System.Enum.ToString">Enum.ToString</see> method, though result is not guaranteed to be exactly the same if there are more defined names for the
            same value. The produced result will always be parseable by the <see cref="M:System.Enum.Parse(System.Type,System.String)">System.Enum.Parse(Type, string)</see> method as long as used separator is the comma character.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumFormattingOptions.NonFlags">
            <summary>
            The <see langword="enum"/> value is forced to be treated as a non-flags value. If there is no defined name for the current value, then a number is returned.
            This result is always parseable by the <see cref="M:System.Enum.Parse(System.Type,System.String)">System.Enum.Parse(Type, string)</see> method.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumFormattingOptions.DistinctFlags">
            <summary>
            The result will contain only names of single bit values. Missing names will be substituted by integers. Result
            will not be parseable by the <see cref="M:System.Enum.Parse(System.Type,System.String)">System.Enum.Parse(Type, string)</see> method if the string contains a non-standalone number. To parse such a
            result the <see cref="O:KGySoft.CoreLibraries.Enum`1.Parse"><![CDATA[Enum<TEnum>.Parse]]></see> and <see cref="O:KGySoft.CoreLibraries.Enum`1.TryParse"><![CDATA[Enum<TEnum>.TryParse]]></see> overloads can be used.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumFormattingOptions.CompoundFlagsOrNumber">
            <summary>
            The result can contain either defined names (including compound ones, which do not represent single bits) or a single numeric value. This behavior is similar to the <see cref="M:System.Enum.ToString">Enum.ToString</see> method
            for a <see cref="T:System.FlagsAttribute">Flags</see>&#160;<see langword="enum"/> and the result is always parseable by the <see cref="M:System.Enum.Parse(System.Type,System.String)">System.Enum.Parse(Type, string)</see> method as long as the separator is the comma character.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumFormattingOptions.CompoundFlagsAndNumber">
            <summary>
            The result can contain defined names (including compound ones, which do not represent single bits) and optionally also a numeric value if the result cannot be covered only by names.
            The result will not be parseable by the <see cref="M:System.Enum.Parse(System.Type,System.String)">System.Enum.Parse(Type, string)</see> method if a number was applied to the names. To parse such a
            result the <see cref="O:KGySoft.CoreLibraries.Enum`1.Parse"><![CDATA[Enum<TEnum>.Parse]]></see> and <see cref="O:KGySoft.CoreLibraries.Enum`1.TryParse"><![CDATA[Enum<TEnum>.TryParse]]></see> overloads can be used.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.EnumFormattingOptions.Number">
            <summary>
            The result is always a number, even if the value or flags has a named alternative.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.TypeNameKind">
            <summary>
            Represents name formatting options for the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.GetName">TypeExtensions.GetName</see> methods.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeNameKind.ShortName">
            <summary>
            <para>Represents the short name of a <see cref="T:System.Type"/> without namespaces, eg.:
            <br/><c>SomeType[String,SomeType]</c></para>
            <para>
            Differences from <see cref="P:System.Reflection.MemberInfo.Name">Type.Name</see>:
            <list type="bullet">
            <item><see cref="P:System.Reflection.MemberInfo.Name">Type.Name</see> does not dump the generic type arguments for constructed generic types.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeNameKind.LongName">
            <summary>
            <para>Represents the long name of a <see cref="T:System.Type"/> along with namespaces, eg.:
            <br/><c>SomeNamespace.SomeType[System.String,SomeNamespace.SomeType]</c></para>
            <para>If this name is unique in the loaded assemblies, then the name can be successfully parsed by
            the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method.</para>
            <para>
            Differences from <see cref="M:System.Type.ToString">Type.ToString</see>:
            <list type="bullet">
            <item><see cref="M:System.Type.ToString">Type.ToString</see> dumps generic argument names for generic type definitions.</item>
            <item><see cref="M:System.Type.ToString">Type.ToString</see> returns <see cref="P:System.Reflection.MemberInfo.Name">Type.Name</see> for generic parameter types.</item>
            <item><see cref="M:System.Type.ToString">Type.ToString</see> dumps open generic types in a non parseable way.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeNameKind.FullName">
            <summary>
            <para>Represents the full name of a <see cref="T:System.Type"/> with assembly qualified names for generic arguments of non-core types, eg.:
            <br/><c>SomeNamespace.SomeType[System.String,[SomeNamespace.SomeType, SomeAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]</c></para>
            <para>If this name is unique in the loaded assemblies, then the name can be successfully parsed by
            the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method.</para>
            <para>
            Differences from <see cref="P:System.Type.FullName">Type.FullName</see>:
            <list type="bullet">
            <item><see cref="P:System.Type.FullName">Type.FullName</see> dumps the assembly names for every generic type argument.</item>
            <item><see cref="P:System.Type.FullName">Type.FullName</see> returns <see langword="null"/> for generic parameter types.</item>
            <item><see cref="P:System.Type.FullName">Type.FullName</see> does not dump the generic arguments for constructed open generic types.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeNameKind.ForcedFullName">
            <summary>
            <para>Represents the full name of a <see cref="T:System.Type"/> with assembly qualified names for all generic arguments, eg.:
            <br/><c>SomeNamespace.SomeType[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[SomeNamespace.SomeType, SomeAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]</c></para>
            <para>If this name is unique in the loaded assemblies, then the name can be successfully parsed by
            the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method.</para>
            <para>
            Differences from <see cref="P:System.Type.FullName">Type.FullName</see>:
            <list type="bullet">
            <item><see cref="P:System.Type.FullName">Type.FullName</see> returns <see langword="null"/> for generic parameter types.</item>
            <item><see cref="P:System.Type.FullName">Type.FullName</see> does not dump the generic arguments for constructed open generic types.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeNameKind.AssemblyQualifiedName">
            <summary>
            <para>Represents the assembly qualified name of a <see cref="T:System.Type"/> omitting assembly names for core types, eg.:
            <br/><c>SomeNamespace.SomeType[System.String,[SomeNamespace.SomeType, SomeAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], SomeAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</c></para>
            <para>If all needed assemblies are available, then the name can be successfully parsed by
            the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method.</para>
            <para>If the type does not contain generic parameter types, then the name can be parsed even by
            the <see cref="M:System.Type.GetType(System.String)">Type.GetType</see> method.</para>
            <para>
            Differences from <see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see>:
            <list type="bullet">
            <item><see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see> dumps assembly names even for core library types.
            For a similar result use the <see cref="F:KGySoft.CoreLibraries.TypeNameKind.ForcedAssemblyQualifiedName"/> option. This is not needed for <see cref="M:System.Type.GetType(System.String)">Type.GetType</see> though.</item>
            <item><see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see> returns <see langword="null"/> for generic parameter types.</item>
            <item><see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see> returns the name of the generic type definition only for constructed open generic types.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeNameKind.ForcedAssemblyQualifiedName">
            <summary>
            <para>Represents the assembly qualified name of a <see cref="T:System.Type"/> forcing assembly names for core types, eg.:
            <br/><c>SomeNamespace.SomeType[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[SomeNamespace.SomeType, SomeAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], SomeAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</c></para>
            <para>If all needed assemblies are available, then the name can be successfully parsed by
            the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method.</para>
            <para>If the type does not contain generic parameter types, then the name can be parsed even by
            the <see cref="M:System.Type.GetType(System.String)">Type.GetType</see> method.</para>
            <para>
            Differences from <see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see>:
            <list type="bullet">
            <item><see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see> returns <see langword="null"/> for generic parameter types.</item>
            <item><see cref="P:System.Type.AssemblyQualifiedName">Type.AssemblyQualifiedName</see> returns the name of the generic type definition only for constructed open generic types.</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.EventArgs`1">
            <summary>
            Represents a simple event argument of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the event argument.</typeparam>
        </member>
        <member name="P:KGySoft.CoreLibraries.EventArgs`1.EventData">
            <summary>
            Gets the event data.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.EventArgs`1"/> class.
            </summary>
            <param name="arg">The argument.</param>
        </member>
        <member name="T:KGySoft.CoreLibraries.HiResTimerElapsedEventArgs">
            <summary>
            Provides data for the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed">HiResTimer.Elapsed</see> event.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.HiResTimerElapsedEventArgs.Delay">
            <summary>
            Gets the delay, in milliseconds, of the triggering of the <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed">HiResTimer.Elapsed</see> event
            compared to when it should have been called.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.HiResTimerElapsedEventArgs.Fallouts">
            <summary>
            Gets the number of the fallen out <see cref="P:KGySoft.CoreLibraries.HiResTimer.Enabled">HiResTimer.Enabled</see> events since the last invoke.
            The value is nonzero if a larger delay occurred than the value of the <see cref="P:KGySoft.CoreLibraries.HiResTimer.IgnoreElapsedThreshold">HiResTimer.IgnoreElapsedThreshold</see> property
            and thus one or more <see cref="E:KGySoft.CoreLibraries.HiResTimer.Elapsed">HiResTimer.Elapsed</see> events were skipped to catch up the timer.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.ArrayExtensions">
            <summary>
            Provides extension methods for arrays.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.ArrayExtensions.AsSection``1(``0[],System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:KGySoft.Collections.ArraySection`1"/> instance, which represents a section of the specified <paramref name="array"/>.
            No heap allocation occurs when using this method.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="array">The array to create the <see cref="T:KGySoft.Collections.ArraySection`1"/> from.</param>
            <param name="offset">The zero-based offset that points to the first element of the returned section.</param>
            <param name="length">The desired length of the returned section.</param>
            <returns>An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance, which represents a section of the specified <paramref name="array"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ArrayExtensions.AsSection``1(``0[],System.Int32)">
            <summary>
            Gets an <see cref="T:KGySoft.Collections.ArraySection`1"/> instance, which represents a section of the specified <paramref name="array"/>.
            No heap allocation occurs when using this method.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="array">The array to create the <see cref="T:KGySoft.Collections.ArraySection`1"/> from.</param>
            <param name="offset">The zero-based offset that points to the first element of the returned section.</param>
            <returns>An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance, which represents a section of the specified <paramref name="array"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ArrayExtensions.AsSection``1(``0[])">
            <summary>
            Gets the specified <paramref name="array"/> as an <see cref="T:KGySoft.Collections.ArraySection`1"/> instance.
            No heap allocation occurs when using this method.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="array">The array to create the <see cref="T:KGySoft.Collections.ArraySection`1"/> from.</param>
            <returns>An <see cref="T:KGySoft.Collections.ArraySection`1"/> instance for the specified <paramref name="array"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ArrayExtensions.AsArray2D``1(``0[],System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:KGySoft.Collections.Array2D`1"/> wrapper for the specified <paramref name="array"/>.
            The array must have enough capacity for the specified <paramref name="height"/> and <paramref name="width"/>.
            No heap allocation occurs when using this method.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="array">The desired underlying buffer for the <see cref="T:KGySoft.Collections.Array2D`1"/> instance to be created.
            It must have sufficient capacity for the specified dimensions.</param>
            <param name="height">The height of the array to be returned.</param>
            <param name="width">The width of the array to be returned.</param>
            <returns>An <see cref="T:KGySoft.Collections.Array2D`1"/> instance using the specified <paramref name="array"/> as its underlying buffer that has the specified dimensions.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ArrayExtensions.AsArray3D``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:KGySoft.Collections.Array3D`1"/> wrapper for the specified <paramref name="array"/>.
            The array must have enough capacity for the specified <paramref name="depth"/>, <paramref name="height"/> and <paramref name="width"/>.
            No heap allocation occurs when using this method.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="array">The desired underlying buffer for the <see cref="T:KGySoft.Collections.Array3D`1"/> instance to be created.
            It must have sufficient capacity for the specified dimensions.</param>
            <param name="depth">The depth of the array to be returned.</param>
            <param name="height">The height of the array to be returned.</param>
            <param name="width">The width of the array to be returned.</param>
            <returns>An <see cref="T:KGySoft.Collections.Array3D`1"/> instance using the specified <paramref name="array"/> as its underlying buffer that has the specified dimensions.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.ByteArrayExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Array">byte[]</see> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.ToHexValuesString(System.Byte[],System.String)">
            <summary>
            Converts the byte array to string of hexadecimal values.
            </summary>
            <param name="bytes">The byte array to convert.</param>
            <param name="separator">The separator to use between the hex numbers. If <see langword="null"/> or empty, the hex stream will be continuous. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The string representation, in hex, of the contents of <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="separator"/> contains hex digits</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.ToHexValuesString(System.Byte[],System.String,System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Converts the byte array to string of hexadecimal values.
            </summary>
            <param name="bytes">The byte array to convert.</param>
            <param name="separator">The separator to use between the hex numbers. If <see langword="null"/> or empty, the hex stream will be continuous.</param>
            <param name="lineLength">Specifies the length of a line in the result not counting the indentation. When 0 or less, the result will not be wrapped to lines.</param>
            <param name="indentSize">Size of the indentation. If greater than zero, the new lines will be prefixed with as many <paramref name="indentChar"/> characters as this parameter specifies. This parameter is optional.
            <br/>Default value: <c>0</c></param>
            <param name="indentChar">The character to be used for the indentation. This parameter is optional.
            <br/>Default value: <c>' '</c> (space)</param>
            <param name="indentSingleLine">If set to <see langword="true"/>, then a single line result will be indented, too. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The string representation, in hex, of the contents of <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="separator"/> contains hex digits</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.ToDecimalValuesString(System.Byte[],System.String)">
            <summary>
            Converts the byte array to string of decimal values.
            </summary>
            <param name="bytes">The byte array to convert.</param>
            <param name="separator">The separator to use between the decimal numbers. This parameter is optional.
            <br/>Default value: <c>", "</c> (comma and space)</param>
            <returns>The string representation, in decimal, of the contents of <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/> or <paramref name="separator"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="separator"/> is empty or contains decimal digits</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.ToDecimalValuesString(System.Byte[],System.String,System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Converts the byte array to string of decimal values.
            </summary>
            <param name="bytes">The byte array to convert.</param>
            <param name="separator">The separator to use between the decimal numbers.</param>
            <param name="lineLength">Specifies the length of a line in the result not counting the indentation. When 0 or less, the result will not be wrapped to lines.</param>
            <param name="indentSize">Size of the indentation. If greater than zero, the new lines will be prefixed with as many <paramref name="indentChar"/> characters as this parameter specifies. This parameter is optional.
            <br/>Default value: <c>0</c></param>
            <param name="indentChar">The character to be used for the indentation. This parameter is optional.
            <br/>Default value: <c>' '</c> (space)</param>
            <param name="indentSingleLine">If set to <see langword="true"/>, then a single line result will be indented, too. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The string representation, in decimal, of the contents of <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/> or <paramref name="separator"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="separator"/> is empty or contains decimal digits</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.ToBase64String(System.Byte[],System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Converts the given <paramref name="bytes"/> into a Base64 encoded string.
            </summary>
            <param name="bytes">The bytes to convert.</param>
            <param name="lineLength">Specifies the length of a line in the result not counting the indentation. When 0 or less, the result will not be wrapped to lines. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="indentSize">Size of the indentation. If greater than zero, the new lines will be prefixed with as many <paramref name="indentChar"/> characters as this parameter specifies. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="indentChar">The character to be used for the indentation. This parameter is optional.
            <br/>Default value: <c>' '</c> (space)</param>
            <param name="indentSingleLine">If set to <see langword="true"/>, then a single line result will be indented, too. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The string representation, in base 64, of the contents of <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/> is <see langword="null"/></exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Compress(System.Byte[])">
            <summary>
            Compresses the provided <paramref name="bytes"/> and returns the compressed data.
            Compressed data can be decompressed by <see cref="M:KGySoft.CoreLibraries.ByteArrayExtensions.Decompress(System.Byte[])">Decompress</see> method.
            </summary>
            <param name="bytes">The bytes to compress.</param>
            <returns>Compressed data. It is not guaranteed that compressed data is shorter than original one.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Decompress(System.Byte[])">
            <summary>
            Decompresses the provided <paramref name="bytes"/> that was compressed by <see cref="M:KGySoft.CoreLibraries.ByteArrayExtensions.Compress(System.Byte[])">Compress</see> method.
            </summary>
            <param name="bytes">The bytes to decompress.</param>
            <returns>Decompressed data. It is not guaranteed that compressed data is shorter than original one.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Encrypt(System.Byte[],System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[])">
            <summary>
            Encrypts a byte array by the provided symmetric <paramref name="algorithm"/>, <paramref name="key"/> and initialization vector.
            </summary>
            <param name="bytes">Source bytes to encrypt.</param>
            <param name="algorithm">A <see cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> instance to be used for encryption.</param>
            <param name="key">Key to be used for encryption.</param>
            <param name="iv">Initialization vector to be used for encryption.</param>
            <returns>The encrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Encrypt(System.Byte[],System.Security.Cryptography.SymmetricAlgorithm,System.String,System.String)">
            <summary>
            Encrypts a byte array by the provided symmetric <paramref name="algorithm"/>, <paramref name="password"/> and <paramref name="salt"/>.
            </summary>
            <param name="bytes">Source bytes to encrypt.</param>
            <param name="algorithm">A <see cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> instance to be used for encryption.</param>
            <param name="password">Password of encryption.</param>
            <param name="salt">A salt value to be used for encryption. If <see langword="null"/> or is empty, a default salt will be used.</param>
            <returns>The encrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Encrypt(System.Byte[],System.String,System.String)">
            <summary>
            Encrypts a byte array by the <see cref="T:System.Security.Cryptography.Aes"/> algorithm using the provided <paramref name="password"/> and <paramref name="salt"/>.
            </summary>
            <param name="bytes">Source bytes to encrypt.</param>
            <param name="password">Password of encryption.</param>
            <param name="salt">A salt value to be used for encryption. If <see langword="null"/> or is empty, a default salt will be used.</param>
            <returns>The encrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Encrypt(System.Byte[],System.Security.Cryptography.SymmetricAlgorithm,System.Byte[]@,System.Byte[]@)">
            <summary>
            Encrypts a byte array by the provided symmetric <paramref name="algorithm"/>, using a randomly generated key and initialization vector, which are
            returned in <paramref name="key"/> and <paramref name="iv"/> parameters, respectively.
            </summary>
            <param name="bytes">Source bytes to encrypt.</param>
            <param name="algorithm">A <see cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> instance to be used for encryption.</param>
            <param name="key">Returns the automatically generated key used for encryption.</param>
            <param name="iv">Returns the automatically generated initialization vector used for encryption.</param>
            <returns>The encrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Encrypt(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Encrypts a byte array by the <see cref="T:System.Security.Cryptography.Aes"/> algorithm using a randomly generated key and initialization vector, which are
            returned in <paramref name="key"/> and <paramref name="iv"/> parameters, respectively.
            </summary>
            <param name="bytes">Source bytes to encrypt.</param>
            <param name="key">Returns the automatically generated key used for encryption.</param>
            <param name="iv">Returns the automatically generated initialization vector used for encryption.</param>
            <returns>The encrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Decrypt(System.Byte[],System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[])">
            <summary>
            Decrypts a byte array by the provided symmetric <paramref name="algorithm"/>, <paramref name="key"/> and initialization vector.
            </summary>
            <param name="bytes">Source bytes to decrypt.</param>
            <param name="algorithm">A <see cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> instance to use for decryption.</param>
            <param name="key">Key of decryption.</param>
            <param name="iv">The initialization vector to be used for decryption.</param>
            <returns>The decrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Decrypt(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Decrypts a byte array by the <see cref="T:System.Security.Cryptography.Aes"/> algorithm using the provided <paramref name="key"/> and initialization vector.
            </summary>
            <param name="bytes">Source bytes to decrypt.</param>
            <param name="key">Key of decryption.</param>
            <param name="iv">The initialization vector to be used for decryption.</param>
            <returns>The decrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Decrypt(System.Byte[],System.Security.Cryptography.SymmetricAlgorithm,System.String,System.String)">
            <summary>
            Decrypts a byte array by the provided symmetric <paramref name="algorithm"/>, <paramref name="password"/> and <paramref name="salt"/>.
            </summary>
            <param name="bytes">Source bytes to decrypt.</param>
            <param name="algorithm">A <see cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> instance to use for decryption.</param>
            <param name="password">Password of decryption.</param>
            <param name="salt">A salt value to be used for decryption. If <see langword="null"/> or is empty, a default salt will be used.</param>
            <returns>The decrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ByteArrayExtensions.Decrypt(System.Byte[],System.String,System.String)">
            <summary>
            Decrypts a byte array by the <see cref="T:System.Security.Cryptography.Aes"/> algorithm using the provided <paramref name="password"/> and <paramref name="salt"/>.
            </summary>
            <param name="bytes">Source bytes to decrypt.</param>
            <param name="password">Password of decryption.</param>
            <param name="salt">A salt value to be used for decryption. If <see langword="null"/> or is empty, a default salt will be used.</param>
            <returns>The decrypted result of <paramref name="bytes"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.CharExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Char">char</see> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.CharExtensions.IsNonCharacter(System.Char)">
            <summary>
            Gets whether <paramref name="c"/> is a non-character code point in Unicode.
            </summary>
            <param name="c">The <see cref="T:System.Char"/> code point to check.</param>
            <returns><see langword="true"/> if <paramref name="c"/> is a non-character code point in Unicode; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.CharExtensions.IsValidCharacter(System.Char)">
            <summary>
            Gets whether <paramref name="c"/> is a valid standalone character code point in Unicode.
            That is, if <paramref name="c"/> is not a half-surrogate and is not defined as a non-character code point.
            </summary>
            <param name="c">The <see cref="T:System.Char"/> code point to check.</param>
            <returns><see langword="true"/> if <paramref name="c"/> is a valid standalone character code point in Unicode; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.CollectionExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Collections.Generic.ICollection`1"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.CollectionExtensions.AsThreadSafe``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns a <see cref="T:KGySoft.Collections.LockingCollection`1"/>, which provides a thread-safe wrapper for the specified <paramref name="collection"/>.
            This only means that if the members are accessed through the returned <see cref="T:KGySoft.Collections.LockingCollection`1"/>, then the inner state of the wrapped collection remains always consistent and not that all of the multi-threading concerns can be ignored.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Collections.LockingCollection`1"/> class for details and some examples.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <param name="collection">The collection to create a thread-safe wrapper for.</param>
            <returns>A <see cref="T:KGySoft.Collections.LockingCollection`1"/>, which provides a thread-safe wrapper for the specified <paramref name="collection"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.CollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a <paramref name="collection"/> to the <paramref name="target"/>&#160;<see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="target">The target collection.</param>
            <param name="collection">The collection to add to the <paramref name="target"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> or <paramref name="collection"/> is <see langword="null"/>.</exception>
            <remarks>
            <note>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements of <paramref name="collection"/> will be added one by one.</note>
            </remarks>
        </member>
        <member name="T:KGySoft.CoreLibraries.DateTimeExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.DateTime"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.DateTimeExtensions.AsUtc(System.DateTime)">
            <summary>
            Converts the specified <paramref name="dateTime"/> to UTC time. Unlike <see cref="M:System.DateTime.ToUniversalTime">DateTime.ToUniversalTime</see>, this
            method does not treat <see cref="T:System.DateTime"/> instances with <see cref="F:System.DateTimeKind.Unspecified"/>&#160;<see cref="P:System.DateTime.Kind"/> as local times.
            </summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> to convert.</param>
            <returns>A <see cref="T:System.DateTime"/> instance with <see cref="F:System.DateTimeKind.Utc"/>&#160;<see cref="P:System.DateTime.Kind"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DateTimeExtensions.AsLocal(System.DateTime)">
            <summary>
            Converts the specified <paramref name="dateTime"/> to a local time. Unlike <see cref="M:System.DateTime.ToLocalTime">DateTime.ToLocalTime</see>, this
            method does not treat <see cref="T:System.DateTime"/> instances with <see cref="F:System.DateTimeKind.Unspecified"/>&#160;<see cref="P:System.DateTime.Kind"/> as UTC times.
            </summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> to convert.</param>
            <returns>A <see cref="T:System.DateTime"/> instance with <see cref="F:System.DateTimeKind.Local"/>&#160;<see cref="P:System.DateTime.Kind"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DateTimeExtensions.ToUnixMilliseconds(System.DateTime)">
            <summary>
            Gets the time elapsed since the Unix Epoch time (1970-01-01T00:00Z) in milliseconds, not counting leap seconds.
            </summary>
            <param name="value">A <see cref="T:System.DateTime"/> value to get the Unix time from.</param>
            <returns>The number of milliseconds that have elapsed since 1970-01-01T00:00Z.</returns>
            <remarks>
            <para>This method is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetimeoffset.tounixtimemilliseconds" target="_blank">DateTimeOffset.ToUnixTimeMilliseconds</a>
            but is available even below .NET Framework 4.6.</para>
            <para>If <paramref name="value"/> is a <see cref="F:System.DateTimeKind.Local"/> time, then its <see cref="P:System.DateTime.Kind"/> is converted to UTC first.</para>
            <para>This method returns a negative value for times before 1970-01-01T00:00Z.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DateTimeExtensions.ToUnixSeconds(System.DateTime)">
            <summary>
            Gets the time elapsed since the Unix Epoch time (1970-01-01T00:00Z) in seconds, not counting leap seconds.
            </summary>
            <param name="value">A <see cref="T:System.DateTime"/> value to get the Unix time from.</param>
            <returns>The number of seconds that have elapsed since 1970-01-01T00:00Z.</returns>
            <remarks>
            <para>This method is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetimeoffset.tounixtimeseconds" target="_blank">DateTimeOffset.ToUnixTimeSeconds</a>
            but is available even below .NET Framework 4.6.</para>
            <para>If <paramref name="value"/> is a <see cref="F:System.DateTimeKind.Local"/> time, then its <see cref="P:System.DateTime.Kind"/> is converted to UTC first.</para>
            <para>This method returns a negative value for times before 1970-01-01T00:00Z.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DateTimeExtensions.FromUnixMilliseconds(System.Int64)">
            <summary>
            Gets a <see cref="F:System.DateTimeKind.Utc"/>&#160;<see cref="T:System.DateTime"/> from the milliseconds elapsed since the Unix Epoch time (1970-01-01T00:00Z).
            </summary>
            <param name="milliseconds">The number of milliseconds elapsed since the Unix Epoch time (1970-01-01T00:00Z), not counting leap seconds. Negative values as also allowed.</param>
            <returns>A <see cref="F:System.DateTimeKind.Utc"/>&#160;<see cref="T:System.DateTime"/> that represents the same moment as the specified <paramref name="milliseconds"/> parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds"/> is less than -62,135,596,800,000, or greater than 253,402,300,799,999.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DateTimeExtensions.FromUnixSeconds(System.Int64)">
            <summary>
            Gets a <see cref="F:System.DateTimeKind.Utc"/>&#160;<see cref="T:System.DateTime"/> from the seconds elapsed since the Unix Epoch time (1970-01-01T00:00Z).
            </summary>
            <param name="seconds">The number of seconds elapsed since the Unix Epoch time (1970-01-01T00:00Z), not counting leap seconds. Negative values as also allowed.</param>
            <returns>A <see cref="F:System.DateTimeKind.Utc"/>&#160;<see cref="T:System.DateTime"/> that represents the same moment as the specified <paramref name="seconds"/> parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="seconds"/> is less than -62,135,596,800, or greater than 253,402,300,799.</exception>
        </member>
        <member name="T:KGySoft.CoreLibraries.DecimalExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Decimal">decimal</see> type.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.DecimalExtensions.NegativeZero">
            <summary>
            Represents one possible negative zero value of the <see cref="T:System.Decimal"/> type.
            </summary>
            <remarks>The value of this constant is <c>-0.0</c>.</remarks>
        </member>
        <member name="F:KGySoft.CoreLibraries.DecimalExtensions.E">
            <summary>
            Represents the natural logarithmic base, specified by the constant, <em>e</em>.
            </summary>
            <remarks>
            <para>This member is similar to <see cref="F:System.Math.E">Math.E</see> but has <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            <para>The value of this constant is <c>2.7182818284590452353602874714</c>.</para>
            </remarks>
        </member>
        <member name="F:KGySoft.CoreLibraries.DecimalExtensions.PI">
            <summary>
            Represents the ratio of the circumference of a circle to its diameter, specified by the constant, <em>π</em>.
            </summary>
            <remarks>
            <para>This member is similar to <see cref="F:System.Math.PI">Math.PI</see> but has <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            <para>The value of this constant is <c>3.1415926535897932384626433833</c>.</para>
            </remarks>
        </member>
        <member name="F:KGySoft.CoreLibraries.DecimalExtensions.Epsilon">
            <summary>
            Represents the smallest positive <see cref="T:System.Decimal"/> value that is greater than zero.
            </summary>
            <remarks>The value of this constant is <c>0.0000000000000000000000000001</c>.</remarks>
        </member>
        <member name="F:KGySoft.CoreLibraries.DecimalExtensions.eReciprocal">
            <summary>
            1 / e = 0.3678794411714423215955237702
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.DecimalExtensions.log10E">
            <summary>
            Logarithm of e in base 10 = log(e, 10)
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.ToRoundtripString(System.Decimal)">
            <summary>
            Returns a culture-invariant <see cref="T:System.String"/> representation of the given <see cref="T:System.Decimal"/>&#160;<paramref name="value"/>,
            from which the original value can be parsed without losing any information.
            </summary>
            <param name="value">A <see cref="T:System.Decimal"/> value to be converted to <see cref="T:System.String"/>.</param>
            <returns>A <see cref="T:System.Decimal"/> value, from which the original value can be parsed without losing any information.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.IsNegativeZero(System.Decimal)">
            <summary>
            Gets whether the specified <paramref name="value"/> is negative zero.
            </summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if <paramref name="value"/> represents a negative zero value; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Normalize(System.Decimal)">
            <summary>
            Removes the trailing zeros after the decimal sign of the specified <see cref="T:System.Decimal"/>&#160;<paramref name="value"/>.
            </summary>
            <param name="value">The value to normalize.</param>
            <returns>The normalized value of the specified <see cref="T:System.Decimal"/>&#160;<paramref name="value"/> containing no trailing zeros after the decimal sign.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Log(System.Decimal)">
            <summary>
            Returns the natural (base <em>e</em>) logarithm of a <see cref="T:System.Decimal"/>&#160;<paramref name="value"/>.
            </summary>
            <param name="value">The value whose logarithm is to be found. Must be greater than zero.</param>
            <returns>The natural logarithm of <paramref name="value"/>.</returns>
            <remarks>
            <para>This member is similar to <see cref="M:System.Math.Log(System.Double)">Math.Log(double)</see> but uses <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is less than or equal to 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Log10(System.Decimal)">
            <summary>
            Returns the base 10 logarithm of a <see cref="T:System.Decimal"/>&#160;<paramref name="value"/>.
            </summary>
            <param name="value">The value whose logarithm is to be found. Must be greater than zero.</param>
            <returns>The base 10 logarithm of <paramref name="value"/>.</returns>
            <remarks>
            <para>This member is similar to <see cref="M:System.Math.Log10(System.Double)">Math.Log10</see> but uses <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is less than or equal to 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Log(System.Decimal,System.Decimal)">
            <summary>
            Returns the logarithm of a specified <paramref name="value"/> in a specified <paramref name="base"/>.
            </summary>
            <param name="value">The value whose logarithm is to be found. Must be greater than zero.</param>
            <param name="base">The base of the logarithm.</param>
            <returns>The logarithm of the specified <paramref name="value"/> in the specified <paramref name="base"/>.</returns>
            <remarks>
            <para>This member is similar to <see cref="M:System.Math.Log(System.Double,System.Double)">Math.Log(double, double)</see> but uses <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is less than or equal to 0.
            <br/>-or-
            <br/><paramref name="base"/> equals to 1 or is less or equal to 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Exp(System.Decimal)">
            <summary>
            Returns <em>e</em> raised to the specified <paramref name="power"/>.
            </summary>
            <param name="power">The specified power.</param>
            <returns>The number <em>e</em> raised to the specified <paramref name="power"/>.</returns>
            <exception cref="T:System.OverflowException"><paramref name="power"/> is too large for the result to fit in a <see cref="T:System.Decimal"/> value.</exception>
            <remarks>
            <para>This member is similar to <see cref="M:System.Math.Exp(System.Double)">Math.Exp</see> but uses <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Pow(System.Decimal,System.Decimal)">
            <summary>
            Returns the specified <paramref name="value"/> raised to the specified <paramref name="power"/>.
            </summary>
            <param name="value">The value to be raised to a power.</param>
            <param name="power">The specified power.</param>
            <returns>The specified <paramref name="value"/> raised to the specified <paramref name="power"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is negative and <paramref name="power"/> is not an integer.</exception>
            <exception cref="T:System.OverflowException"><paramref name="power"/> is too large for the result to fit in a <see cref="T:System.Decimal"/> value.</exception>
            <remarks>
            <para>This member is similar to <see cref="M:System.Math.Pow(System.Double,System.Double)">Math.Pow</see> but uses <see cref="T:System.Decimal"/> type instead of <see cref="T:System.Double"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.Pow(System.Decimal,System.Int32)">
            <summary>
            Returns the specified <paramref name="value"/> raised to the specified <paramref name="power"/>.
            </summary>
            <param name="value">The value to be raised to a power.</param>
            <param name="power">The specified power.</param>
            <returns>The specified <paramref name="value"/> raised to the specified <paramref name="power"/>.</returns>
            <exception cref="T:System.OverflowException"><paramref name="power"/> is too large for the result to fit in a <see cref="T:System.Decimal"/> value.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.InitPowerOf10">
            <summary>
            Initialized the power of 10 cache.
            Could be in static constructor but moved here for performance reasons (CA1810)
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.LogE(System.Decimal)">
            <summary>
            Calculates the natural base logarithm.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.DecimalExtensions.RoundInternal(System.Decimal)">
            <summary>
            If the decimal value rounded to 23 places are the same as the rounded value to 4 decimals, then returns the rounded value.
            This helps to correct the results of the Log methods.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.DelegateExtensions">
            <summary>
            Provides extension methods for delegates.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.DelegateExtensions.AddSafe``1(``0,``0@)">
            <summary>
            Combines <paramref name="value"/> with the referenced <paramref name="location"/> in a thread-safe way.
            </summary>
            <typeparam name="TDelegate">The type of the delegate.</typeparam>
            <param name="value">The value to combine with the referenced <paramref name="location"/>.</param>
            <param name="location">The reference of the delegate to combine with <paramref name="value"/>.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.DelegateExtensions.RemoveSafe``1(``0,``0@)">
            <summary>
            If the referenced <paramref name="location"/> contains the <paramref name="value"/> delegate, then the last occurrence of it will be removed in a thread-safe way.
            </summary>
            <typeparam name="TDelegate">The type of the delegate.</typeparam>
            <param name="value">The value to remove from the referenced <paramref name="location"/>.</param>
            <param name="location">The reference of the delegate from which <paramref name="value"/> should be removed.</param>
        </member>
        <member name="T:KGySoft.CoreLibraries.DictionaryExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Collections.Generic.IDictionary`2"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0)">
            <summary>
            Tries to get a value from the provided <paramref name="dictionary"/> for the given key.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <returns>The found value or the default value of <typeparamref name="TValue"/> if <paramref name="key"/> was not found in the <paramref name="dictionary"/>.</returns>
            <remarks><note>If <paramref name="dictionary"/> is neither an <see cref="T:System.Collections.Generic.IDictionary`2"/>, nor an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> instance,
            then a sequential lookup is performed using a default equality comparer on the keys.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0,``1)">
            <summary>
            Tries to get a value from the provided <paramref name="dictionary"/> for the given key.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found in the <paramref name="dictionary"/>.</returns>
            <remarks><note>If <paramref name="dictionary"/> is neither an <see cref="T:System.Collections.Generic.IDictionary`2"/>, nor an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> instance,
            then a sequential lookup is performed using a default equality comparer on the keys.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0,System.Func{``1})">
            <summary>
            Tries to get a value from the provided <paramref name="dictionary"/> for the given key.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the <paramref name="dictionary"/>.</returns>
            <remarks><note>If <paramref name="dictionary"/> is neither an <see cref="T:System.Collections.Generic.IDictionary`2"/>, nor an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> instance,
            then a sequential lookup is performed using a default equality comparer on the keys.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetActualValueOrDefault``3(System.Collections.Generic.IDictionary{``0,``1},``0,``2)">
            <summary>
            Tries to get the typed value from a <paramref name="dictionary"/> for the given key.
            In this method <paramref name="defaultValue"/> can have a different type than <typeparamref name="TValue"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type is not compatible with <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetActualValueOrDefault``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``2})">
            <summary>
            Tries to get the typed value from a <paramref name="dictionary"/> for the given key.
            In this method <paramref name="defaultValueFactory"/> can return an instance of a different type than <typeparamref name="TValue"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetActualValueOrDefault``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0,``2)">
            <summary>
            Tries to get the typed value from a <paramref name="dictionary"/> for the given key. Unlike in the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0,``1)"/> overload,
            here <paramref name="defaultValue"/> can have a different type than <typeparamref name="TValue"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type is not compatible with <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
            <remarks><note>If <paramref name="dictionary"/> is neither an <see cref="T:System.Collections.Generic.IDictionary`2"/>, nor an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> instance,
            then a sequential lookup is performed using a default equality comparer on the keys.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetActualValueOrDefault``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0,System.Func{``2})">
            <summary>
            Tries to get the typed value from a <paramref name="dictionary"/> for the given key. Unlike in the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},``0,System.Func{``1})"/> overload,
            here <paramref name="defaultValueFactory"/> can return an instance of a different type than <typeparamref name="TValue"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValueFactory">A delegate that can be invoked to return a default value if <paramref name="key"/> was not found.</param>
            <typeparam name="TKey">The type of the stored keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">Type of the stored values in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or the result of <paramref name="defaultValueFactory"/> if <paramref name="key"/> was not found in the <paramref name="dictionary"/>.</returns>
            <remarks><note>If <paramref name="dictionary"/> is neither an <see cref="T:System.Collections.Generic.IDictionary`2"/>, nor an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> instance,
            then a sequential lookup is performed using a default equality comparer on the keys.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)">
             <summary>
             Tries to get the typed value from a <see cref="T:System.String">string</see>-<see cref="T:System.Object">object</see>&#160;<paramref name="dictionary"/> for the given key.
             </summary>
             <param name="dictionary">The dictionary.</param>
             <param name="key">The key whose value to get.</param>
             <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type is not compatible with <typeparamref name="TActualValue"/> This parameter is optional.
             <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
             <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
             <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
             <example>
             The following example demonstrates how to use the <see cref="O:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault">GetValueOrDefault</see> overloads.
             <note type="tip">Try also <a href="https://dotnetfiddle.net/GKSif4" target="_blank">online</a>.</note>
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections.Generic;
             using KGySoft.CoreLibraries;
             
             public class Example
             {
                 public static void Main()
                 {
                     var dict = new Dictionary<string, object>
                     {
                         { "Int", 42 },
                         { "String", "Blah" },
                     };
             
                     // old way:
                     object obj;
                     int intValue;
                     if (dict.TryGetValue("Int", out obj) && obj is int)
                         intValue = (int)obj;
             
                     // C# 7.0 way:
                     if (dict.TryGetValue("Int", out object o) && o is int i)
                         intValue = i;
             
                     // GetValueOrDefault ways:
             
                     // TValue return type (which is object now)
                     intValue = (int)dict.GetValueOrDefault("Int");
             
                     // by defining a default value the actual type (and return type) can be specified
                     intValue = dict.GetValueOrDefault("Int", 0);
            
                     // an alternative syntax for string-object dictionaries (a default value still can be specified)
                     intValue = dict.GetValueOrDefault<int>("Int");
            
                     // to use different actual (and return) type for non string-object dictionaries use the GetActualValueOrDefault method:
                     intValue = dict.GetActualValueOrDefault("Int", 0);
             
                     // using nullable int actual type to get null if "Unknown" does not exist or is not an int
                     int? intOrNull = dict.GetValueOrDefault<int?>("Unknown");
            
                     // If obtaining a default value is an expensive operation you can use the delegate overloads.
                     // The delegate is invoked only when the key was not found in the dictionary:
                     intValue = (int)dict.GetValueOrDefault("Unknown", () =>
                     {
                         Console.WriteLine("Default value factory was invoked from GetValueOrDefault");
                         return -1;
                     });
            
            		   // Which is the same as:
                    intValue = dict.GetActualValueOrDefault("Unknown", () =>
                    {
                        Console.WriteLine("Default value factory was invoked from GetActualValueOrDefault");
                        return -1;
                    });
             
                    Console.WriteLine($"{nameof(intValue)}: {intValue}; {nameof(intOrNull)}: {intOrNull}");
                 }
             }]]></code>
             </example>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.String,``0)">
            <summary>
            Tries to get the typed value from a <see cref="T:System.String">string</see>-<see cref="T:System.Object">object</see>&#160;<paramref name="dictionary"/> for the given key.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.DictionaryExtensions.GetValueOrDefault``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,``0)"/> method for some examples.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">The default value to return if <paramref name="key"/> was not found or its actual type is not compatible with <typeparamref name="TActualValue"/> This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="TActualValue"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="TActualValue"/>.</param>
            <typeparam name="TActualValue">The type of the value with the corresponding <paramref name="key"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="key"/> was not found or its value cannot be cast to <typeparamref name="TActualValue"/>.</returns>
            <remarks><note>If <paramref name="dictionary"/> is neither an <see cref="T:System.Collections.Generic.IDictionary`2"/>, nor an <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/> instance,
            then a sequential lookup is performed using a default equality comparer on the keys.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.AsThreadSafe``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a <see cref="T:KGySoft.Collections.LockingDictionary`2"/>, which provides a thread-safe wrapper for the specified <paramref name="dictionary"/>.
            This only means that if the members are accessed through the returned <see cref="T:KGySoft.Collections.LockingDictionary`2"/>, then the inner state of the wrapped dictionary remains always consistent and not that all of the multi-threading concerns can be ignored.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Collections.LockingDictionary`2"/> class for details and some examples.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The dictionary to create a thread-safe wrapper for.</param>
            <returns>A <see cref="T:KGySoft.Collections.LockingDictionary`2"/>, which provides a thread-safe wrapper for the specified <paramref name="dictionary"/>.</returns>
            <remarks>
            <para>To use a thread-safe dictionary without wrapping any <see cref="T:System.Collections.Generic.IDictionary`2"/> instance consider to use the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> class instead.</para>
            <para>For a <see cref="T:KGySoft.Collections.Cache`2"/> instance consider to use the <see cref="M:KGySoft.Collections.Cache`2.GetThreadSafeAccessor(System.Boolean)">GetThreadSafeAccessor</see> method instead, which does not necessarily lock the item loader delegate.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Tries to add a pair of key and value the specified <paramref name="dictionary"/>. The operation is thread safe if <paramref name="dictionary"/>
            is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance.
            For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="item">The <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to add to the <paramref name="dictionary"/>.</param>
            <returns><see langword="true"/> if <paramref name="item"/> was added to the <paramref name="dictionary"/> successfully;
            <see langword="false"/> if the key already exists or when <see cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/> returns <see langword="true"/> for <paramref name="dictionary"/>.</returns>
            <remarks>
            <para>The <see cref="T:System.Collections.Generic.CollectionExtensions"/> class in .NET Core 2.0 and above also has
            a <see cref="M:System.Collections.Generic.CollectionExtensions.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">TryAdd</see> method that behaves somewhat differently.
            To avoid ambiguity with that method this one has a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> parameter.</para>
            <para>Unlike the <see cref="M:System.Collections.Generic.CollectionExtensions.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">CollectionExtensions.TryAdd</see> method, this one
            is thread safe when used with <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/> and <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instances.
            Additionally, this one returns <see langword="false"/> if <paramref name="dictionary"/> is read-only instead of throwing an exception.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="item"/> has a <see langword="null"/> key.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.TryUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,``1)">
            <summary>
            Tries to update the value associated with <paramref name="key"/> to <paramref name="newValue"/> if the existing value with <paramref name="key"/>
            is equal to <paramref name="originalValue"/>. The operation is thread safe if <paramref name="dictionary"/>
            is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance.
            For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key of the item to replace.</param>
            <param name="newValue">The replacement value of <paramref name="key"/> if its value equals to <paramref name="originalValue"/>.</param>
            <param name="originalValue">The expected original value of the stored item with the associated <paramref name="key"/>.</param>
            <returns><see langword="true"/> if <paramref name="dictionary"/> is not read-only and the value with <paramref name="key"/>
            was equal to <paramref name="originalValue"/> and was replaced with <paramref name="newValue"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,``1)">
            <summary>
            Adds or updates a key/value pair in the <paramref name="dictionary"/> based on whether the specified <paramref name="key"/> already exists.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValue">The value to be added for an absent key.</param>
            <param name="updateValue">The value to be set for an existing key.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either <paramref name="addValue"/> (if the key was absent)
            or <paramref name="updateValue"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="dictionary"/> is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,System.Func{``0,``1,``1})">
            <summary>
            Adds a key/value pair to the <paramref name="dictionary"/> if the <paramref name="key"/> does not already exist,
            or updates a key/value pair in the <paramref name="dictionary"/> by using the specified <paramref name="updateValueFactory"/> if the <paramref name="key"/> already exists.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValue">The value to be added for an absent key.</param>
            <param name="updateValueFactory">A delegate used to generate a new value for an existing key based on the key's existing value.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either <paramref name="addValue"/> (if the key was absent)
            or the result of <paramref name="updateValueFactory"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/>, <paramref name="key"/> or <paramref name="updateValueFactory"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="dictionary"/> is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <summary>
            Uses the specified delegates to add a key/value pair to the <paramref name="dictionary"/> if the <paramref name="key"/> does not already exist,
            or to update a key/value pair in the <paramref name="dictionary"/> if the <paramref name="key"/> already exists.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValueFactory">A delegate used to generate a value for an absent key.</param>
            <param name="updateValueFactory">A delegate used to generate a new value for an existing key based on the key's existing value.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either the result of <paramref name="addValueFactory"/> (if the key was absent)
            or the result of <paramref name="updateValueFactory"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/>, <paramref name="key"/>, <paramref name="addValueFactory"/> or <paramref name="updateValueFactory"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="dictionary"/> is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.AddOrUpdate``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``2,``1},System.Func{``0,``1,``2,``1},``2)">
            <summary>
            Uses the specified delegates to add a key/value pair to the <paramref name="dictionary"/> if the <paramref name="key"/> does not already exist,
            or to update a key/value pair in the <paramref name="dictionary"/> if the <paramref name="key"/> already exists.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TArg">The type of an argument to pass into <paramref name="addValueFactory"/> and <paramref name="updateValueFactory"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key to be added or whose value should be updated.</param>
            <param name="addValueFactory">A delegate used to generate a value for an absent key.</param>
            <param name="updateValueFactory">A delegate used to generate a new value for an existing key based on the key's existing value.</param>
            <param name="factoryArgument">An argument to pass into <paramref name="addValueFactory"/> and <paramref name="updateValueFactory"/>.</param>
            <returns>The new value for the <paramref name="key"/>. This will be either the result of <paramref name="addValueFactory"/> (if the key was absent)
            or the result of <paramref name="updateValueFactory"/> (if the key was present).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/>, <paramref name="key"/>, <paramref name="addValueFactory"/> or <paramref name="updateValueFactory"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="dictionary"/> is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds a key/value pair to the <paramref name="dictionary"/> if the key does not already exist, and returns either the added or the existing value.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key of the element to add or whose value should be returned.</param>
            <param name="addValue">The value to be added, if the key does not already exist.</param>
            <returns>The value for the key. This will be either the existing value for the <paramref name="key"/> if the key is already in the dictionary,
            or the specified <paramref name="addValue"/> if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="key"/> was not present in the <paramref name="dictionary"/>, which is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Adds a key/value pair to the <paramref name="dictionary"/> by using the specified <paramref name="addValueFactory"/>
            if the key does not already exist, and returns either the added or the existing value.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key of the element to add or whose value should be returned.</param>
            <param name="addValueFactory">The delegate to be used to generate the value, if the key does not already exist.</param>
            <returns>The value for the key. This will be either the existing value for the <paramref name="key"/> if the key is already in the dictionary,
            or the result of the specified <paramref name="addValueFactory"/> if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/>, <paramref name="key"/> or <paramref name="addValueFactory"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="key"/> was not present in the <paramref name="dictionary"/>, which is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.GetOrAdd``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Adds a key/value pair to the <paramref name="dictionary"/> by using the specified <paramref name="addValueFactory"/>
            if the key does not already exist, and returns either the added or the existing value.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TArg">The type of an argument to pass into <paramref name="addValueFactory"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">The key of the element to add or whose value should be returned.</param>
            <param name="addValueFactory">The delegate to be used to generate the value, if the key does not already exist.</param>
            <param name="factoryArgument">An argument to pass into <paramref name="addValueFactory"/>.</param>
            <returns>The value for the key. This will be either the existing value for the <paramref name="key"/> if the key is already in the dictionary,
            or the result of the specified <paramref name="addValueFactory"/> if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/>, <paramref name="key"/> or <paramref name="addValueFactory"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="key"/> was not present in the <paramref name="dictionary"/>, which is read-only.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.TryRemove``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Tries to remove the value with the specified <paramref name="key"/> from the specified <paramref name="dictionary"/>.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">Key of the item to remove.</param>
            <returns><see langword="true"/> if <paramref name="dictionary"/> is not read-only and the element is successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.DictionaryExtensions.TryRemove``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary>
            Tries to remove and return the <paramref name="value"/> with the specified <paramref name="key"/> from the specified <paramref name="dictionary"/>.
            The operation is thread safe if <paramref name="dictionary"/> is a <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>, <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            or <see cref="T:KGySoft.Collections.LockingDictionary`2"/> instance. For other <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations the caller should care about thread safety if needed.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">The target dictionary.</param>
            <param name="key">Key of the item to remove.</param>
            <param name="value">When this method returns, contains the value removed from the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>,
            or the default value of the <typeparamref name="TValue"/> type if <paramref name="dictionary"/> is read-only or <paramref name="key"/> does not exist.</param>
            <returns><see langword="true"/> if the element is successfully removed; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:KGySoft.CoreLibraries.DoubleExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Double">double</see> type.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.DoubleExtensions.NegativeZero">
            <summary>
            Represents the negative zero value. This value is constant.
            </summary>
            <remarks>The value of this constant is <c>-0.0</c>.</remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DoubleExtensions.ToRoundtripString(System.Double)">
            <summary>
            Returns a culture-invariant <see cref="T:System.String"/> representation of the given <see cref="T:System.Double"/>&#160;<paramref name="value"/>,
            from which the original value can be parsed without losing any information.
            </summary>
            <param name="value">A <see cref="T:System.Double"/> value to be converted to <see cref="T:System.String"/>.</param>
            <returns>A <see cref="T:System.Double"/> value, from which the original value can be parsed without losing any information.</returns>
            <remarks>
            The result of this method can be parsed by <see cref="M:System.Double.Parse(System.String,System.IFormatProvider)">Double.Parse</see>; however, to retrieve exactly the
            original value, including a negative zero value, use the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)">Parse</see>&#160;<see cref="T:System.String"/> extension method instead.
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.DoubleExtensions.IsNegativeZero(System.Double)">
            <summary>
            Gets whether the specified <paramref name="value"/> is negative zero.
            </summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if <paramref name="value"/> represents a negative zero value; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DoubleExtensions.TolerantIsZero(System.Double,System.Double)">
            <summary>
            Gets whether the specified <paramref name="value"/> can be considered zero using a specific <paramref name="tolerance"/>.
            </summary>
            <param name="value">The value to be check.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but the reasonable value is between 0 and 0.5. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns><see langword="true"/> if <paramref name="value"/> can be considered zero using the specified <paramref name="tolerance"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DoubleExtensions.TolerantEquals(System.Double,System.Double,System.Double)">
            <summary>
            Gets whether two <see cref="T:System.Double">double</see> values are equal considering the specified <paramref name="tolerance"/>.
            </summary>
            <param name="value">The value to be compared to another one.</param>
            <param name="other">The other value compared to the self <paramref name="value"/>.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but it should be some low positive value to get a reasonable result. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns><see langword="true"/>, if the values are equal considering the specified <paramref name="tolerance"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DoubleExtensions.TolerantCeiling(System.Double,System.Double)">
            <summary>
            Gets the ceiling of the specified <paramref name="value"/> using a specific <paramref name="tolerance"/>.
            That is the closest integral number to <paramref name="value"/> if the difference from that is not larger than <paramref name="tolerance"/>;
            otherwise, the smallest integral value that is greater than <paramref name="value"/>.
            </summary>
            <param name="value">The value, whose ceiling is abut to be retrieved.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but the reasonable value is between 0 and 0.5. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns>The ceiling of the specified <paramref name="value"/> using the specified <paramref name="tolerance"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.DoubleExtensions.TolerantFloor(System.Double,System.Double)">
            <summary>
            Gets the floor of the specified <paramref name="value"/> using a specific <paramref name="tolerance"/>.
            That is the closest integral number to <paramref name="value"/> if the difference from that is not larger than <paramref name="tolerance"/>;
            otherwise, the largest integral value that is less than <paramref name="value"/>.
            </summary>
            <param name="value">The value, whose floor is abut to be retrieved.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but the reasonable value is between 0 and 0.5. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns>The floor of the specified <paramref name="value"/> using the specified <paramref name="tolerance"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumerableExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Collections.Generic.IEnumerable`1"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Similarly to the <see cref="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})"><![CDATA[List<T>.ForEach]]></see> method, processes an action on each element of an enumerable collection.
            </summary>
            <typeparam name="T">The type of the elements in the enumeration.</typeparam>
            <param name="source">The source enumeration.</param>
            <param name="action">The action to perform on each element.</param>
            <returns>Returns the original <paramref name="source"/> making possible to link it into a LINQ chain.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryAdd``1(System.Collections.Generic.IEnumerable{``0},``0,System.Boolean,System.Boolean)">
            <summary>
            Tries to add the specified <paramref name="item"/> to the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to add the <paramref name="item"/> to.</param>
            <param name="item">The item to add.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the collection is read-only; <see langword="false"/> to attempt adding the element without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found add method; <see langword="false"/> to suppress the exceptions thrown by the found add method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if an adding method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnly"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the adding method threw an exception.</returns>
            <remarks>
            <para>The <paramref name="item"/> can be added to the <paramref name="collection"/> if that is either an <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryAdd(System.Collections.IEnumerable,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Tries to add the specified <paramref name="item"/> to the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to add the <paramref name="item"/> to.</param>
            <param name="item">The item to add.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the collection is read-only; <see langword="false"/> to attempt adding the element without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found add method; <see langword="false"/> to suppress the exceptions thrown by the found add method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if an adding method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnly"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the adding method threw an exception.</returns>
            <remarks>
            <para>The <paramref name="item"/> can be added to the <paramref name="collection"/> if that is either an <see cref="T:System.Collections.IList"/>, <see cref="T:System.Collections.IDictionary"/> (when <paramref name="item"/> is a <see cref="T:System.Collections.DictionaryEntry"/> instance),
            <see cref="T:System.Collections.Generic.ICollection`1"/> or <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> implementation.</para>
            <note>If it is known that the collection implements only the supported generic interfaces, then for better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryAdd``1(System.Collections.Generic.IEnumerable{``0},``0,System.Boolean,System.Boolean)"><![CDATA[TryAdd<T>]]></see> overload if possible.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryAddRange``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)">
            <summary>
            Tries to add the specified <paramref name="collection"/> to the <paramref name="target"/> collection.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="target">The target collection.</param>
            <param name="collection">The collection to add to the <paramref name="target"/>.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only; <see langword="false"/> to attempt adding the <paramref name="collection"/> without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found add method; <see langword="false"/> to suppress the exceptions thrown by the found add method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole <paramref name="collection"/> could be added to <paramref name="target"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The specified <paramref name="collection"/> can be added to the <paramref name="target"/> collection if that is either an <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <para>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements of <paramref name="collection"/> will only be added one by one.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryAddRange(System.Collections.IEnumerable,System.Collections.IEnumerable,System.Boolean,System.Boolean)">
            <summary>
            Tries to add the specified <paramref name="collection"/> to the <paramref name="target"/> collection.
            </summary>
            <param name="target">The target collection.</param>
            <param name="collection">The collection to add to the <paramref name="target"/>.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only; <see langword="false"/> to attempt adding the <paramref name="collection"/> without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found add method; <see langword="false"/> to suppress the exceptions thrown by the found add method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole <paramref name="collection"/> could be added to <paramref name="target"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The <paramref name="collection"/> can be added to the <paramref name="target"/> collection if that is either an <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <para>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements of <paramref name="collection"/> will only be added one by one.</para>
            <note>Whenever possible, try to use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryAddRange``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)"><![CDATA[TryAddRange<T>]]></see> overload for better performance.</note>
            <note type="warning">If not every element in <paramref name="collection"/> is compatible with <paramref name="target"/>, then it can happen that some elements
            of <paramref name="collection"/> have been added to <paramref name="target"/> and the method returns <see langword="false"/>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryClear``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)">
            <summary>
            Tries to remove all elements from the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to clear.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the collection is read-only; <see langword="false"/> to attempt the clearing without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by the matching clear method; <see langword="false"/> to suppress inner exceptions and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if a clear method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnly"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the clear method threw an exception.</returns>
            <remarks>
            <para>The <paramref name="collection"/> can be cleared if that is either an <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.IDictionary"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryClear(System.Collections.IEnumerable,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove all elements from the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to clear.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the collection is read-only; <see langword="false"/> to attempt the clearing without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by the matching clear method; <see langword="false"/> to suppress inner exceptions and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if a clear method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnly"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the clear method threw an exception.</returns>
            <remarks>
            <para>The <paramref name="collection"/> can be cleared if that is either an <see cref="T:System.Collections.IList"/>, <see cref="T:System.Collections.IDictionary"/> or <see cref="T:System.Collections.Generic.ICollection`1"/> implementation.</para>
            <note>If it is known that the collection implements only the supported generic <see cref="T:System.Collections.Generic.ICollection`1"/> interface, then for better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryClear``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)"><![CDATA[TryClear<T>]]></see> overload if possible.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryInsert``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0,System.Boolean,System.Boolean)">
            <summary>
            Tries to insert the specified <paramref name="item"/> at the specified <paramref name="index"/> to the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to insert the <paramref name="item"/> into.</param>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The item to be inserted.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the element without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found insert method; <see langword="false"/> to suppress the exceptions thrown by the found insert method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if an inserting method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnlyAndBounds"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the inserting method threw an exception.</returns>
            <remarks>
            <para>The <paramref name="item"/> can be inserted into the <paramref name="collection"/> if that is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryInsert(System.Collections.IEnumerable,System.Int32,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Tries to insert the specified <paramref name="item"/> at the specified <paramref name="index"/> to the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to insert the <paramref name="item"/> into.</param>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The item to be inserted.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the element without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found insert method; <see langword="false"/> to suppress the exceptions thrown by the found insert method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if an inserting method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnlyAndBounds"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the inserting method threw an exception.</returns>
            <remarks>
            <para>The <paramref name="item"/> can be inserted into the <paramref name="collection"/> if that is either an <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.IList`1"/> implementation.</para>
            <note>If it is known that the collection implements only the supported generic <see cref="T:System.Collections.Generic.IList`1"/> interface, then for better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryInsert``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0,System.Boolean,System.Boolean)"><![CDATA[TryInsert<T>]]></see> overload if possible.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryInsertRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)">
            <summary>
            Tries to insert the specified <paramref name="collection"/> into the <paramref name="target"/> collection.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="target">The target collection.</param>
            <param name="index">The zero-based index at which the <paramref name="collection"/> should be inserted.</param>
            <param name="collection">The collection to insert into the <paramref name="target"/>.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the <paramref name="collection"/> without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found insert method; <see langword="false"/> to suppress the exceptions thrown by the found insert method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole <paramref name="collection"/> could be inserted into <paramref name="target"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The specified <paramref name="collection"/> can be inserted in the <paramref name="target"/> collection if that is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <para>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements of <paramref name="collection"/> will only be inserted one by one.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryInsertRange(System.Collections.IEnumerable,System.Int32,System.Collections.IEnumerable,System.Boolean,System.Boolean)">
            <summary>
            Tries to insert the specified <paramref name="collection"/> into the <paramref name="target"/> collection.
            </summary>
            <param name="target">The target collection.</param>
            <param name="index">The zero-based index at which the <paramref name="collection"/> should be inserted.</param>
            <param name="collection">The collection to insert into the <paramref name="target"/>.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the <paramref name="collection"/> without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found insert method; <see langword="false"/> to suppress the exceptions thrown by the found insert method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole <paramref name="collection"/> could be inserted into <paramref name="target"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The specified <paramref name="collection"/> can be inserted in the <paramref name="target"/> collection if that is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <para>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements of <paramref name="collection"/> will only be inserted one by one.</para>
            <note>Whenever possible, try to use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryInsertRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)"><![CDATA[TryInsertRange<T>]]></see> overload for better performance.</note>
            <note type="warning">If not every element in <paramref name="collection"/> is compatible with <paramref name="target"/>, then it can happen that some elements
            of <paramref name="collection"/> have been added to <paramref name="target"/> and the method returns <see langword="false"/>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemove``1(System.Collections.Generic.IEnumerable{``0},``0,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove the specified <paramref name="item"/> from to the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to remove the <paramref name="item"/> from.</param>
            <param name="item">The item to be removed.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the collection is read-only; <see langword="false"/> to attempt removing the element without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found remove method; <see langword="false"/> to suppress the exceptions thrown by the found remove method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if <paramref name="item"/> could be successfully removed; <see langword="false"/> if a removing method was not found or the <paramref name="item"/> could not be removed, <paramref name="checkReadOnly"/> is <see langword="true"/> and the collection was read-only,
            <paramref name="throwError"/> is <see langword="false"/> and the removing method threw an exception, or the removing method returned <see langword="false"/>.</returns>
            <remarks>
            <para>Removal is supported if <paramref name="collection"/> is either an <see cref="T:System.Collections.Generic.ICollection`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemove(System.Collections.IEnumerable,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove the specified <paramref name="item"/> from to the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to remove the <paramref name="item"/> from.</param>
            <param name="item">The item to be removed.</param>
            <param name="checkReadOnly"><see langword="true"/> to return <see langword="false"/> if the collection is read-only; <see langword="false"/> to attempt removing the element without checking the read-only state. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found remove method; <see langword="false"/> to suppress the exceptions thrown by the found remove method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if <paramref name="item"/> could be successfully removed; <see langword="false"/> if a removing method was not found or the <paramref name="item"/> could not be removed, <paramref name="checkReadOnly"/> is <see langword="true"/> and the collection was read-only,
            <paramref name="throwError"/> is <see langword="false"/> and the removing method threw an exception, or the removing method returned <see langword="false"/>.</returns>
            <remarks>
            <para>Removal is supported if <paramref name="collection"/> is either an <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.ICollection`1"/> implementation.</para>
            <note>If it is known that the collection implements only the supported generic <see cref="T:System.Collections.Generic.ICollection`1"/> interface, then for better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemove``1(System.Collections.Generic.IEnumerable{``0},``0,System.Boolean,System.Boolean)"><![CDATA[TryRemove<T>]]></see> overload if possible.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemoveAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove an item at the specified <paramref name="index"/> from the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to remove the item from.</param>
            <param name="index">The zero-based index of the item to be removed.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt removing the element without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found remove method; <see langword="false"/> to suppress the exceptions thrown by the found remove method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if a remove method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnlyAndBounds"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the removing method threw an exception.</returns>
            <remarks>
            <para>Removal is supported if <paramref name="collection"/> is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemoveAt(System.Collections.IEnumerable,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove an item at the specified <paramref name="index"/> from the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to remove the item from.</param>
            <param name="index">The zero-based index of the item to be removed.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt removing the element without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found remove method; <see langword="false"/> to suppress the exceptions thrown by the found remove method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if a remove method could be successfully called; <see langword="false"/> if such method was not found, or <paramref name="checkReadOnlyAndBounds"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the removing method threw an exception.</returns>
            <remarks>
            <para>Removal is supported if <paramref name="collection"/> is either an <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.IList`1"/> implementation.</para>
            <note>If it is known that the collection implements only the supported generic <see cref="T:System.Collections.Generic.IList`1"/> interface, then for better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemoveAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Boolean)"><![CDATA[TryRemoveAt<T>]]></see> overload if possible.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemoveRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove <paramref name="count"/> amount of items from the specified <paramref name="collection"/> at the specified <paramref name="index"/>.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="collection">The collection to remove the elements from.</param>
            <param name="index">The zero-based index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the <paramref name="collection"/> without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found remove method; <see langword="false"/> to suppress the exceptions thrown by the found remove method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole range could be removed from <paramref name="collection"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>Removal is supported if <paramref name="collection"/> is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <note>If <paramref name="collection"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> implementation,
            then the elements will only be removed one by one.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemoveRange(System.Collections.IEnumerable,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove <paramref name="count"/> amount of items from the specified <paramref name="collection"/> at the specified <paramref name="index"/>.
            </summary>
            <param name="collection">The collection to remove the elements from.</param>
            <param name="index">The zero-based index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the <paramref name="collection"/> without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found remove method; <see langword="false"/> to suppress the exceptions thrown by the found remove method and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole range could be removed from <paramref name="collection"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>Removal is supported if <paramref name="collection"/> is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <note>If <paramref name="collection"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> implementation,
            then the elements will only be removed one by one.</note>
            <note>Whenever possible, try to use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryRemoveRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Boolean,System.Boolean)"><![CDATA[TryRemoveRange<T>]]></see> overload for better performance.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TrySetElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0,System.Boolean,System.Boolean)">
            <summary>
            Tries to set the specified <paramref name="item"/> at the specified <paramref name="index"/> in the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to set the <paramref name="item"/> in.</param>
            <param name="index">The zero-based index at which <paramref name="item"/> should be set.</param>
            <param name="item">The item to be set.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt setting the element without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found setting member; <see langword="false"/> to suppress the exceptions thrown by the found setting member and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if a setting member could be successfully called; <see langword="false"/> if such member was not found, or <paramref name="checkReadOnlyAndBounds"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the setting member threw an exception.</returns>
            <remarks>
            <para>The <paramref name="item"/> can be set in the <paramref name="collection"/> if that is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TrySetElementAt(System.Collections.IEnumerable,System.Int32,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Tries to set the specified <paramref name="item"/> at the specified <paramref name="index"/> in the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to set the <paramref name="item"/> in.</param>
            <param name="index">The zero-based index at which <paramref name="item"/> should be set.</param>
            <param name="item">The item to be set.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt setting the element without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found setting member; <see langword="false"/> to suppress the exceptions thrown by the found setting member and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if a setting member could be successfully called; <see langword="false"/> if such member was not found, or <paramref name="checkReadOnlyAndBounds"/> is <see langword="true"/> and the collection was read-only,
            or <paramref name="throwError"/> is <see langword="false"/> and the setting member threw an exception.</returns>
            <remarks>
            <para>The <paramref name="item"/> can be set in the <paramref name="collection"/> if that is either an <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.IList`1"/> implementation.</para>
            <note>If it is known that the collection implements only the supported generic <see cref="T:System.Collections.Generic.IList`1"/> interface, then for better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TrySetElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0,System.Boolean,System.Boolean)"><![CDATA[TrySetElementAt<T>]]></see> overload if possible.</note>
            <note>This method returns <see langword="false"/> also for multidimensional arrays.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryReplaceRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)">
            <summary>
            Tries to remove <paramref name="count"/> amount of items from the <paramref name="target"/> at the specified <paramref name="index"/>, and
            to insert the specified <paramref name="collection"/> at the same position. The number of elements in <paramref name="collection"/> can be different from the amount of removed items.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="target">The target collection.</param>
            <param name="index">The zero-based index of the first item to remove and also the index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="count">The number of items to remove.</param>
            <param name="collection">The collection to insert into the <paramref name="target"/> list.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the <paramref name="collection"/> without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by the used modifier members; <see langword="false"/> to suppress the exceptions thrown by the used members and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole range could be removed and <paramref name="collection"/> could be inserted into <paramref name="target"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The replacement can be performed if the <paramref name="target"/> collection is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <para>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements will only be replaced one by one.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryReplaceRange(System.Collections.IEnumerable,System.Int32,System.Int32,System.Collections.IEnumerable,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove <paramref name="count"/> amount of items from the <paramref name="target"/> at the specified <paramref name="index"/>, and
            to insert the specified <paramref name="collection"/> at the same position. The number of elements in <paramref name="collection"/> can be different from the amount of removed items.
            </summary>
            <param name="target">The target collection.</param>
            <param name="index">The zero-based index of the first item to remove and also the index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="count">The number of items to remove.</param>
            <param name="collection">The collection to insert into the <paramref name="target"/> list.</param>
            <param name="checkReadOnlyAndBounds"><see langword="true"/> to return <see langword="false"/> if the target collection is read-only or the <paramref name="index"/> is invalid; <see langword="false"/> to attempt inserting the <paramref name="collection"/> without checking the read-only state and bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by the used modifier members; <see langword="false"/> to suppress the exceptions thrown by the used members and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/>, if the whole range could be removed and <paramref name="collection"/> could be inserted into <paramref name="target"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The replacement can be performed if the <paramref name="target"/> collection is either an <see cref="T:System.Collections.Generic.IList`1"/> or <see cref="T:System.Collections.IList"/> implementation.</para>
            <para>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeCollection`1"/> implementation,
            then the elements will only be replaced one by one.</para>
            <note>Whenever possible, try to use the generic <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.TryReplaceRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean)"><![CDATA[TryReplaceRange<T>]]></see> overload for better performance.</note>
            <note type="warning">If not every element in <paramref name="collection"/> is compatible with <paramref name="target"/>, then it can happen that some elements
            of <paramref name="collection"/> have been added to <paramref name="target"/> and the method returns <see langword="false"/>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
            <summary>
            Determines whether the specified <paramref name="source"/> is <see langword="null"/> or empty (has no elements).
            </summary>
            <param name="source">The source to check.</param>
            <returns><see langword="true"/> if the <paramref name="source"/> collection is <see langword="null"/> or empty; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="source"/> is <see langword="null"/> or empty (has no elements).
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The source to check.</param>
            <returns><see langword="true"/> if the <paramref name="source"/> collection is <see langword="null"/> or empty; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Searches for an element in the <paramref name="source"/> enumeration where the specified <paramref name="predicate"/> returns <see langword="true"/>.
            </summary>
            <typeparam name="T">The type of the elements in the enumeration..</typeparam>
            <param name="source">The source enumeration to search.</param>
            <param name="predicate">The predicate to use for the search.</param>
            <returns>The index of the found element, or -1 if there was no match.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.IndexOf(System.Collections.IEnumerable,System.Func{System.Object,System.Boolean})">
            <summary>
            Searches for an element in the <paramref name="source"/> enumeration where the specified <paramref name="predicate"/> returns <see langword="true"/>.
            </summary>
            <param name="source">The source enumeration to search.</param>
            <param name="predicate">The predicate to use for the search.</param>
            <returns>The index of the found element, or -1 if there was no match.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Searches for an element in the <paramref name="source"/> enumeration.
            </summary>
            <typeparam name="T">The type of the elements in the enumeration.</typeparam>
            <param name="source">The source enumeration to search.</param>
            <param name="element">The element to search.</param>
            <returns>The index of the found element, or -1 if <paramref name="element"/> was not found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.IndexOf(System.Collections.IEnumerable,System.Object)">
            <summary>
            Searches for an element in the <paramref name="source"/> enumeration.
            </summary>
            <param name="source">The source enumeration to search.</param>
            <param name="element">The element to search.</param>
            <returns>The index of the found element, or -1 if <paramref name="element"/> was not found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryGetElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0@,System.Boolean,System.Boolean)">
            <summary>
            Tries to get an <paramref name="item"/> at the specified <paramref name="index"/> in the <paramref name="collection"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The collection to retrieve the <paramref name="item"/> from.</param>
            <param name="index">The zero-based index at which <paramref name="item"/> should be returned.</param>
            <param name="item">If this method returns <see langword="true"/>, then this parameter contains the found item. This parameter is passed uninitialized.</param>
            <param name="checkBounds"><see langword="true"/> to return <see langword="false"/> if the <paramref name="index"/> is invalid; <see langword="false"/> to attempt getting the element via the possible interfaces without checking bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found getting member; <see langword="false"/> to suppress the exceptions thrown by the found getting member and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if <paramref name="item"/> could be retrieved; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>If <paramref name="collection"/> is neither an <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>, nor an <see cref="T:System.Collections.IList"/> implementation, then the <paramref name="collection"/> will be iterated.
            In this case the <paramref name="checkBounds"/> argument is ignored and the method returns <see langword="false"/> if the <paramref name="index"/> is invalid.</para>
            <note>This method is similar to the <see cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">Enumerable.ElementAtOrDefault</see> method.
            The main difference is that if <see cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">Enumerable.ElementAtOrDefault</see>
            returns the default value of <typeparamref name="T"/>, then it cannot be known whether the returned item existed in the collection at the specified position.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryGetElementAt(System.Collections.IEnumerable,System.Int32,System.Object@,System.Boolean,System.Boolean)">
            <summary>
            Tries to get an <paramref name="item"/> at the specified <paramref name="index"/> in the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection to retrieve the <paramref name="item"/> from.</param>
            <param name="index">The zero-based index at which <paramref name="item"/> should be returned.</param>
            <param name="item">If this method returns <see langword="true"/>, then this parameter contains the found item. This parameter is passed uninitialized.</param>
            <param name="checkBounds"><see langword="true"/> to return <see langword="false"/> if the <paramref name="index"/> is invalid; <see langword="false"/> to attempt getting the element via the possible interfaces without checking bounds. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="throwError"><see langword="true"/> to forward any exception thrown by a found getting member; <see langword="false"/> to suppress the exceptions thrown by the found getting member and return <see langword="false"/> on failure. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns><see langword="true"/> if <paramref name="item"/> could be retrieved; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>If <paramref name="collection"/> is neither an <see cref="T:System.Collections.Generic.IList`1"/> of objects, <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of objects, nor an <see cref="T:System.Collections.IList"/> implementation, then the <paramref name="collection"/> will be iterated.
            In this case the <paramref name="checkBounds"/> argument is ignored and the method returns <see langword="false"/> if the <paramref name="index"/> is invalid.</para>
            <note>This method is similar to the <see cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">Enumerable.ElementAtOrDefault</see> method.
            The main difference is that if <see cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">Enumerable.ElementAtOrDefault</see>
            returns the default value of the element type, then it cannot be known whether the returned item existed in the collection at the specified position.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryGetCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary>
            Tries to get the number of elements in the <paramref name="source"/> enumeration without enumerating it.
            </summary>
            <typeparam name="T">The type of the elements in the enumeration.</typeparam>
            <param name="source">The source to check.</param>
            <param name="count">If this method returns <see langword="true"/>, then this parameter contains the number of elements in the <paramref name="source"/> enumeration. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if the number of elements could be determined without enumeration; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method supports some public interfaces as well as some common LINQ iterators (on .NET Core/.NET platforms).</para>
            <note>This method is similar to the <see cref="!:Enumerable.TryGetNonEnumeratedCount&lt;TSource&gt;">Enumerable.TryGetNonEnumeratedCount</see> method in .NET 6 and above but can be used
            in any targeted platform and considers also <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/> implementations.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryGetCount(System.Collections.IEnumerable,System.Int32@)">
            <summary>
            Tries to get the number of elements in the <paramref name="source"/> enumeration without enumerating it.
            </summary>
            <param name="source">The source to check.</param>
            <param name="count">If this method returns <see langword="true"/>, then this parameter contains the number of elements in the <paramref name="source"/> enumeration. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if the number of elements could be determined without enumeration; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.ToCircularList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:KGySoft.Collections.CircularList`1"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a <see cref="T:KGySoft.Collections.CircularList`1"/> from.</param>
            <returns>A <see cref="T:KGySoft.Collections.CircularList`1"/> that contains elements from the input sequence.</returns>
            <remarks>
            The method forces immediate query evaluation and returns a <see cref="T:KGySoft.Collections.CircularList`1"/> that contains the query results.
            You can append this method to your query in order to obtain a cached copy of the query results.
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.ToStringKeyedDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Func{``0,``1},KGySoft.CoreLibraries.StringSegmentComparer)">
            <summary>
            Creates a <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance using the specified key and value selector delegates and a comparer.
            </summary>
            <typeparam name="TSource">The type of the elements in the <paramref name="source"/> collection.</typeparam>
            <typeparam name="TValue">The type of the value returned by the specified <paramref name="valueSelector"/>.</typeparam>
            <param name="source">The source collection to create a <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> from.</param>
            <param name="keySelector">A delegate to produce a key for each element in the <paramref name="source"/> collection.</param>
            <param name="valueSelector">A delegate to produce a value for each element in the <paramref name="source"/> collection.</param>
            <param name="comparer">A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> to compare keys. If <see langword="null"/>, then ordinal comparison will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>A <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> that contains values of type <typeparamref name="TValue"/> created by the specified <paramref name="valueSelector"/>
            for each elements in the <paramref name="source"/> collection.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.ToStringKeyedDictionary``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},KGySoft.CoreLibraries.StringSegmentComparer)">
            <summary>
            Creates a <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance using the specified <paramref name="keySelector"/> delegate and a <paramref name="comparer"/>.
            </summary>
            <typeparam name="TValue">The type of the elements in the <paramref name="source"/> collection and the type of the values in the returned <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/>.</typeparam>
            <param name="source">The source collection to create a <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> from.</param>
            <param name="keySelector">A delegate to produce a key for each element in the <paramref name="source"/> collection.</param>
            <param name="comparer">A <see cref="T:KGySoft.CoreLibraries.StringSegmentComparer"/> to compare keys. If <see langword="null"/>, then ordinal comparison will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>A <see cref="T:KGySoft.Collections.StringKeyedDictionary`1"/> that contains the same values that are in <paramref name="source"/> associated with keys returned created
            by the specified <paramref name="keySelector"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.Join``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Concatenates the items of the <paramref name="source"/> collection into a new <see cref="T:System.String">string</see> instance
            using the specified <paramref name="separator"/> between the items.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a <see cref="T:System.String">string</see> from.</param>
            <param name="separator">The separator to be used between the items. If <see langword="null"/> or empty, then the result will be concatenated without using separators.</param>
            <returns>A <see cref="T:System.String">string</see> that consists of the elements of the <paramref name="source"/> collection delimited by the specified <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.Join``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>
            Concatenates the items of the <paramref name="source"/> collection into a new <see cref="T:System.String">string</see> instance
            using the specified <paramref name="separator"/> between the items.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a <see cref="T:System.String">string</see> from.</param>
            <param name="separator">The separator to be used between the items.</param>
            <returns>A <see cref="T:System.String">string</see> that consists of the elements of the <paramref name="source"/> collection delimited by the specified <paramref name="separator"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Shuffles an enumerable <paramref name="source"/> (randomizes its elements) using the provided <paramref name="seed"/> with a new <see cref="T:KGySoft.CoreLibraries.FastRandom"/> instance.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle its elements.</param>
            <param name="seed">The seed to use for the shuffling.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that can enumerate the items of <paramref name="source"/> in a randomized order.</returns>
            <remarks>
            <note>Subsequent enumerations of the returned collection shuffles the order of the items again an again.</note>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Guid)">
            <summary>
            Shuffles an enumerable <paramref name="source"/> (randomizes its elements) using the provided <paramref name="seed"/> with a new <see cref="T:KGySoft.CoreLibraries.FastRandom"/> instance.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle its elements.</param>
            <param name="seed">A non-<see cref="F:System.Guid.Empty"/> seed to use for the shuffling.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that can enumerate the items of <paramref name="source"/> in a randomized order.</returns>
            <remarks>
            <note>Subsequent enumerations of the returned collection shuffles the order of the items again an again.</note>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="seed"/> is <see cref="F:System.Guid.Empty"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Shuffles an enumerable <paramref name="source"/> (randomizes its elements) using a new <see cref="T:KGySoft.CoreLibraries.FastRandom"/> instance.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle its elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that can enumerate the items of <paramref name="source"/> in a randomized order.</returns>
            <remarks>
            <note>Subsequent enumerations of the returned collection shuffles the order of the items again an again.</note>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Shuffles an enumerable <paramref name="source"/> (randomizes its elements) using a specified <see cref="T:System.Random"/> instance.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle its elements.</param>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that can enumerate the items of <paramref name="source"/> in a randomized order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="source"/> is <see langword="null"/>.</exception>
            <remarks>
            <note>Subsequent enumerations of the returned collection shuffles the order of the items again an again.</note>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.GetRandomElement``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Gets a random element from the enumerable <paramref name="source"/> using a new <see cref="T:KGySoft.CoreLibraries.FastRandom"/> instance.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to select an element from.</param>
            <param name="defaultIfEmpty">If <see langword="true"/> and <paramref name="source"/> is empty, the default value of <typeparamref name="T"/> is returned.
            If <see langword="false"/>, and <paramref name="source"/> is empty, an <see cref="T:System.ArgumentException"/> will be thrown. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A random element from <paramref name="source"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.GetRandomElement``1(System.Collections.Generic.IEnumerable{``0},System.Random,System.Boolean)">
            <summary>
            Gets a random element from the enumerable <paramref name="source"/> using a specified <see cref="T:System.Random"/> instance.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to select an element from.</param>
            <param name="defaultIfEmpty">If <see langword="true"/> and <paramref name="source"/> is empty, the default value of <typeparamref name="T"/> is returned.
            If <see langword="false"/>, and <paramref name="source"/> is empty, an <see cref="T:System.ArgumentException"/> will be thrown. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A random element from the <paramref name="source"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="source"/> contains no elements and <paramref name="defaultIfEmpty"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.AdjustInitializerCollection(System.Collections.IEnumerable,System.Reflection.ConstructorInfo)">
            <summary>
            Adjusts the initializer collection created by <see cref="M:KGySoft.CoreLibraries.TypeExtensions.CreateInitializerCollection(System.Type,System.Boolean)"/> after it is populated before calling the constructor.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumerableExtensions.TryReplaceRangeDefault(System.Collections.IEnumerable,System.Int32,System.Int32,System.Collections.IEnumerable,System.Boolean,System.Boolean)">
            <summary>
            Tries to remove <paramref name="count"/> amount of items from the <paramref name="target"/> at the specified <paramref name="index"/>, and
            to insert the specified <paramref name="collection"/> at the same position. The number of elements in <paramref name="collection"/> can be different from the amount of removed items.
            This method performs the replace one by one.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.EnumExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Enum"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.ToString``1(``0,KGySoft.CoreLibraries.EnumFormattingOptions,System.String)">
            <summary>
            Returns the <see cref="T:System.String"/> representation of the given <see langword="enum"/> value specified in the <paramref name="value"/> parameter.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">An <see name="Enum"/> value that has to be converted to <see cref="T:System.String"/>.</param>
            <param name="format">Formatting option. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.EnumFormattingOptions.Auto"/>.</param>
            <param name="separator">Separator in case of flags formatting. If <see langword="null"/> or is empty, then comma-space (<c>, </c>) separator is used. This parameter is optional.
            <br/>Default value: <c>, </c>.</param>
            <returns>The string representation of <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="format"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.ToString``1(``0,System.String)">
            <summary>
            Returns the <see cref="T:System.String"/> representation of the given enum <paramref name="value"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">An <see name="Enum"/> value that has to be converted to <see cref="T:System.String"/>.</param>
            <param name="separator">Separator in case of flags formatting. If <see langword="null"/> or is empty, then comma-space (", ") separator is used.</param>
            <returns>The string representation of <paramref name="value"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.GetName``1(``0)">
            <summary>
            Retrieves the name of the constant in the specified enumeration that has the specified <paramref name="value"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">The enum value whose name is required.</param>
            <returns>A string containing the name of the enumerated <paramref name="value"/>, or <see langword="null"/> if no such constant is found.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.IsDefined``1(``0)">
            <summary>
            Gets whether <paramref name="value"/> is defined in <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">A <typeparamref name="TEnum"/> value.</param>
            <returns><see langword="true"/> if <typeparamref name="TEnum"/> has a defined field that equals <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.GetDefinedOrDefault``1(``0,``0)">
            <summary>
            Returns <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, returns <paramref name="defaultValue"/>, even if it is undefined.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">A <typeparamref name="TEnum"/> value.</param>
            <param name="defaultValue">A <typeparamref name="TEnum"/> value to return if <paramref name="value"/>
            is not defined in <typeparamref name="TEnum"/>. It does not needed to be a defined value. This parameter is optional.
            <br/>Default value: The bitwise zero value of <typeparamref name="TEnum"/>.</param>
            <returns><paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>;
            otherwise, <paramref name="defaultValue"/>, even if it is undefined.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.GetDefinedOrNull``1(``0)">
            <summary>
            Returns <paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>; otherwise, returns <see langword="null"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">A <typeparamref name="TEnum"/> value.</param>
            <returns><paramref name="value"/> if it is defined in <typeparamref name="TEnum"/>; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.AllFlagsDefined``1(``0)">
            <summary>
            Gets whether every single bit value in <paramref name="flags"/> are defined in the <typeparamref name="TEnum"/> type,
            or, when <paramref name="flags"/> is zero, it is checked whether zero is defined in <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="flags"/>.</typeparam>
            <param name="flags">A flags enum value, whose flags should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/>.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is a zero value and zero is defined,
            or if <paramref name="flags"/> is nonzero and its every bit has a defined name.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.HasFlag``1(``0,``0)">
            <summary>
            Gets whether the bits that are set in the <paramref name="flags"/> parameter are set in the specified <paramref name="value"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">An enumeration value of <typeparamref name="TEnum"/> type.</param>
            <param name="flags">A flags enum value, whose flags should be checked. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/> and whether all bits that are set are defined in the <typeparamref name="TEnum"/> type.</param>
            <returns><see langword="true"/>, if <paramref name="flags"/> is zero, or when the bits that are set in <paramref name="flags"/> are set in <paramref name="value"/>;
            otherwise, <see langword="false"/>.</returns>
            <remarks>
            <note>Always specify the <typeparamref name="TEnum"/> generic argument when use this method; otherwise, in .NET 4.0 and above the less performant <see cref="M:System.Enum.HasFlag(System.Enum)"/> method will be used.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.IsSingleFlag``1(``0)">
            <summary>
            Gets whether only a single bit is set in <paramref name="value"/>. It is not checked, whether this flag is defined in <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if only a single bit is set in <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.GetFlags``1(``0,System.Boolean)">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> enumeration of <paramref name="flags"/>,
            where each flags are returned as distinct values.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="flags"/>.</typeparam>
            <param name="flags">A flags enum value, whose flags should be returned. It is not checked whether <typeparamref name="TEnum"/>
            is really marked by <see cref="T:System.FlagsAttribute"/>.</param>
            <param name="onlyDefinedValues"><see langword="true"/> to return only flags that are defined in <typeparamref name="TEnum"/>;
            <see langword="false"/> to return also undefined flags. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A lazy-enumerated <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance containing each flags of <paramref name="flags"/> as distinct values.</returns>
            <remarks>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.GetFlagsCount``1(``0)">
            <summary>
            Gets the number of bits set in <paramref name="value"/>.
            It is not checked, whether all flags are defined in <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>&#160;<paramref name="value"/>.</typeparam>
            <param name="value">The value to check.</param>
            <returns>The number of bits set in <paramref name="value"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.AllFlagsDefined(System.Enum)">
            <summary>
            Gets whether every single bit value in <paramref name="flags"/> are defined in the <see langword="enum"/> type of <paramref name="flags"/>,
            or when <paramref name="flags"/> is zero, it is checked whether zero is defined in the <see langword="enum"/> type of <paramref name="flags"/>.
            </summary>
            <param name="flags">The <see langword="enum"/> value.</param>
            <returns><c>true</c>, if <paramref name="flags"/> is a zero value and zero is defined,
            or if <paramref name="flags"/> is nonzero and its every bit has a defined name.</returns>
            <remarks><note>For better performance use the generic <see cref="M:KGySoft.CoreLibraries.EnumExtensions.AllFlagsDefined``1(``0)">AllFlagsDefined</see> overload whenever it is possible.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.EnumExtensions.IsSingleFlag(System.Enum)">
            <summary>
            Gets whether only a single bit is set in <paramref name="value"/>.
            </summary>
            <param name="value">The value to check.</param>
            <returns><c>true</c>, if only a single bit is set in <paramref name="value"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.FloatExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Single">float</see> type.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.FloatExtensions.NegativeZero">
            <summary>
            Represents the negative zero value. This value is constant.
            </summary>
            <remarks>The value of this constant is <c>-0.0</c>.</remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FloatExtensions.ToRoundtripString(System.Single)">
            <summary>
            Returns a culture-invariant <see cref="T:System.String"/> representation of the given <see cref="T:System.Single"/>&#160;<paramref name="value"/>,
            from which the original value can be parsed without losing any information.
            </summary>
            <param name="value">A <see cref="T:System.Single"/> value to be converted to <see cref="T:System.String"/>.</param>
            <returns>A <see cref="T:System.Single"/> value, from which the original value can be parsed without losing any information.</returns>
            <remarks>
            The result of this method can be parsed by <see cref="M:System.Single.Parse(System.String,System.IFormatProvider)">Float.Parse</see>; however, to retrieve exactly the
            original value, including a negative zero value, use the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)">Parse</see>&#160;<see cref="T:System.String"/> extension method instead.
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.FloatExtensions.IsNegativeZero(System.Single)">
            <summary>
            Gets whether the specified <paramref name="value"/> is negative zero.
            </summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/>, if <paramref name="value"/> represents a negative zero value; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FloatExtensions.TolerantIsZero(System.Single,System.Single)">
            <summary>
            Gets whether the specified <paramref name="value"/> can be considered zero using a specific <paramref name="tolerance"/>.
            </summary>
            <param name="value">The value to be check.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but the reasonable value is between 0 and 0.5. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns><see langword="true"/> if <paramref name="value"/> can be considered zero using the specified <paramref name="tolerance"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FloatExtensions.TolerantEquals(System.Single,System.Single,System.Single)">
            <summary>
            Gets whether two <see cref="T:System.Single">float</see> values are equal considering the specified <paramref name="tolerance"/>.
            </summary>
            <param name="value">The value to be compared to another one.</param>
            <param name="other">The other value compared to the self <paramref name="value"/>.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but it should be some low positive value to get a reasonable result. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns><see langword="true"/>, if the values are equal considering the specified <paramref name="tolerance"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FloatExtensions.TolerantCeiling(System.Single,System.Single)">
            <summary>
            Gets the ceiling of the specified <paramref name="value"/> using a specific <paramref name="tolerance"/>.
            That is the closest integral number to <paramref name="value"/> if the difference from that is not larger than <paramref name="tolerance"/>;
            otherwise, the smallest integral value that is greater than <paramref name="value"/>.
            </summary>
            <param name="value">The value, whose ceiling is abut to be retrieved.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but the reasonable value is between 0 and 0.5. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns>The ceiling of the specified <paramref name="value"/> using the specified <paramref name="tolerance"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.FloatExtensions.TolerantFloor(System.Single,System.Single)">
            <summary>
            Gets the floor of the specified <paramref name="value"/> using a specific <paramref name="tolerance"/>.
            That is the closest integral number to <paramref name="value"/> if the difference from that is not larger than <paramref name="tolerance"/>;
            otherwise, the largest integral value that is less than <paramref name="value"/>.
            </summary>
            <param name="value">The value, whose floor is abut to be retrieved.</param>
            <param name="tolerance">The tolerance to be used. For the best performance its value is not checked but the reasonable value is between 0 and 0.5. This parameter is optional.
            <br/>Default value: <c>0.000001</c> (10<sup>-6</sup>).</param>
            <returns>The floor of the specified <paramref name="value"/> using the specified <paramref name="tolerance"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.ListExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Collections.Generic.IList`1"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.ListExtensions.AsThreadSafe``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a <see cref="T:KGySoft.Collections.LockingList`1"/>, which provides a thread-safe wrapper for the specified <paramref name="list"/>.
            This only means that if the members are accessed through the returned <see cref="T:KGySoft.Collections.LockingList`1"/>, then the inner state of the wrapped list remains always consistent and not that all of the multi-threading concerns can be ignored.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Collections.LockingList`1"/> class for details and some examples.
            </summary>
            <typeparam name="T">The type of the elements in the list.</typeparam>
            <param name="list">The list to create a thread-safe wrapper for.</param>
            <returns>A <see cref="T:KGySoft.Collections.LockingCollection`1"/>, which provides a thread-safe wrapper for the specified <paramref name="list"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ListExtensions.InsertRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Inserts a <paramref name="collection"/> into the <paramref name="target"/>&#160;<see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="target">The target collection.</param>
            <param name="index">The zero-based index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="collection">The collection to insert into the <paramref name="target"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> or <paramref name="collection"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <remarks>
            <note>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> implementation,
            then the elements of <paramref name="collection"/> will be inserted one by one.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ListExtensions.RemoveRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Removes <paramref name="count"/> amount of items from the specified <paramref name="collection"/> at the specified <paramref name="index"/>.
            </summary>
            <typeparam name="T">The type of the elements in the <paramref name="collection"/>.</typeparam>
            <param name="collection">The list to remove the elements from.</param>
            <param name="index">The zero-based index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.
            <br/>-or-
            <br/><paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> and <paramref name="count"/> do not denote a valid range of elements in the list.</exception>
            <remarks>
            <note>If <paramref name="collection"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> nor an <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> implementation,
            then the elements will be removed one by one.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ListExtensions.ReplaceRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Removes <paramref name="count"/> amount of items from the <paramref name="target"/>&#160;<see cref="T:System.Collections.Generic.IList`1"/> at the specified <paramref name="index"/>, and
            inserts the specified <paramref name="collection"/> at the same position. The number of elements in <paramref name="collection"/> can be different from the amount of removed items.
            </summary>
            <typeparam name="T">The type of the elements in the collections.</typeparam>
            <param name="target">The target collection.</param>
            <param name="index">The zero-based index of the first item to remove and also the index at which <paramref name="collection"/> items should be inserted.</param>
            <param name="count">The number of items to remove.</param>
            <param name="collection">The collection to insert into the <paramref name="target"/> list.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> or <paramref name="collection"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:KGySoft.Collections.CircularList`1"/>.</exception>
            <remarks>
            <note>If <paramref name="target"/> is neither a <see cref="T:System.Collections.Generic.List`1"/> or an <see cref="T:KGySoft.Collections.ISupportsRangeList`1"/> implementation,
            then after overwriting the elements of the overlapping range, the difference will be removed or inserted one by one.</note>
            </remarks>
        </member>
        <member name="T:KGySoft.CoreLibraries.ObjectExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Object"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.In(System.Object,System.Object[])">
            <summary>
            Gets whether <paramref name="item"/> is among the elements of <paramref name="set"/>.
            <br/>See the <strong>Examples</strong> section of the generic <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,``0[])"/> overload for an example.
            </summary>
            <param name="item">The item to search for in <paramref name="set"/>.</param>
            <param name="set">The set of items in which to search the specified <paramref name="item"/>.</param>
            <returns><see langword="true"/> if <paramref name="item"/> is among the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method works similarly to the <c>in</c> operator in SQL and Pascal.</para>
            <para>This overload uses <see cref="M:System.Object.Equals(System.Object,System.Object)">Object.Equals</see> method to compare the items.
            <note>For better performance use the generic <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,``0[])"/> or <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,System.Func{``0}[])"/> methods whenever possible.</note></para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,``0[])">
            <summary>
            Gets whether <paramref name="item"/> is among the elements of <paramref name="set"/>.
            </summary>
            <param name="item">The item to search for in <paramref name="set"/>.</param>
            <param name="set">The set of items in which to search the specified <paramref name="item"/>.</param>
            <typeparam name="T">The type of <paramref name="item"/> and the <paramref name="set"/> elements.</typeparam>
            <returns><see langword="true"/> if <paramref name="item"/> is among the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method works similarly to the <c>in</c> operator in SQL and Pascal.</para>
            <para>This overload uses generic <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementations to compare the items for the best performance.
            <note>If elements of <paramref name="set"/> are complex expressions consider to use the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,System.Func{``0}[])"/> overload instead to prevent evaluating all elements until they are actually compared.</note></para>
            </remarks>
            <example>
            <code lang="C#"><![CDATA[
            using System;
            using KGySoft.CoreLibraries;
            
            public class Example
            {
                public static void Main()
                {
                    string stringValue = "blah";
            
                    // standard way:
                    if (stringValue == "something" || stringValue == "something else" || stringValue == "maybe some other value" || stringValue == "or...")
                        DoSomething();
            
                    // In method:
                    if (stringValue.In("something", "something else", "maybe some other value", "or..."))
                        DoSomething();
                }
            }]]></code>
            </example>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,System.ReadOnlySpan{``0})">
            <summary>
            Gets whether <paramref name="item"/> is among the elements of <paramref name="set"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,``0[])"/> overload for an example.
            </summary>
            <param name="item">The item to search for in <paramref name="set"/>.</param>
            <param name="set">The set of items in which to search the specified <paramref name="item"/>.</param>
            <typeparam name="T">The type of <paramref name="item"/> and the <paramref name="set"/> elements.</typeparam>
            <returns><see langword="true"/> if <paramref name="item"/> is among the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method works similarly to the <c>in</c> operator in SQL and Pascal.</para>
            <para>This overload uses generic <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementations to compare the items for the best performance.
            <note>If elements of <paramref name="set"/> are complex expressions consider to use the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,System.Func{``0}[])"/> overload instead to prevent evaluating all elements until they are actually compared.</note></para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,System.Func{``0}[])">
            <summary>
            Gets whether <paramref name="item"/> is among the results of <paramref name="set"/>.
            </summary>
            <param name="item">The item to search for in the results of <paramref name="set"/>.</param>
            <param name="set">The set of delegates, whose results are checked whether they are equal to the specified <paramref name="item"/>.</param>
            <typeparam name="T">The type of <paramref name="item"/> and the <paramref name="set"/> elements.</typeparam>
            <returns><see langword="true"/> if <paramref name="item"/> is among the results of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>This method works similarly to the <c>in</c> operator in SQL and Pascal.</para>
            <para>This overload uses generic <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementations to compare the items for the best performance.
            The elements of <paramref name="set"/> are evaluated only when they are actually compared so if a result is found the rest of the elements will not be evaluated.
            <note>If elements of <paramref name="set"/> are constants or simple expressions consider to use the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,``0[])"/> overload to eliminate the overhead of delegate invokes.</note></para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets whether <paramref name="item"/> is among the results of <paramref name="set"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.In``1(``0,``0[])"/> overload for an example.
            </summary>
            <param name="item">The item to search for in the results of <paramref name="set"/>.</param>
            <param name="set">The set of items in which to search the specified <paramref name="item"/>.</param>
            <typeparam name="T">The type of <paramref name="item"/> and the <paramref name="set"/> elements.</typeparam>
            <returns><see langword="true"/> if <paramref name="item"/> is among the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.DeepClone``1(``0,System.Boolean)">
            <summary>
            Clones an object by deep cloning.
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="obj">The object to clone.</param>
            <param name="ignoreCustomSerialization"><see langword="true"/> to ignore <see cref="T:System.Runtime.Serialization.ISerializable"/> and <see cref="T:System.Runtime.Serialization.IObjectReference"/> implementations
            as well as serialization constructors and serializing methods; <see langword="false"/> to consider all of these techniques instead of performing a forced
            field-based serialization. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The functionally equivalent clone of the object.</returns>
            <remarks>
            <note><strong>Obsolete Note:</strong> This overload uses the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> internally, which is not always applicable.
            It is recommended to use the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.DeepClone``1(``0,System.Func{System.Object,System.Object})"/> overload instead.</note>
            <para>This method makes possible to clone objects even if their type is not marked by the <see cref="T:System.SerializableAttribute"/>; however,
            in such case it is not guaranteed that the result is functionally equivalent to the input object.</para>
            <note type="warning">In .NET Core there are some types that implement the <see cref="T:System.Runtime.Serialization.ISerializable"/> interface, though they are not serializable.
            In such cases the cloning attempt typically throws a <see cref="T:System.PlatformNotSupportedException"/>. To clone such objects the <paramref name="ignoreCustomSerialization"/>
            parameter should be <see langword="true"/>.</note>
            <para>If <paramref name="ignoreCustomSerialization"/> is <see langword="false"/>, then it is not guaranteed that the object can be cloned in all circumstances (see the note above).</para>
            <para>On the other hand, if <paramref name="ignoreCustomSerialization"/> is <see langword="true"/>, then it can happen that even singleton types will be deep cloned.
            The cloning is performed by the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class, which supports some singleton types natively (such as <see cref="T:System.Type"/> and <see cref="T:System.DBNull"/>),
            which will be always cloned correctly.</para>
            <para>In .NET Framework remote objects are cloned in a special way and the result is always a local object.
            The <paramref name="ignoreCustomSerialization"/> parameter is ignored for remote objects.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.DeepClone``1(``0,System.Func{System.Object,System.Object})">
            <summary>
            Clones an object by deep cloning.
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="obj">The object to clone.</param>
            <param name="customClone">An optional delegate that can be used to customize the cloning of individual instances.
            If specified, then it is always called with a non-<see langword="null"/> instance.
            If it returns <see langword="null"/>, then the input object will be cloned by using the default logic.</param>
            <returns>The clone of the object.</returns>
            <remarks>
            <para>If <paramref name="customClone"/> is <see langword="null"/>, then this method returns a functionally equivalent clone of the original object.</para>
            <para><see cref="T:System.String"/>, <see cref="T:System.Delegate"/> and runtime <see cref="T:System.Type"/> instances are not cloned but their original reference is returned in the result.
            This can be overridden by handling these types in <paramref name="customClone"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.Convert``1(System.Object,System.Globalization.CultureInfo)">
             <summary>
             Converts an <see cref="T:System.Object"/> specified in the <paramref name="obj"/> parameter to the desired <typeparamref name="TTarget"/>.
             </summary>
             <typeparam name="TTarget">The desired type of the return value.</typeparam>
             <param name="obj">The object to convert.</param>
             <param name="culture">The culture to use for the conversion. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used. This parameter is optional.
             <br/>Default value: <see langword="null"/>.</param>
             <returns>An object of <typeparamref name="TTarget"/>, which is the result of the conversion.</returns>
             <exception cref="T:System.ArgumentException"><paramref name="obj"/> cannot be converted to <typeparamref name="TTarget"/>.</exception>
             <remarks>
             <para>The method firstly tries to use registered direct conversions between source and target types, then attempts to perform the conversion via <see cref="T:System.IConvertible"/> types and registered <see cref="T:System.ComponentModel.TypeConverter"/>s.
             If these attempts fail, then the registered conversions tried to be used for intermediate steps, if possible. As an ultimate fallback, the <see cref="T:System.String"/> type is attempted to be used as intermediate conversion.</para>
             <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
             <para>A <see cref="T:System.ComponentModel.TypeConverter"/> can be registered by the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterTypeConverter``1(System.Type)">RegisterTypeConverter</see> extension method.</para>
             <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/>,
             then conversions from <see cref="T:System.DateTime"/> to <see cref="T:System.Double"/> becomes automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
             <para><typeparamref name="TTarget"/> can be even a collection type if <paramref name="obj"/> is also an <see cref="T:System.Collections.IEnumerable"/> implementation.
             The target collection type must have either a default constructor or a constructor that can accept a list, array or dictionary as an initializer collection.</para>
             </remarks>
             <example>
             <note type="tip">Try also <a href="https://dotnetfiddle.net/rzg8If" target="_blank">online</a>.</note>
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections;
             using System.Collections.Generic;
             using System.Collections.ObjectModel;
             using System.Linq;
            
             using KGySoft.CoreLibraries;
             
             public class Example
             {
                 public static void Main()
                 {
                     // between convertible types: like the Convert class but supports also enums in both ways
                     ConvertTo<int>("123"); // culture can be specified, default is InvariantCulture
                     ConvertTo<float>(ConsoleColor.Blue);
                     ConvertTo<ConsoleColor>(13); // this would fail by Convert.ChangeType
            
                     // TypeConverters are used if possible:
                     ConvertTo<Guid>("AADC78003DAB4906826EFD8B2D5CF33D");
            
                     // As a fallback, string is used as an intermediate step
                     ConvertTo<DateTimeOffset>(DateTime.Now); // DateTime -> string -> DateTimeOffset
            
                     // Collection conversion is also supported:
                     ConvertTo<bool[]>(new List<int> { 1, 0, 0, 1 });
                     ConvertTo<List<int>>("Blah"); // works because string is an IEnumerable<char>
                     ConvertTo<string>(new[] { 'h', 'e', 'l', 'l', 'o' }); // because string has a char[] constructor
                     ConvertTo<ReadOnlyCollection<string>>(new[] { 1.0m, 2, -1 }); // via the IList<T> constructor
            
                     // even between non-generic collections:
                     ConvertTo<ArrayList>(new HashSet<int> { 1, 2, 3 });
                     ConvertTo<Dictionary<ConsoleColor, string>>(new Hashtable { { 1, "One" }, { "Black", 'x' } });
            
                     // New conversions can be registered:
                     ConvertTo<long>(DateTime.Now); // fail
                     typeof(DateTime).RegisterConversion(typeof(long), (obj, type, culture) => ((DateTime)obj).Ticks);
                     ConvertTo<long>(DateTime.Now); // success
            
                     // Registered conversions can be used as intermediate steps:
                     ConvertTo<double>(DateTime.Now); // DateTime -> long -> double
                 }
            
                 private static void ConvertTo<T>(object source)
                 {
                     Console.Write($"{source.GetType().GetName(TypeNameKind.ShortName)} => {typeof(T).GetName(TypeNameKind.ShortName)}: {AsString(source)} => ");
                     try
                     {
                         T result = source.Convert<T>(); // a culture can be specified here for string conversions
                         Console.WriteLine(AsString(result));
                     }
                     catch (Exception e)
                     {
                         Console.WriteLine(e.Message.Replace(Environment.NewLine, " "));
                     }
                 }
            
                 private static string AsString(object obj)
                 {
                     if (obj == null)
                         return "<null>";
            
                     // KeyValuePair has a similar ToString to this one
                     if (obj is DictionaryEntry de)
                         return $"[{de.Key}, {de.Value}]";
            
                     if (obj is not IEnumerable || obj is string)
                         return obj.ToString();
            
                     return ((IEnumerable)obj).Cast<object>().Select(AsString).Join(", ");
                 }
             }
             
             // This example produces the following output:
             // String => Int32: 123 => 123
             // ConsoleColor => Single: Blue => 9
             // Int32 => ConsoleColor: 13 => Magenta
             // String => Guid: AADC78003DAB4906826EFD8B2D5CF33D => aadc7800-3dab-4906-826e-fd8b2d5cf33d
             // DateTime => DateTimeOffset: 10/11/2021 7:45:46 PM => 10/11/2021 7:45:46 PM +02:00
             // List`1[Int32] => Boolean[]: 1, 0, 0, 1 => True, False, False, True
             // String => List`1[Int32]: Blah => 66, 108, 97, 104
             // Char[] => String: h, e, l, l, o => hello
             // Decimal[] => ReadOnlyCollection`1[String]: 1.0, 2, -1 => 1.0, 2, -1
             // HashSet`1[Int32] => ArrayList: 1, 2, 3 => 1, 2, 3
             // Hashtable => Dictionary`2[ConsoleColor,String]: [1, One], [Black, x] => [DarkBlue, One], [Black, x]
             // DateTime => Int64: 10/11/2021 7:45:46 PM => The specified argument cannot be converted to type System.Int64. Parameter name: obj
             // DateTime => Int64: 10/11/2021 7:45:46 PM => 637695783464721787
             // DateTime => Double: 10/11/2021 7:45:46 PM => 6.37695783464721787E+17]]></code>
             </example>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.Convert(System.Object,System.Type,System.Globalization.CultureInfo)">
            <summary>
            Converts an <see cref="T:System.Object"/> specified in the <paramref name="obj"/> parameter to the desired <paramref name="targetType"/>.
            <br/>See the <strong>Examples</strong> section of the generic <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.Convert``1(System.Object,System.Globalization.CultureInfo)"/> overload for an example.
            </summary>
            <param name="targetType">The desired type of the return value.</param>
            <param name="obj">The object to convert.</param>
            <param name="culture">The culture to use for the conversion. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An object of <paramref name="targetType"/>, which is the result of the conversion.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> cannot be converted to <paramref name="targetType"/>.</exception>
            <remarks>
            <para>The method firstly tries to use registered direct conversions between source and target types, then attempts to perform the conversion via <see cref="T:System.IConvertible"/> types and registered <see cref="T:System.ComponentModel.TypeConverter"/>s.
            If these attempts fail, then the registered conversions tried to be used for intermediate steps, if possible. As an ultimate fallback, the <see cref="T:System.String"/> type is attempted to be used as intermediate conversion.</para>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/>,
            then conversions from <see cref="T:System.DateTime"/> to <see cref="T:System.Double"/> becomes automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            <para><paramref name="targetType"/> can be even a collection type if <paramref name="obj"/> is also an <see cref="T:System.Collections.IEnumerable"/> implementation.
            The target collection type must have either a default constructor or a constructor that can accept a list, array or dictionary as an initializer collection.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.TryConvert``1(System.Object,System.Globalization.CultureInfo,``0@)">
            <summary>
            Tries to convert an <see cref="T:System.Object"/> specified in the <paramref name="obj"/> parameter to the desired <typeparamref name="TTarget"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.Convert``1(System.Object,System.Globalization.CultureInfo)"/> method for a related example.
            </summary>
            <typeparam name="TTarget">The desired type of the returned <paramref name="value"/>.</typeparam>
            <param name="obj">The object to convert.</param>
            <param name="culture">The culture to use for the conversion. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the conversion.</param>
            <returns><see langword="true"/>, if <paramref name="obj"/> could be converted to <typeparamref name="TTarget"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The method firstly tries to use registered direct conversions between source and target types, then attempts to perform the conversion via <see cref="T:System.IConvertible"/> types and registered <see cref="T:System.ComponentModel.TypeConverter"/>s.
            If these attempts fail, then the registered conversions tried to be used for intermediate steps, if possible. As an ultimate fallback, the <see cref="T:System.String"/> type is attempted to be used as intermediate conversion.</para>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/>,
            then conversions from <see cref="T:System.DateTime"/> to <see cref="T:System.Double"/> becomes automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.TryConvert``1(System.Object,``0@)">
            <summary>
            Tries to convert an <see cref="T:System.Object"/> specified in the <paramref name="obj"/> parameter to the desired <typeparamref name="TTarget"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.Convert``1(System.Object,System.Globalization.CultureInfo)"/> method for a related example.
            </summary>
            <typeparam name="TTarget">The desired type of the returned <paramref name="value"/>.</typeparam>
            <param name="obj">The object to convert.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the conversion.</param>
            <returns><see langword="true"/>, if <paramref name="obj"/> could be converted to <typeparamref name="TTarget"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The method firstly tries to use registered direct conversions between source and target types, then attempts to perform the conversion via <see cref="T:System.IConvertible"/> types and registered <see cref="T:System.ComponentModel.TypeConverter"/>s.
            If these attempts fail, then the registered conversions tried to be used for intermediate steps, if possible. As an ultimate fallback, the <see cref="T:System.String"/> type is attempted to be used as intermediate conversion.</para>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/>,
            then conversions from <see cref="T:System.DateTime"/> to <see cref="T:System.Double"/> becomes automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.TryConvert(System.Object,System.Type,System.Object@)">
            <summary>
            Tries to convert an <see cref="T:System.Object"/> specified in the <paramref name="obj"/> parameter to the desired <paramref name="targetType"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.Convert``1(System.Object,System.Globalization.CultureInfo)"/> method for a related example.
            </summary>
            <param name="obj">The object to convert.</param>
            <param name="targetType">The desired type of the returned <paramref name="value"/>.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the conversion.</param>
            <returns><see langword="true"/>, if <paramref name="obj"/> could be converted to <paramref name="targetType"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The method firstly tries to use registered direct conversions between source and target types, then attempts to perform the conversion via <see cref="T:System.IConvertible"/> types and registered <see cref="T:System.ComponentModel.TypeConverter"/>s.
            If these attempts fail, then the registered conversions tried to be used for intermediate steps, if possible. As an ultimate fallback, the <see cref="T:System.String"/> type is attempted to be used as intermediate conversion.</para>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/>,
            then conversions from <see cref="T:System.DateTime"/> to <see cref="T:System.Double"/> becomes automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.TryConvert(System.Object,System.Type,System.Globalization.CultureInfo,System.Object@)">
            <summary>
            Tries to convert an <see cref="T:System.Object"/> specified in the <paramref name="obj"/> parameter to the desired <paramref name="targetType"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.Convert``1(System.Object,System.Globalization.CultureInfo)"/> method for a related example.
            </summary>
            <param name="obj">The object to convert.</param>
            <param name="targetType">The desired type of the returned <paramref name="value"/>.</param>
            <param name="culture">The culture to use for the conversion. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the conversion.</param>
            <returns><see langword="true"/>, if <paramref name="obj"/> could be converted to <paramref name="targetType"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>The method firstly tries to use registered direct conversions between source and target types, then attempts to perform the conversion via <see cref="T:System.IConvertible"/> types and registered <see cref="T:System.ComponentModel.TypeConverter"/>s.
            If these attempts fail, then the registered conversions tried to be used for intermediate steps, if possible. As an ultimate fallback, the <see cref="T:System.String"/> type is attempted to be used as intermediate conversion.</para>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/>,
            then conversions from <see cref="T:System.DateTime"/> to <see cref="T:System.Double"/> becomes automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.ObjectExtensions.ToStringInternal(System.Object,System.Globalization.CultureInfo)">
            <summary>
            This is the inverse operation for the public <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse(System.String,System.Type,System.Globalization.CultureInfo)"/> method for natively supported types.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.RandomExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Random"/> type.
            </summary>
            <example>
            <note type="tip">Try also <a href="https://dotnetfiddle.net/EPHRIx" target="_blank">online</a>.</note>
            <code lang="C#"><![CDATA[
            using System;
            using System.Collections;
            using System.Collections.Generic;
            using System.Globalization;
            using System.Linq;
            using System.Reflection;
            using KGySoft.CoreLibraries;
            
            public static class Example
            {
                public static void Main()
                {
                    // Or FastRandom for the fastest results, or SecureRandom for cryptographically safe results.
                    var rnd = new Random();
            
                    // Next... for all simple types:
                    Console.WriteLine(rnd.NextBoolean());
                    Console.WriteLine(rnd.NextDouble(Double.PositiveInfinity)); // see also the overloads
                    Console.WriteLine(rnd.NextString()); // see also the overloads
                    Console.WriteLine(rnd.NextDateTime()); // also NextDate, NextDateTimeOffset, NextTimeSpan
                    Console.WriteLine(rnd.NextEnum<ConsoleColor>());
                    // and NextByte, NextSByte, NextInt16, NextDecimal, etc.
            
                    // NextObject: for practically anything. See also GenerateObjectSettings.
                    Console.WriteLine(rnd.NextObject<Person>().Dump()); // custom type
                    Console.WriteLine(rnd.NextObject<(int, string)>()); // tuple
                    Console.WriteLine(rnd.NextObject<IConvertible>()); // interface implementation
                    Console.WriteLine(rnd.NextObject<MarshalByRefObject>()); // abstract type implementation
                    Console.WriteLine(rnd.NextObject<int[]>().Dump()); // array
                    Console.WriteLine(rnd.NextObject<IList<IConvertible>>().Dump()); // some collection of an interface
                    Console.WriteLine(rnd.NextObject<Func<DateTime>>().Invoke()); // delegate with random result
            
                    // specific type for object (useful for non-generic collections)
                    Console.WriteLine(rnd.NextObject<ArrayList>(new GenerateObjectSettings
                    {
                        SubstitutionForObjectType = typeof(ConsoleColor)
                    }).Dump());
            
                    // literally any random object
                    Console.WriteLine(rnd.NextObject<object>(new GenerateObjectSettings
                    {
                        AllowDerivedTypesForNonSealedClasses = true
                    })/*.Dump()*/); // dump may end up in an exception for property getters or even in an endless recursion
                }
            
                private static string Dump(this object o)
                {
                    if (o == null)
                        return "<null>";
            
                    if (o is IConvertible convertible)
                        return convertible.ToString(CultureInfo.InvariantCulture);
            
                    if (o is IEnumerable enumerable)
                        return $"[{String.Join(", ", enumerable.Cast<object>().Select(Dump))}]";
            
                    return $"{{{String.Join("; ", o.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance).Select(p => $"{p.Name} = {Dump(p.GetValue(o))}"))}}}";
                }
            }
            
            public class Person
            {
                public string FirstName { get; set; }
                public string LastName { get; set; }
                public DateTime BirthDate { get; set; }
                public List<string> PhoneNumbers { get; set; }
            }
            
            // A possible output of the code above can be the following:
            // False
            // 1,65543763243888E+266
            // }\&qc54# d
            // 8806. 02. 18. 6:25:21
            // White
            // {FirstName = Jemp; LastName = Aeltep; BirthDate = 07/04/2003 00:00:00; PhoneNumbers = [17251827, 7099649772]}
            // (1168349297, oufos)
            // Renegotiated
            // System.Net.Sockets.NetworkStream
            // [336221768]
            // [Off, Invalid]
            // 1956. 08. 24. 4:28:57
            // [Yellow, Gray]
            // System.Xml.XmlCharCheckingReader+<ReadElementContentAsBinHexAsync>d__40 *
            ]]></code>
            </example>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextBytes(System.Random,System.Int32)">
            <summary>
            Returns an <see cref="T:System.Array"/> of random bytes that has the specified <paramref name="length"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="length">The desired length of the result.</param>
            <returns>An array of random bytes that has the specified <paramref name="length"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextBoolean(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A <see cref="T:System.Boolean"/> value that is either <see langword="true"/> or <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleSByte(System.Random)">
            <summary>
            Returns a random <see cref="T:System.SByte"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>An 8-bit signed integer that is greater than or equal to <see cref="F:System.SByte.MinValue">SByte.MinValue</see> and less than or equal to <see cref="F:System.SByte.MaxValue">SByte.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextSByte(System.Random)">
            <summary>
            Returns a non-negative random 8-bit signed integer that is less than <see cref="F:System.SByte.MaxValue">SByte.MaxValue</see>.
            To return any <see cref="T:System.SByte"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleSByte(System.Random)">SampleSByte</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>An 8-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.SByte.MaxValue">SByte.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextSByte(System.Random,System.SByte,System.Boolean)">
            <summary>
            Returns a non-negative random 8-bit signed integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An 8-bit signed integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextSByte(System.Random,System.SByte,System.SByte,System.Boolean)">
            <summary>
            Returns a random 8-bit signed integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An 8-bit signed integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleByte(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Byte"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>An 8-bit unsigned integer that is greater than or equal to 0 and less than or equal to <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextByte(System.Random)">
            <summary>
            Returns a random 8-bit unsigned integer that is less than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.
            To return any <see cref="T:System.Byte"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleByte(System.Random)">SampleByte</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>An 8-bit unsigned integer that is greater than or equal to 0 and less than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextByte(System.Random,System.Byte,System.Boolean)">
            <summary>
            Returns a random 8-bit unsigned integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An 8-bit unsigned integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextByte(System.Random,System.Byte,System.Byte,System.Boolean)">
            <summary>
            Returns a random 8-bit unsigned integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>An 8-bit unsigned integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt16(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Int16"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 16-bit signed integer that is greater than or equal to <see cref="F:System.Int16.MinValue">Int16.MinValue</see> and less than or equal to <see cref="F:System.Int16.MaxValue">Int16.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt16(System.Random)">
            <summary>
            Returns a non-negative random 16-bit signed integer that is less than <see cref="F:System.Int16.MaxValue">Int16.MaxValue</see>.
            To return any <see cref="T:System.Int16"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt16(System.Random)">SampleInt16</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 16-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int16.MaxValue">Int16.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt16(System.Random,System.Int16,System.Boolean)">
            <summary>
            Returns a non-negative random 16-bit signed integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 16-bit signed integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt16(System.Random,System.Int16,System.Int16,System.Boolean)">
            <summary>
            Returns a random 16-bit signed integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 16-bit signed integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleUInt16(System.Random)">
            <summary>
            Returns a random <see cref="T:System.UInt16"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 16-bit unsigned integer that is greater than or equal to 0 and less than or equal to <see cref="F:System.UInt16.MaxValue">UInt16.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt16(System.Random)">
            <summary>
            Returns a random 16-bit unsigned integer that is less than <see cref="F:System.UInt16.MaxValue">UInt16.MaxValue</see>.
            To return any <see cref="T:System.UInt16"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleUInt16(System.Random)">SampleUInt16</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 16-bit unsigned integer that is greater than or equal to 0 and less than <see cref="F:System.UInt16.MaxValue">UInt16.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt16(System.Random,System.UInt16,System.Boolean)">
            <summary>
            Returns a random 16-bit unsigned integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 16-bit unsigned integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt16(System.Random,System.UInt16,System.UInt16,System.Boolean)">
            <summary>
            Returns a random 16-bit unsigned integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 16-bit unsigned integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt32(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Int32"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 32-bit signed integer that is greater than or equal to <see cref="F:System.Int32.MinValue">Int32.MinValue</see> and less than or equal to <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</returns>
            <remarks>Similarly to the <see cref="M:System.Random.Next">Random.Next()</see> method this one returns an <see cref="T:System.Int32"/> value; however, the result can be negative and
            the maximum possible value can be <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt32(System.Random)">
            <summary>
            Returns a non-negative random 32-bit signed integer that is less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.
            To return any <see cref="T:System.Int32"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt32(System.Random)">SampleInt32</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt32(System.Random,System.Int32,System.Boolean)">
            <summary>
            Returns a non-negative random 32-bit signed integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt32(System.Random,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns a random 32-bit signed integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 64-bit signed integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleUInt32(System.Random)">
            <summary>
            Returns a random <see cref="T:System.UInt32"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 32-bit unsigned integer that is greater than or equal to 0 and less than or equal to <see cref="F:System.UInt32.MaxValue">UInt32.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt32(System.Random)">
            <summary>
            Returns a random 32-bit unsigned integer that is less than <see cref="F:System.UInt32.MaxValue">UInt32.MaxValue</see>.
            To return any <see cref="T:System.UInt32"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleUInt32(System.Random)">SampleUInt32</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 32-bit unsigned integer that is greater than or equal to 0 and less than <see cref="F:System.UInt32.MaxValue">UInt32.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt32(System.Random,System.UInt32,System.Boolean)">
            <summary>
            Returns a random 32-bit unsigned integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 32-bit unsigned integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt32(System.Random,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Returns a random 32-bit unsigned integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 32-bit unsigned integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt64(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Int64"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 64-bit signed integer that is greater than or equal to <see cref="F:System.Int64.MinValue">Int64.MinValue</see> and less than or equal to <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt64(System.Random)">
            <summary>
            Returns a non-negative random 64-bit signed integer that is less than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.
            To return any <see cref="T:System.Int64"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleInt64(System.Random)">SampleInt64</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 64-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt64(System.Random,System.Int64,System.Boolean)">
            <summary>
            Returns a non-negative random 64-bit signed integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 64-bit signed integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextInt64(System.Random,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Returns a random <see cref="T:System.Int64"/> value that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 64-bit signed integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleUInt64(System.Random)">
            <summary>
            Returns a random <see cref="T:System.UInt64"/> that can have any value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 64-bit unsigned integer that is greater than or equal to 0 and less than or equal to <see cref="F:System.UInt64.MaxValue">UInt64.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt64(System.Random)">
            <summary>
            Returns a random 64-bit unsigned integer that is less than <see cref="F:System.UInt64.MaxValue">UInt64.MaxValue</see>.
            To return any <see cref="T:System.UInt64"/> use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleUInt64(System.Random)">SampleUInt64</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A 64-bit unsigned integer that is greater than or equal to 0 and less than <see cref="F:System.UInt64.MaxValue">UInt64.MaxValue</see>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt64(System.Random,System.UInt64,System.Boolean)">
            <summary>
            Returns a random 64-bit unsigned integer that is within the specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 64-bit unsigned integer that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextUInt64(System.Random,System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Returns a random 64-bit unsigned integer that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A 64-bit unsigned integer that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.SampleBigInteger(System.Random,System.Int32,System.Boolean)">
            <summary>
            Returns a random <see cref="T:System.Numerics.BigInteger"/> that represents an integer of <paramref name="byteSize"/> bytes.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="byteSize">Determines the range of the generated value in bytes. For example, if this parameter is <c>1</c>, then
            the result will be between 0 and 255 if <paramref name="isSigned"/> is <see langword="false"/>,
            or between -128 and 127 if <paramref name="isSigned"/> is <see langword="true"/>.</param>
            <param name="isSigned"><see langword="true"/> to generate a signed result; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A random <see cref="T:System.Numerics.BigInteger"/> that represents an integer of <paramref name="byteSize"/> bytes.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteSize"/> is negative.</exception>
            <exception cref="T:System.OverflowException"><paramref name="byteSize"/> is too large.</exception>
            <exception cref="T:System.OutOfMemoryException"><paramref name="byteSize"/> is too large.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextBigInteger(System.Random,System.Numerics.BigInteger,System.Boolean)">
            <summary>
            Returns a non-negative random <see cref="T:System.Numerics.BigInteger"/> that is within the specified maximum.
            To generate a random n-byte integer use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleBigInteger(System.Random,System.Int32,System.Boolean)">SampleBigInteger</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A <see cref="T:System.Numerics.BigInteger"/> that is greater than or equal to 0 and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="maxValue"/> equals 0, then 0 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextBigInteger(System.Random,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Boolean)">
            <summary>
            Returns a random <see cref="T:System.Numerics.BigInteger"/> value that is within a specified range.
            To generate a random n-byte integer use the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.SampleBigInteger(System.Random,System.Int32,System.Boolean)">SampleBigInteger</see> method instead.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="inclusiveUpperBound"><see langword="true"/> to allow that the generated value is equal to <paramref name="maxValue"/>; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>A <see cref="T:System.Numerics.BigInteger"/> that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.
            If <paramref name="inclusiveUpperBound"/> is <see langword="false"/>, then <paramref name="maxValue"/> is an exclusive upper bound; however, if <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="maxValue"/> is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextSingle(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Single"/> value that is greater than or equal to 0.0 and less than 1.0.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A single-precision floating point number that is greater than or equal to 0.0 and less than 1.0.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextSingle(System.Random,System.Single,KGySoft.CoreLibraries.FloatScale)">
            <summary>
            Returns a non-negative random <see cref="T:System.Single"/> value that is less than or equal to the specified <paramref name="maxValue"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="scale">The scale to use to generate the random number. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.</param>
            <returns>A single-precision floating point number that is greater than or equal to 0.0 and less than or equal to <paramref name="maxValue"/>.</returns>
            <remarks>
            <para>In most cases return value is less than <paramref name="maxValue"/>. Return value can be equal to <paramref name="maxValue"/> in very edge cases.
            With <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/>&#160;<paramref name="scale"/> the result will be always less than <paramref name="maxValue"/>.</para>
            <para>If <paramref name="scale"/> is <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>, then the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/> option is used
            if <paramref name="maxValue"/> is less than or equal to 65535. For larger range the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic"/> option is used.</para>
            <para>Generating random numbers by this method on the logarithmic scale is about 3 times slower than on the linear scale.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.0
            <br/>-or-.
            <br/><paramref name="scale"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextSingle(System.Random,System.Single,System.Single,KGySoft.CoreLibraries.FloatScale)">
            <summary>
            Returns a random <see cref="T:System.Single"/> value that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="scale">The scale to use to generate the random number. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.</param>
            <returns>A single-precision floating point number that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.</returns>
            <remarks>
            <para>In most cases return value is less than <paramref name="maxValue"/>. Return value can be equal to <paramref name="maxValue"/> in very edge cases such as
            when <paramref name="minValue"/> is equal to <paramref name="maxValue"/> or when integer parts of both limits are beyond the precision of the <see cref="T:System.Single"/> type.
            With <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/>&#160;<paramref name="scale"/> the result will be always less than <paramref name="maxValue"/>.</para>
            <para>If <paramref name="scale"/> is <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>, then the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/> option is used
            if the absolute value of both <paramref name="minValue"/> and <paramref name="maxValue"/> are less than or equal to 65535, or when they have the same sign
            and the absolute value of <paramref name="maxValue"/> is less than 16 times greater than the absolute value of <paramref name="minValue"/>.
            For larger ranges the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic"/> option is used.</para>
            <para>Generating random numbers by this method on the logarithmic scale is about 3 times slower than on the linear scale.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>
            <br/>-or-
            <br/><paramref name="scale"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDouble(System.Random,System.Double,KGySoft.CoreLibraries.FloatScale)">
            <summary>
            Returns a non-negative random <see cref="T:System.Double"/> value that is less than or equal to the specified <paramref name="maxValue"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="scale">The scale to use to generate the random number. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.</param>
            <returns>A double-precision floating point number that is greater than or equal to 0.0 and less than or equal to <paramref name="maxValue"/>.</returns>
            <remarks>
            <para>In most cases return value is less than <paramref name="maxValue"/>. Return value can be equal to <paramref name="maxValue"/> in very edge cases.
            With <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/>&#160;<paramref name="scale"/> the result will be always less than <paramref name="maxValue"/>.</para>
            <para>If <paramref name="scale"/> is <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>, then the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/> option is used
            if <paramref name="maxValue"/> is less than or equal to 65535. For larger range the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic"/> option is used.</para>
            <para>Generating random numbers by this method on the logarithmic scale is about 3 times slower than on the linear scale.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.0
            <br/>-or-
            <br/><paramref name="scale"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDouble(System.Random,System.Double,System.Double,KGySoft.CoreLibraries.FloatScale)">
            <summary>
            Returns a random <see cref="T:System.Double"/> value that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="scale">The scale to use to generate the random number. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.</param>
            <returns>A double-precision floating point number that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.</returns>
            <remarks>
            <para>In most cases return value is less than <paramref name="maxValue"/>. Return value can be equal to <paramref name="maxValue"/> in very edge cases such as
            when <paramref name="minValue"/> is equal to <paramref name="maxValue"/> or when integer parts of both limits are beyond the precision of the <see cref="T:System.Double"/> type.
            With <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/>&#160;<paramref name="scale"/> the result will be always less than <paramref name="maxValue"/>.</para>
            <para>If <paramref name="scale"/> is <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>, then the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/> option is used
            if the absolute value of both <paramref name="minValue"/> and <paramref name="maxValue"/> are less than or equal to 65535, or when they have the same sign
            and the absolute value of <paramref name="maxValue"/> is less than 16 times greater than the absolute value of <paramref name="minValue"/>.
            For larger ranges the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic"/> option is used.</para>
            <para>Generating random numbers by this method on the logarithmic scale is about 3 times slower than on the linear scale.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>
            <br/>-or-
            <br/><paramref name="scale"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDecimal(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Decimal"/> value that is greater than or equal to 0.0 and less than 1.0.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A decimal floating point number that is greater than or equal to 0.0 and less than 1.0.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDecimal(System.Random,System.Decimal,KGySoft.CoreLibraries.FloatScale)">
            <summary>
            Returns a non-negative random <see cref="T:System.Decimal"/> value that is less than or equal to the specified <paramref name="maxValue"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="maxValue">The upper bound of the random number returned.</param>
            <param name="scale">The scale to use to generate the random number. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.</param>
            <returns>A decimal floating point number that is greater than or equal to 0.0 and less than or equal to <paramref name="maxValue"/>.</returns>
            <remarks>
            <para>In most cases return value is less than <paramref name="maxValue"/>. Return value can be equal to <paramref name="maxValue"/> in very edge cases,
            such as when <paramref name="maxValue"/> is near <see cref="F:KGySoft.CoreLibraries.DecimalExtensions.Epsilon"/>.</para>
            <para>If <paramref name="scale"/> is <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>, then the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/> option is used
            if <paramref name="maxValue"/> is less than or equal to 65535. For larger range the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic"/> option is used.</para>
            <para>Generating random numbers by this method on the logarithmic scale is about 25-50 times slower than on the linear scale.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than 0.0
            <br/>-or-
            <br/><paramref name="scale"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDecimal(System.Random,System.Decimal,System.Decimal,KGySoft.CoreLibraries.FloatScale)">
            <summary>
            Returns a random <see cref="T:System.Decimal"/> value that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The lower bound of the random number returned.</param>
            <param name="maxValue">The upper bound of the random number returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <param name="scale">The scale to use to generate the random number. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.</param>
            <returns>A decimal floating point number that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.</returns>
            <remarks>
            <para>In most cases return value is less than <paramref name="maxValue"/>. Return value can be equal to <paramref name="maxValue"/> in very edge cases such as
            when <paramref name="minValue"/> is equal to <paramref name="maxValue"/> or when the range is near <see cref="F:KGySoft.CoreLibraries.DecimalExtensions.Epsilon"/>.
            With <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/>&#160;<paramref name="scale"/> the result will be always less than <paramref name="maxValue"/>.</para>
            <para>If <paramref name="scale"/> is <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>, then the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLinear"/> option is used
            if the absolute value of both <paramref name="minValue"/> and <paramref name="maxValue"/> are less than or equal to 65535, or when they have the same sign
            and the absolute value of <paramref name="maxValue"/> is less than 16 times greater than the absolute value of <paramref name="minValue"/>.
            For larger ranges the <see cref="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic"/> option is used.</para>
            <para>Generating random numbers by this method on the logarithmic scale is about 25-50 times slower than on the linear scale.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>
            <br/>-or-
            <br/><paramref name="scale"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChar(System.Random,System.Char,System.Char)">
            <summary>
            Returns a random <see cref="T:System.Char"/> value that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random character returned. This parameter is optional.
            <br/>Default value: <see cref="F:System.Char.MinValue">Char.MinValue</see>.</param>
            <param name="maxValue">The inclusive upper bound of the random character returned. Must be greater or equal to <paramref name="minValue"/>. This parameter is optional.
            <br/>Default value: <see cref="F:System.Char.MaxValue">Char.MaxValue</see>.</param>
            <returns>A <see cref="T:System.Char"/> value that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Int32,System.String)">
            <summary>
            Returns an <see cref="T:System.Array"/> of random characters that has the specified <paramref name="length"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="length">The desired length of the result.</param>
            <param name="allowedCharacters">An string containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <returns>An array of random characters that has the specified <paramref name="length"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="allowedCharacters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Int32,System.Char[])">
            <summary>
            Returns an <see cref="T:System.Array"/> of random characters that has the specified <paramref name="length"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="length">The desired length of the result.</param>
            <param name="allowedCharacters">An array of the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <returns>An array of random characters that has the specified <paramref name="length"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="allowedCharacters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Int32,System.ReadOnlySpan{System.Char})">
            <summary>
            Returns an <see cref="T:System.Array"/> of random characters that has the specified <paramref name="length"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="length">The desired length of the result.</param>
            <param name="allowedCharacters">A <see cref="T:System.ReadOnlySpan`1"/> containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <returns>An array of random characters that has the specified <paramref name="length"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Int32,KGySoft.CoreLibraries.StringCreation)">
            <summary>
            Returns an <see cref="T:System.Array"/> of random characters using the specified <paramref name="strategy"/> that has the specified <paramref name="length"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="length">The desired length of the result.</param>
            <param name="strategy">The strategy to use. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringCreation.Ascii"/>.</param>
            <returns>An array of characters <see cref="T:System.String"/> value generated by the specified <paramref name="strategy"/> that has the specified <paramref name="length"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is less than 0
            <br/>-or-
            <br/><paramref name="strategy"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.StringCreation"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Char[],System.String)">
            <summary>
            Fills the elements of a <paramref name="buffer"/> of character array with random characters using the specified <paramref name="allowedCharacters"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="buffer">An array of characters to contain random values.</param>
            <param name="allowedCharacters">A string containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/>, <paramref name="buffer"/> or <paramref name="allowedCharacters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Char[],System.Char[])">
            <summary>
            Fills the elements of a <paramref name="buffer"/> of character array with random characters using the specified <paramref name="allowedCharacters"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="buffer">An array of characters to contain random values.</param>
            <param name="allowedCharacters">An array of the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/>, <paramref name="buffer"/> or <paramref name="allowedCharacters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Char[],KGySoft.CoreLibraries.StringCreation)">
            <summary>
            Fills the elements of a <paramref name="buffer"/> of character array with random characters using the specified <paramref name="strategy"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="buffer">An array of characters to contain random values.</param>
            <param name="strategy">The strategy to use. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringCreation.Ascii"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="buffer"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strategy"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.StringCreation"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Span{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Fills the elements of a <paramref name="buffer"/> with random characters using the specified <paramref name="allowedCharacters"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="buffer">A <see cref="T:System.Span`1"/> of characters to contain random values.</param>
            <param name="allowedCharacters">A <see cref="T:System.ReadOnlySpan`1"/> containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextChars(System.Random,System.Span{System.Char},KGySoft.CoreLibraries.StringCreation)">
            <summary>
            Fills the elements of a <paramref name="buffer"/> with random characters using the specified <paramref name="strategy"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="buffer">A <see cref="T:System.Span`1"/> of characters to contain random values.</param>
            <param name="strategy">The strategy to use. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringCreation.Ascii"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="buffer"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strategy"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.StringCreation"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextString(System.Random,System.Int32,System.Int32,System.String)">
            <summary>
            Returns a random <see cref="T:System.String"/> that has the length between the specified range and consists of the specified <paramref name="allowedCharacters"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minLength">The inclusive lower bound of the length of the returned string.</param>
            <param name="maxLength">The inclusive upper bound of the length of the returned string. Must be greater or equal to <paramref name="minLength"/>.</param>
            <param name="allowedCharacters">A string containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <returns>A <see cref="T:System.String"/> value that has the length greater than or equal to <paramref name="minLength"/> and less and less than or equal to <paramref name="maxLength"/>
            and contains only the specified characters.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="allowedCharacters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minLength"/> is less than 0 or <paramref name="maxLength"/> is less than <paramref name="minLength"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextString(System.Random,System.Int32,System.Int32,System.Char[])">
            <summary>
            Returns a random <see cref="T:System.String"/> that has the length between the specified range and consists of the specified <paramref name="allowedCharacters"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minLength">The inclusive lower bound of the length of the returned string.</param>
            <param name="maxLength">The inclusive upper bound of the length of the returned string. Must be greater or equal to <paramref name="minLength"/>.</param>
            <param name="allowedCharacters">An array containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <returns>A <see cref="T:System.String"/> value that has the length greater than or equal to <paramref name="minLength"/> and less and less than or equal to <paramref name="maxLength"/>
            and contains only the specified characters.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="allowedCharacters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minLength"/> is less than 0 or <paramref name="maxLength"/> is less than <paramref name="minLength"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextString(System.Random,System.Int32,System.Int32,System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a random <see cref="T:System.String"/> that has the length between the specified range and consists of the specified <paramref name="allowedCharacters"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minLength">The inclusive lower bound of the length of the returned string.</param>
            <param name="maxLength">The inclusive upper bound of the length of the returned string. Must be greater or equal to <paramref name="minLength"/>.</param>
            <param name="allowedCharacters">A <see cref="T:System.ReadOnlySpan`1"/> containing the allowed characters. Recurring characters may appear in the result more frequently than others.</param>
            <returns>A <see cref="T:System.String"/> value that has the length greater than or equal to <paramref name="minLength"/> and less and less than or equal to <paramref name="maxLength"/>
            and contains only the specified characters.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minLength"/> is less than 0 or <paramref name="maxLength"/> is less than <paramref name="minLength"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="allowedCharacters"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextString(System.Random,System.Int32,System.Int32,KGySoft.CoreLibraries.StringCreation)">
            <summary>
            Returns a random <see cref="T:System.String"/> using the specified <paramref name="strategy"/> that has the length between the specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minLength">The inclusive lower bound of the length of the returned string.</param>
            <param name="maxLength">The inclusive upper bound of the length of the returned string. Must be greater or equal to <paramref name="minLength"/>.</param>
            <param name="strategy">The strategy to use. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringCreation.Ascii"/>.</param>
            <returns>A <see cref="T:System.String"/> value generated by the specified <paramref name="strategy"/> that has the length greater than or equal to <paramref name="minLength"/> and less and less than or equal to <paramref name="maxLength"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minLength"/> is less than 0 or <paramref name="maxLength"/> is less than <paramref name="minLength"/>
            <br/>-or-
            <br/><paramref name="strategy"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.StringCreation"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextString(System.Random,System.Int32,KGySoft.CoreLibraries.StringCreation)">
            <summary>
            Returns a random <see cref="T:System.String"/> of the specified <paramref name="length"/> using the specified <paramref name="strategy"/> that has the length between the specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="length">The length of the string to be generated.</param>
            <param name="strategy">The strategy to use. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringCreation.Ascii"/>.</param>
            <returns>A <see cref="T:System.String"/> value generated by the specified <paramref name="strategy"/> and <paramref name="length"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is less than 0
            <br/>-or-
            <br/><paramref name="strategy"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.StringCreation"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextString(System.Random,KGySoft.CoreLibraries.StringCreation)">
            <summary>
            Returns a random <see cref="T:System.String"/> using the specified <paramref name="strategy"/> that has the length between 4 and 10 inclusive.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="strategy">The strategy to use. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.StringCreation.Ascii"/>.</param>
            <returns>A <see cref="T:System.String"/> value generated by the specified <paramref name="strategy"/> that has the length between 4 and 10 inclusive.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strategy"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.StringCreation"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextRune(System.Random)">
            <summary>
            Returns a random <see cref="T:System.Text.Rune"/> (Unicode character).
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A <see cref="T:System.Text.Rune"/> (Unicode character).</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextRune(System.Random,System.Text.Rune,System.Text.Rune)">
            <summary>
            Returns a random <see cref="T:System.Text.Rune"/> (Unicode character) that is within a specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random character returned.</param>
            <param name="maxValue">The inclusive upper bound of the random character returned. Must be greater or equal to <paramref name="minValue"/>.</param>
            <returns>A <see cref="T:System.Text.Rune"/> (Unicode character) that is greater than or equal to <paramref name="minValue"/> and less than or equal to <paramref name="maxValue"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextRune(System.Random,System.Globalization.UnicodeCategory)">
            <summary>
            Returns a random <see cref="T:System.Text.Rune"/> (Unicode character) that is within the specified <paramref name="category"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="category">The category of the character to be returned.</param>
            <returns>A <see cref="T:System.Text.Rune"/> (Unicode character) that is greater that is within the specified <paramref name="category"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="category"/> is <see cref="F:System.Globalization.UnicodeCategory.Surrogate"/> or an undefined value.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDateTime(System.Random,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Returns a random <see cref="T:System.DateTime"/> that is between the specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random <see cref="T:System.DateTime"/> returned or <see langword="null"/> to use <see cref="F:System.DateTime.MinValue">DateTime.MinValue</see>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="maxValue">The inclusive upper bound of the random <see cref="T:System.DateTime"/> returned or <see langword="null"/> to use <see cref="F:System.DateTime.MaxValue">DateTime.MaxValue</see>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>A <see cref="T:System.DateTime"/> value that is in the specified range.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
            <remarks>
            <para>The <see cref="P:System.DateTime.Kind"/> property of <paramref name="minValue"/> and <paramref name="maxValue"/> is ignored.</para>
            <para>The <see cref="P:System.DateTime.Kind"/> property of the generated <see cref="T:System.DateTime"/> instances is always <see cref="F:System.DateTimeKind.Unspecified"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDate(System.Random,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Returns a random <see cref="T:System.DateTime"/> that is between the specified range and has only date component.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random <see cref="T:System.DateTime"/> returned or <see langword="null"/> to use <see cref="F:System.DateTime.MinValue">DateTime.MinValue</see>.
            The time component is ignored. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="maxValue">The inclusive upper bound of the random <see cref="T:System.DateTime"/> returned or <see langword="null"/> to use <see cref="F:System.DateTime.MaxValue">DateTime.MaxValue</see>.
            The time component is ignored. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>A <see cref="T:System.DateTime"/> value that is in the specified range and has only date component.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
            <remarks>
            <para>The <see cref="P:System.DateTime.Kind"/> property of <paramref name="minValue"/> and <paramref name="maxValue"/> is ignored.</para>
            <para>The time component of <paramref name="minValue"/> and <paramref name="maxValue"/> is ignored.</para>
            <para>The <see cref="P:System.DateTime.Kind"/> property of the generated <see cref="T:System.DateTime"/> instances is always <see cref="F:System.DateTimeKind.Unspecified"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextDateTimeOffset(System.Random,System.Nullable{System.DateTimeOffset},System.Nullable{System.DateTimeOffset})">
            <summary>
            Returns a random <see cref="T:System.DateTimeOffset"/> that is between the specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random <see cref="T:System.DateTimeOffset"/> returned or <see langword="null"/> to use <see cref="F:System.DateTimeOffset.MinValue">DateTimeOffset.MinValue</see>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="maxValue">The inclusive upper bound of the random <see cref="T:System.DateTimeOffset"/> returned or <see langword="null"/> to use <see cref="F:System.DateTimeOffset.MaxValue">DateTimeOffset.MaxValue</see>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>A <see cref="T:System.DateTimeOffset"/> value that is in the specified range.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextTimeSpan(System.Random,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Returns a random <see cref="T:System.TimeSpan"/> that is between the specified range.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="minValue">The inclusive lower bound of the random <see cref="T:System.TimeSpan"/> returned or <see langword="null"/> to use <see cref="F:System.TimeSpan.MinValue">TimeSpan.MinValue</see>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="maxValue">The inclusive upper bound of the random <see cref="T:System.TimeSpan"/> returned or <see langword="null"/> to use <see cref="F:System.TimeSpan.MaxValue">TimeSpan.MaxValue</see>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>A <see cref="T:System.TimeSpan"/> value that is in the specified range.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue"/> is less than <paramref name="minValue"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextEnum``1(System.Random)">
            <summary>
            Returns a random <typeparamref name="TEnum"/> value.
            </summary>
            <typeparam name="TEnum">The type of the <see langword="enum"/>. Must be an <see cref="T:System.Enum"/> type.</typeparam>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <returns>A random <typeparamref name="TEnum"/> value or the default value of <typeparamref name="TEnum"/> if it has no defined values.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextGuid(System.Random)">
            <summary>
            Returns a random RFC 4122 compliant <see cref="T:System.Guid"/> value generated by using the specified <see cref="T:System.Random"/> instance.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use. Note that if it is a non-derived <see cref="T:System.Random">System.Random</see> instance, then
            the result cannot be considered as a cryptographically secure identifier.</param>
            <returns>An RFC 4122 compliant <see cref="T:System.Guid"/> value.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <remarks>
            <note type="security">To create cryptographically secure <see cref="T:System.Guid"/> values use a derived type of <see cref="T:System.Random"/>,
            such as <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/>, which can be considered as secure, or just call <see cref="M:System.Guid.NewGuid">Guid.NewGuid</see> instead.</note>
            </remarks>
            <seealso cref="T:KGySoft.Security.Cryptography.SecureRandom"/>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextObject``1(System.Random,KGySoft.CoreLibraries.GenerateObjectSettings)">
            <summary>
            Returns a random object of type <typeparamref name="T"/> or the default value of <typeparamref name="T"/>
            if <typeparamref name="T"/> cannot be instantiated with the provided <paramref name="settings"/>.
            </summary>
            <typeparam name="T">The type of the object to be created. If <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.TryResolveInterfacesAndAbstractTypes"/> property
            in <paramref name="settings"/> is <see langword="true"/>, then it can be also an interface or abstract type;
            however, if no implementation or usable constructor found, then a <see langword="null"/> value will be returned.</typeparam>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="settings">The settings to use or <see langword="null"/> to use the default settings.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An instance of <typeparamref name="T"/> or <see langword="null"/> if the type cannot be
            instantiated with the provided <paramref name="settings"/> See the <strong>Remarks</strong> section for details.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> is <see langword="null"/>.</exception>
            <remarks>
            <para><note type="caution">The generated object is not guaranteed to be in a consistent format, especially if <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.AllowCreateObjectWithoutConstructor"/>
            property is <see langword="true"/> or <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.ObjectInitialization"/> property is <see cref="F:KGySoft.CoreLibraries.ObjectInitialization.Fields"/> in <paramref name="settings"/>.</note></para>
            <para><typeparamref name="T"/> can be basically any type as long as it has a default constructor or (in case of collections) a constructor with a parameter that can accept a collection.</para>
            <para>If <typeparamref name="T"/> is an interface or an abstract class you can set the <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.TryResolveInterfacesAndAbstractTypes"/> property to
            use a random implementation of <typeparamref name="T"/>. If no implementation is found among the loaded assemblies with a proper constructor, then the result will be <see langword="null"/>.</para>
            <para>If <typeparamref name="T"/> is a non-sealed class you can set the <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.AllowDerivedTypesForNonSealedClasses"/> property to
            allow to use a random derived class of <typeparamref name="T"/>.</para>
            <para>All types, which can be generated by the <c>Next...</c> methods of the <see cref="T:KGySoft.CoreLibraries.RandomExtensions"/> class, are supported.
            Some other types have some special handling for better support:
            <list type="bullet">
            <item><term><see cref="T:System.Text.StringBuilder"/></term><description>The same behavior as for strings.</description></item>
            <item><term><see cref="T:System.Uri"/></term><description>The result will match the following pattern: <c>http://&lt;lowercase word-like string of length between 4 and 10&gt;.&lt;3 lower case letters&gt;</c></description></item>
            <item><term><see cref="T:System.IntPtr"/></term><description>The same behavior as for 32 or 64 bit signed integers, based on the used platform.</description></item>
            <item><term><see cref="T:System.UIntPtr"/></term><description>The same behavior as for 32 or 64 bit unsigned integers, based on the used platform.</description></item>
            <item><term><see cref="T:System.Collections.Generic.KeyValuePair`2"/></term><description>Using its parameterized constructor to create an instance.</description></item>
            <item><term><see cref="T:System.Reflection.Assembly"/></term><description>A random loaded assembly will be picked.</description></item>
            <item><term><see cref="T:System.Type"/></term><description>A random type will be picked from one of the loaded assemblies.</description></item>
            <item><term><see cref="T:System.Reflection.MemberInfo"/> types</term><description>A random member will be picked from one of the types of the loaded assemblies.</description></item>
            <item><term><see cref="T:System.Delegate"/> types</term><description>A dynamic method will be created for the specified delegate, which returns random objects both by return value and by the possible <c>out</c> parameters.</description></item>
            </list>
            <note>The generated delegates do not use the specified <paramref name="random"/> instance because in that case the <paramref name="random"/> instance could
            never be reclaimed by the garbage collector. To avoid leaking memory generated delegates use an internal static <see cref="T:System.Random"/> instance.</note>
            </para>
            <note type="tip">See the <strong>Examples</strong> section of the <see cref="T:KGySoft.CoreLibraries.RandomExtensions"/> class for some examples.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.RandomExtensions.NextObject(System.Random,System.Type,KGySoft.CoreLibraries.GenerateObjectSettings)">
            <summary>
            Returns a random object of the specified <paramref name="type"/> or <see langword="null"/> 
            if <paramref name="type"/> cannot be instantiated with the provided <paramref name="settings"/>.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance to use.</param>
            <param name="type">The type of the object to be created. If <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.TryResolveInterfacesAndAbstractTypes"/> property
            in <paramref name="settings"/> is <see langword="true"/>, then it can be also an interface or abstract type;
            however, if no implementation or usable constructor found, then a <see langword="null"/> value will be returned.</param>
            <param name="settings">The settings to use or <see langword="null"/> to use the default settings.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An instance of <paramref name="type"/> or <see langword="null"/> if the type cannot be
            instantiated with the provided <paramref name="settings"/> See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.RandomExtensions.NextObject``1(System.Random,KGySoft.CoreLibraries.GenerateObjectSettings)"/> overload for details.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="random"/> or <paramref name="type"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:KGySoft.CoreLibraries.RandomExtensions.ObjectGenerator.DefaultGenericTypeKey">
            <summary>
            Cache key for a generic type with its suggested arguments, with Equals/GetHashCode by array elements.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.RandomExtensions.ObjectGenerator.randomForDelegates">
            <summary>
            Must be a separate instance because dynamic method references will never freed.
            Other problem if the original Random is a disposable secure random: invoking the delegate would throw an exception.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.SpanExtensions">
            <summary>
            Provides extension methods for <see cref="T:System.Span`1"/> and <see cref="T:System.ReadOnlySpan`1"/> types.
            </summary>
            <remarks><note>This class is available only in .NET Core 2.1/.NET Standard 2.1 and above.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.ReadToWhiteSpace(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next whitespace character and returns
            the consumed part without the whitespace. If the first character of <paramref name="rest"/> was a whitespace
            before the call, then an empty span is returned. If the whole <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> has been processed,
            then <paramref name="rest"/> will be <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> if the whole span has been processed.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by whitespace characters,
            or the complete original value of <paramref name="rest"/> if it contained no more whitespace characters.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.ReadToSeparator(System.ReadOnlySpan{System.Char}@,System.Char)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next <paramref name="separator"/> character and returns
            the consumed part without the <paramref name="separator"/>. If the first character of <paramref name="rest"/> was a <paramref name="separator"/>
            before the call, then an empty span is returned. If the whole <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> has been processed,
            then <paramref name="rest"/> will be <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> if the whole span has been processed.</param>
            <param name="separator">The separator character to search in the specified span.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by the specified <paramref name="separator"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.ReadToSeparator(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next <paramref name="separator"/> and returns
            the consumed part without the <paramref name="separator"/>. If <paramref name="rest"/> started with <paramref name="separator"/>
            before the call, then an empty span is returned. If the whole <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> has been processed,
            then <paramref name="rest"/> will be <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> if the whole span has been processed.</param>
            <param name="separator">The separator to search in the specified span.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by the specified <paramref name="separator"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.ReadToSeparator(System.ReadOnlySpan{System.Char}@,System.Char[])">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next separator and returns
            the consumed part without the separator. If <paramref name="rest"/> started with one of the <paramref name="separators"/>
            before the call, then an empty span is returned. If the whole <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> has been processed,
            then <paramref name="rest"/> will be <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> if the whole span has been processed.</param>
            <param name="separators">The separators to search in the specified span.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by any of the specified <paramref name="separators"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.ReadLine(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the current line and returns
            the consumed part without the newline character(s). If <paramref name="rest"/> started with a new line
            before the call, then an empty span is returned. If the whole <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> has been processed,
            then <paramref name="rest"/> will be <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> if the whole span has been processed.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that contains the first line of the original value of the <paramref name="rest"/> parameter,
            or the complete original value of <paramref name="rest"/> if it contained no more lines.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.Read(System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter consuming up to <paramref name="maxLength"/> characters and returns
            the consumed part. If <paramref name="rest"/> started with a new line
            before the call, then an empty span is returned. If the whole <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> has been processed,
            then <paramref name="rest"/> will be <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="P:System.ReadOnlySpan`1.Empty"><![CDATA[ReadOnlySpan<char>.Empty]]></see> if the whole span has been processed.</param>
            <param name="maxLength">The maximum number of characters to read.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> that contains the first line of the original value of the <paramref name="rest"/> parameter,
            or the complete original value of <paramref name="rest"/> if it contained no more than <paramref name="maxLength"/> characters.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.RemoveQuotes(System.ReadOnlySpan{System.Char})">
            <summary>
            Extracts content of a single or double quoted string.
            </summary>
            <param name="span">The span to be extracted from quotes.</param>
            <returns>If <paramref name="span"/> was surrounded by single or double quotes, returns a new string without the quotes; otherwise, returns <paramref name="span"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.RemoveQuotes(System.Span{System.Char})">
            <summary>
            Extracts content of a single or double quoted string.
            </summary>
            <param name="span">The span to be extracted from quotes.</param>
            <returns>If <paramref name="span"/> was surrounded by single or double quotes, returns a new string without the quotes; otherwise, returns <paramref name="span"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.ToEnum``1(System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>
            Tries to convert the specified <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to an <see cref="T:System.Enum"/> value of <typeparamref name="TEnum"/> type.
            No string allocation occurs when using this method.
            </summary>
            <typeparam name="TEnum">The type of the <see cref="T:System.Enum"/>.</typeparam>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> to convert.</param>
            <param name="definedOnly">If <see langword="true"/>, the result can only be a defined value in the specified <typeparamref name="TEnum"/> type.
            If <see langword="false"/>, the result can be a non-defined value, too.</param>
            <returns>A non-<see langword="null"/> value if the conversion was successful; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.Parse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Parses an object of type <typeparamref name="T"/> from a <see cref="T:System.String"/> represented by a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value.
            Firstly, it tries to parse the type natively. If <typeparamref name="T"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/>
            or a registered conversion that can convert from string, then the type converter or conversion will be used.
            </summary>
            <typeparam name="T">The desired type of the return value.</typeparam>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value to parse. If represents <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type, then the method returns <see langword="null"/>.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An instance of <typeparamref name="T"/>, which is the result of the parsing. A <see langword="null"/> reference can be returned if <paramref name="s"/> represents <see langword="null"/>, and <typeparamref name="T"/> is a reference or nullable type.</returns>
            <remarks>
            <para>The following types are parsed natively:
            <list type="bullet">
            <item><description><see cref="T:System.Enum"/> based types</description></item>
            <item><description><see cref="T:System.String"/></description></item>
            <item><description><see cref="T:System.Char"/></description></item>
            <item><description><see cref="T:System.Byte"/></description></item>
            <item><description><see cref="T:System.SByte"/></description></item>
            <item><description><see cref="T:System.Int16"/></description></item>
            <item><description><see cref="T:System.UInt16"/></description></item>
            <item><description><see cref="T:System.Int32"/></description></item>
            <item><description><see cref="T:System.UInt32"/></description></item>
            <item><description><see cref="T:System.Int64"/></description></item>
            <item><description><see cref="T:System.UInt64"/></description></item>
            <item><description><see cref="T:System.Single"/></description></item>
            <item><description><see cref="T:System.Double"/></description></item>
            <item><description><see cref="T:System.Decimal"/></description></item>
            <item><description><see cref="T:System.Boolean"/></description></item>
            <item><description><see cref="T:System.IntPtr"/></description></item>
            <item><description><see cref="T:System.UIntPtr"/></description></item>
            <item><description><see cref="T:System.Type"/></description></item>
            <item><description><see cref="T:System.DateTime"/></description></item>
            <item><description><see cref="T:System.DateTimeOffset"/></description></item>
            <item><description><see cref="T:System.TimeSpan"/></description></item>
            <item><description><see cref="T:System.Numerics.BigInteger"/> (.NET Framework 4.0 and above)</description></item>
            <item><description><see cref="T:System.Text.Rune"/> (.NET Core 3.0 and above)</description></item>
            <item><description><see cref="!:Half"/> (.NET 5.0 and above)</description></item>
            <item><description><see cref="!:DateOnly"/> (.NET 6.0 and above)</description></item>
            <item><description><see cref="!:TimeOnly"/> (.NET 6.0 and above)</description></item>
            <item><description><see cref="T:System.Nullable`1"/> of types above: <see langword="null"/> or empty value returns <see langword="null"/>; otherwise, <paramref name="s"/> is parsed as the underlying type</description></item>
            </list>
            <note>Apart from <see cref="T:System.Enum"/> and <see cref="T:System.Type"/> types, no string allocation occurs when parsing any of the types above.
            When targeting at least .NET 6.0, no string allocation occurs even for <see cref="T:System.Enum"/> types.</note>
            </para>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.
            If a registered conversion can convert from <see cref="T:System.String">string</see>, then it can be used, though in that case a string allocation will occur.</para>
            <para>A <see cref="T:System.ComponentModel.TypeConverter"/> can be registered by the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterTypeConverter``1(System.Type)">RegisterTypeConverter</see> extension method.
            If a type converter can convert from <see cref="T:System.String">string</see>, then it can be used, though in that case a string allocation will occur.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Parameter <paramref name="s"/> cannot be parsed as <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.Parse(System.ReadOnlySpan{System.Char},System.Type,System.Globalization.CultureInfo)">
            <summary>
            Parses an object from a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value.
            Firstly, it tries to parse the type natively. If <paramref name="type"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/>
            or a registered conversion that can convert from string, then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.SpanExtensions.Parse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo)"/> overload for details.
            </summary>
            <returns>An object of <paramref name="type"/>, which is the result of the parsing.</returns>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value to parse. If represents <see langword="null"/> and <paramref name="type"/> is a reference or nullable type, then the method returns <see langword="null"/>.</param>
            <param name="type">The desired type of the return value.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The parsed value. A <see langword="null"/> reference can be returned if <paramref name="s"/> represents <see langword="null"/>, and <paramref name="type"/> is a reference or nullable type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Parameter <paramref name="s"/> cannot be parsed as <paramref name="type"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.TryParse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo,``0@)">
            <summary>
            Tries to parse an object of type <typeparamref name="T"/> from a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value.
            Firstly, it tries to parse the type natively. If <typeparamref name="T"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/>
            or a registered conversion that can convert from string, then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.SpanExtensions.Parse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <typeparam name="T">The desired type of the returned <paramref name="value"/>.</typeparam>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value to parse. If represents <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It will be <see langword="null"/> if <paramref name="s"/> represents <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <typeparamref name="T"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.TryParse``1(System.ReadOnlySpan{System.Char},``0@)">
            <summary>
            Tries to parse an object of type <typeparamref name="T"/> from a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value.
            Firstly, it tries to parse the type natively. If <typeparamref name="T"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/>
            or a registered conversion that can convert from string, then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.SpanExtensions.Parse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <typeparam name="T">The desired type of the returned <paramref name="value"/>.</typeparam>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value to parse. If represents <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It will be <see langword="null"/> if <paramref name="s"/> represents <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <typeparamref name="T"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.TryParse(System.ReadOnlySpan{System.Char},System.Type,System.Globalization.CultureInfo,System.Object@)">
            <summary>
            Tries to parse an object of type <paramref name="type"/> from a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value.
            Firstly, it tries to parse the type natively. If <paramref name="type"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/>
            or a registered conversion that can convert from string, then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.SpanExtensions.Parse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value to parse. If <see langword="null"/> and <paramref name="type"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="type">The desired type of the returned <paramref name="value"/>.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It will be <see langword="null"/>, if <paramref name="s"/> represents <see langword="null"/> and <paramref name="type"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <paramref name="type"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.SpanExtensions.TryParse(System.ReadOnlySpan{System.Char},System.Type,System.Object@)">
            <summary>
            Tries to parse an object of type <paramref name="type"/> from a <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value.
            Firstly, it tries to parse the type natively. If <paramref name="type"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/>
            or a registered conversion that can convert from string, then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.SpanExtensions.Parse``1(System.ReadOnlySpan{System.Char},System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <param name="s">The <see cref="T:System.ReadOnlySpan`1"><![CDATA[ReadOnlySpan<char>]]></see> value to parse. If <see langword="null"/> and <paramref name="type"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="type">The desired type of the returned <paramref name="value"/>.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It will be <see langword="null"/>, if <paramref name="s"/> represents <see langword="null"/> and <paramref name="type"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <paramref name="type"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:KGySoft.CoreLibraries.SpanExtensions.Parser">
            <summary>
            A separate class so knowing all the supported types do not impact the <see cref="T:KGySoft.CoreLibraries.StringExtensions"/> class.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.StreamExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.IO.Stream"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Copies the <paramref name="source"/>&#160;<see cref="T:System.IO.Stream"/> into the <paramref name="destination"/> one.
            Copy begins on the current position of source stream. None of the streams are closed or sought after
            the end of the copy progress.
            </summary>
            <param name="source">Source stream.</param>
            <param name="destination">Destination stream.</param>
            <param name="bufferSize">Size of the buffer used for copying.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies the <paramref name="source"/>&#160;<see cref="T:System.IO.Stream"/> into the <paramref name="destination"/> one.
            Copy begins on the current position of source stream. None of the streams are closed or sought after
            the end of the copy progress.
            </summary>
            <param name="source">Source stream.</param>
            <param name="destination">Destination stream.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.StreamExtensions.ToArray(System.IO.Stream)">
            <summary>
            Converts a stream to array of bytes. If the stream can be sought, its position will be the same as before calling this method.
            </summary>
            <param name="s">Source stream</param>
            <returns>A byte <see cref="T:System.Array"/> with the stream content.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.String">string</see> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.RemoveQuotes(System.String)">
            <summary>
            Extracts content of a single or double quoted string.
            </summary>
            <param name="s">The string to be extracted from quotes.</param>
            <returns>If <paramref name="s"/> was surrounded by single or double quotes, returns a new string without the quotes; otherwise, returns <paramref name="s"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ToWildcardsRegex(System.String)">
            <summary>
            Converts the passed string to a <see cref="T:System.Text.RegularExpressions.Regex"/> that matches wildcard characters (? and *).
            </summary>
            <param name="s">The string containing possible wildcard characters.</param>
            <returns>A <see cref="T:System.Text.RegularExpressions.Regex"/> instance that matches the pattern of the given string in <paramref name="s"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.Repeat(System.String,System.Int32)">
            <summary>
            Repeats a <see cref="T:System.String"/>&#160;<paramref name="count"/> times.
            </summary>
            <param name="s">The string to repeat <paramref name="count"/> times.</param>
            <param name="count">The count of repeating <paramref name="s"/>. If 0, an empty string is returned. If 1 the original <paramref name="s"/> is returned.</param>
            <returns><paramref name="s"/> repeated <paramref name="count"/> times.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is less than 0.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ParseHexBytes(System.String,System.String)">
            <summary>
            Parses delimited hex values from a string into an array of bytes.
            </summary>
            <param name="s">A string containing delimited hex values.</param>
            <param name="separator">A separator delimiting the hex values. If <see langword="null"/>, then <paramref name="s"/> is parsed as a continuous hex stream.</param>
            <returns>A byte array containing the hex values as bytes.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="separator"/> is <see langword="null"/> or empty, and <paramref name="s"/> does not consist of event number of hex digits,
            or parsing failed.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ParseHexBytes(System.String)">
            <summary>
            Parses a continuous hex stream from a string.
            </summary>
            <param name="s">A string containing continuous hex values without delimiters.</param>
            <returns>A byte array containing the hex values as bytes.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="s"/> does not consist of event amount of hex digits, or parsing failed.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ParseDecimalBytes(System.String,System.String)">
            <summary>
            Parses separated decimal bytes from a string.
            </summary>
            <param name="s">A string containing delimited decimal integer numbers.</param>
            <param name="separator">A separator delimiting the values.</param>
            <returns>A byte array containing the decimal values as bytes.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="separator"/> is <see langword="null"/> or empty.</exception>
            <exception cref="T:System.FormatException"><paramref name="s"/> is not of the correct format.</exception>
            <exception cref="T:System.OverflowException">A value in <paramref name="s"/> does not fit in the range of a <see cref="T:System.Byte">byte</see> value.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Tries to convert the specified <see cref="T:System.String">string</see> to an <see cref="T:System.Enum"/> value of <typeparamref name="TEnum"/> type.
            </summary>
            <typeparam name="TEnum">The type of the <see cref="T:System.Enum"/>.</typeparam>
            <param name="s">The <see cref="T:System.String">string</see> to convert.</param>
            <param name="definedOnly">If <see langword="true"/>, the result can only be a defined value in the specified <typeparamref name="TEnum"/> type.
            If <see langword="false"/>, the result can be a non-defined value, too.</param>
            <returns>A non-<see langword="null"/> value if the conversion was successful; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)">
            <summary>
            Parses an object of type <typeparamref name="T"/> from a <see cref="T:System.String">string</see> value. Firstly, it tries to parse the type natively.
            If <typeparamref name="T"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/> or a registered conversion that can convert from string,
            then the type converter or conversion will be used.
            </summary>
            <typeparam name="T">The desired type of the return value.</typeparam>
            <param name="s">The string value to parse. If <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type, then the method returns <see langword="null"/>.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>An instance of <typeparamref name="T"/>, which is the result of the parsing. A <see langword="null"/> reference can be returned if <paramref name="s"/> is <see langword="null"/>, and <typeparamref name="T"/> is a reference or nullable type.</returns>
            <remarks>
            <para>New conversions can be registered by the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> extension methods.</para>
            <para>A <see cref="T:System.ComponentModel.TypeConverter"/> can be registered by the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterTypeConverter``1(System.Type)">RegisterTypeConverter</see> extension method.</para>
            <para>Natively parsed types:
            <list type="bullet">
            <item><description><see cref="T:System.Enum"/> based types</description></item>
            <item><description><see cref="T:System.String"/></description></item>
            <item><description><see cref="T:System.Char"/></description></item>
            <item><description><see cref="T:System.Byte"/></description></item>
            <item><description><see cref="T:System.SByte"/></description></item>
            <item><description><see cref="T:System.Int16"/></description></item>
            <item><description><see cref="T:System.UInt16"/></description></item>
            <item><description><see cref="T:System.Int32"/></description></item>
            <item><description><see cref="T:System.UInt32"/></description></item>
            <item><description><see cref="T:System.Int64"/></description></item>
            <item><description><see cref="T:System.UInt64"/></description></item>
            <item><description><see cref="T:System.Single"/></description></item>
            <item><description><see cref="T:System.Double"/></description></item>
            <item><description><see cref="T:System.Decimal"/></description></item>
            <item><description><see cref="T:System.Boolean"/></description></item>
            <item><description><see cref="T:System.IntPtr"/></description></item>
            <item><description><see cref="T:System.UIntPtr"/></description></item>
            <item><description><see cref="T:System.Type"/></description></item>
            <item><description><see cref="T:System.DateTime"/></description></item>
            <item><description><see cref="T:System.DateTimeOffset"/></description></item>
            <item><description><see cref="T:System.TimeSpan"/></description></item>
            <item><description><see cref="T:System.Numerics.BigInteger"/> (.NET Framework 4.0 and above)</description></item>
            <item><description><see cref="T:System.Text.Rune"/> (.NET Core 3.0 and above)</description></item>
            <item><description><see cref="!:Half"/> (.NET 5.0 and above)</description></item>
            <item><description><see cref="!:DateOnly"/> (.NET 6.0 and above)</description></item>
            <item><description><see cref="!:TimeOnly"/> (.NET 6.0 and above)</description></item>
            <item><description><see cref="T:System.Nullable`1"/> of types above: <see langword="null"/> or empty value returns <see langword="null"/>; otherwise, <paramref name="s"/> is parsed as the underlying type</description></item>
            </list>
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><typeparamref name="T"/> is not nullable and <paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Parameter <paramref name="s"/> cannot be parsed as <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.Parse(System.String,System.Type,System.Globalization.CultureInfo)">
            <summary>
            Parses an object from a <see cref="T:System.String">string</see> value. Firstly, it tries to parse the type natively.
            If <paramref name="type"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/> or a registered conversion that can convert from string,
            then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)"/> overload for details.
            </summary>
            <returns>An object of <paramref name="type"/>, which is the result of the parsing.</returns>
            <param name="s">The string value to parse. If <see langword="null"/> and <paramref name="type"/> is a reference or nullable type, then the method returns <see langword="null"/>.</param>
            <param name="type">The desired type of the return value.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The parsed value. A <see langword="null"/> reference can be returned if <paramref name="s"/> is <see langword="null"/>, and <paramref name="type"/> is a reference or nullable type.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>, or <paramref name="type"/> is not nullable and <paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Parameter <paramref name="s"/> cannot be parsed as <paramref name="type"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.TryParse``1(System.String,System.Globalization.CultureInfo,``0@)">
            <summary>
            Tries to parse an object of type <typeparamref name="T"/> from a <see cref="T:System.String">string</see> value. Firstly, it tries to parse the type natively.
            If <typeparamref name="T"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/> or a registered conversion that can convert from string,
            then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <typeparam name="T">The desired type of the returned <paramref name="value"/>.</typeparam>
            <param name="s">The string value to parse. If <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It can be <see langword="null"/> even if <paramref name="s"/> is <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <typeparamref name="T"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><typeparamref name="T"/> is not nullable and <paramref name="s"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.TryParse``1(System.String,``0@)">
            <summary>
            Tries to parse an object of type <typeparamref name="T"/> from a <see cref="T:System.String">string</see> value. Firstly, it tries to parse the type natively.
            If <typeparamref name="T"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/> or a registered conversion that can convert from string,
            then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <typeparam name="T">The desired type of the returned <paramref name="value"/>.</typeparam>
            <param name="s">The string value to parse. If <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It can be <see langword="null"/> even if <paramref name="s"/> is <see langword="null"/> and <typeparamref name="T"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <typeparamref name="T"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><typeparamref name="T"/> is not nullable and <paramref name="s"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.TryParse(System.String,System.Type,System.Globalization.CultureInfo,System.Object@)">
            <summary>
            Tries to parse an object of type <paramref name="type"/> from a <see cref="T:System.String">string</see> value. Firstly, it tries to parse the type natively.
            If <paramref name="type"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/> or a registered conversion that can convert from string,
            then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <param name="s">The string value to parse. If <see langword="null"/> and <paramref name="type"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="type">The desired type of the returned <paramref name="value"/>.</param>
            <param name="culture">The culture to use for the parsing. If <see langword="null"/>, then the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> will be used.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It can be <see langword="null"/> even if <paramref name="s"/> is <see langword="null"/> and <paramref name="type"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <paramref name="type"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null, or <paramref name="type"/> is not nullable and <paramref name="s"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.TryParse(System.String,System.Type,System.Object@)">
            <summary>
            Tries to parse an object of type <paramref name="type"/> from a <see cref="T:System.String">string</see> value. Firstly, it tries to parse the type natively.
            If <paramref name="type"/> cannot be parsed natively but the type has a <see cref="T:System.ComponentModel.TypeConverter"/> or a registered conversion that can convert from string,
            then the type converter or conversion will be used.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse``1(System.String,System.Globalization.CultureInfo)"/> method for details.
            </summary>
            <param name="s">The string value to parse. If <see langword="null"/> and <paramref name="type"/> is a reference or nullable type, then <paramref name="value"/> will be <see langword="null"/>.</param>
            <param name="type">The desired type of the returned <paramref name="value"/>.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the result of the parsing.
            It can be <see langword="null"/> even if <paramref name="s"/> is <see langword="null"/> and <paramref name="type"/> is a reference or nullable type.</param>
            <returns><see langword="true"/>, if <paramref name="s"/> could be parsed as <paramref name="type"/>, which is returned in the <paramref name="value"/> parameter; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null, or <paramref name="type"/> is not nullable and <paramref name="s"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.Contains(System.String,System.String,System.StringComparison)">
            <summary>
            Gets whether the specified string <paramref name="s"/> contains the specified <paramref name="value"/> using the specified <paramref name="comparison"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/> instance in which <paramref name="value"/> is searched.</param>
            <param name="value">The <see cref="T:System.String"/> to seek.</param>
            <param name="comparison">The <see cref="T:System.StringComparison"/> to use.</param>
            <returns><see langword="true"/> if string <paramref name="s"/> contains <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>
            <br/>-or-
            <br/><paramref name="value"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="comparison"/> is not a defined <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.EqualsAny(System.String,System.String[])">
            <summary>
            Gets whether the specified string <paramref name="s"/> equals any of the strings in the specified <paramref name="set"/> set by case sensitive ordinal comparison.
            </summary>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">An <see cref="T:System.Array"/> of strings.</param>
            <returns><see langword="true"/> if string <paramref name="s"/> equals any of the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.EqualsAny(System.String,System.StringComparer,System.String[])">
            <summary>
            Gets whether the specified string <paramref name="s"/> equals any of the strings in the specified <paramref name="set"/> set using a specific <paramref name="comparer"/>.
            </summary>
            <param name="comparer">A <see cref="T:System.StringComparer"/> that checks the equality.</param>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">An <see cref="T:System.Array"/> of strings.</param>
            <returns><see langword="true"/> if string <paramref name="s"/> equals any of the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.EqualsAny(System.String,System.StringComparison,System.String[])">
            <summary>
            Gets whether the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> equals any of the strings in the specified <paramref name="set"/> set using a specific <paramref name="comparison"/>.
            </summary>
            <param name="comparison">The <see cref="T:System.StringComparison"/> to use.</param>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">An <see cref="T:System.Array"/> of strings.</param>
            <returns><see langword="true"/> if string <paramref name="s"/> equals any of the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="comparison"/> is not a defined <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.IndexOfAny(System.String,System.String[])">
            <summary>
            Gets the zero-based index of the first occurrence in the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> of any of the strings in the specified <paramref name="set"/> by case sensitive ordinal comparison.
            </summary>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">An <see cref="T:System.Array"/> of strings.</param>
            <returns>The zero-based index of the first occurrence in the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> of any of the strings in the specified <paramref name="set"/>,
            or -1 if none of the strings of <paramref name="set"/> are found in <paramref name="s"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>
            <br/>-or-
            <br/><paramref name="set"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="set"/>contains a <see langword="null"/> element.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.IndexOfAny(System.String,System.StringComparison,System.String[])">
            <summary>
            Gets the zero-based index of the first occurrence in the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> of any of the strings in the specified <paramref name="set"/> using a specific <paramref name="comparison"/>.
            </summary>
            <param name="comparison">The <see cref="T:System.StringComparison"/> to use.</param>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">An <see cref="T:System.Array"/> of strings.</param>
            <returns>The zero-based index of the first occurrence in the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> of any of the strings in the specified <paramref name="set"/>,
            or -1 if none of the strings of <paramref name="set"/> are found in <paramref name="s"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>
            <br/>-or-
            <br/><paramref name="set"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="comparison"/> is not a defined <see cref="T:System.StringComparison"/> value.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="set"/>contains a <see langword="null"/> element.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ContainsAny(System.String,System.String[])">
            <summary>
            Gets whether the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> contains any of the strings in the specified <paramref name="set"/> by case sensitive ordinal comparison.
            </summary>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">A string array</param>
            <returns><see langword="true"/> if string <paramref name="s"/> contains any of the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>
            <br/>-or-
            <br/><paramref name="set"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="set"/>contains a <see langword="null"/> element.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.ContainsAny(System.String,System.StringComparison,System.String[])">
            <summary>
            Gets whether the specified <see cref="T:System.String"/>&#160;<paramref name="s"/> contains any of the strings in the specified <paramref name="set"/> set using a specific <paramref name="comparison"/>.
            </summary>
            <param name="comparison">The <see cref="T:System.StringComparison"/> to use.</param>
            <param name="s">A <see cref="T:System.String"/> instance that is to be compared to each element of the <paramref name="set"/>.</param>
            <param name="set">A string array</param>
            <returns><see langword="true"/> if string <paramref name="s"/> contains any of the elements of <paramref name="set"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>
            <br/>-or-
            <br/><paramref name="set"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="comparison"/> is not a defined <see cref="T:System.StringComparison"/> value.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="set"/>contains a <see langword="null"/> element.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.AsSegment(System.String,System.Int32,System.Int32)">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, which represents a segment of the specified <see cref="T:System.String">string</see>.
            No new string allocation occurs when using this method.
            </summary>
            <param name="s">The string to create the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> from.</param>
            <param name="offset">The offset that points to the first character of the returned segment.</param>
            <param name="length">The desired length of the returned segment.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, which represents a segment of the specified <see cref="T:System.String">string</see>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.AsSegment(System.String,System.Int32)">
            <summary>
            Gets a <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, which represents a segment of the specified <see cref="T:System.String">string</see>.
            No new string allocation occurs when using this method.
            </summary>
            <param name="s">The string to create the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> from.</param>
            <param name="offset">The offset that points to the first character of the returned segment.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance, which represents a segment of the specified <see cref="T:System.String">string</see>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringExtensions.AsSegment(System.String)">
            <summary>
            Gets the specified string as a <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance.
            </summary>
            <param name="s">The string to create the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> from.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> instance for the specified string.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringExtensions.Parser">
            <summary>
            A separate class so knowing all the supported types do not impact the <see cref="T:KGySoft.CoreLibraries.StringExtensions"/> class.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringSegmentExtensions">
            <summary>
            Provides extension methods for the <see cref="T:KGySoft.CoreLibraries.StringSegment"/> type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToWhiteSpace(KGySoft.CoreLibraries.StringSegment@)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next whitespace character and returns
            the consumed part without the whitespace. If the first character of <paramref name="rest"/> was a whitespace
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by whitespace characters,
            or the complete original value of <paramref name="rest"/> if it contained no more whitespace characters.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next <paramref name="separator"/> character and returns
            the consumed part without the <paramref name="separator"/>. If the first character of <paramref name="rest"/> was a <paramref name="separator"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separator">The separator character to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by the specified <paramref name="separator"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next <paramref name="separator"/> and returns
            the consumed part without the <paramref name="separator"/>. If <paramref name="rest"/> started with <paramref name="separator"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separator">The separator segment to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by the specified <paramref name="separator"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next <paramref name="separator"/> and returns
            the consumed part without the <paramref name="separator"/>. If <paramref name="rest"/> started with <paramref name="separator"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separator">The separator string to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by the specified <paramref name="separator"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.Char[])">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next separator and returns
            the consumed part without the separator. If <paramref name="rest"/> started with one of the <paramref name="separators"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separators">The separators to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by any of the specified <paramref name="separators"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String[])">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next separator and returns
            the consumed part without the separator. If <paramref name="rest"/> started with one of the <paramref name="separators"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separators">The separators to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by any of the specified <paramref name="separators"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,KGySoft.CoreLibraries.StringSegment[])">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next separator and returns
            the consumed part without the separator. If <paramref name="rest"/> started with one of the <paramref name="separators"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separators">The separators to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by any of the specified <paramref name="separators"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.ReadOnlySpan{System.Char})">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the next <paramref name="separator"/> and returns
            the consumed part without the <paramref name="separator"/>. If <paramref name="rest"/> started with <paramref name="separator"/>
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="separator">The separator segment to search in the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/>.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first segment of the original value of the <paramref name="rest"/> parameter delimited by the specified <paramref name="separator"/>,
            or the complete original value of <paramref name="rest"/> if it contained no more separators.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadLine(KGySoft.CoreLibraries.StringSegment@)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter after the current line and returns
            the consumed part without the newline character(s). If <paramref name="rest"/> started with a new line
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first line of the original value of the <paramref name="rest"/> parameter,
            or the complete original value of <paramref name="rest"/> if it contained no more lines.</returns>
            <remarks>
            <para>The effect of this method is the same as calling the <see cref="M:KGySoft.CoreLibraries.StringSegmentExtensions.ReadToSeparator(KGySoft.CoreLibraries.StringSegment@,System.String[])"/> method with <c><![CDATA["\r\n", "\r", "\n"]]></c>
            parameters but it is implemented a bit more optimized way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.Read(KGySoft.CoreLibraries.StringSegment@,System.Int32)">
            <summary>
            Advances the specified <paramref name="rest"/> parameter consuming up to <paramref name="maxLength"/> characters and returns
            the consumed part. If <paramref name="rest"/> started with a new line
            before the call, then an empty segment is returned. If the whole <see cref="T:KGySoft.CoreLibraries.StringSegment"/> has been processed, then <paramref name="rest"/>
            will be <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> after returning.
            </summary>
            <param name="rest">Represents the rest of the string to process. When this method returns, the value of this
            parameter will be the remaining unprocessed part, or <see cref="F:KGySoft.CoreLibraries.StringSegment.Null">StringSegment.Null</see> if the whole segment has been processed.</param>
            <param name="maxLength">The maximum number of characters to read.</param>
            <returns>A <see cref="T:KGySoft.CoreLibraries.StringSegment"/> that contains the first line of the original value of the <paramref name="rest"/> parameter,
            or the complete original value of <paramref name="rest"/> if it contained no more than <paramref name="maxLength"/> characters.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.RemoveQuotes(KGySoft.CoreLibraries.StringSegment)">
            <summary>
            Extracts content of a single or double quoted string.
            </summary>
            <param name="segment">The span to be extracted from quotes.</param>
            <returns>If <paramref name="segment"/> was surrounded by single or double quotes, returns a new string without the quotes; otherwise, returns <paramref name="segment"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentExtensions.ToEnum``1(KGySoft.CoreLibraries.StringSegment,System.Boolean)">
            <summary>
            Tries to convert the specified <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to an <see cref="T:System.Enum"/> value of <typeparamref name="TEnum"/> type.
            No string allocation occurs when using this method.
            </summary>
            <typeparam name="TEnum">The type of the <see cref="T:System.Enum"/>.</typeparam>
            <param name="s">The <see cref="T:KGySoft.CoreLibraries.StringSegment"/> to convert.</param>
            <param name="definedOnly">If <see langword="true"/>, the result can only be a defined value in the specified <typeparamref name="TEnum"/> type.
            If <see langword="false"/>, the result can be a non-defined value, too.</param>
            <returns>A non-<see langword="null"/> value if the conversion was successful; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.TypeExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Type"/> type.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.TypeExtensions.conversions">
            <summary>
            The conversions used in <see cref="M:KGySoft.CoreLibraries.ObjectExtensions.Convert(System.Object,System.Type,System.Globalization.CultureInfo)"/> and <see cref="M:KGySoft.CoreLibraries.StringExtensions.Parse(System.String,System.Type,System.Boolean)"/> methods.
            Main key is the target type, the inner one is the source type.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.CanAcceptValue(System.Type,System.Object)">
            <summary>
            Checks whether a <paramref name="value"/> can be an instance of <paramref name="type"/> when, for example,
            <paramref name="value"/> is passed to a method with <paramref name="type"/> parameter type.
            </summary>
            <param name="type">The type to check.</param>
            <param name="value">The value, whose compatibility with the <paramref name="type"/> is checked.</param>
            <returns><see langword="true"/> if <paramref name="value"/> can be an instance of <paramref name="type"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
            <remarks>
            <para><paramref name="type"/> can be a <see cref="T:System.Nullable`1"/> type.</para>
            <para>If <paramref name="type"/> is passed by reference, then the element type is checked.</para>
            <para>If either <paramref name="type"/> or <paramref name="value"/> is <see langword="enum"/>, then its underlying type is also accepted because both can be unboxed from an <see cref="T:System.Object"/> without casting errors.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsNullable(System.Type)">
            <summary>
            Gets whether given <paramref name="type"/> is a <see cref="T:System.Nullable`1"/> type.
            </summary>
            <param name="type">The type to check</param>
            <returns><see langword="true"/>, if <paramref name="type"/> is a <see cref="T:System.Nullable`1"/> type; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsFlagsEnum(System.Type)">
            <summary>
            Determines whether the specified <paramref name="type"/> is an <see cref="T:System.Enum">enum</see> and <see cref="T:System.FlagsAttribute"/> is defined on it.
            </summary>
            <param name="type">The type to check.</param>
            <returns><see langword="true"/> if <paramref name="type"/> is a flags <see cref="T:System.Enum">enum</see>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsDelegate(System.Type)">
            <summary>
            Gets whether the specified <paramref name="type"/> is a delegate.
            </summary>
            <param name="type">The type to check.</param>
            <returns><see langword="true"/> if the specified type is a delegate; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsGenericTypeOf(System.Type,System.Type)">
            <summary>
            Gets whether the given <paramref name="type"/> is a generic type of the specified <paramref name="genericTypeDefinition"/>.
            </summary>
            <param name="type">The type to check.</param>
            <param name="genericTypeDefinition">The generic type definition.</param>
            <returns><see langword="true"/> if the given <paramref name="type"/> is a generic type of the specified <paramref name="genericTypeDefinition"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> or <paramref name="genericTypeDefinition"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsImplementationOfGenericType(System.Type,System.Type)">
            <summary>
            Gets whether the given <paramref name="type"/>, its base classes or interfaces implement the specified <paramref name="genericTypeDefinition"/>.
            </summary>
            <param name="type">The type to check.</param>
            <param name="genericTypeDefinition">The generic type definition.</param>
            <returns><see langword="true"/> if the given <paramref name="type"/> implements the specified <paramref name="genericTypeDefinition"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> or <paramref name="genericTypeDefinition"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsImplementationOfGenericType(System.Type,System.Type,System.Type@)">
            <summary>
            Gets whether the given <paramref name="type"/>, its base classes or interfaces implement the specified <paramref name="genericTypeDefinition"/>.
            </summary>
            <param name="type">The type to check.</param>
            <param name="genericTypeDefinition">The generic type definition.</param>
            <param name="genericType">When this method returns <see langword="true"/>, then this parameter contains the found implementation of the specified <paramref name="genericTypeDefinition"/>.</param>
            <returns><see langword="true"/> if the given <paramref name="type"/> implements the specified <paramref name="genericTypeDefinition"/>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> or <paramref name="genericTypeDefinition"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.RegisterTypeConverter``1(System.Type)">
            <summary>
            Registers a type converter for a type.
            </summary>
            <typeparam name="TConverter">The <see cref="T:System.ComponentModel.TypeConverter"/> to be registered.</typeparam>
            <param name="type">The <see cref="T:System.Type"/> to be associated with the new <typeparamref name="TConverter"/>.</param>
            <remarks>
            <para>After calling this method the <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)">TypeDescriptor.GetConverter</see>
            method will return the converter defined in <typeparamref name="TConverter"/>.</para>
            <note>Please note that if <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)">TypeDescriptor.GetConverter</see>
            has already been called for <paramref name="type"/> before registering the new converter, then the further calls
            after the registering may continue to return the original converter. So make sure you register your custom converters
            at the start of your application.</note></remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion(System.Type,System.Type,KGySoft.CoreLibraries.ConversionAttempt)">
            <summary>
            Registers a <see cref="T:KGySoft.CoreLibraries.ConversionAttempt"/> from the specified <paramref name="sourceType"/> to <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The source <see cref="T:System.Type"/> for which the <paramref name="conversion"/> can be called.</param>
            <param name="targetType">The result <see cref="T:System.Type"/> that <paramref name="conversion"/> produces.</param>
            <param name="conversion">A <see cref="T:KGySoft.CoreLibraries.ConversionAttempt"/> delegate, which is able to perform the conversion.</param>
            <remarks>
            <para>After calling this method the <see cref="O:KGySoft.CoreLibraries.ObjectExtensions.Convert">Convert</see>/<see cref="O:KGySoft.CoreLibraries.ObjectExtensions.TryConvert">TryConvert</see>&#160;<see cref="T:System.Object"/>
            extension methods and <see cref="O:KGySoft.CoreLibraries.StringExtensions.Parse">Parse</see>/<see cref="O:KGySoft.CoreLibraries.StringExtensions.TryParse">TryParse</see>&#160;<see cref="T:System.String"/> extension methods
            will be able to use the registered <paramref name="conversion"/> between <paramref name="sourceType"/> and <paramref name="targetType"/>.</para>
            <para>Calling the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> methods for the same source and target types multiple times
            will override the old registered conversion with the new one.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.Int64"/> to <see cref="T:System.IntPtr"/>,
            then conversions from other convertible types become automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            <para><paramref name="sourceType"/> and <paramref name="targetType"/> can be interface, abstract or even a generic type definition.
            Preregistered conversions:
            <list type="bullet">
            <item><see cref="T:System.Collections.Generic.KeyValuePair`2"/> to another <see cref="T:System.Collections.Generic.KeyValuePair`2"/></item>
            <item><see cref="T:System.Collections.Generic.KeyValuePair`2"/> to <see cref="T:System.Collections.DictionaryEntry"/></item>
            <item><see cref="T:System.Collections.DictionaryEntry"/> to <see cref="T:System.Collections.Generic.KeyValuePair`2"/></item>
            <item><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Char">char</see> to <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Text.Rune"/> (.NET Core 3.0 and above)</item>
            <item><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Text.Rune"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Char">char</see> (.NET Core 3.0 and above)</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion(System.Type,System.Type,KGySoft.CoreLibraries.Conversion)">
            <summary>
            Registers a <see cref="T:KGySoft.CoreLibraries.Conversion"/> from the specified <paramref name="sourceType"/> to <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The source <see cref="T:System.Type"/> for which the <paramref name="conversion"/> can be called.</param>
            <param name="targetType">The result <see cref="T:System.Type"/> that <paramref name="conversion"/> produces.</param>
            <param name="conversion">A <see cref="T:KGySoft.CoreLibraries.Conversion"/> delegate, which is able to perform the conversion.</param>
            <remarks>
            <para>After calling this method the <see cref="O:KGySoft.CoreLibraries.ObjectExtensions.Convert">Convert</see>/<see cref="O:KGySoft.CoreLibraries.ObjectExtensions.TryConvert">TryConvert</see>&#160;<see cref="T:System.Object"/>
            extension methods and <see cref="O:KGySoft.CoreLibraries.StringExtensions.Parse">Parse</see>/<see cref="O:KGySoft.CoreLibraries.StringExtensions.TryParse">TryParse</see>&#160;<see cref="T:System.String"/> extension methods
            will be able to use the registered <paramref name="conversion"/> between <paramref name="sourceType"/> and <paramref name="targetType"/>.</para>
            <para>Calling the <see cref="O:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion">RegisterConversion</see> methods for the same source and target types multiple times
            will override the old registered conversion with the new one.</para>
            <note type="tip">The registered conversions are tried to be used for intermediate conversion steps if possible. For example, if a conversion is registered from <see cref="T:System.Int64"/> to <see cref="T:System.IntPtr"/>,
            then conversions from other convertible types become automatically available using the <see cref="T:System.Int64"/> type as an intermediate conversion step.</note>
            <para><paramref name="sourceType"/> and <paramref name="targetType"/> can be interface, abstract or even a generic type definition.
            Preregistered conversions:
            <list type="bullet">
            <item><see cref="T:System.Collections.Generic.KeyValuePair`2"/> to another <see cref="T:System.Collections.Generic.KeyValuePair`2"/></item>
            <item><see cref="T:System.Collections.Generic.KeyValuePair`2"/> to <see cref="T:System.Collections.DictionaryEntry"/></item>
            <item><see cref="T:System.Collections.DictionaryEntry"/> to <see cref="T:System.Collections.Generic.KeyValuePair`2"/></item>
            <item><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Char">char</see> to <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Text.Rune"/> (.NET Core 3.0 and above)</item>
            <item><see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Text.Rune"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Char">char</see> (.NET Core 3.0 and above)</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">
            <summary>
            Gets the name of the <paramref name="type"/> by the specified <paramref name="kind"/>.
            </summary>
            <param name="type">The type whose name is to be obtained.</param>
            <param name="kind">The formatting kind for the name to be retrieved.</param>
            <returns>The name of the <paramref name="type"/> by the specified <paramref name="kind"/>.</returns>
            <remarks>
            <para>See the values of the <see cref="T:KGySoft.CoreLibraries.TypeNameKind"/>&#160;<see langword="enum"/> for the detailed differences
            from <see cref="T:System.Type"/> members such as <see cref="P:System.Reflection.MemberInfo.Name"/>, <see cref="P:System.Type.FullName"/> and <see cref="P:System.Type.AssemblyQualifiedName"/>.</para>
            <para>Unlike the <see cref="T:System.Type"/> properties, the names produced by this method are never <see langword="null"/> for runtime types.</para>
            <para>This method always provides parseable type names by using the <see cref="F:KGySoft.CoreLibraries.TypeNameKind.AssemblyQualifiedName"/> kind.
            If the type contains generic arguments, then the result will be able to be parsed by
            the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method.</para>
            </remarks>
            <seealso cref="T:KGySoft.CoreLibraries.TypeNameKind"/>
            <seealso cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</seealso>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind,System.Func{System.Type,System.Reflection.AssemblyName},System.Func{System.Type,System.String})">
            <summary>
            Gets the name of the <paramref name="type"/> by the specified <paramref name="kind"/> using custom callbacks
            for resolving the assembly and type names.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)"/> overload for details.
            </summary>
            <param name="type">The type whose name is to be obtained.</param>
            <param name="kind">The formatting kind for the name to be retrieved. Determines the fallback names if the callbacks return <see langword="null"/>,
            and whether the <paramref name="assemblyNameResolver"/> will be called.</param>
            <param name="assemblyNameResolver">If not <see langword="null"/>, then will be called when the assembly identity of a type is requested.</param>
            <param name="typeNameResolver">If not <see langword="null"/>, then will be called for each ultimate element type and generic type definitions from
            which <paramref name="type"/> consists of.</param>
            <returns>The name of the <paramref name="type"/> by the specified <paramref name="kind"/> using the specified custom callbacks.</returns>
            <seealso cref="T:KGySoft.CoreLibraries.TypeNameKind"/>
            <seealso cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</seealso>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.CanBeParsedNatively(System.Type)">
            <summary>
            Gets whether <paramref name="type"/> can be parsed by the Parse methods in the <see cref="T:KGySoft.CoreLibraries.StringExtensions"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsSupportedCollectionForReflection(System.Type,System.Reflection.ConstructorInfo@,System.Reflection.ConstructorInfo@,System.Type@,System.Boolean@)">
            <summary>
            Gets whether <paramref name="type"/> is supported collection to populate by reflection.
            If <see langword="true"/> is returned one of the constructors are not <see langword="null"/> or <paramref name="type"/> is an array or a value type.
            If default constructor is used the collection still can be read-only or fixed size.
            </summary>
            <param name="type">The type to check.</param>
            <param name="defaultCtor">The default constructor or <see langword="null"/>. Non-null is returned only if the collection can be populated as an IList or generic Collection.</param>
            <param name="collectionCtor">The constructor to be initialized by collection or <see langword="null"/>. Can accept list, array or dictionary of element type.</param>
            <param name="elementType">The element type. For non-generic collections it is <see cref="T:System.Object"/>.</param>
            <param name="isDictionary"><see langword="true"/>&#160;<paramref name="type"/> is a dictionary.</param>
            <returns><see langword="true"/> if <paramref name="type"/> is a supported collection to populate by reflection; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.CreateInitializerCollection(System.Type,System.Boolean)">
            <summary>
            Creates an initializer collection for types for which <see cref="M:KGySoft.CoreLibraries.TypeExtensions.IsSupportedCollectionForReflection(System.Type,System.Reflection.ConstructorInfo@,System.Reflection.ConstructorInfo@,System.Type@,System.Boolean@)"/> returns <see langword="true"/> and returns a non-<see langword="null"/> collection initializer constructor.
            After the collection is populated call <see cref="M:KGySoft.CoreLibraries.EnumerableExtensions.AdjustInitializerCollection(System.Collections.IEnumerable,System.Reflection.ConstructorInfo)"/> before calling the constructor.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsCollection(System.Type)">
            <summary>
            Gets whether given type is a collection type and is capable to add/remove/clear items
            either by generic or non-generic way.
            </summary>
            <param name="type">The type to test</param>
            <returns>True if <paramref name="type"/> is a collection type: implements <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.ICollection`1"/></returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.TypeExtensions.IsReadWriteCollection(System.Type,System.Object)">
            <summary>
            Gets whether given instance of type is a non read-only collection
            either by generic or non-generic way.
            </summary>
            <param name="type">The type to test</param>
            <param name="instance">The object instance to test</param>
            <returns><see langword="true"/> if <paramref name="type"/> is a collection type: implements <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.Generic.ICollection`1"/> and <c><paramref name="instance"/>.IsReadOnly</c> returns <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.GenerateObjectSettings">
            <summary>
            Represents the settings for generating an object by the <see cref="O:KGySoft.CoreLibraries.RandomExtensions.NextObject">NextObject</see> extension methods.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.CollectionsLength">
            <summary>
            Gets or sets the length of the collections to generate.
            It also affects the size of generated <see cref="T:System.Numerics.BigInteger"/> instances (interpreted as the amount of 4 byte chunks to generate).
            <br/>Default value: <c>1..2</c>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:KGySoft.CoreLibraries.Range`1.LowerBound"/> is less than 0.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.StringsLength">
            <summary>
            Gets or sets the length of the non-sentence strings to generate.
            <br/>Default value: <c>4..10</c>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:KGySoft.CoreLibraries.Range`1.LowerBound"/> is less than 0.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.SentencesLength">
            <summary>
            Gets or sets the length of the sentence strings to generate.
            <br/>Default value: <c>30..60</c>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:KGySoft.CoreLibraries.Range`1.LowerBound"/> is less than 0.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.ChanceOfNull">
            <summary>
            Gets or sets the chance of generating a <see langword="null"/> value when the type is compatible with <see langword="null"/>.
            <br/>Default value: <c>0.0</c>.
            </summary>
            <value>
            A floating point number between 0.0 and 1.0.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is smaller than 0.0 or greater than 1.0.</exception>
            <remarks><note>If a reference type cannot be instantiated by the current settings a <see langword="null"/> value will be created even if the value of this property is <c>0.0</c>.</note></remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.StringCreation">
            <summary>
            Gets or sets the strategy for generating strings. Set <see langword="null"/> to auto select strategy by member name.
            <br/>Default value: <see langword="null"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is not a valid value of <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.StringCreation"/>.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.ObjectInitialization">
            <summary>
            Gets or sets the strategy for initializing a random generated object.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.ObjectInitialization.PublicFieldsAndProperties"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.ObjectInitialization"/>.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.FloatScale">
            <summary>
            Gets or sets the scale for generating floating point numbers.
            <br/>Default value: <see cref="F:KGySoft.CoreLibraries.FloatScale.Auto"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> is not a valid value of <see cref="T:KGySoft.CoreLibraries.FloatScale"/>.</exception>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.AllowNegativeValues">
            <summary>
            Gets or sets whether negative values are allowed when generating numbers.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.PastDateTimes">
            <summary>
            Gets or sets whether past date and time values should be produced when generating <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> instances.
            <br/>Default value: <see langword="null"/>.
            </summary>
            <value>
            <see langword="true"/>: Use past date and time values only.
            <br/><see langword="false"/>: Use future date and time values only.
            <br/><see langword="null"/>: Allow both past and future date and time values.
            </value>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.CloseDateTimes">
            <summary>
            Gets or sets whether close date and time values (current date plus-minus 100 years) should be produced when generating <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> values.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.TryResolveInterfacesAndAbstractTypes">
            <summary>
            Gets or sets whether a random implementation should be picked for interfaces and abstract types.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.AllowDerivedTypesForNonSealedClasses">
            <summary>
            Gets or sets whether a random derived type is allowed to be picked for non-sealed classes.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.AllowCreateObjectWithoutConstructor">
            <summary>
            Gets or sets whether non-value type objects are allowed to be created without using the default constructor or (in case of collections) a constructor with a collection parameter.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks><note type="caution">If the value of this property is <see langword="true"/>, then it cannot be guaranteed that a generated object will be in a consistent state.</note></remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.SubstitutionForObjectType">
            <summary>
            Gets or sets the type to be used when a type of <see cref="T:System.Object"/> has to be generated.
            <br/>Default value: <see langword="null"/>.
            </summary>
            <value>
            The <see cref="T:System.Type"/> to be used to generate <see cref="T:System.Object"/> instances or <see langword="null"/> for not using a substitution.
            </value>
            <remarks>
            <para>Specifying a substitution for the <see cref="T:System.Object"/> type can be useful for non-generic collections or when it is known that <see cref="T:System.Object"/> type
            has to be always replaced by a more specific type.</para>
            <para>If this property is not <see langword="null"/>, then whenever an instance of <see cref="T:System.Object"/> has to be generated the specified type will be used.</para>
            <para>The value of this property can be also an interface or abstract type. If <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.TryResolveInterfacesAndAbstractTypes"/> property is <see langword="true"/>,
            then a random implementation of the specified type will be used for every generated instance.</para>
            <para>If the value of this property is a non-sealed class and <see cref="P:KGySoft.CoreLibraries.GenerateObjectSettings.AllowDerivedTypesForNonSealedClasses"/> property is <see langword="true"/>,
            then a random derived type can be used for every generated instance.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.CoreLibraries.GenerateObjectSettings.MaxRecursionLevel">
            <summary>
            Gets or sets the maximum level of allowed recursion when generating objects, which contain members or elements of assignable types from their container types.
            <br/>Default value: <c>1</c>.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.Conversion">
            <summary>
            Represents a delegate for a type conversion. A conversion can be registered by the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion(System.Type,System.Type,KGySoft.CoreLibraries.Conversion)">RegisterConversion</see> extension method.
            </summary>
            <param name="obj">The source object to convert.</param>
            <param name="targetType">The desired type of the result.</param>
            <param name="culture">The used culture for the conversion. If <see langword="null"/>, then the conversion must use culture invariant conversion.</param>
            <returns>The result instance of the conversion.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.ConversionAttempt">
            <summary>
            Represents a delegate for a type conversion attempt. A conversion can be registered by the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterConversion(System.Type,System.Type,KGySoft.CoreLibraries.ConversionAttempt)">RegisterConversion</see> extension method.
            </summary>
            <param name="obj">The source object to convert.</param>
            <param name="targetType">The desired type of the <paramref name="result"/> parameter if the return value is <see langword="true"/>.</param>
            <param name="culture">The used culture for the conversion. If <see langword="null"/>, then the conversion must use culture invariant conversion.</param>
            <param name="result">The result if the return value is <see langword="true"/>.</param>
            <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.FloatScale">
            <summary>
            Represents the scaling strategy when generating random floating-point numbers.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.FloatScale.Auto">
            <summary>
            The scaling will be chosen automatically based on the provided range.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.FloatScale.ForceLinear">
            <summary>
            Forces to use linear scaling when generating random numbers.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.FloatScale.ForceLogarithmic">
            <summary>
            Forces to use logarithmic scaling when generating random numbers.
            Please that generating random numbers on the logarithmic scale can be significantly slower than
            on the linear scale, especially when generating <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.ObjectInitialization">
            <summary>
            Represents a strategy for initializing types when generating random objects.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.ObjectInitialization.PublicFieldsAndProperties">
            <summary>
            When initializing a new random object the public fields and public read-write properties are set (including non-public setters).
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.ObjectInitialization.PublicProperties">
            <summary>
            When initializing a new random object the public read-write properties (including non-public setters) are set.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.ObjectInitialization.Fields">
            <summary>
            When initializing a new random object fields are set (including non-public and read-only ones). It has a high chance that the object will contain inconsistent data.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringCreation">
            <summary>
            Represents a strategy for generating random strings.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.AnyChars">
            <summary>
            Represents random characters including invalid ones (unpaired surrogates and non-character UTF-16 code points).
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.AnyValidChars">
            <summary>
            Represents random characters ensuring that the string will not contain invalid Unicode characters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.Ascii">
            <summary>
            Represents random ASCII non-control characters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.Digits">
            <summary>
            Represents random digit characters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.DigitsNoLeadingZeros">
            <summary>
            Represents random digit characters ensuring that the first character is not zero.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.Letters">
            <summary>
            Represents random English letters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.LettersAndDigits">
            <summary>
            Represents random English letters and digit characters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.UpperCaseLetters">
            <summary>
            Represents random English uppercase letters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.LowerCaseLetters">
            <summary>
            Represents random English lowercase letters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.TitleCaseLetters">
            <summary>
            Represents random English title case letters.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.UpperCaseWord">
            <summary>
            Represents random word-like English characters in uppercase.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.LowerCaseWord">
            <summary>
            Represents random word-like English characters in lowercase.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.TitleCaseWord">
            <summary>
            Represents random word-like English characters in title case.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringCreation.Sentence">
            <summary>
            Represents random word-like sequences with uppercase first letter and sentence end mark.
            </summary>
        </member>
        <member name="T:KGySoft.CoreLibraries.Range`1">
            <summary>
            Represents a range with lower and upper bounds.
            </summary>
            <typeparam name="T">The type of the range.</typeparam>
        </member>
        <member name="P:KGySoft.CoreLibraries.Range`1.LowerBound">
            <summary>
            Gets the lower bound of the range.
            </summary>
        </member>
        <member name="P:KGySoft.CoreLibraries.Range`1.UpperBound">
            <summary>
            Gets the upper bound of the range. Whether this is an exclusive or inclusive bound, it depends on the context the <see cref="T:KGySoft.CoreLibraries.Range`1"/> is used in.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.op_Equality(KGySoft.CoreLibraries.Range{`0},KGySoft.CoreLibraries.Range{`0})">
            <summary>
            Implements the equality check operator.
            </summary>
            <param name="left">The left argument of the equality check.</param>
            <param name="right">The right argument of the equality check.</param>
            <returns>The result of the equality check.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.op_Inequality(KGySoft.CoreLibraries.Range{`0},KGySoft.CoreLibraries.Range{`0})">
            <summary>
            Implements the inequality check operator.
            </summary>
            <param name="left">The left argument of the inequality check.</param>
            <param name="right">The right argument of the inequality check.</param>
            <returns>The result of the inequality check.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.op_Implicit(`0)~KGySoft.CoreLibraries.Range{`0}">
            <summary>
            Performs an implicit conversion from <typeparamref name="T"/> to <see cref="T:KGySoft.CoreLibraries.Range`1"/> using the provided value as upper bound.
            </summary>
            <param name="upperBound">The upper bound of the range. Whether this is an exclusive or inclusive bound, it depends on the context the <see cref="T:KGySoft.CoreLibraries.Range`1"/> is used in.</param>
            <returns>
            A <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance representing a range between the default value of <typeparamref name="T"/> and <paramref name="upperBound"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.op_Implicit(System.ValueTuple{`0,`0})~KGySoft.CoreLibraries.Range{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:System.ValueTuple`2"/> to <see cref="T:KGySoft.CoreLibraries.Range`1"/>.
            </summary>
            <param name="bounds">The <see cref="T:System.ValueTuple`2"/> instance to be converted to <see cref="T:KGySoft.CoreLibraries.Range`1"/>.</param>
            <returns>
            A <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance representing a range between the provided <see cref="F:System.ValueTuple`2.Item1"/> and <see cref="F:System.ValueTuple`2.Item2"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.Range`1"/>&#160;<see langword="struct"/> between the default value of <typeparamref name="T"/> and
            the specified <paramref name="upperBound"/>.
            </summary>
            <param name="upperBound">The upper bound. Whether this is an exclusive or inclusive bound, it depends on the context it is used in.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.#ctor(`0,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.CoreLibraries.Range`1"/>&#160;<see langword="struct"/> between the specified <paramref name="lowerBound"/> and <paramref name="upperBound"/>.
            </summary>
            <param name="lowerBound">The lower bound.</param>
            <param name="upperBound">The upper bound. Whether this is an exclusive or inclusive bound, it depends on the context it is used in.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.Deconstruct(`0@,`0@)">
            <summary>
            Deconstructs this <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance.
            </summary>
            <param name="lowerBound">Returns the lower bound of the range.</param>
            <param name="upperBound">Returns the upper bound of the range. Whether this is an exclusive or inclusive bound, it depends on the context the <see cref="T:KGySoft.CoreLibraries.Range`1"/> is used in.</param>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.Equals(KGySoft.CoreLibraries.Range{`0})">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">An <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance to compare with this instance.</param>
            <returns><see langword="true" /> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.Range`1.ToString">
            <summary>
            Gets the string representation of this <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this <see cref="T:KGySoft.CoreLibraries.Range`1"/> instance.
            </returns>
        </member>
        <member name="T:KGySoft.CoreLibraries.StringSegmentSplitOptions">
            <summary>
            Specifies options for applicable <see cref="O:KGySoft.CoreLibraries.StringSegment.Split">StringSegment.Split</see> method overloads,
            such as whether to omit empty substrings from the returned array or trim whitespace from segments.
            </summary>
            <remarks>
            <para>The <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> is specified as a <see langword="struct"/> rather than an <see langword="enum"/>,
            so it can be compatible both with <see cref="T:System.StringSplitOptions"/> and the old <see cref="O:KGySoft.CoreLibraries.StringSegment.Split">StringSegment.Split</see>
            methods that defined a simple <see cref="T:System.Boolean">bool</see>&#160;<c>removeEmptyEntries</c> parameter as options.</para>
            <para>Unlike <see cref="T:System.StringSplitOptions"/>, this struct defines the <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.TrimEntries"/> option for all platform targets.</para>
            </remarks>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None">
            <summary>
            Represents the default options when splitting string segments by the <see cref="O:KGySoft.CoreLibraries.StringSegment.Split">Split</see> method overloads.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.RemoveEmptyEntries">
            <summary>
            Omits elements that contain an empty string segment from the result. When combined with the <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.TrimEntries"/> option,
            then whitespace-only segments will also be omitted.
            </summary>
        </member>
        <member name="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.TrimEntries">
            <summary>
            Trims white-space characters from each string segment in the result. When combined with the <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.RemoveEmptyEntries"/> option,
            then whitespace-only segments will also be omitted.
            </summary>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Equality(KGySoft.CoreLibraries.StringSegmentSplitOptions,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instances have the same value.
            </summary>
            <param name="left">The left argument of the equality check.</param>
            <param name="right">The right argument of the equality check.</param>
            <returns>The result of the equality check.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Inequality(KGySoft.CoreLibraries.StringSegmentSplitOptions,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Determines whether two specified <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instances have different values.
            </summary>
            <param name="left">The left argument of the equality check.</param>
            <param name="right">The right argument of the equality check.</param>
            <returns>The result of the inequality check.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Implicit(System.StringSplitOptions)~KGySoft.CoreLibraries.StringSegmentSplitOptions">
            <summary>
            Performs an implicit conversion from <see cref="T:System.StringSplitOptions"/> to <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/>.
            </summary>
            <param name="options">The <see cref="T:System.StringSplitOptions"/> value to be converted to <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/>.</param>
            <returns>
            A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance that represents the specified <paramref name="options"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Explicit(KGySoft.CoreLibraries.StringSegmentSplitOptions)~System.StringSplitOptions">
            <summary>
            Performs an explicit conversion from <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> to <see cref="T:System.StringSplitOptions"/>.
            </summary>
            <param name="options">The <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> value to be converted to <see cref="T:System.StringSplitOptions"/>.</param>
            <returns>
            A <see cref="T:System.StringSplitOptions"/> instance that represents the specified <paramref name="options"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Implicit(System.Boolean)~KGySoft.CoreLibraries.StringSegmentSplitOptions">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean">bool</see> to <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/>.
            <br/>This member is obsolete and is specified to provide compatibility with the old <see cref="O:KGySoft.CoreLibraries.StringSegment.Split">StringSegment.Split</see> overloads,
            which used to specify a boolean <paramref name="removeEmptyEntries"/> argument in place of the new <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> type.
            </summary>
            <param name="removeEmptyEntries"><see langword="true"/> to return <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.RemoveEmptyEntries"/>; <see langword="false"/> to return <see cref="F:KGySoft.CoreLibraries.StringSegmentSplitOptions.None"/>.</param>
            <returns>
            A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance that represents the value of the specified <paramref name="removeEmptyEntries"/> parameter.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Explicit(System.Int32)~KGySoft.CoreLibraries.StringSegmentSplitOptions">
            <summary>
            Performs an explicit conversion from <see cref="T:System.Int32"/> to <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/>.
            </summary>
            <param name="value">The integer value to be converted to <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/>.</param>
            <returns>
            A <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance that has the specified underlying <paramref name="value"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_Explicit(KGySoft.CoreLibraries.StringSegmentSplitOptions)~System.Int32">
            <summary>
            Performs an explicit conversion from <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> to <see cref="T:System.Int32"/>.
            </summary>
            <param name="options">The options to be converted to <see cref="T:System.Int32"/>.</param>
            <returns>
            The underlying <see cref="T:System.Int32"/> value of the specified <paramref name="options"/>.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_BitwiseOr(KGySoft.CoreLibraries.StringSegmentSplitOptions,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Performs a bitwise OR operation on the provided operands.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of the bitwise OR operation.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_BitwiseAnd(KGySoft.CoreLibraries.StringSegmentSplitOptions,KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Performs a bitwise AND operation on the provided operands.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of the bitwise AND operation.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.op_OnesComplement(KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Performs a bitwise NOT operation on the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value to be negated.</param>
            <returns>The result of the bitwise NOT operation.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.Equals(KGySoft.CoreLibraries.StringSegmentSplitOptions)">
            <summary>
            Indicates whether the current <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance is equal to another one specified in the <paramref name="other"/> parameter.
            </summary>
            <param name="other">An <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance to compare with this instance.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object">object</see> is equal to this instance.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the specified object is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.GetHashCode">
            <summary>
            Returns a hash code for this <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:KGySoft.CoreLibraries.StringSegmentSplitOptions.ToString">
            <summary>
            Gets the string representation of this <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this <see cref="T:KGySoft.CoreLibraries.StringSegmentSplitOptions"/> instance.
            </returns>
        </member>
        <member name="T:KGySoft.Diagnostics.CollectionDebugView`1">
            <summary>
            Provides a debug view applicable for <see cref="T:System.Diagnostics.DebuggerTypeProxyAttribute"/> for <see cref="T:System.Collections.Generic.ICollection`1"/> types.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="P:KGySoft.Diagnostics.CollectionDebugView`1.Items">
            <summary>
            Gets the visible items in debugger view
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.CollectionDebugView`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
             Creates a new instance of CollectionDebugView
            </summary>
             <param name="collection">The collection to provide the view for.</param>
        </member>
        <member name="T:KGySoft.Diagnostics.DictionaryDebugView`2">
            <summary>
            Provides a debug view applicable for <see cref="T:System.Diagnostics.DebuggerTypeProxyAttribute"/>
            for <see cref="T:System.Collections.Generic.IDictionary`2"/> types.
            </summary>
            <typeparam name="TKey">Type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values in the dictionary.</typeparam>
        </member>
        <member name="P:KGySoft.Diagnostics.DictionaryDebugView`2.Items">
            <summary>
            Gets the visible items in the debugger view
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.DictionaryDebugView`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
             Creates a new instance of <see cref="T:KGySoft.Diagnostics.DictionaryDebugView`2"/> class.
            </summary>
             <param name="dictionary">The dictionary to provide the view for.</param>
        </member>
        <member name="P:KGySoft.Diagnostics.DictionaryKeyCollectionDebugView`2.Items">
            <summary>
            Gets the visible items in debugger view
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.DictionaryKeyCollectionDebugView`2.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
             Creates a new instance of CollectionDebugView
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.DictionaryValueCollectionDebugView`2.Items">
            <summary>
            Gets the visible items in debugger view
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.DictionaryValueCollectionDebugView`2.#ctor(System.Collections.Generic.ICollection{`1})">
            <summary>
             Creates a new instance of CollectionDebugView
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.MeasureItem">
            <summary>
            Represents a measured profiler item.
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.MeasureOperation">
            <summary>
            Represents a measured profiler operation
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.PerformanceTest">
             <summary>
             Provides a class for performance tests of <see cref="T:System.Action"/> delegate test cases.
             </summary>
             <example>
             <para>The following example shows the simplest usage for timed tests.
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.CoreLibraries;
             using KGySoft.Diagnostics;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     new PerformanceTest()
                         .AddCase(() => ConsoleColor.Black.ToString(), "Enum.ToString")
                         .AddCase(() => Enum<ConsoleColor>.ToString(ConsoleColor.Black), "Enum<TEnum>.ToString")
                         .DoTest()
                         .DumpResults(Console.Out);
                 }
             }
            
             // This code example produces an output similar to the following one:
             // ==[Performance Test Results]================================================
             // Test Time: 2,000 ms
             // Warming up: Yes
             // Test cases: 2
             // Calling GC.Collect: Yes
             // Forced CPU Affinity: No
             // Cases are sorted by fulfilled iterations (the most first)
             // --------------------------------------------------
             // 1. Enum<TEnum>.ToString: 26,104,501 iterations in 2,000.00 ms. Adjusted for 2,000 ms: 26,104,498.39
             // 2. Enum.ToString: 3,956,036 iterations in 2,000.01 ms. Adjusted for 2,000 ms: 3,956,026.31 (-22,148,472.08 / 15.15 %)]]></code>
             </para>
             <para>Each test case can be repeated multiple times. To see the costs of the first execution the default warming up session can be disabled:
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.CoreLibraries;
             using KGySoft.Diagnostics;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     new PerformanceTest
                         {
                             TestName = "System.Enum vs. KGySoft.CoreLibraries.Enum<TEnum>",
                             TestTime = 2000,
                             WarmUp = false,
                             Repeat = 2
                         }
                         .AddCase(() => ConsoleColor.Black.ToString(), "Enum.ToString")
                         .AddCase(() => Enum<ConsoleColor>.ToString(ConsoleColor.Black), "Enum<TEnum>.ToString")
                         .DoTest()
                         .DumpResults(Console.Out);
                 }
             }
            
             // This code example produces an output similar to the following one:
             // ==[System.Enum vs. KGySoft.CoreLibraries.Enum<TEnum> Results]================================================
             // Test Time: 2,000 ms
             // Warming up: No
             // Test cases: 2
             // Repeats: 2
             // Calling GC.Collect: Yes
             // Forced CPU Affinity: No
             // Cases are sorted by fulfilled iterations (the most first)
             // --------------------------------------------------
             // 1. Enum<TEnum>.ToString: 57,500,126 iterations in 4,000.00 ms. Adjusted for 2,000 ms: 28,750,060.12
             //   #1  28,730,396 iterations in 2,000.00 ms. Adjusted: 28,730,393.13      <---- Worst
             //   #2  28,769,730 iterations in 2,000.00 ms. Adjusted: 28,769,727.12      <---- Best
             //   Worst-Best difference: 39,334.00 (0.14 %)
             // 2. Enum.ToString: 7,618,943 iterations in 4,000.01 ms. Adjusted for 2,000 ms: 3,809,466.01 (-24,940,594.12 / 13.25 %)
             //   #1  3,786,163 iterations in 2,000.01 ms. Adjusted: 3,786,152.78        <---- Worst
             //   #2  3,832,780 iterations in 2,000.00 ms. Adjusted: 3,832,779.23        <---- Best
             //   Worst-Best difference: 46,626.46 (1.23 %)]]></code>
             </para>
             <para>By specifying <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.Iterations"/> you can constrain to execute the test cases for a fix number of times instead of
             executing them for the specified time period:
             <note type="tip">Try also <a href="https://dotnetfiddle.net/PCcVuD" target="_blank">online</a>.</note>
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.CoreLibraries;
             using KGySoft.Diagnostics;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     new PerformanceTest { Iterations = 10000 }
                         .AddCase(() => ConsoleColor.Black.ToString(), "Enum.ToString")
                         .AddCase(() => Enum<ConsoleColor>.ToString(ConsoleColor.Black), "Enum<TEnum>.ToString")
                         .DoTest()
                         .DumpResults(Console.Out);
                 }
             }
            
             // This code example produces an output similar to the following one:
             // ==[Performance Test Results]================================================
             // Iterations: 10,000
             // Warming up: Yes
             // Test cases: 2
             // Calling GC.Collect: Yes
             // Forced CPU Affinity: 2
             // Cases are sorted by time (quickest first)
             // --------------------------------------------------
             // 1. Enum<TEnum>.ToString: average time: 0.23 ms
             // 2. Enum.ToString: average time: 4.50 ms (+4.27 ms / 1,994.32 %)]]></code>
             </para>
             <para>Similarly to time-based tests, you can increase number of repetitions:
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.CoreLibraries;
             using KGySoft.Diagnostics;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     new PerformanceTest
                         {
                             WarmUp = false,
                             Iterations = 10000,
                             Repeat = 5
                         }
                         .AddCase(() => ConsoleColor.Black.ToString(), "Enum.ToString")
                         .AddCase(() => Enum<ConsoleColor>.ToString(ConsoleColor.Black), "Enum<TEnum>.ToString")
                         .DoTest()
                         .DumpResults(Console.Out);
                 }
             }
            
             // This code example produces an output similar to the following one:
             // ==[Performance Test Results]================================================
             // Iterations: 10,000
             // Warming up: No
             // Test cases: 2
             // Repeats: 5
             // Calling GC.Collect: Yes
             // Forced CPU Affinity: No
             // Cases are sorted by time (quickest first)
             // --------------------------------------------------
             // 1. Enum<TEnum>.ToString: average time: 1.66 ms
             //   #1           7.39 ms   <---- Worst
             //   #2           0.22 ms   <---- Best
             //   #3           0.22 ms
             //   #4           0.23 ms
             //   #5           0.22 ms
             //   Worst-Best difference: 7.17 ms (3,266.23 %)
             // 2. Enum.ToString: average time: 5.00 ms (+3.35 ms / 302.10 %)
             //   #1           5.25 ms
             //   #2           4.40 ms   <---- Best
             //   #3           4.54 ms
             //   #4           5.97 ms   <---- Worst
             //   #5           4.85 ms
             //   Worst-Best difference: 1.58 ms (35.86 %)]]></code>
             </para>
             <note>See a further example in the <see cref="T:KGySoft.Diagnostics.PerformanceTest`1"/> class.</note>
             <note type="tip">See also the <strong>Examples</strong> section of the <see cref="T:KGySoft.Diagnostics.PerformanceTestBase`2"/> class to see how to create a custom type for parameterized performance tests.</note>
             </example>
             <seealso cref="T:KGySoft.Diagnostics.PerformanceTest`1" />
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTest.Invoke(System.Action)">
            <summary>
            Invokes the specified delegate.
            </summary>
            <param name="del">The delegate to invoke.</param>
            <returns>In <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> class this method returns always <see langword="null"/>.</returns>
        </member>
        <member name="T:KGySoft.Diagnostics.PerformanceTestBase">
            <summary>
            Provides a base class for performance tests.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> class for some examples.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.TestName">
            <summary>
            Gets or sets the name of the test.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.Iterations">
            <summary>
            Gets or sets number of iterations of test cases. If greater than zero, then <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.TestTime"/> is ignored.
            <br/>Default value: <c>0</c>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.TestTime">
            <summary>
            Gets or sets the test duration, in milliseconds, for each test case and the warming-up sessions.
            If <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.Iterations"/> is greater than zero, then this property affects only the warm-up time.
            <br/>Default value: <c>2000</c>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.WarmUp">
            <summary>
            Gets or sets whether there is an untested warm-up session before each test.
            Its duration equals to <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.TestTime"/>.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.Collect">
            <summary>
            Gets or sets whether <see cref="M:System.GC.Collect">GC.Collect</see> should be called before running the test cases.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.Repeat">
            <summary>
            Gets or sets how many times the test cases should be repeated.
            <br/>Default value: <c>1</c>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.CpuAffinity">
            <summary>
            Gets or sets the CPU affinity to be used for executing tests. If <see langword="null"/>, or is too large for the executing system, then the affinity is not adjusted for the test.
            <br/>Default value: <c>null</c>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.PerformanceTestBase.SortBySize">
            <summary>
            Gets or sets whether the results should be sorted by the size of the produced result instead of iterations count or time results.
            Makes sense only if the test delegate has a return type and the returned value of a test case is always the same for each run.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase.DoTest">
            <summary>
            In a derived class performs the test and returns the test results.
            </summary>
            <returns>An <see cref="T:KGySoft.Diagnostics.IPerformanceTestResultCollection"/> instance containing the test results.</returns>
        </member>
        <member name="T:KGySoft.Diagnostics.PerformanceTestBase`2">
            <summary>
            Provides a base class for performance tests.
            </summary>
            <typeparam name="TDelegate">The delegate type of the test cases.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <example>
            <note type="tip">Try also <a href="https://dotnetfiddle.net/KNiZa7" target="_blank">online</a>.</note>
            The following example demonstrates how to derive this class to create parameterized performance tests.
            <code lang="C#"><![CDATA[
            public class RandomizedPerformanceTest<T> : PerformanceTestBase<Func<Random, T>, T>
            {
                private Random random;
            
                // a fix seed can be specified when initializing the test
                public int Seed { get; set; }
            
                protected override T Invoke(Func<Random, T> del) => del.Invoke(random);
            
                // resetting the random instance with the specified seed before executing each case
                protected override void OnBeforeCase() => random = new Random(Seed);
            }]]></code>
            And now the delegate of the <see cref="M:KGySoft.Diagnostics.PerformanceTestBase`2.AddCase(`0,System.String)">AddCase</see> method will have a <see cref="T:System.Random"/> parameter can be used in the test cases:
            <code lang="C#"><![CDATA[
            new RandomizedPerformanceTest<string> { Seed = 0, Iterations = 1_000_000 }
                .AddCase(rnd => rnd.NextEnum<ConsoleColor>().ToString(), "Enum.ToString")
                .AddCase(rnd => Enum<ConsoleColor>.ToString(rnd.NextEnum<ConsoleColor>()), "Enum<TEnum>.ToString")
                .DoTest()
                .DumpResults(Console.Out);]]></code> 
            <note>See also the <strong>Examples</strong> section of the <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> and <see cref="T:KGySoft.Diagnostics.PerformanceTest`1"/> classes for some further examples.</note>
            </example>
            <seealso cref="T:KGySoft.Diagnostics.PerformanceTest"/>
            <seealso cref="T:KGySoft.Diagnostics.PerformanceTest`1"/>
        </member>
        <member name="E:KGySoft.Diagnostics.PerformanceTestBase`2.Initialize">
            <summary>
            Occurs before running the test cases.
            </summary>
        </member>
        <member name="E:KGySoft.Diagnostics.PerformanceTestBase`2.TearDown">
            <summary>
            Occurs after running the tests, even after a failure.
            </summary>
        </member>
        <member name="E:KGySoft.Diagnostics.PerformanceTestBase`2.BeforeCase">
            <summary>
            Occurs before each repetition of a test case, including the warming-up session.
            </summary>
        </member>
        <member name="E:KGySoft.Diagnostics.PerformanceTestBase`2.AfterCase">
            <summary>
            Occurs after each repetition of a test case, including the warming-up session.
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.AddCase(`0,System.String)">
            <summary>
            Adds a test case to the test suit.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> class for some examples.
            </summary>
            <param name="testCase">The test case.</param>
            <param name="name">The name of the test. If not specified, a default name will be added.</param>
            <returns>The self <see cref="T:KGySoft.Diagnostics.PerformanceTestBase`2"/> instance to provide fluent initialization syntax.</returns>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.DoTest">
            <summary>
            Performs the test and returns the test results.
            </summary>
            <returns>An <see cref="T:KGySoft.Diagnostics.IPerformanceTestResultCollection"/> instance containing the test results.</returns>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.GetLength(`1)">
            <summary>
            Gets the length of the result in any unit specified by the <see cref="M:KGySoft.Diagnostics.PerformanceTestBase`2.GetUnit">GetUnit</see> method.
            <br/>The base implementation returns element count if <typeparamref name="TResult"/> is <see cref="T:System.Collections.IEnumerable"/>; otherwise, the size of <typeparamref name="TResult"/> in bytes (which is 4 or 8 bytes for reference types, depending on the platform target).
            </summary>
            <param name="result">The result.</param>
            <returns>The length of the result.</returns>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.GetUnit">
            <summary>
            Gets the length unit name of <typeparamref name="TResult"/>.
            <br/>The base implementation returns the element name if <typeparamref name="TResult"/> is <see cref="T:System.Collections.Generic.IEnumerable`1"/> (C# alias name, if applicable);
            a localized string for <c>item</c>, if <typeparamref name="TResult"/> is a non-generic <see cref="T:System.Collections.IEnumerable"/>; otherwise, a localized string for <c>byte</c>.
            </summary>
            <returns>The unit name of <typeparamref name="TResult"/>.</returns>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.AsString(`1)">
            <summary>
            Gets the string representation of the specified <paramref name="result"/>.
            </summary>
            <param name="result">The result.</param>
            <returns>The string representation of the specified <paramref name="result"/>.</returns>
            <remarks>
            <para>If <typeparamref name="TResult"/> is a <see cref="T:System.Array">byte[]</see>, then it is returned as a raw string with <see cref="P:System.Text.Encoding.Default">Encoding.Default</see>
            encoding (similarly to a HEX editor), while non-whitespace control characters are replaced by square characters (<c>□</c>).</para>
            <para>Zero characters are replaced also if <typeparamref name="TResult"/> is <see cref="T:System.String"/>.</para>
            <para>If <typeparamref name="TResult"/> is <see cref="T:System.Collections.IEnumerable"/>, then the string representation of elements (simply by <see cref="M:System.Object.ToString">ToString</see>) are concatenated.</para>
            <para>In any other case returns the result of <see cref="M:System.Object.ToString">ToString</see> for <paramref name="result"/>, or a localized string for <c>null</c>, if <paramref name="result"/> is <see langword="null"/>.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.Invoke(`0)">
            <summary>
            Invokes the specified delegate.
            </summary>
            <param name="del">The delegate to invoke.</param>
            <returns>A <typeparamref name="TResult"/> instance returned by the specified delegate. Returns <see langword="null"/> for <see langword="void"/> delegate types.</returns>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.OnInitialize">
            <summary>
            Raises the <see cref="E:KGySoft.Diagnostics.PerformanceTestBase`2.Initialize"/> event. This method is called before running the test cases.
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.OnTearDown">
            <summary>
            Raises the <see cref="E:KGySoft.Diagnostics.PerformanceTestBase`2.TearDown"/> event. Called after running the tests, even after a failure.
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.OnBeforeCase">
            <summary>
            Raises the <see cref="E:KGySoft.Diagnostics.PerformanceTestBase`2.BeforeCase"/> event. Called before each repetition of a test case, including the warming-up session.
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTestBase`2.OnAfterCase">
            <summary>
            Raises the <see cref="E:KGySoft.Diagnostics.PerformanceTestBase`2.AfterCase"/> event. Called after each repetition of a test case, including the warming-up session.
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.PerformanceTest`1">
             <summary>
             Provides a class for performance tests of <see cref="T:System.Func`1"/> delegate test cases (tests with a return value).
             </summary>
             <typeparam name="TResult">The type of the result.</typeparam>
             <example>
             <para>The following example demonstrates how to use the <see cref="T:KGySoft.Diagnostics.PerformanceTest`1"/> class:
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections.Generic;
             using System.IO;
             using System.Runtime.Serialization.Formatters.Binary;
             using KGySoft.Diagnostics;
             using KGySoft.Serialization.Binary;
            
             class Example
             {
                 private static object testObj = new List<int> { 1, 2, 3 };
            
                 static void Main(string[] args)
                 {
                     new PerformanceTest<byte[]> { Iterations = 10_000, Repeat = 5 }
                         .AddCase(() =>
                         {
                             using (var ms = new MemoryStream())
                             {
                                 new BinaryFormatter().Serialize(ms, testObj);
                                 return ms.ToArray();
                             }
                         }, "BinaryFormatter")
                         .AddCase(() => BinarySerializer.Serialize(testObj), "BinarySerializer")
                         .DoTest()
                         .DumpResults(Console.Out, forceShowReturnSizes: true);
                 }
             }
            
             // This code example produces an output similar to the following one:
             // ==[Performance Test Results]================================================
             // Iterations: 10,000
             // Warming up: Yes
             // Test cases: 2
             // Repeats: 5
             // Calling GC.Collect: Yes
             // Forced CPU Affinity: No
             // Cases are sorted by time (quickest first)
             // --------------------------------------------------
             // 1. BinarySerializer: average time: 27.16 ms
             //   #1          27.27 ms
             //   #2          26.53 ms   <---- Best
             //   #3          28.26 ms   <---- Worst
             //   #4          26.94 ms
             //   #5          26.78 ms
             //   Worst-Best difference: 1.73 ms (6.53 %)
             //   Result size: 16 byte(s)
             // 2. BinaryFormatter: average time: 42.93 ms (+15.77 ms / 158.07 %)
             //   #1          44.94 ms   <---- Worst
             //   #2          43.52 ms
             //   #3          42.79 ms
             //   #4          42.21 ms
             //   #5          41.18 ms   <---- Best
             //   Worst-Best difference: 3.76 ms (9.14 %)
             //   Result size: 221 byte(s) (+205.00 byte(s) / 1,381.25 %)]]></code>
             </para>
             <note type="tip">If the test focuses on size performance set <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.Iterations"/> to <c>1</c> and <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.SortBySize"/> to <see langword="true"/>.</note>
             <note>See some further examples in the <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> class.</note>
             <note type="tip">See also the <strong>Examples</strong> section of the <see cref="T:KGySoft.Diagnostics.PerformanceTestBase`2"/> class to see how to create a custom type for parameterized performance tests.</note>
             </example>
             <seealso cref="T:KGySoft.Diagnostics.PerformanceTest" />
        </member>
        <member name="M:KGySoft.Diagnostics.PerformanceTest`1.Invoke(System.Func{`0})">
            <summary>
            Invokes the specified delegate.
            </summary>
            <param name="del">The delegate to invoke.</param>
            <returns>A <typeparamref name="TResult" /> instance returned by the specified delegate.</returns>
        </member>
        <member name="T:KGySoft.Diagnostics.Profiler">
             <summary>
             Provides members for performance monitoring.
             </summary>
             <remarks>
             <para>The <see cref="T:KGySoft.Diagnostics.Profiler"/> class can be used to place measurement sections into the code. The results can be accessed either directly
             by the <see cref="M:KGySoft.Diagnostics.Profiler.GetMeasurementResults(System.String)">GetMeasurementResults</see> method or when the <see cref="P:KGySoft.Diagnostics.Profiler.AutoSaveResults"/> property is <see langword="true"/>,
             then the results will be dumped into an .XML file into a folder designated by the <see cref="P:KGySoft.Diagnostics.Profiler.ProfilerDirectory"/> property.</para>
             <para>The profiling can be turned on and off globally by the <see cref="P:KGySoft.Diagnostics.Profiler.Enabled"/> property.</para>
             <note>It is recommended to measure performance with <c>Release</c> builds.</note>
             </remarks>
             <example>
             The following example demonstrates how to place measurement sections into the code:
             <note type="tip">Try also <a href="https://dotnetfiddle.net/BuuisW" target="_blank">online</a>.</note>
             <code lang="C#"><![CDATA[
             using System;
             using System.Threading;
             using KGySoft.Diagnostics;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     Profiler.Enabled = true; // set false to turn off profiling
                     Profiler.AutoSaveResults = true; // if true a result .XML file is saved on exit
            
                     // put the measurement into a using block. You can specify a category and operation name.
                     using (Profiler.Measure(nameof(Example), $"{nameof(Main)} total"))
                     {
                         for (int i = 0; i < 10; i++)
                         {
                             using (Profiler.Measure(nameof(Example), $"{nameof(Main)}/1 iteration"))
                             {
                                 DoSmallTask();
                                 DoBigTask();
                             }
                         }
                     }
            
                     // if Profiler.AutoSaveResults is false you might want to check the results here: Profiler.GetMeasurementResults(nameof(Example));
                 }
            
                 private static void DoSmallTask()
                 {
                     using (Profiler.Measure(nameof(Example), nameof(DoSmallTask)))
                         Console.WriteLine(nameof(DoSmallTask));
                 }
            
                 private static void DoBigTask()
                 {
                     using (Profiler.Measure(nameof(Example), nameof(DoBigTask)))
                     {
                         for (int i = 0; i < 5; i++)
                         {
                             Thread.Sleep(10);
                             DoSmallTask();
                         }
                     }
                 }
             }]]></code>
             As a result, in the folder of the application a new <c>Profiler</c> folder has been created with a file named something like <c>[time stamp]_ConsoleApp1.exe.xml</c>
             with a similar content to the following:
             <code lang="XML"><![CDATA[
             <?xml version="1.0" encoding="utf-8"?>
             <ProfilerResult>
               <item Category = "Example" Operation="Main total" NumberOfCalls="1" FirstCall="00:00:00.5500736" TotalTime="00:00:00.5500736" AverageCallTime="00:00:00.5500736" />
               <item Category = "Example" Operation="Main/1 iteration" NumberOfCalls="10" FirstCall="00:00:00.0555439" TotalTime="00:00:00.5500554" AverageCallTime="00:00:00.0550055" />
               <item Category = "Example" Operation="DoSmallTask" NumberOfCalls="60" FirstCall="00:00:00.0005378" TotalTime="00:00:00.0124114" AverageCallTime="00:00:00.0002068" />
               <item Category = "Example" Operation="DoBigTask" NumberOfCalls="10" FirstCall="00:00:00.0546513" TotalTime="00:00:00.5455339" AverageCallTime="00:00:00.0545533" />
             </ProfilerResult>]]></code>
             You can open the result even in Microsoft Excel as a table, which allows you to filter and sort the results easily:
             <br/><img src="../Help/Images/ProfilerResults.png" alt="The Profiler results opened in Microsoft Excel."/>
             </example>
        </member>
        <member name="P:KGySoft.Diagnostics.Profiler.Enabled">
            <summary>
            Gets or sets whether profiling is enabled.
            <br/>Default value: <see langword="true"/>
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.Profiler.AutoSaveResults">
            <summary>
            Gets or sets whether results are automatically saved into the directory determined by the <see cref="P:KGySoft.Diagnostics.Profiler.ProfilerDirectory"/> property.
            <br/>Default value: <see langword="true"/>
            </summary>
            <remarks>
            If the value of this property is <see langword="true"/>, the profiler results are dumped automatically when the current
            <see cref="T:System.AppDomain"/> is unloaded. This happens typically when the application is closed.
            </remarks>
            <seealso cref="P:KGySoft.Diagnostics.Profiler.ProfilerDirectory"/>
        </member>
        <member name="P:KGySoft.Diagnostics.Profiler.ProfilerDirectory">
            <summary>
            Gets or sets the output folder of the profiler. When <see langword="null"/> or empty value is assigned,
            sets the <c>Profiler</c> subdirectory of the executing assembly.
            </summary>
            <remarks>
            <para>Results are dumped only if <see cref="P:KGySoft.Diagnostics.Profiler.AutoSaveResults"/> property is <see langword="true"/>.</para>
            <para>By default, the value of this property is the <c>Profiler</c> subdirectory of the executing assembly.
            When <see langword="null"/> or empty value is assigned, this default value is reset.</para>
            <para>When the directory does not exist, it will be created automatically. The profiler results are
            dumped when the current <see cref="T:System.AppDomain"/> is unloaded. This happens typically when the application is closed.</para>
            </remarks>
            <seealso cref="P:KGySoft.Diagnostics.Profiler.AutoSaveResults"/>
        </member>
        <member name="M:KGySoft.Diagnostics.Profiler.GetMeasurementResults">
            <summary>
            Gets the measurement results so far.
            </summary>
            <returns>The measurement results collected so far.</returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Diagnostics.Profiler.AutoSaveResults"/> is <see langword="true"/>, the measurement results are automatically dumped in
            XML files on application exit, so accessing this property is required only
            when measurements are needed to be accessed programmatically.
            </para>
            <para>Getting this property is an O(1) operation. The returned value is a lazy enumerator. If <see cref="M:KGySoft.Diagnostics.Profiler.Measure(System.String,System.String)"/>
            method is called during the enumeration an exception might be thrown.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Diagnostics.Profiler.GetMeasurementResults(System.String)">
            <summary>
            Gets the measurement results of the given <paramref name="category"/> so far.
            </summary>
            <param name="category">The category of the measurement results to obtain.</param>
            <returns>The measurement results of the given <paramref name="category"/> collected so far.</returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Diagnostics.Profiler.AutoSaveResults"/> is <see langword="true"/>, the measurement results are automatically dumped in
            XML files on application exit, so accessing this property is required only
            when measurements are needed to be accessed programmatically.
            </para>
            <para>Getting this property is an O(1) operation. The returned value is a lazy enumerator. If <see cref="M:KGySoft.Diagnostics.Profiler.Measure(System.String,System.String)"/>
            method is called during the enumeration an exception might be thrown.</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Diagnostics.Profiler.GetMeasurementResult(System.String,System.String)">
            <summary>
            Gets a measurement result as an <see cref="T:KGySoft.Diagnostics.IMeasureItem"/> instance, or <see langword="null"/>, if the
            measurement result is not found with the given <paramref name="category"/> and <paramref name="operation"/>.
            </summary>
            <param name="category">The category name of the operation. If <see langword="null"/> or empty, looks for an uncategorized operation.</param>
            <param name="operation">Name of the operation.</param>
            <returns>An <see cref="T:KGySoft.Diagnostics.IMeasureItem"/> instance that contains the measurement results of the required
            operation, or <see langword="null"/>, if the measurement result is not found with the given <paramref name="category"/>
            and <paramref name="operation"/>.</returns>
            <remarks>Unless <see cref="M:KGySoft.Diagnostics.Profiler.Reset"/> is called, there is no need to retrieve the measurement result of the same
            <paramref name="category"/> and <see paramref="operation"/> again and again because the returned <see cref="T:KGySoft.Diagnostics.IMeasureItem"/>
            instance reflects the changes of the measurement operation.</remarks>
        </member>
        <member name="M:KGySoft.Diagnostics.Profiler.Measure(System.String,System.String)">
            <summary>
            If <see cref="P:KGySoft.Diagnostics.Profiler.Enabled"/> is <see langword="true"/>, starts a profiling measure. Use in <see langword="using"/> block.
            </summary>
            <param name="category">A category that contains the operation. Can be the name of the caller type, for example.
            If <see langword="null"/> or empty, the measurement will be uncategorized.</param>
            <param name="operation">Name of the operation.</param>
            <returns>An <see cref="T:System.IDisposable"/> instance that should be enclosed into a <see langword="using"/> block.
            When <see cref="P:KGySoft.Diagnostics.Profiler.Enabled"/> is <see langword="false"/>, this method returns <see langword="null"/>.</returns>
            <remarks>
            <note type="tip">See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Diagnostics.Profiler"/> class for details and an example.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Diagnostics.Profiler.Reset">
            <summary>
            Resets the profiler results. Every measurement performed earlier will be lost.
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Diagnostics"/> namespace contains diagnostic tools such as the <see cref="T:KGySoft.Diagnostics.Profiler"/>
            and <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> classes along with some generic debugger views.
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.IMeasureItem">
            <summary>
            Represents a measurement item that is managed by the <see cref="T:KGySoft.Diagnostics.Profiler"/> class.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.IMeasureItem.Category">
            <summary>
            Gets the category name of the measurement item.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.IMeasureItem.Operation">
            <summary>
            Gets the operation name of the measurement item.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.IMeasureItem.NumberOfCalls">
            <summary>
            Gets the number of calls of the current operation.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.IMeasureItem.FirstCall">
            <summary>
            Gets the duration of the first call of the current operation.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.IMeasureItem.TotalTime">
            <summary>
            Gets the total duration of the current operation.
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.IPerformanceTestResultCollection">
            <summary>
            Represents the performance test results of a <see cref="T:KGySoft.Diagnostics.PerformanceTestBase"/> implementation.
            Items are sorted either by execution time (ascending - if <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.Iterations"/> was specified in the original test),
            by performed iterations (descending - if <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.TestTime"/> was specified),
            or by result size (ascending - if <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.SortBySize"/> was <see langword="true"/>).
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Diagnostics.PerformanceTest"/> class for some examples.
            </summary>
        </member>
        <member name="M:KGySoft.Diagnostics.IPerformanceTestResultCollection.DumpResults(System.IO.TextWriter,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Dumps the results by the specified <paramref name="textWriter"/> by using predefined localizable resources.
            </summary>
            <param name="textWriter">The text writer to use for dumping the results.</param>
            <param name="dumpConfig"><see langword="true"/> to dump the test configuration; otherwise, <see langword="false"/>. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <param name="dumpReturnValue"><see langword="true"/> to dump also the return value (or the call stack of the thrown exception) of the test cases.
            Ignored, when the delegate type of the test has a <see langword="void"/> return value and the test case did not throw an exception. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="forceShowReturnSizes"><see langword="true"/> to show the size of non-<see langword="void"/> test cases even if <paramref name="dumpReturnValue"/> is <see langword="false"/> and results are not sorted by size;
            <see langword="false"/> to show result size only when return values are dumped or results are sorted by size. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <remarks>
            <para>If <paramref name="dumpConfig"/> is <see langword="true"/>, then please note that the configuration properties are taken from the
            <see cref="T:KGySoft.Diagnostics.PerformanceTestBase"/> instance at the moment the results are dumped. If you change the configuration after retrieving a result the new values will be reflected in the dumped values.</para>
            <para>If <paramref name="dumpReturnValue"/> is <see langword="true"/>, then the lastly returned value will also be dumped. Can be useful for tests, which measure size instead of execution time.
            In this case it can make sense to set <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.SortBySize"/> to <see langword="true"/>. If the test case has thrown an exception, then
            the call stack of the exception will be dumped.
            </para>
            </remarks>
        </member>
        <member name="T:KGySoft.Diagnostics.ITestCaseRepetition">
            <summary>
            Represents the performance test results of a single repetition of a test case.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.ITestCaseRepetition.ExecutionTime">
            <summary>
            Gets the actual execution time of the test case. It can be a somewhat longer time than
            <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.TestTime"/>, especially if the test case is an expensive operation.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.ITestCaseRepetition.Iterations">
            <summary>
            Gets the performed iterations during this repetition.
            </summary>
        </member>
        <member name="T:KGySoft.Diagnostics.ITestCaseResult">
            <summary>
            Represents a performance test case result in an <see cref="T:KGySoft.Diagnostics.IPerformanceTestResultCollection"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.ITestCaseResult.Name">
            <summary>
            Gets the name of the test case.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.ITestCaseResult.Result">
            <summary>
            Gets the result of the test case, or <see langword="null"/>, if not applicable.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.ITestCaseResult.Error">
            <summary>
            Gets the <see cref="T:System.Exception"/> of the test case if it failed; otherwise, gets <see langword="null"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Diagnostics.ITestCaseResult.Repetitions">
            <summary>
            Gets the results of repetitions of this test case.
            Items count is determined by the <see cref="P:KGySoft.Diagnostics.PerformanceTestBase.Repeat"/> property of the original test,
            unless <see cref="P:KGySoft.Diagnostics.ITestCaseResult.Error"/> returns a non-<see langword="null"/> value.
            Order of the items is the original execution order.
            </summary>
        </member>
        <member name="T:KGySoft.IO.UnmanagedMemoryStreamWrapper">
            <summary>
            Similar to the System version but this is read-only and provides no overridden logic for async operations.
            </summary>
        </member>
        <member name="T:KGySoft.LanguageSettings">
            <summary>
            Represents the language settings of the current thread. Use this class also when you want to be notified on
            language changes and to control the behavior of those <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances,
            which are configured to use centralized settings.
            </summary>
            <seealso cref="T:KGySoft.PublicResources"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
            <remarks>
            <para>If you use <c>KGySoft.CoreLibraries</c> in a class library, then you do not really need to use this class. Just use the publicly available resources via
            the <see cref="T:KGySoft.PublicResources"/> class and let the consumers of your library adjusting the language settings by this class in their applications.</para>
            <para>If you use <c>KGySoft.CoreLibraries</c> or other class libraries dependent on <c>KGySoft.CoreLibraries</c> in an application, then use this class to
            set the language of your application and the behavior of centralized resource managers. The <c>KGySoft.CoreLibraries</c> contains one centralized resource manager
            for the string resources used in the library. Some of these strings can be publicly accessed via the <see cref="T:KGySoft.PublicResources"/> members. See also the example below.</para>
            </remarks>
            <example>
            The following example demonstrates how to generate resource files in your application for any language.
            <code lang="C#"><![CDATA[
            using System;
            using System.Globalization;
            using KGySoft;
            using KGySoft.Resources;
            
            class Example
            {
                static void Main(string[] args)
                {
                    LanguageSettings.DisplayLanguage = CultureInfo.GetCultureInfo("de-DE");
            
                    // Even though we set the language above centralized resources still return the built-in compiled resources.
                    // Of course, if you use compiled resources in your application with the selected language, then they will be considered.
                    Console.WriteLine("Non-localized resource:");
                    Console.WriteLine(PublicResources.ArgumentNull);
                    Console.WriteLine();
            
                    // In an application that uses KGySoft.CoreLibraries you can opt-in to use dynamic resources from .resx files.
                    LanguageSettings.DynamicResourceManagersSource = ResourceManagerSources.CompiledAndResX;
            
                    // Next line tells that whenever a resource is requested, which does not exist in the resource file of the display
                    // language, then its resource file will be dynamically created and/or expanded by the requested resource.
                    LanguageSettings.DynamicResourceManagersAutoAppend = AutoAppendOptions.AppendFirstNeutralCulture;
            
                    // Actually the default value is AutoAppendOptions.AppendFirstNeutralCulture | AutoAppendOptions.AppendOnLoad,
                    // which causes to add not just the requested resource but all of the missing ones to the target resource file.
                    // Delete the line above to see the difference.
            
                    Console.WriteLine("Localized resource:");
                    Console.WriteLine(PublicResources.ArgumentNull);
                }
            }
            
            // When this example is executed for the first time it produces the following output:
            
            // Non-localized resource:
            // Value cannot be null.
            // 
            // Localized resource:
            // [T]Value cannot be null.]]></code>
            <para>The <c>[T]</c> before a resource indicates that a new resource has been generated, which is not translated yet. In the <c>Resources</c> subfolder of your compiled project
            now there must be a new file named <c>KGySoft.CoreLibraries.Messages.de.resx</c> (the exact name depends on the display language and the appending strategy). Its content now must be the following:</para>
            <code lang="XML"><![CDATA[
            <?xml version="1.0"?>
            <root>
              <data name = "General_ArgumentNull">
                <value>[T]Value cannot be null.</value>
              </data>
            </root>]]></code>
            <para>Search for the <c>[T]</c> values in the generated file to find the untranslated resources and feel free to change them. If you change the resource and execute the example again it will now show the translation you provided.</para>
            <note type="tip"><list type="bullet">
            <item>If the <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/> flag is enabled in <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/> property, then not only the explicitly obtained resources but all resource entries will
            appeared in the localized resource set.</item>
            <item>You can use the <see cref="M:KGySoft.LanguageSettings.EnsureResourcesGenerated">EnsureResourcesGenerated</see> method to generate the possibly non-existing resource sets without explicitly accessing a resource first.</item>
            <item>You can use the <see cref="M:KGySoft.LanguageSettings.EnsureInvariantResourcesMerged">EnsureInvariantResourcesMerged</see> method to forcibly merge all invariant resource entries even if a localized resource set already exists.
            This can be useful to add the possibly missing entries to the localization, if some new entries have been introduced in a new version, for example.</item>
            <item>To see how to add a dynamic resource manager to your own class library
            see the <em>Recommended usage for string resources in a class library</em> section in the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</item>
            <item>To see how to use dynamically created resources for any language in a live application with editing support see
            the <a href="https://github.com/koszeggy/KGySoft.Drawing.Tools" target="_blank">KGySoft.Drawing.Tools</a> GitHub repository.</item>
            </list></note>
            </example>
        </member>
        <member name="E:KGySoft.LanguageSettings.FormattingLanguageChanged">
            <summary>
            Occurs when the formatting language (<see cref="P:System.Threading.Thread.CurrentCulture">Thread.CurrentThread.CurrentCulture</see>) has been changed by setting the
            <see cref="P:KGySoft.LanguageSettings.FormattingLanguage"/> property. Only the subscriptions from the same thread are invoked.
            </summary>
            <remarks>
            Use this event if you want to be notified of changing the formatting culture of the current thread.
            When this event is triggered only the subscribers from the thread of the language change are notified.
            </remarks>
            <seealso cref="P:KGySoft.LanguageSettings.FormattingLanguage"/>
            <seealso cref="E:KGySoft.LanguageSettings.FormattingLanguageChangedGlobal"/>
        </member>
        <member name="E:KGySoft.LanguageSettings.FormattingLanguageChangedGlobal">
            <summary>
            Occurs when the formatting language (<see cref="P:System.Threading.Thread.CurrentCulture">Thread.CurrentThread.CurrentCulture</see>) has been changed in any <see cref="T:System.Threading.Thread"/>
            by setting <see cref="P:KGySoft.LanguageSettings.FormattingLanguage"/> property. The subscribers are invoked from all threads.
            </summary>
            <remarks>
            The <see cref="P:KGySoft.LanguageSettings.FormattingLanguage"/> property reflects the formatting culture of the current thread (<see cref="P:System.Threading.Thread.CurrentCulture">Thread.CurrentThread.CurrentCulture</see>).
            This event triggers all subscribers regardless of their source thread in the current <see cref="T:System.AppDomain"/>.
            When the event is triggered, the subscribers are invoked in the thread of the changed formatting language. You might
            want to check if the thread of the invocation is the same as the thread of the subscription.
            To notify subscribers from the affected thread only use the <see cref="E:KGySoft.LanguageSettings.FormattingLanguageChanged"/> event instead.
            </remarks>
            <seealso cref="P:KGySoft.LanguageSettings.FormattingLanguage"/>
            <seealso cref="E:KGySoft.LanguageSettings.FormattingLanguageChanged"/>
        </member>
        <member name="E:KGySoft.LanguageSettings.DisplayLanguageChanged">
            <summary>
            Occurs when the display language (<see cref="P:System.Threading.Thread.CurrentUICulture">Thread.CurrentThread.CurrentUICulture</see>) has been changed by setting the
            <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/> property. Only the subscriptions from the same thread are invoked.
            </summary>
            <remarks>
            Use this event if you want to be notified of changing the display culture of the current thread.
            When this event is triggered only the subscribers from the thread of the language change are notified.
            </remarks>
            <seealso cref="P:KGySoft.LanguageSettings.DisplayLanguage"/>
            <seealso cref="E:KGySoft.LanguageSettings.DisplayLanguageChangedGlobal"/>
        </member>
        <member name="E:KGySoft.LanguageSettings.DisplayLanguageChangedGlobal">
            <summary>
            Occurs when the display language (<see cref="P:System.Threading.Thread.CurrentUICulture">Thread.CurrentThread.CurrentUICulture</see>) has been changed in any <see cref="T:System.Threading.Thread"/>
            by setting <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/> property. The subscribers are invoked from all threads.
            </summary>
            <remarks>
            The <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/> property reflects the display culture of the current thread (<see cref="P:System.Threading.Thread.CurrentUICulture">Thread.CurrentThread.CurrentUICulture</see>).
            This event triggers all subscribers regardless of their source thread in the current <see cref="T:System.AppDomain"/>.
            When the event is triggered, the subscribers are invoked in the thread of the changed display language. You might
            want to check if the thread of the invocation is the same as the thread of the subscription.
            To notify subscribers from the affected thread only use the <see cref="E:KGySoft.LanguageSettings.DisplayLanguageChanged"/> event instead.
            </remarks>
            <seealso cref="P:KGySoft.LanguageSettings.DisplayLanguage"/>
            <seealso cref="E:KGySoft.LanguageSettings.DisplayLanguageChanged"/>
        </member>
        <member name="P:KGySoft.LanguageSettings.FormattingLanguage">
            <summary>
            Gets or sets the formatting language of the current <see cref="T:System.Threading.Thread"/>, which is used for formatting and parsing numbers,
            date and time values, currency, etc.
            When set, <see cref="E:KGySoft.LanguageSettings.FormattingLanguageChanged"/> and <see cref="E:KGySoft.LanguageSettings.FormattingLanguageChangedGlobal"/> events are triggered.
            </summary>
            <remarks>
            <para>Formatting language represents the regional setting of formatting and parsing numbers, date and time values,
            currency, etc.</para>
            <para>Use this property instead of <see cref="P:System.Threading.Thread.CurrentCulture">Thread.CurrentThread.CurrentCulture</see> to
            keep language changes synchronized in your application.</para>
            <para>When this property is set, <see cref="E:KGySoft.LanguageSettings.FormattingLanguageChanged"/> and <see cref="E:KGySoft.LanguageSettings.FormattingLanguageChangedGlobal"/> events are triggered,
            which makes possible for example refreshing UI components displaying culture-specific formatted values.</para>
            </remarks>
            <value>The formatting language of the current <see cref="T:System.Threading.Thread"/>. By default equals to the language of formats
            of system regional settings.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see kangword="null"/>.</exception>
        </member>
        <member name="P:KGySoft.LanguageSettings.DisplayLanguage">
            <summary>
            Gets or sets the display language of the current <see cref="T:System.Threading.Thread"/>, which is used for looking up localizable resources.
            When set, <see cref="E:KGySoft.LanguageSettings.DisplayLanguageChanged"/> and <see cref="E:KGySoft.LanguageSettings.DisplayLanguageChangedGlobal"/> events are triggered.
            <br/>Default value: The display culture of the operating system.
            </summary>
            <remarks>
            <para>Display language represents the language of the user interface of the application. This value is used when
            looking up localizable resources.</para>
            <para>Use this property instead of <see cref="P:System.Threading.Thread.CurrentUICulture">Thread.CurrentThread.CurrentUICulture</see> to
            keep language changes synchronized in your application.</para>
            <para>When this property is set, <see cref="E:KGySoft.LanguageSettings.DisplayLanguageChanged"/> and <see cref="E:KGySoft.LanguageSettings.DisplayLanguageChangedGlobal"/> events are triggered,
            which makes possible for example to refresh the language of the UI on the fly on language change.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">
            <summary>
            Gets or sets the source, from which the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances of the current application
            domain should take the resources when their <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>
            </summary>
            <remarks>Considering that the default value is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>, all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances, which
            use <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> property with <see langword="true"/> value, will work fully compatible with the <see cref="T:System.Resources.ResourceManager"/>
            class by default. Therefore, an application, which uses <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings (maybe indirectly via
            class libraries), must opt-in the dynamic behavior of creating .resx resource files on the fly by setting this property either to
            <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/> or <see cref="F:KGySoft.Resources.ResourceManagerSources.ResXOnly"/>.</remarks>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.Source"/>
        </member>
        <member name="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave">
            <summary>
            Gets or sets the auto saving options for the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances
            of the current application domain when their <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            <br/>Default value: <see cref="F:KGySoft.Resources.AutoSaveOptions.LanguageChange"/>, <see cref="F:KGySoft.Resources.AutoSaveOptions.DomainUnload"/>, <see cref="F:KGySoft.Resources.AutoSaveOptions.SourceChange"/>
            </summary>
            <remarks>Considering that the default value of the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> property is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>,
            none of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/>, whose <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> property is <see langword="true"/> will
            auto save their content by default. Therefore, an application, which uses <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings (maybe indirectly via
            class libraries), must opt-in the dynamic behavior of creating .resx resource files on the fly by setting the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> property
            either to <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/> or <see cref="F:KGySoft.Resources.ResourceManagerSources.ResXOnly"/>.</remarks>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/>
            <seealso cref="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError"/>
        </member>
        <member name="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend">
            <summary>
            Gets or sets the auto append options for the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances
            of the current application domain when their <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            <br/>Default value: <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendFirstNeutralCulture"/>, <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/>
            </summary>
            <remarks>Considering that the default value of the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> property is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>,
            none of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/>, whose <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> property is <see langword="true"/> will
            auto append their content by default. Therefore, an application, which uses <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings (maybe indirectly via
            class libraries), must opt-in the dynamic behavior of creating .resx resource files on the fly by setting the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> property
            either to <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/> or <see cref="F:KGySoft.Resources.ResourceManagerSources.ResXOnly"/>.</remarks>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/>
        </member>
        <member name="P:KGySoft.LanguageSettings.DynamicResourceManagersResXResourcesDir">
            <summary>
            Gets or sets the path of the .resx resource files for the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances
            of the current application domain when their <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            If <see langword="null"/>, then even the centralized <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances may use individual path settings.
            <br/>Default value: <see langword="null"/>
            </summary>
            <remarks>
            <para>Due to compatibility reasons the .resx resources path can be handled individually for all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances,
            even if their <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>. To opt-in using a centralized path,
            set this property to a non-<see langword="null"/> value.</para>
            <para>Setting this property to a non-<see langword="null"/> value overwrites the <see cref="P:KGySoft.Resources.HybridResourceManager.ResXResourcesDir"/> property
            of all centralized <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances so setting it to <see langword="null"/> again will not make them switch back
            to their previous value.</para>
            <note>Changing this property does not trigger any auto save or release operation.
            To save the possible changes regarding to the original path you need to call the <see cref="M:KGySoft.LanguageSettings.SavePendingResources(System.Boolean)">SavePendingResources</see> method
            before changing this property. After changing this property it is recommended to call the <see cref="M:KGySoft.LanguageSettings.ReleaseAllResources">ReleaseAllResources</see>
            method to drop all possibly loaded/created resources that are related to the original path.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">
            <summary>
            Gets or sets the prefix of an untranslated <see cref="T:System.String"/> resource.
            Used by the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances if <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/>
            or <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property is configured to use auto appending.
            <br/>Default value: <c>[T]</c>
            </summary>
        </member>
        <member name="P:KGySoft.LanguageSettings.UnknownResourcePrefix">
            <summary>
            Gets or sets the prefix of an unknown (non-existing) <see cref="T:System.String"/> resource.
            Used by the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances if <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/>
            or <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property is configured to add non existing resources to the invariant resource set.
            <br/>Default value: <c>[U]</c>
            </summary>
        </member>
        <member name="M:KGySoft.LanguageSettings.EnsureResourcesGenerated">
            <summary>
            Ensures that <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings load or generate the resource sets
            for the current <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/>. This method affects all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances in
            the current application domain, whose <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            </summary>
            <remarks>
            <note>This method is similar to <see cref="M:KGySoft.LanguageSettings.EnsureInvariantResourcesMerged">EnsureInvariantResourcesMerged</see> but it skips
            merging of resources for already existing resource sets (either in memory or in a loadable file).
            Use the <see cref="M:KGySoft.LanguageSettings.EnsureInvariantResourcesMerged">EnsureInvariantResourcesMerged</see> method to force a new merge even for possibly existing resource sets.</note>
            <para>This method makes all centralized <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances in the current <see cref="T:System.AppDomain"/>
            (a <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instance uses centralized settings when its <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>)
            load or generate the resource set for the current <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/> in memory. This makes possible that for the next auto save event
            (see also the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave"/> property) all such <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances will have
            a saved resource set for the current <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/>.</para>
            <para>You can call also the <see cref="M:KGySoft.LanguageSettings.SavePendingResources(System.Boolean)">SavePendingResources</see> method to save the generated resource sets immediately.</para>
            <para>When generating resources, the value of the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/> is be respected.</para>
            <note>This method has no effect if <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>,
            or when there are no append options enabled in the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/> property.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.LanguageSettings.EnsureInvariantResourcesMerged">
            <summary>
            Ensures that all invariant resource entries in all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings are
            merged for the current <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/>. This method affects all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances in
            the current application domain, whose <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            </summary>
            <remarks>
            <note>This method is similar to <see cref="M:KGySoft.LanguageSettings.EnsureResourcesGenerated">EnsureResourcesGenerated</see> but it forces a new merge even
            for existing resource sets. It can be useful if we want to ensure that possibly newly introduced resources (due to a new version release, for example)
            are also merged into the optionally already existing resource set files.</note>
            <para>If there are no existing resources for the current <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/> yet, then this method is functionally equivalent with
            the <see cref="M:KGySoft.LanguageSettings.EnsureResourcesGenerated">EnsureResourcesGenerated</see> method, though it can be significantly slower than that.</para>
            <para>You can call also the <see cref="M:KGySoft.LanguageSettings.SavePendingResources(System.Boolean)">SavePendingResources</see> method to save the generated or updated resource sets immediately.</para>
            <para>Merging is performed using the rules specified by the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/> property.</para>
            <note>This method has no effect if <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>,
            or when there are no append options enabled in the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/> property.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.LanguageSettings.SavePendingResources(System.Boolean)">
            <summary>
            Ensures that <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings save all pending changes. This method affects
            all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances in the current application domain, whose <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            </summary>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx files can be read
            by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx files are often shorter, and the values can be deserialized with better
            accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />), but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <remarks>
            <para>This method forces all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings to save possibly changed or generated resources
            independently from the value of the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave"/> property.</para>
            <para>If this method is called right after the <see cref="M:KGySoft.LanguageSettings.EnsureResourcesGenerated">EnsureResourcesGenerated</see> method, then we can ensure that
            resource files are generated for the currently set <see cref="P:KGySoft.LanguageSettings.DisplayLanguage"/>.</para>
            <note>This method has no effect if <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.LanguageSettings.ReleaseAllResources">
            <summary>
            Ensures that <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings release all loaded resource sets without saving. This method affects
            all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances in the current application domain, whose <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.
            </summary>
            <remarks>
            <para>This method forces all <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances with centralized settings to drop all currently loaded resource sets.</para>
            <para>It can be useful if we saved new .resx files and we want to ensure that all centralized <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances
            reload or regenerate the resource sets when they attempt to access a resource for the next time.</para>
            <note>When calling this method all possible unsaved resource changes will be lost.</note>
            </remarks>
        </member>
        <member name="T:KGySoft.NamespaceDoc">
            <summary>
            The root <see cref="N:KGySoft"/> namespace contains two public classes: the <see cref="T:KGySoft.LanguageSettings"/>, by which you can configure how the language resources should be handled in your library or application;
            and the <see cref="T:KGySoft.PublicResources"/> class, which contains some public string resources that can be used in any project.
            </summary>
            <remarks>
            <para>To see how to configure the language resources of your application see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.LanguageSettings"/> class.</para>
            <para>To see how to add a dynamic resource manager to your own class library
            see the <em>Recommended usage for string resources in a class library</em> section in the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</para>
            </remarks>
        </member>
        <member name="T:KGySoft.PublicResources">
            <summary>
            Provides localizable public string resources that can be used in any project.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.LanguageSettings"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/> classes for examples.
            </summary>
        </member>
        <member name="P:KGySoft.PublicResources.Undefined">
            <summary>Looks up a localized string similar to <c>&lt;undefined&gt;</c></summary>
            <returns>A localized string similar to <c>&lt;undefined&gt;</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.Null">
            <summary>Looks up a localized string similar to <c>&lt;null&gt;</c></summary>
            <returns>A localized string similar to <c>&lt;null&gt;</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArgumentNull">
            <summary>Looks up a localized string similar to <c>Value cannot be null.</c></summary>
            <returns>A localized string similar to <c>Value cannot be null.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArgumentEmpty">
            <summary>Looks up a localized string similar to <c>Value cannot be empty.</c></summary>
            <returns>A localized string similar to <c>Value cannot be empty.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArgumentInvalid">
            <summary>Looks up a localized string similar to <c>The specified argument is invalid.</c></summary>
            <returns>A localized string similar to <c>The specified argument is invalid.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.CollectionEmpty">
            <summary>Looks up a localized string similar to <c>The collection contains no elements.</c></summary>
            <returns>A localized string similar to <c>The collection contains no elements.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArgumentContainsNull">
            <summary>Looks up a localized string similar to <c>Specified argument contains a null element.</c></summary>
            <returns>A localized string similar to <c>Specified argument contains a null element.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArgumentOutOfRange">
            <summary>Looks up a localized string similar to <c>Specified argument was out of the range of valid values.</c></summary>
            <returns>A localized string similar to <c>Specified argument was out of the range of valid values.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.IndexOutOfRange">
            <summary>Looks up a localized string similar to <c>Index was outside the bounds of the array.</c></summary>
            <returns>A localized string similar to <c>Index was outside the bounds of the array.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ObjectDisposed">
            <summary>Looks up a localized string similar to <c>Cannot access a disposed object.</c></summary>
            <returns>A localized string similar to <c>Cannot access a disposed object.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.NotSupported">
            <summary>Looks up a localized string similar to <c>This operation is not supported.</c></summary>
            <returns>A localized string similar to <c>This operation is not supported.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArgumentInvalidString">
            <summary>Looks up a localized string similar to <c>Input string contains an invalid value.</c></summary>
            <returns>A localized string similar to <c>Input string contains an invalid value.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.MaxValueLessThanMinValue">
            <summary>Looks up a localized string similar to <c>Maximum value must be greater than or equal to minimum value.</c></summary>
            <returns>A localized string similar to <c>Maximum value must be greater than or equal to minimum value.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.MaxLengthLessThanMinLength">
            <summary>Looks up a localized string similar to <c>Maximum length must be greater than or equal to minimum length.</c></summary>
            <returns>A localized string similar to <c>Maximum length must be greater than or equal to minimum length.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.Yes">
            <summary>Looks up a localized string similar to <c>Yes</c></summary>
            <returns>A localized string similar to <c>Yes</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.No">
            <summary>Looks up a localized string similar to <c>No</c></summary>
            <returns>A localized string similar to <c>No</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.Millisecond">
            <summary>Looks up a localized string similar to <c>ms</c></summary>
            <returns>A localized string similar to <c>ms</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.QuoteStart">
            <summary>Looks up a localized string similar to <c>'</c></summary>
            <returns>A localized string similar to <c>'</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.QuoteEnd">
            <summary>Looks up a localized string similar to <c>'</c></summary>
            <returns>A localized string similar to <c>'</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ArrayInvalidOffsLen">
            <summary>Looks up a localized string similar to <c>Offset and length were out of bounds for the array.</c></summary>
            <returns>A localized string similar to <c>Offset and length were out of bounds for the array.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.IEnumeratorEnumerationNotStartedOrFinished">
            <summary>Looks up a localized string similar to <c>Enumeration has either not started or has already finished.</c></summary>
            <returns>A localized string similar to <c>Enumeration has either not started or has already finished.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.IEnumeratorCollectionModified">
            <summary>Looks up a localized string similar to <c>Collection was modified; enumeration operation may not execute.</c></summary>
            <returns>A localized string similar to <c>Collection was modified; enumeration operation may not execute.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.IDictionaryKeyNotFound">
            <summary>Looks up a localized string similar to <c>The given key was not present in the dictionary.</c></summary>
            <returns>A localized string similar to <c>The given key was not present in the dictionary.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.IDictionaryDuplicateKey">
            <summary>Looks up a localized string similar to <c>An item with the same key has already been added.</c></summary>
            <returns>A localized string similar to <c>An item with the same key has already been added.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ICollectionCopyToDestArrayShort">
            <summary>Looks up a localized string similar to <c>Destination array is not long enough to copy all the items in the collection. Check array index and length.</c></summary>
            <returns>A localized string similar to <c>Destination array is not long enough to copy all the items in the collection. Check array index and length.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ICollectionCopyToSingleDimArrayOnly">
            <summary>Looks up a localized string similar to <c>Only single dimensional arrays are supported for the requested action.</c></summary>
            <returns>A localized string similar to <c>Only single dimensional arrays are supported for the requested action.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ICollectionArrayTypeInvalid">
            <summary>Looks up a localized string similar to <c>Target array type is not compatible with the type of items in the collection.</c></summary>
            <returns>A localized string similar to <c>Target array type is not compatible with the type of items in the collection.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.ICollectionReadOnlyModifyNotSupported">
            <summary>Looks up a localized string similar to <c>Modifying a read-only collection is not supported.</c></summary>
            <returns>A localized string similar to <c>Modifying a read-only collection is not supported.</c></returns>
        </member>
        <member name="P:KGySoft.PublicResources.IListInvalidOffsLen">
            <summary>Looks up a localized string similar to <c>Offset and length were out of bounds for the list or count is greater than the number of elements from index to the end of the source collection.</c></summary>
            <returns>A localized string similar to <c>Offset and length were out of bounds for the list or count is greater than the number of elements from index to the end of the source collection.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ArgumentMustBeGreaterThan``1(``0)">
            <summary>Looks up a localized string similar to <c>Specified argument must be greater than {0}.</c></summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Specified argument must be greater than {0}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ArgumentMustBeGreaterThanOrEqualTo``1(``0)">
            <summary>Looks up a localized string similar to <c>Specified argument must be greater than or equal to {0}.</c></summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Specified argument must be greater than or equal to {0}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ArgumentMustBeLessThan``1(``0)">
            <summary>Looks up a localized string similar to <c>Specified argument must be less than {0}.</c></summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Specified argument must be less than {0}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ArgumentMustBeLessThanOrEqualTo``1(``0)">
            <summary>Looks up a localized string similar to <c>Specified argument must be less than or equal to {0}.</c></summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Specified argument must be less than or equal to {0}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ArgumentMustBeBetween``1(``0,``0)">
            <summary>Looks up a localized string similar to <c>Specified argument must be between {0} and {1}.</c></summary>
            <typeparam name="T">Type of the values.</typeparam>
            <param name="low">The low limit.</param>
            <param name="high">The high limit.</param>
            <returns>A localized string similar to <c>Specified argument must be between {0} and {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyNull(System.String)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must not be null.</c></summary>
            <param name="propertyName">The name of the property.</param>
            <returns>A localized string similar to <c>Property '{0}' must not be null.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeGreaterThan``1(System.String,``0)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be greater than {1}.</c></summary>
            <typeparam name="T">Type of the property.</typeparam>
            <param name="propertyName">The name of the property.</param>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Property '{0}' must be greater than {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeGreaterThanOrEqualTo``1(System.String,``0)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be greater than or equal to {1}.</c></summary>
            <typeparam name="T">Type of the property.</typeparam>
            <param name="propertyName">The name of the property.</param>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Property '{0}' must be greater than or equal to {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeLessThan``1(System.String,``0)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be less than {1}.</c></summary>
            <typeparam name="T">Type of the property.</typeparam>
            <param name="propertyName">The name of the property.</param>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Property '{0}' must be less than {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeLessThanOrEqualTo``1(System.String,``0)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be less than or equal to {1}.</c></summary>
            <typeparam name="T">Type of the property.</typeparam>
            <param name="propertyName">The name of the property.</param>
            <param name="limit">The value of the limit.</param>
            <returns>A localized string similar to <c>Property '{0}' must be less than or equal to {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeBetween``1(System.String,``0,``0)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be between {1} and {2}.</c></summary>
            <typeparam name="T">Type of the property.</typeparam>
            <param name="propertyName">The name of the property.</param>
            <param name="low">The low limit.</param>
            <param name="high">The high limit.</param>
            <returns>A localized string similar to <c>Property '{0}' must be between {1} and {2}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeGreaterThanProperty(System.String,System.String)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be greater than property '{1}'.</c></summary>
            <param name="propertyGreater">The name of the property to be expected to have the greater value.</param>
            <param name="propertyLess">The name of the property to be expected to have the less value.</param>
            <returns>A localized string similar to <c>Property '{0}' must be greater than property '{1}'.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMustBeGreaterThanOrEqualToProperty(System.String,System.String)">
            <summary>Looks up a localized string similar to <c>Property '{0}' must be greater than or equal to property '{1}'.</c></summary>
            <param name="propertyGreater">The name of the property to be expected to have the greater value.</param>
            <param name="propertyLess">The name of the property to be expected to have the less value.</param>
            <returns>A localized string similar to <c>Property '{0}' must be greater than or equal to property '{1}'.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.PropertyMessage(System.String,System.String)">
            <summary>Looks up a localized string similar to <c>Property '{0}': {1}</c></summary>
            <param name="propertyName">The name of the property.</param>
            <param name="message">The message to display.</param>
            <returns>A localized string similar to <c>Property '{0}': {1}</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.EnumOutOfRangeWithValues``1(``0)">
            <summary>Looks up a localized string similar to <c>Enum instance of '{0}' type must be one of the following values: {1}.</c></summary>
            <typeparam name="TEnum">Type of the value.</typeparam>
            <param name="value">The enum value.</param>
            <returns>A localized string similar to <c>Enum instance of '{0}' type must be one of the following values: {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.FlagsEnumOutOfRangeWithValues``1(``0)">
            <summary>Looks up a localized string similar to <c>Enum instance of '{0}' type must consist of the following flags: {1}.</c></summary>
            <typeparam name="TEnum">Type of the value.</typeparam>
            <param name="value">The enum value.</param>
            <returns>A localized string similar to <c>Enum instance of '{0}' type must consist of the following flags: {1}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.EnumOutOfRange``1(``0)">
            <summary>Looks up a localized string similar to <c>Enum instance of '{0}' type must be one of the defined values.</c></summary>
            <typeparam name="TEnum">Type of the value.</typeparam>
            <param name="value">The enum value.</param>
            <returns>A localized string similar to <c>Enum instance of '{0}' type must be one of the defined values.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.FlagsEnumOutOfRange``1(``0)">
            <summary>Looks up a localized string similar to <c>Enum instance of '{0}' type must consist of the defined flags.</c></summary>
            <typeparam name="TEnum">Type of the value.</typeparam>
            <param name="value">The enum value.</param>
            <returns>A localized string similar to <c>Enum instance of '{0}' type must consist of the defined flags.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.NotAnInstanceOfType(System.Type)">
            <summary>Looks up a localized string similar to <c>Specified argument is expected to be an instance of type {0}.</c></summary>
            <param name="type">The expected type.</param>
            <returns>A localized string similar to <c>Specified argument is expected to be an instance of type {0}.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ValueContainsIllegalPathCharacters(System.String)">
            <summary>Looks up a localized string similar to <c>Value "{0}" contains illegal path characters.</c></summary>
            <param name="path">The invalid path.</param>
            <returns>A localized string similar to <c>Value "{0}" contains illegal path characters.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.ICollectionNonGenericValueTypeInvalid(System.Object,System.Type)">
            <summary>Looks up a localized string similar to <c>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</c></summary>
            <param name="value">The provided value.</param>
            <param name="type">The expected type.</param>
            <returns>A localized string similar to <c>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</c></returns>
        </member>
        <member name="M:KGySoft.PublicResources.IDictionaryNonGenericKeyTypeInvalid(System.Object,System.Type)">
            <summary>Looks up a localized string similar to <c>The key "{0}" is not of type "{1}" and cannot be used in this generic collection.</c></summary>
            <param name="key">The provided key.</param>
            <param name="type">The expected type.</param>
            <returns>A localized string similar to <c>The key "{0}" is not of type "{1}" and cannot be used in this generic collection.</c></returns>
        </member>
        <member name="T:KGySoft.Reflection.Accessors">
            <summary>
            Contains lazy initialized well-known accessors used in the project.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.Accessors.TryInvokeCtor(System.Object,System.Object[])">
            <summary>
            Invokes a constructor on an already created instance.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.ActionMethodAccessor">
            <summary>
            Action method accessor invoker for any parameters.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.AssemblyResolver.LoadAssembly(System.Reflection.AssemblyName,KGySoft.Reflection.ResolveAssemblyOptions)">
            <summary>
            Loads the assembly with partial name. It is needed because Assembly.LoadWithPartialName is obsolete.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.CreateInstanceAccessor">
            <summary>
            Provides an efficient way for creating objects via dynamically created delegates.
            </summary>
            <remarks>
            <para>You can obtain a <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> instance by the static <see cref="O:KGySoft.Reflection.CreateInstanceAccessor.GetAccessor">GetAccessor</see> methods.
            There are two overloads of them: <see cref="M:KGySoft.Reflection.CreateInstanceAccessor.GetAccessor(System.Type)"/> can be used for types with parameterless constructors and for creating value types without a constructor,
            and the <see cref="M:KGySoft.Reflection.CreateInstanceAccessor.GetAccessor(System.Reflection.ConstructorInfo)"/> overload is for creating an instance by a specified constructor (with or without parameters).</para>
            <para>The <see cref="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance(System.Object[])">CreateInstance</see> method can be used to create an actual instance of an object. It can be used even for constructors with parameters passed by reference.
            To obtain the result of possible <see langword="ref"/>/<see langword="out"/> parameters, pass a preallocated array to the <see cref="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance(System.Object[])">CreateInstance</see> method.
            The parameters passed by reference will be assigned back to the corresponding array elements.</para>
            <para>If you know the created instance type and the parameter types at compile time, then you can use the
            generic <see cref="O:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance">CreateInstance</see> methods for better performance. These strongly typed methods can be used as
            long as the constructors to invoke have no more than four parameters and none of the parameters are passed by reference.</para>
            <para>The first call of these methods is slow because the delegate is generated on the first access, but further calls are much faster.</para>
            <para>The already obtained accessors are cached so subsequent <see cref="O:KGySoft.Reflection.CreateInstanceAccessor.GetAccessor">GetAccessor</see> calls return the already created accessors unless
            they were dropped out from the cache, which can store about 8000 elements.</para>
            <note>If you want to create an instance just by enlisting the constructor parameters of a <see cref="T:System.Type"/> rather than specifying a <see cref="T:System.Reflection.ConstructorInfo"/>, then you can use the <see cref="O:KGySoft.Reflection.Reflector.CreateInstance">CreateInstance</see>
            methods in the <see cref="T:KGySoft.Reflection.Reflector"/> class, which have some overloads for that purpose.</note>
            <note type="warning">The .NET Standard 2.0 version of the <see cref="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance(System.Object[])">CreateInstance</see> does not return the ref/out parameters.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.CreateInstance">Reflector.CreateInstance</see> methods to invoke constructors with ref/out parameters without losing the returned parameter values.</note>
            </remarks>
            <example><code lang="C#"><![CDATA[
            using System;
            using System.Reflection;
            
            using KGySoft.Diagnostics;
            using KGySoft.Reflection;
            
            class Example
            {
                private class TestClass
                {
                    public TestClass() { }
                    public TestClass(int i) { }
                }
            
                static void Main(string[] args)
                {
                    Type testType = typeof(TestClass);
                    ConstructorInfo ctor = testType.GetConstructor(Type.EmptyTypes);
                    CreateInstanceAccessor accessor = CreateInstanceAccessor.GetAccessor(testType);
            
                    new PerformanceTest<TestClass> { TestName = "Default Constructor", Iterations = 1_000_000 }
                        .AddCase(() => new TestClass(), "Direct call")
                        .AddCase(() => (TestClass)Activator.CreateInstance(testType), "Activator.CreateInstance")
                        .AddCase(() => (TestClass)ctor.Invoke(null), "ConstructorInfo.Invoke")
                        .AddCase(() => (TestClass)accessor.CreateInstance(), "CreateInstanceAccessor.CreateInstance")
                        .AddCase(() => accessor.CreateInstance<TestClass>(), "CreateInstanceAccessor.CreateInstance<>")
                        .DoTest()
                        .DumpResults(Console.Out);
            
                    ctor = testType.GetConstructor(new[] { typeof(int) });
                    accessor = CreateInstanceAccessor.GetAccessor(ctor);
                    new PerformanceTest<TestClass> { TestName = "Parameterized Constructor", Iterations = 1_000_000 }
                        .AddCase(() => new TestClass(1), "Direct call")
                        .AddCase(() => (TestClass)Activator.CreateInstance(testType, 1), "Activator.CreateInstance")
                        .AddCase(() => (TestClass)ctor.Invoke(new object[] { 1 }), "ConstructorInfo.Invoke")
                        .AddCase(() => (TestClass)accessor.CreateInstance(1), "CreateInstanceAccessor.CreateInstance")
                        .AddCase(() => accessor.CreateInstance<TestClass, int>(1), "CreateInstanceAccessor.CreateInstance<,>")
                        .DoTest()
                        .DumpResults(Console.Out);
                }
            }
            
            // This code example produces a similar output to this one:
            // ==[Default Constructor Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 5
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct call: average time: 5.52 ms
            // 2. CreateInstanceAccessor.CreateInstance<>: average time: 9.35 ms (+3.82 ms / 169.17%)
            // 3. CreateInstanceAccessor.CreateInstance: average time: 9.64 ms(+4.12 ms / 174.58%)
            // 4. Activator.CreateInstance: average time: 14.36 ms(+8.83 ms / 259.85%)
            // 5. ConstructorInfo.Invoke: average time: 101.75 ms(+96.22 ms / 1,841.76%)
            // 
            // ==[Parameterized Constructor Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 5
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct call: average time: 5.03 ms
            // 2. CreateInstanceAccessor.CreateInstance<,>: average time: 9.91 ms (+4.88 ms / 197.08%)
            // 3. CreateInstanceAccessor.CreateInstance: average time: 19.62 ms(+14.59 ms / 390.25%)
            // 4. ConstructorInfo.Invoke: average time: 156.54 ms(+151.51 ms / 3,113.43%)
            // 5. Activator.CreateInstance: average time: 443.71 ms(+438.68 ms / 8,824.98%)]]></code>
            </example>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.#ctor(System.Reflection.MemberInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> class.
            </summary>
            <param name="member">Can be a <see cref="T:System.Type"/> or a <see cref="T:System.Reflection.ConstructorInfo"/>.</param>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.GetAccessor(System.Type)">
            <summary>
            Gets a <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> for the specified <see cref="T:System.Type"/>.
            Given <paramref name="type"/> must have a parameterless constructor or must be a <see cref="T:System.ValueType"/>.
            </summary>
            <param name="type">A <see cref="T:System.Type"/> for which the accessor should be retrieved.</param>
            <returns>A <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> instance that can be used to create an instance of <paramref name="type"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.GetAccessor(System.Reflection.ConstructorInfo)">
            <summary>
            Gets a <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> for the specified <see cref="T:System.Reflection.ConstructorInfo"/>.
            </summary>
            <param name="ctor">The constructor for which the accessor should be retrieved.</param>
            <returns>A <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> instance that can be used to create an instance by the constructor.</returns>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateAccessor(System.Reflection.MemberInfo)">
            <summary>
            Creates an accessor for a constructor or type without caching.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance(System.Object[])">
            <summary>
            Creates a new instance by the associated <see cref="T:System.Reflection.ConstructorInfo"/> or <see cref="T:System.Type"/>.
            For types and parameterless constructors the <paramref name="parameters"/> parameter is omitted.
            </summary>
            <param name="parameters">The parameters for parameterized constructors.</param>
            <returns>The created instance.</returns>
            <remarks>
            <para>Invoking the constructor for the first time is slower than the <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">System.Reflection.MethodBase.Invoke</see>
            method but further calls are much faster.</para>
            <note type="tip">If the constructor has no more than four parameters and none of them are passed by reference, then you can use the generic
            <see cref="O:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance">CreateInstance</see> methods for better performance if the types are known at compile time.</note>
            <note type="caller">The .NET Standard 2.0 version of this method does not assign back the ref/out parameters in the <paramref name="parameters"/> argument.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.CreateInstance">Reflector.CreateInstance</see> methods to invoke constructors with ref/out parameters without losing the returned parameter values.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">This <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> represents a constructor with parameters and <paramref name="parameters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type of one of the <paramref name="parameters"/> is invalid.
            <br/>-or-
            <br/><paramref name="parameters"/> has too few elements.</exception>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance``1">
            <summary>
            Creates a new instance using the associated <see cref="T:System.Type"/> or parameterless constructor.
            </summary>
            <typeparam name="TInstance">The type of the created instance.</typeparam>
            <returns>The created instance.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> represents a constructor with more than four parameters
            or a constructor that has parameters passed by reference.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance``2(``1)">
            <summary>
            Creates a new instance using the associated constructor with one parameter.
            </summary>
            <typeparam name="TInstance">The type of the created instance.</typeparam>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="param">The value of the parameter.</param>
            <returns>The created instance.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> represents a constructor with more than four parameters
            or a constructor that has parameters passed by reference.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance``3(``1,``2)">
            <summary>
            Creates a new instance using the associated constructor with two parameters.
            </summary>
            <typeparam name="TInstance">The type of the created instance.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <returns>The created instance.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> represents a constructor with more than four parameters
            or a constructor that has parameters passed by reference.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance``4(``1,``2,``3)">
            <summary>
            Creates a new instance using the associated constructor with three parameters.
            </summary>
            <typeparam name="TInstance">The type of the created instance.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <returns>The created instance.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> represents a constructor with more than four parameters
            or a constructor that has parameters passed by reference.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.CreateInstanceAccessor.CreateInstance``5(``1,``2,``3,``4)">
            <summary>
            Creates a new instance using the associated constructor with four parameters.
            </summary>
            <typeparam name="TInstance">The type of the created instance.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <returns>The created instance.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> represents a constructor with more than four parameters
            or a constructor that has parameters passed by reference.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="T:KGySoft.Reflection.DefaultCreateInstanceAccessor">
            <summary>
            Object factory for creating new instance of an object with default constructor
            or without constructor (for value types).
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.DefaultCreateInstanceAccessor.CreateInitializer">
            <summary>
            Creates object initialization delegate. Stored MemberInfo is a Type so it works
            also in case of value types where actually there is no parameterless constructor.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.FieldAccessor">
            <summary>
            Provides an efficient way for setting and getting field values via dynamically created delegates.
            </summary>
            <remarks>
            <para>You can obtain a <see cref="T:KGySoft.Reflection.FieldAccessor"/> instance by the static <see cref="M:KGySoft.Reflection.FieldAccessor.GetAccessor(System.Reflection.FieldInfo)">GetAccessor</see> method.</para>
            <para>The <see cref="M:KGySoft.Reflection.FieldAccessor.Get(System.Object)">Get</see> and <see cref="M:KGySoft.Reflection.FieldAccessor.Set(System.Object,System.Object)">Set</see> methods can be used to get and set the field, respectively.</para>
            <para>If you know the field type at compile time, then you can use the generic <see cref="M:KGySoft.Reflection.FieldAccessor.SetStaticValue``1(``0)">SetStaticValue</see>/<see cref="M:KGySoft.Reflection.FieldAccessor.GetStaticValue``1">GetStaticValue</see>
            methods for static fields. If you know also the instance type, then
            the <see cref="O:KGySoft.Reflection.FieldAccessor.GetInstanceValue">GetInstanceValue</see>/<see cref="O:KGySoft.Reflection.FieldAccessor.SetInstanceValue">SetInstanceValue</see>
            methods can be used for instance field for better performance.</para>
            <para>The first call of these methods are slow because the delegates are generated on the first access, but further calls are much faster.</para>
            <para>The already obtained accessors are cached so subsequent <see cref="M:KGySoft.Reflection.FieldAccessor.GetAccessor(System.Reflection.FieldInfo)">GetAccessor</see> calls return the already created accessors unless
            they were dropped out from the cache, which can store about 8000 elements.</para>
            <note>If you want to access a field by name rather then by a <see cref="T:System.Reflection.FieldInfo"/>, then you can use the <see cref="O:KGySoft.Reflection.Reflector.SetField">SetField</see>
            and <see cref="O:KGySoft.Reflection.Reflector.SetField">GetField</see> methods in the <see cref="T:KGySoft.Reflection.Reflector"/> class, which have some overloads with a <c>fieldName</c> parameter.</note>
            <note type="warning">The .NET Standard 2.0 version of the <see cref="M:KGySoft.Reflection.FieldAccessor.Set(System.Object,System.Object)">Set</see> method throws a <see cref="T:System.PlatformNotSupportedException"/>
            if the field to set is read-only or is an instance member of a value type (<see langword="struct"/>).
            The generic <see cref="O:KGySoft.Reflection.FieldAccessor.SetInstanceValue">SetInstanceValue</see> methods also throw a <see cref="T:System.PlatformNotSupportedException"/>
            for read-only fields when using the .NET Standard 2.0 build of the libraries, though they support non read-only value type fields.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.SetField">Reflector.SetField</see> methods to set read-only fields or value type instance fields in a non-generic way.</note>
            </remarks>
            <example><code lang="C#"><![CDATA[
            using System;
            using System.Reflection;
            using KGySoft.Diagnostics;
            using KGySoft.Reflection;
            
            class Example
            {
                private class TestClass
                {
                    public int TestField;
                }
            
                static void Main(string[] args)
                {
                    var instance = new TestClass();
                    FieldInfo field = instance.GetType().GetField(nameof(TestClass.TestField));
                    FieldAccessor accessor = FieldAccessor.GetAccessor(field);
            
                    new PerformanceTest { TestName = "Set Field", Iterations = 1_000_000 }
                        .AddCase(() => instance.TestField = 1, "Direct set")
                        .AddCase(() => field.SetValue(instance, 1), "FieldInfo.SetValue")
                        .AddCase(() => accessor.Set(instance, 1), "FieldAccessor.Set")
                        .AddCase(() => accessor.SetInstanceValue(instance, 1), "FieldAccessor.SetInstanceValue<,>")
                        .DoTest()
                        .DumpResults(Console.Out);
            
                    new PerformanceTest<int> { TestName = "Get Field", Iterations = 1_000_000 }
                        .AddCase(() => instance.TestField, "Direct get")
                        .AddCase(() => (int)field.GetValue(instance), "FieldInfo.GetValue")
                        .AddCase(() => (int)accessor.Get(instance), "FieldAccessor.Get")
                        .AddCase(() => accessor.GetInstanceValue<TestClass, int>(instance), "FieldAccessor.GetInstanceValue<,>")
                        .DoTest()
                        .DumpResults(Console.Out);
                }
            }
            
            // This code example produces a similar output to this one:
            // ==[Set Field Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 4
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct set: average time: 2.79 ms
            // 2. FieldAccessor.SetInstanceValue<,>: average time: 7.51 ms (+4.72 ms / 269.41%)
            // 3. FieldAccessor.Set: average time: 10.20 ms(+7.42 ms / 366.09%)
            // 4. FieldInfo.SetValue: average time: 61.40 ms(+58.62 ms / 2,202.91%)
            // 
            // ==[Get Field Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 4
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct get: average time: 2.08 ms
            // 2. FieldAccessor.GetInstanceValue<,>: average time: 4.84 ms (+2.77 ms / 233.33%)
            // 3. FieldAccessor.Get: average time: 8.06 ms(+5.98 ms / 388.12%)
            // 4. FieldInfo.GetValue: average time: 50.32 ms(+48.24 ms / 2,423.40%)]]></code>
            </example>
        </member>
        <member name="P:KGySoft.Reflection.FieldAccessor.IsReadOnly">
            <summary>
            Gets whether the field is read-only.
            </summary>
            <remarks>
            <note>Even if this property returns <see langword="true"/> the <see cref="T:KGySoft.Reflection.FieldAccessor"/>
            is able to set the field, except if the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is used,
            which throws a <see cref="T:System.PlatformNotSupportedException"/> in that case.</note>
            </remarks>
        </member>
        <member name="P:KGySoft.Reflection.FieldAccessor.IsConstant">
            <summary>
            Gets whether the field is a constant. Constant fields cannot be set.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.#ctor(System.Reflection.FieldInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.FieldAccessor"/> class.
            </summary>
            <param name="field">The field for which the accessor is to be created.</param>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.GetAccessor(System.Reflection.FieldInfo)">
            <summary>
            Gets a <see cref="T:KGySoft.Reflection.FieldAccessor"/> for the specified <paramref name="field"/>.
            </summary>
            <param name="field">The field for which the accessor should be retrieved.</param>
            <returns>A <see cref="T:KGySoft.Reflection.FieldAccessor"/> instance that can be used to get or set the field.</returns>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.CreateAccessor(System.Reflection.FieldInfo)">
            <summary>
            Creates an accessor for a field without caching.
            </summary>
            <param name="field">The field for which an accessor should be created.</param>
            <returns>A <see cref="T:KGySoft.Reflection.FieldAccessor"/> instance that can be used to get or set the field.</returns>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.Set(System.Object,System.Object)">
            <summary>
            Sets the field.
            For static fields the <paramref name="instance"/> parameter is omitted (can be <see langword="null"/>).
            </summary>
            <param name="instance">The instance that the field belongs to. Can be <see langword="null"/> for static fields.</param>
            <param name="value">The value to set.</param>
            <remarks>
            <para>Setting the field for the first time is slower than the <see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">System.Reflection.FieldInfo.SetValue</see>
            method but further calls are much faster.</para>
            <note type="tip">If you know the type of the field at compile time (and also the declaring type for instance fields),
            then you can use the generic <see cref="M:KGySoft.Reflection.FieldAccessor.SetStaticValue``1(``0)">SetStaticValue</see>
            or <see cref="O:KGySoft.Reflection.FieldAccessor.SetInstanceValue">SetInstanceValue</see> methods for better performance.</note>
            <note type="caller">Calling the .NET Standard 2.0 version of this method throws a <see cref="T:System.PlatformNotSupportedException"/>
            if the field to set is read-only or is an instance member of a value type (<see langword="struct"/>).
            The <see cref="O:KGySoft.Reflection.FieldAccessor.SetInstanceValue">SetInstanceValue</see> methods support setting value fields though.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.SetField">Reflector.SetField</see> methods to set read-only fields or value type instance fields in a non-generic way.</note>
            </remarks>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a constant field.</exception>
            <exception cref="T:System.ArgumentNullException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents an instance field and <paramref name="instance"/> is <see langword="null"/>
            <br/>-or-
            <br/>This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a value type field and <paramref name="value"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type of <paramref name="instance"/> or <paramref name="value"/> is invalid.</exception>
            <exception cref="T:System.PlatformNotSupportedException">You use the .NET Standard 2.0 build of <c>KGySoft.CoreLibraries</c> and this <see cref="T:KGySoft.Reflection.FieldAccessor"/>
            represents a read-only field or its declaring type is a value type.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.Get(System.Object)">
            <summary>
            Gets the value of the field.
            For static fields the <paramref name="instance"/> parameter is omitted (can be <see langword="null"/>).
            </summary>
            <param name="instance">The instance that the field belongs to. Can be <see langword="null"/> for static fields.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para>Getting the field for the first time is slower than the <see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)">System.Reflection.FieldInfo.GetValue</see>
            method but further calls are much faster.</para>
            <note type="tip">If you know the type of the field at compile time (and also the declaring type for instance fields),
            then you can use the generic <see cref="M:KGySoft.Reflection.FieldAccessor.GetStaticValue``1">GetStaticValue</see>
            or <see cref="O:KGySoft.Reflection.FieldAccessor.GetInstanceValue">GetInstanceValue</see> methods for better performance.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents an instance field and <paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type of <paramref name="instance"/> is invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.SetStaticValue``1(``0)">
            <summary>
            Sets the strongly typed value of a static field. If the type of the field is not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.FieldAccessor.Set(System.Object,System.Object)">Set</see> method can be used.
            </summary>
            <typeparam name="TField">The type of the field.</typeparam>
            <param name="value">The value to set.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a constant or an instance field.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TField"/> is invalid.</exception>
            <exception cref="T:System.PlatformNotSupportedException">You use the .NET Standard 2.0 build of <c>KGySoft.CoreLibraries</c>
            and this <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a read-only field.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.GetStaticValue``1">
            <summary>
            Gets the strongly typed value of a static field. If the type of the field is not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.FieldAccessor.Get(System.Object)">Get</see> method can be used.
            </summary>
            <typeparam name="TField">The type of the field.</typeparam>
            <returns>The value of the field.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents an instance field.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TField"/> is invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.SetInstanceValue``2(``0,``1)">
            <summary>
            Sets the strongly typed value of an instance field in a reference type.
            If the type of the field or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.FieldAccessor.Set(System.Object,System.Object)">Set</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the field.</typeparam>
            <typeparam name="TField">The type of the field.</typeparam>
            <param name="instance">The instance that the field belongs to.</param>
            <param name="value">The value to set.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a constant or a static field.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type arguments are invalid.</exception>
            <exception cref="T:System.PlatformNotSupportedException">You use the .NET Standard 2.0 build of <c>KGySoft.CoreLibraries</c>
            and this <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a read-only field.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.GetInstanceValue``2(``0)">
            <summary>
            Gets the strongly typed value of an instance field in a reference type.
            If the type of the field or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.FieldAccessor.Get(System.Object)">Get</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the field.</typeparam>
            <typeparam name="TField">The type of the field.</typeparam>
            <param name="instance">The instance that the field belongs to.</param>
            <returns>The value of the field.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a constant or a static field.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.SetInstanceValue``2(``0@,``1)">
            <summary>
            Sets the strongly typed value of an instance field in a value type.
            If the type of the field or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.FieldAccessor.Set(System.Object,System.Object)">Set</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the field.</typeparam>
            <typeparam name="TField">The type of the field.</typeparam>
            <param name="instance">The instance that the field belongs to.</param>
            <param name="value">The value to set.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a constant or a static field.</exception>
            <exception cref="T:System.ArgumentException">The type arguments are invalid.</exception>
            <exception cref="T:System.PlatformNotSupportedException">You use the .NET Standard 2.0 build of <c>KGySoft.CoreLibraries</c>
            and this <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a read-only field.</exception>
        </member>
        <member name="M:KGySoft.Reflection.FieldAccessor.GetInstanceValue``2(``0@)">
            <summary>
            Gets the strongly typed value of an instance field in a value type.
            If the type of the field or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.FieldAccessor.Get(System.Object)">Get</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the field.</typeparam>
            <typeparam name="TField">The type of the field.</typeparam>
            <param name="instance">The instance that the field belongs to.</param>
            <returns>The value of the field.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.FieldAccessor"/> represents a constant or a static field.</exception>
            <exception cref="T:System.ArgumentException">The type arguments are invalid.</exception>
        </member>
        <member name="T:KGySoft.Reflection.FunctionMethodAccessor">
            <summary>
            Function method accessor for any parameters.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.MemberAccessor">
            <summary>
            Base class of accessor classes that may access members without system reflection.
            See the derived classes for more details.
            </summary>
            <seealso cref="T:KGySoft.Reflection.FieldAccessor"/>
            <seealso cref="T:KGySoft.Reflection.PropertyAccessor"/>
            <seealso cref="T:KGySoft.Reflection.MethodAccessor"/>
            <seealso cref="T:KGySoft.Reflection.CreateInstanceAccessor"/>
        </member>
        <member name="P:KGySoft.Reflection.MemberAccessor.MemberInfo">
            <summary>
            Gets the reflection member info of the accessed member.
            </summary>
        </member>
        <member name="P:KGySoft.Reflection.MemberAccessor.ParameterTypes">
            <summary>
            Gets the type of parameters of the accessed member in the reflected type.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.#ctor(System.Reflection.MemberInfo,System.Type[])">
            <summary>
            Protected constructor for the abstract <see cref="T:KGySoft.Reflection.MemberAccessor"/>.
            </summary>
            <param name="member">The <see cref="P:KGySoft.Reflection.MemberAccessor.MemberInfo"/> for which the accessor is created.</param>
            <param name="parameterTypes">A <see cref="T:System.Type"/> array of member parameters (method/constructor/indexer)</param>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.GetCreateAccessor(System.Reflection.MemberInfo)">
            <summary>
            Gets an existing or creates a new <see cref="T:KGySoft.Reflection.MemberAccessor"/> for the specified <paramref name="memberInfo"/>.
            </summary>
            <param name="memberInfo">The <see cref="P:KGySoft.Reflection.MemberAccessor.MemberInfo"/> for which the accessor is to be obtained.</param>
            <returns>A <see cref="T:KGySoft.Reflection.MemberAccessor"/> instance for the specified <paramref name="memberInfo"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.CreateAccessor(System.Reflection.MemberInfo)">
            <summary>
            This method is associated with the itemLoader of the cache.
            </summary>
            <remarks>
            Note: Make sure that created MemberAccessor is not cached until returning from this method
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:KGySoft.Reflection.MemberAccessor"/>.
            </summary>
            <param name="obj">The object to compare with the current <see cref="T:KGySoft.Reflection.MemberAccessor"/>.</param>
            <returns><see langword="true"/> if the specified object is equal to the current <see cref="T:KGySoft.Reflection.MemberAccessor"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.GetHashCode">
            <summary>
            Gets a hash code for the current <see cref="T:KGySoft.Reflection.MemberAccessor"/> instance.
            </summary>
            <returns>A hash code for the current <see cref="T:KGySoft.Reflection.MemberAccessor"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:KGySoft.Reflection.MemberAccessor"/>.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="M:KGySoft.Reflection.MemberAccessor.CreateMethodInvokerAsDynamicMethod(System.Reflection.MethodBase,KGySoft.Reflection.DynamicMethodOptions)">
            <summary>
            Gets a <see cref="T:System.Reflection.Emit.DynamicMethod"/> that invokes the referred <paramref name="methodBase"/> (method or constructor).
            An overridden class may use this to create a delegate optionally.
            Return type of the created method is <see cref="T:System.Object"/> if the method has any kind of return value, otherwise, <see cref="T:System.Void"/>.
            </summary>
            <param name="methodBase">The method or constructor, which invocation should be generated</param>
            <param name="options">Options for generation. Affects parameters of generated method and ref/out parameters handling</param>
            <returns>
            Returns a <see cref="T:System.Reflection.Emit.DynamicMethod"/> with given options. Return type of the method
            is <see cref="T:System.Void"/> if method has no return type, otherwise, <see cref="T:System.Object"/>.
            By default, method parameters are <c>(<see cref="T:System.Object"/> instance, <see cref="T:System.Object"/>[] parameters)</c>,
            but when <see cref="F:KGySoft.Reflection.DynamicMethodOptions.TreatAsPropertySetter"/> is set, then
            parameters are either <c>(<see cref="T:System.Object"/> instance, <see cref="T:System.Object"/> value)</c>
            or <c>(<see cref="T:System.Object"/> instance, <see cref="T:System.Object"/> value, <see cref="T:System.Object"/>[] indexerParameters)</c>.
            For constructors, generated parameter is always <c><see cref="T:System.Object"/>[] parameters</c>.
            </returns>
        </member>
        <member name="T:KGySoft.Reflection.MethodAccessor">
            <summary>
            Provides an efficient way for invoking methods via dynamically created delegates.
            </summary>
            <remarks>
            <para>You can obtain a <see cref="T:KGySoft.Reflection.MethodAccessor"/> instance by the static <see cref="M:KGySoft.Reflection.MethodAccessor.GetAccessor(System.Reflection.MethodInfo)">GetAccessor</see> method.</para>
            <para>The <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used to invoke the method. It can be used even for methods with parameters passed by reference.
            To obtain the result of possible <see langword="ref"/>/<see langword="out"/> parameters, pass a preallocated array to the <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method.
            The parameters passed by reference will be assigned back to the corresponding array elements.</para>
            <para>If you know the parameter types at compile time (and the return type for function methods), then you can use
            the <see cref="O:KGySoft.Reflection.MethodAccessor.InvokeStaticAction">InvokeStaticAction</see>/<see cref="O:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction">InvokeStaticFunction</see>
            methods to invoke static methods. If you know also the instance type, then
            the <see cref="O:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction">InvokeInstanceAction</see>/<see cref="O:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction">InvokeInstanceFunction</see>
            methods can be used to invoke instance methods for better performance. These strongly typed methods can be used as
            long as the methods to invoke have no more than four parameters and none of the parameters are passed by reference.</para>
            <para>The first call of these methods are slow because the delegates are generated on the first access, but further calls are much faster.</para>
            <para>The already obtained accessors are cached so subsequent <see cref="M:KGySoft.Reflection.MethodAccessor.GetAccessor(System.Reflection.MethodInfo)">GetAccessor</see> calls return the already created accessors unless
            they were dropped out from the cache, which can store about 8000 elements.</para>
            <note>If you want to invoke a method by name rather then by a <see cref="T:System.Reflection.MethodInfo"/>, then you can use the <see cref="O:KGySoft.Reflection.Reflector.InvokeMethod">InvokeMethod</see>
            methods in the <see cref="T:KGySoft.Reflection.Reflector"/> class, which have some overloads with a <c>methodName</c> parameter.</note>
            <note type="warning">The .NET Standard 2.0 version of the <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method does not return the ref/out parameters.
            Furthermore, if an instance method of a value type (<see langword="struct"/>) mutates the instance,
            then the changes will not be applied to the instance on which the method is invoked.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.InvokeMethod">Reflector.InvokeMethod</see> overloads to invoke methods with ref/out parameters without losing the returned parameter values
            and to preserve changes of the mutated value type instances.</note>
            </remarks>
            <example>
            <code lang="C#"><![CDATA[
            using System;
            using System.Reflection;
            using KGySoft.Diagnostics;
            using KGySoft.Reflection;
            
            class Example
            {
                private class TestClass
                {
                    public int TestMethod(int i) => i;
                }
            
                static void Main(string[] args)
                {
                    var instance = new TestClass();
                    MethodInfo method = instance.GetType().GetMethod(nameof(TestClass.TestMethod));
                    MethodAccessor accessor = MethodAccessor.GetAccessor(method);
            
                    new PerformanceTest { Iterations = 1_000_000 }
                        .AddCase(() => instance.TestMethod(1), "Direct call")
                        .AddCase(() => method.Invoke(instance, new object[] { 1 }), "MethodInfo.Invoke")
                        .AddCase(() => accessor.Invoke(instance, 1), "MethodAccessor.Invoke")
                        .AddCase(() => accessor.InvokeInstanceFunction<TestClass, int, int>(instance, 1), "MethodAccessor.InvokeInstanceFunction<,,>")
                        .DoTest()
                        .DumpResults(Console.Out);
                }
            }
            
            // This code example produces a similar output to this one:
            // ==[Performance Test Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 4
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct call: average time: 3.23 ms
            // 2. MethodAccessor.InvokeInstanceFunction<,,>: average time: 5.72 ms (+2.49 ms / 177.25%)
            // 3. MethodAccessor.Invoke: average time: 18.96 ms(+15.73 ms / 587.38%)
            // 4. MethodInfo.Invoke: average time: 155.54 ms(+152.31 ms / 4,819.52%)]]></code>
            </example>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.#ctor(System.Reflection.MethodBase)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.MethodAccessor"/> class.
            </summary>
            <param name="method">The method for which the accessor is to be created.</param>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.GetAccessor(System.Reflection.MethodInfo)">
            <summary>
            Gets a <see cref="T:KGySoft.Reflection.MemberAccessor"/> for the specified <paramref name="method"/>.
            </summary>
            <param name="method">The method for which the accessor should be retrieved.</param>
            <returns>A <see cref="T:KGySoft.Reflection.MethodAccessor"/> instance that can be used to invoke the method.</returns>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.CreateAccessor(System.Reflection.MethodInfo)">
            <summary>
            Creates an accessor for a method without caching.
            </summary>
            <param name="method">The method for which the accessor should be retrieved.</param>
            <returns>A <see cref="T:KGySoft.Reflection.MethodAccessor"/> instance that can be used to invoke the method.</returns>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes the method. The return value of <see langword="void"/> methods is always <see langword="null"/>.
            For static methods the <paramref name="instance"/> parameter is omitted (can be <see langword="null"/>).
            </summary>
            <param name="instance">The instance that the method belongs to. Can be <see langword="null"/> for static methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.
            If the method has ref/out parameters the corresponding array elements are assigned back with the results.</param>
            <returns>The return value of the method, or <see langword="null"/> for <see langword="void"/> methods.</returns>
            <remarks>
            <para>Invoking the method for the first time is slower than the <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">System.Reflection.MethodBase.Invoke</see>
            method but further calls are much faster.</para>
            <note type="tip">If the method has no more than four parameters and none of them are passed by reference, then you can use the strongly typed
            <see cref="O:KGySoft.Reflection.MethodAccessor.InvokeStaticAction">InvokeStaticAction</see>, <see cref="O:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction">InvokeStaticFunction</see>,
            <see cref="O:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction">InvokeInstanceAction</see> or <see cref="O:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction">InvokeInstanceFunction</see>
            methods for better performance if the types are known at compile time.</note>
            <note type="caller">The .NET Standard 2.0 version of this method does not assign back the ref/out parameters in the <paramref name="parameters"/> argument.
            Furthermore, if an instance method of a value type (<see langword="struct"/>) mutates the instance,
            then the changes will not be applied to the <paramref name="instance"/> parameter in the .NET Standard 2.0 version.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.InvokeMethod">Reflector.InvokeMethod</see> overloads to invoke methods with ref/out parameters without losing the returned parameter values
            and to preserve changes of the mutated value type instances.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method and <paramref name="instance"/> is <see langword="null"/>
            <br/>-or-
            <br/>This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with parameters and <paramref name="parameters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type of <paramref name="instance"/> or one of the <paramref name="parameters"/> is invalid.
            <br/>-or-
            <br/><paramref name="parameters"/> has too few elements.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticAction">
            <summary>
            Invokes a parameterless static action method.
            </summary>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> does not represent a parameterless action method so
            type arguments should be specified (use the generic invoker method with matching type arguments).</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticAction``1(``0)">
            <summary>
            Invokes a static action method with one parameter. If the type of the parameter is not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="param">The value of the parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticAction``2(``0,``1)">
            <summary>
            Invokes a static action method with two parameters. If the type of the parameters are not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticAction``3(``0,``1,``2)">
            <summary>
            Invokes a static action method with three parameters. If the type of the parameters are not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticAction``4(``0,``1,``2,``3)">
            <summary>
            Invokes a static action method with four parameters. If the type of the parameters are not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction``1">
            <summary>
            Invokes a parameterless static function method. If the return type is not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction``2(``0)">
            <summary>
            Invokes a static function method with one parameter. If the type of the parameter or the return value
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="param">The value of the parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction``3(``0,``1)">
            <summary>
            Invokes a static function method with two parameters. If the type of the parameters or the return value
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction``4(``0,``1,``2)">
            <summary>
            Invokes a static function method with three parameters. If the type of the parameters or the return value
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeStaticFunction``5(``0,``1,``2,``3)">
            <summary>
            Invokes a static function method with four parameters. If the type of the parameters or the return value
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents an instance method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``1(``0)">
            <summary>
            Invokes a parameterless instance action method in a reference type. If the type of the declaring instance
            is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``2(``0,``1)">
            <summary>
            Invokes an instance action method with one parameter in a reference type. If the type of the parameter or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param">The value of the parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``3(``0,``1,``2)">
            <summary>
            Invokes an instance action method with two parameters in a reference type. If the type of the parameters or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``4(``0,``1,``2,``3)">
            <summary>
            Invokes an instance action method with three parameters in a reference type. If the type of the parameters or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``5(``0,``1,``2,``3,``4)">
            <summary>
            Invokes an instance action method with four parameters in a reference type. If the type of the parameters or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``2(``0)">
            <summary>
            Invokes a parameterless instance function method in a reference type. If the type of the return value or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``3(``0,``1)">
            <summary>
            Invokes an instance function method with one parameter in a reference type. If the type of the parameter, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param">The value of the parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``4(``0,``1,``2)">
            <summary>
            Invokes an instance function method with two parameters in a reference type. If the type of the parameters, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``5(``0,``1,``2,``3)">
            <summary>
            Invokes an instance function method with three parameters in a reference type. If the type of the parameters, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``6(``0,``1,``2,``3,``4)">
            <summary>
            Invokes an instance function method with four parameters in a reference type. If the type of the parameters, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``1(``0@)">
            <summary>
            Invokes a parameterless instance action method in a value type. If the type of the declaring instance
            is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``2(``0@,``1)">
            <summary>
            Invokes an instance action method with one parameter in a value type. If the type of the parameter or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param">The value of the parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``3(``0@,``1,``2)">
            <summary>
            Invokes an instance action method with two parameters in a value type. If the type of the parameters or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``4(``0@,``1,``2,``3)">
            <summary>
            Invokes an instance action method with three parameters in a value type. If the type of the parameters or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceAction``5(``0@,``1,``2,``3,``4)">
            <summary>
            Invokes an instance action method with four parameters in a value type. If the type of the parameters or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``2(``0@)">
            <summary>
            Invokes a parameterless instance function method in a value type. If the type of the return value or the declaring instance
            are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``3(``0@,``1)">
            <summary>
            Invokes an instance function method with one parameter in a value type. If the type of the parameter, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param">The value of the parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``4(``0@,``1,``2)">
            <summary>
            Invokes an instance function method with two parameters in a value type. If the type of the parameters, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``5(``0@,``1,``2,``3)">
            <summary>
            Invokes an instance function method with three parameters in a value type. If the type of the parameters, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="M:KGySoft.Reflection.MethodAccessor.InvokeInstanceFunction``6(``0@,``1,``2,``3,``4)">
            <summary>
            Invokes an instance function method with four parameters in a value type. If the type of the parameters, the return value
            or the declaring instance are not known at compile time the non-generic <see cref="M:KGySoft.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">Invoke</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the method.</typeparam>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <typeparam name="TResult">The return type of the method.</typeparam>
            <param name="instance">The instance that the method belongs to.</param>
            <param name="param1">The value of the first parameter.</param>
            <param name="param2">The value of the second parameter.</param>
            <param name="param3">The value of the third parameter.</param>
            <param name="param4">The value of the fourth parameter.</param>
            <returns>The return value of the method.</returns>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a method with more than four parameters
            or a method that has parameters passed by reference.</exception>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.MethodAccessor"/> represents a static method.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
        </member>
        <member name="T:KGySoft.Reflection.ParameterizedCreateInstanceAccessor">
            <summary>
            Object factory for creating new instance of an object via a specified constructor.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.PropertyAccessor">
            <summary>
            Provides an efficient way for setting and getting property values via dynamically created delegates.
            </summary>
            <remarks>
            <para>You can obtain a <see cref="T:KGySoft.Reflection.PropertyAccessor"/> instance by the static <see cref="M:KGySoft.Reflection.PropertyAccessor.GetAccessor(System.Reflection.PropertyInfo)">GetAccessor</see> method.</para>
            <para>The <see cref="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">Get</see> and <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> methods can be used to get or set the property, respectively.
            These methods can be used for any properties, including indexed ones.</para>
            <para>If you know the property type at compile time, then you can use the generic <see cref="M:KGySoft.Reflection.PropertyAccessor.SetStaticValue``1(``0)">SetStaticValue</see>/<see cref="M:KGySoft.Reflection.PropertyAccessor.GetStaticValue``1">GetStaticValue</see>
            methods for static properties. If you know also the instance type (and the index parameter for indexers), then
            the <see cref="O:KGySoft.Reflection.PropertyAccessor.GetInstanceValue">GetInstanceValue</see>/<see cref="O:KGySoft.Reflection.PropertyAccessor.SetInstanceValue">SetInstanceValue</see>
            methods can be used for instance properties for better performance. These generic methods can be used for properties with no more than one index parameter.</para>
            <para>The first call of these methods are slow because the delegates are generated on the first access, but further calls are much faster.</para>
            <para>The already obtained accessors are cached so subsequent <see cref="M:KGySoft.Reflection.PropertyAccessor.GetAccessor(System.Reflection.PropertyInfo)">GetAccessor</see> calls return the already created accessors unless
            they were dropped out from the cache, which can store about 8000 elements.</para>
            <note>If you want to access a property by name rather then by a <see cref="T:System.Reflection.PropertyInfo"/>, then you can use the <see cref="O:KGySoft.Reflection.Reflector.SetProperty">SetProperty</see>
            and <see cref="O:KGySoft.Reflection.Reflector.SetProperty">GetProperty</see> methods in the <see cref="T:KGySoft.Reflection.Reflector"/> class, which have some overloads with a <c>propertyName</c> parameter.</note>
            <note type="warning">The .NET Standard 2.0 version of the <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> method throws a <see cref="T:System.PlatformNotSupportedException"/>
            if the property is an instance member of a value type (<see langword="struct"/>).
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.PropertyAccessor.SetInstanceValue">SetInstanceValue</see> overloads (if you know the instance type and the property value at compile time),
            or <see cref="O:KGySoft.Reflection.Reflector.SetProperty">Reflector.SetProperty</see> methods to set value type instance properties.</note>
            </remarks>
            <example>
            <code lang="C#"><![CDATA[
            using System;
            using System.Reflection;
            using KGySoft.Diagnostics;
            using KGySoft.Reflection;
            
            class Example
            {
                private class TestClass
                {
                    public int TestProperty { get; set; }
                }
            
                static void Main(string[] args)
                {
                    var instance = new TestClass();
                    PropertyInfo property = instance.GetType().GetProperty(nameof(TestClass.TestProperty));
                    PropertyAccessor accessor = PropertyAccessor.GetAccessor(property);
            
                    new PerformanceTest { TestName = "Set Property", Iterations = 1_000_000 }
                        .AddCase(() => instance.TestProperty = 1, "Direct set")
                        .AddCase(() => property.SetValue(instance, 1), "PropertyInfo.SetValue")
                        .AddCase(() => accessor.Set(instance, 1), "PropertyAccessor.Set")
                        .AddCase(() => accessor.SetInstanceValue(instance, 1), "PropertyAccessor.SetInstanceValue<,>")
                        .DoTest()
                        .DumpResults(Console.Out);
            
                    new PerformanceTest<int> { TestName = "Get Property", Iterations = 1_000_000 }
                        .AddCase(() => instance.TestProperty, "Direct get")
                        .AddCase(() => (int)property.GetValue(instance), "PropertyInfo.GetValue")
                        .AddCase(() => (int)accessor.Get(instance), "PropertyAccessor.Get")
                        .AddCase(() => accessor.GetInstanceValue<TestClass, int>(instance), "PropertyAccessor.GetInstanceValue<,>")
                        .DoTest()
                        .DumpResults(Console.Out);
                }
            }
            
            // This code example produces a similar output to this one:
            // ==[Set Property Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 4
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct set: average time: 2.65 ms
            // 2. PropertyAccessor.SetInstanceValue<,>: average time: 6.40 ms (+3.74 ms / 241.10%)
            // 3. PropertyAccessor.Set: average time: 10.05 ms(+7.40 ms / 378.98%)
            // 4. PropertyInfo.SetValue: average time: 124.49 ms(+121.84 ms / 4,692.95%)
            // 
            // ==[Get Property Results]================================================
            // Iterations: 1,000,000
            // Warming up: Yes
            // Test cases: 4
            // Calling GC.Collect: Yes
            // Forced CPU Affinity: No
            // Cases are sorted by time (quickest first)
            // --------------------------------------------------
            // 1. Direct get: average time: 2.06 ms
            // 2. PropertyAccessor.GetInstanceValue<,>: average time: 4.90 ms (+2.84 ms / 237.98%)
            // 3. PropertyAccessor.Get: average time: 9.72 ms(+7.66 ms / 471.89%)
            // 4. PropertyInfo.GetValue: average time: 81.46 ms(+79.41 ms / 3,955.18%)]]></code>
            </example>
        </member>
        <member name="P:KGySoft.Reflection.PropertyAccessor.CanRead">
            <summary>
            Gets whether the property can be read (has get accessor).
            </summary>
        </member>
        <member name="P:KGySoft.Reflection.PropertyAccessor.CanWrite">
            <summary>
            Gets whether the property can be written (has set accessor).
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.PropertyAccessor"/> class.
            </summary>
            <param name="property">The property for which the accessor is to be created.</param>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.GetAccessor(System.Reflection.PropertyInfo)">
            <summary>
            Gets a <see cref="T:KGySoft.Reflection.PropertyAccessor"/> for the specified <paramref name="property"/>.
            </summary>
            <param name="property">The property for which the accessor should be retrieved.</param>
            <returns>A <see cref="T:KGySoft.Reflection.PropertyAccessor"/> instance that can be used to get or set the property.</returns>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.CreateAccessor(System.Reflection.PropertyInfo)">
            <summary>
            Creates an accessor for a property without caching.
            </summary>
            <param name="property">The property for which an accessor should be created.</param>
            <returns>A <see cref="T:KGySoft.Reflection.PropertyAccessor"/> instance that can be used to get or set the property.</returns>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">
            <summary>
            Sets the property.
            For static properties the <paramref name="instance"/> parameter is omitted (can be <see langword="null"/>).
            If the property is not an indexer, then <paramref name="indexParameters"/> parameter is omitted.
            </summary>
            <param name="instance">The instance that the property belongs to. Can be <see langword="null"/> for static properties.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">The parameters if the property is an indexer.</param>
            <remarks>
            <para>Setting the property for the first time is slower than the <see cref="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Object[])">System.Reflection.PropertyInfo.SetValue</see>
            method but further calls are much faster.</para>
            <note type="tip">If the property has no more than one index parameters and you know the type of the property at compile time
            (and also the declaring type for instance properties), then you can use the generic <see cref="M:KGySoft.Reflection.PropertyAccessor.SetStaticValue``1(``0)">SetStaticValue</see>
            or <see cref="O:KGySoft.Reflection.PropertyAccessor.SetInstanceValue">SetInstanceValue</see> methods for better performance.</note>
            <note type="caller">Calling the .NET Standard 2.0 version of this method throws a <see cref="T:System.PlatformNotSupportedException"/>
            if the property is an instance member of a value type (<see langword="struct"/>).
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly and cannot use the generic setter methods,
            then use the <see cref="O:KGySoft.Reflection.Reflector.SetProperty">Reflector.SetProperty</see> methods to set value type instance properties.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents an instance property and <paramref name="instance"/> is <see langword="null"/>
            <br/>-or-
            <br/>This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a value type property and <paramref name="value"/> is <see langword="null"/>
            <br/>-or-
            <br/>This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents an indexed property and <paramref name="indexParameters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type of <paramref name="instance"/>, <paramref name="value"/> or one of the <paramref name="indexParameters"/> is invalid.
            <br/>-or-
            <br/><paramref name="indexParameters"/> has too few elements.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a read-only property.</exception>
            <exception cref="T:System.PlatformNotSupportedException">You use the .NET Standard 2.0 build of <c>KGySoft.CoreLibraries</c> and this <see cref="T:KGySoft.Reflection.PropertyAccessor"/>
            represents a read-only property or its declaring type is a value type.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">
            <summary>
            Gets the value of the property.
            For static properties the <paramref name="instance"/> parameter is omitted (can be <see langword="null"/>).
            If the property is not an indexer, then <paramref name="indexParameters"/> parameter is omitted.
            </summary>
            <param name="instance">The instance that the property belongs to. Can be <see langword="null"/> for static properties.</param>
            <param name="indexParameters">The parameters if the property is an indexer.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para>Getting the property for the first time is slower than the <see cref="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Object[])">System.Reflection.PropertyInfo.GetValue</see>
            method but further calls are much faster.</para>
            <note type="tip">If the property has no more than one index parameters and you know the type of the property at compile time
            (and also the declaring type for instance properties), then you can use the generic <see cref="M:KGySoft.Reflection.PropertyAccessor.GetStaticValue``1">GetStaticValue</see>
            or <see cref="O:KGySoft.Reflection.PropertyAccessor.GetInstanceValue">GetInstanceValue</see> methods for better performance.</note>
            <note type="caller">When using the .NET Standard 2.0 version of this method, and the getter of an instance property of a value type (<see langword="struct"/>) mutates the instance,
            then the changes will not be applied to the <paramref name="instance"/> parameter.
            <br/>If you reference the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly, then use the
            <see cref="O:KGySoft.Reflection.Reflector.GetProperty">Reflector.GetProperty</see> methods to preserve changes the of mutated value type instances.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents an instance property and <paramref name="instance"/> is <see langword="null"/>
            <br/>-or-
            <br/>This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents an indexed property and <paramref name="indexParameters"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The type of <paramref name="instance"/> or one of the <paramref name="indexParameters"/> is invalid.
            <br/>-or-
            <br/><paramref name="indexParameters"/> has too few elements.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a write-only property.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.SetStaticValue``1(``0)">
            <summary>
            Sets the strongly typed value of a static property. If the type of the property is not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> method can be used.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="value">The value to set.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents an instance property.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TProperty"/> is invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a read-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.GetStaticValue``1">
            <summary>
            Gets the strongly typed value of a static property. If the type of the property is not known at compile time
            the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">Get</see> method can be used.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <returns>The value of the property.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents an instance property.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TProperty"/> is invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a write-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.SetInstanceValue``2(``0,``1)">
            <summary>
            Sets the strongly typed value of a non-indexed instance property in a reference type.
            If the type of the property or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <param name="value">The value to set.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a read-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.GetInstanceValue``2(``0)">
            <summary>
            Gets the strongly typed value of a non-indexed instance property in a reference type.
            If the type of the property or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">Get</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <returns>The value of the property.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a write-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.SetInstanceValue``2(``0@,``1)">
            <summary>
            Sets the strongly typed value of a non-indexed instance property in a value type.
            If the type of the property or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <param name="value">The value to set.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a read-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.GetInstanceValue``2(``0@)">
            <summary>
            Gets the strongly typed value of a non-indexed instance property in a value type.
            If the type of the property or the declaring instance is not known at compile time the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">Get</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <returns>The value of the property.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a write-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.SetInstanceValue``3(``0,``1,``2)">
            <summary>
            Sets the strongly typed value of a single-parameter indexed property in a reference type.
            If the type of the property, the declaring instance or the index parameter is not known at compile time,
            or the indexer has more than one parameters, then the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <typeparam name="TIndex">The type of the index parameter.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <param name="value">The value to set.</param>
            <param name="index">The value of the index parameter.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a read-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.GetInstanceValue``3(``0,``2)">
            <summary>
            Gets the strongly typed value of a single-parameter indexed property in a reference type.
            If the type of the property, the declaring instance or the index parameter is not known at compile time,
            or the indexer has more than one parameters, then the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">Get</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <typeparam name="TIndex">The type of the index parameter.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <param name="index">The value of the index parameter.</param>
            <returns>The value of the property.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a write-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.SetInstanceValue``3(``0@,``1,``2)">
            <summary>
            Sets the strongly typed value of a single-parameter indexed property in a value type.
            If the type of the property, the declaring instance or the index parameter is not known at compile time,
            or the indexer has more than one parameters, then the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Set(System.Object,System.Object,System.Object[])">Set</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <typeparam name="TIndex">The type of the index parameter.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <param name="value">The value to set.</param>
            <param name="index">The value of the index parameter.</param>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a read-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="M:KGySoft.Reflection.PropertyAccessor.GetInstanceValue``3(``0@,``2)">
            <summary>
            Gets the strongly typed value of a single-parameter indexed property in a value type.
            If the type of the property, the declaring instance or the index parameter is not known at compile time,
            or the indexer has more than one parameters, then the non-generic <see cref="M:KGySoft.Reflection.PropertyAccessor.Get(System.Object,System.Object[])">Get</see> method can be used.
            </summary>
            <typeparam name="TInstance">The type of the instance that declares the property.</typeparam>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <typeparam name="TIndex">The type of the index parameter.</typeparam>
            <param name="instance">The instance that the property belongs to.</param>
            <param name="index">The value of the index parameter.</param>
            <returns>The value of the property.</returns>
            <exception cref="T:System.InvalidOperationException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a static property.</exception>
            <exception cref="T:System.ArgumentException">The number or types of the type arguments are invalid.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:KGySoft.Reflection.PropertyAccessor"/> represents a write-only property
            or an indexed property with more than one parameters.</exception>
        </member>
        <member name="T:KGySoft.Reflection.ReflectionException">
            <summary>
            Represent a reflection error.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.ReflectionException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.ReflectionException"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.ReflectionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.ReflectionException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:KGySoft.Reflection.ReflectionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Reflection.ReflectionException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="T:KGySoft.Reflection.Reflector">
            <summary>
            Provides reflection routines on objects that are in most case faster than standard System.Reflection ways.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Sets a <paramref name="property"/> represented by the specified <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set. This parameter is ignored for static properties.</param>
            <param name="property">The property to set.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">Index parameters if <paramref name="property"/> is an indexer. This parameter is ignored for non-indexed properties.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here.</param>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 build of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property is an instance member of a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To set the property explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.PropertyAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,System.Object[])">
            <summary>
            Sets a <paramref name="property"/> represented by the specified <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set. This parameter is ignored for static properties.</param>
            <param name="property">The property to set.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">Index parameters if <paramref name="property"/> is an indexer. This parameter is ignored for non-indexed properties.</param>
            <remarks>
            <para>For setting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property is an instance member of a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To set the property explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.PropertyAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Sets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetProperty">TrySetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.String,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Sets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetProperty">TrySetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.String,System.Boolean,System.Object,System.Object[])">
            <summary>
            Sets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetProperty">TrySetProperty</see> methods instead.</para>
            <para>For setting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.String,System.Object,System.Object[])">
            <summary>
            Sets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetProperty">TrySetProperty</see> methods instead.</para>
            <para>For setting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Type,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetProperty">TrySetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetProperty(System.Type,System.String,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetProperty">TrySetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetProperty(System.Object,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Tries to set the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be set; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetProperty(System.Object,System.String,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Tries to set the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be set; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetProperty(System.Object,System.String,System.Boolean,System.Object,System.Object[])">
            <summary>
            Tries to set the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be set; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For setting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetProperty(System.Object,System.String,System.Object,System.Object[])">
            <summary>
            Tries to set the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be set.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be set; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For setting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.
            If the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the property belongs to a value type (<see langword="struct"/>),
            then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetProperty(System.Type,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to set the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the property could be set; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetProperty(System.Type,System.String,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to set the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the property could be set; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetIndexedMember(System.Object,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Sets the value of an indexable object. It can be either an array instance or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here. This parameter is ignored for arrays.</param>
            <param name="indexParameters">The index parameters.</param>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the indexer belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetIndexedMember(System.Object,System.Object,System.Object[])">
            <summary>
            Sets the value of an indexable object. It can be either an array instance or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be set.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">The index parameters.</param>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For setting an indexed property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the indexer belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetIndexedMember(System.Object,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Tries to set the value of an indexable object. It can be either an array or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here. This parameter is ignored for arrays.</param>
            <param name="indexParameters">The index parameters.</param>
            <returns><see langword="true"/>, if the indexed member could be set; <see langword="false"/>, if a matching property or array setter could not be found.</returns>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <note>If a matching indexed property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the indexer belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetIndexedMember(System.Object,System.Object,System.Object[])">
            <summary>
            Tries to set the value of an indexable object. It can be either an array or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be set.</param>
            <param name="value">The value to set.</param>
            <param name="indexParameters">The index parameters.</param>
            <returns><see langword="true"/>, if the indexed member could be set; <see langword="false"/>, if a matching property or array setter could not be found.</returns>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <note>If a matching indexed property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.SetProperty(System.Object,System.Reflection.PropertyInfo,System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For setting an indexed property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the indexer belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Gets a <paramref name="property"/> represented by the specified <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved. This parameter is ignored for static properties.</param>
            <param name="property">The property to get.</param>
            <param name="indexParameters">Index parameters if <paramref name="property"/> is an indexer. This parameter is ignored for non-indexed properties.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used.</para>
            <note>To get the property explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.PropertyAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,System.Object[])">
            <summary>
            Gets a <paramref name="property"/> represented by the specified <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved. This parameter is ignored for static properties.</param>
            <param name="property">The property to get.</param>
            <param name="indexParameters">Index parameters if <paramref name="property"/> is an indexer. This parameter is ignored for non-indexed properties.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para>For getting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            <note>To get the property explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.PropertyAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Gets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetProperty">TryGetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.String,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Gets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetProperty">TryGetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.String,System.Boolean,System.Object[])">
            <summary>
            Gets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetProperty">TryGetProperty</see> methods instead.</para>
            <para>For getting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.String,System.Object[])">
            <summary>
            Gets the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetProperty">TryGetProperty</see> methods instead.</para>
            <para>For getting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Type,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetProperty">TryGetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetProperty(System.Type,System.String,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the property.</returns>
            <remarks>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a property with the specified <paramref name="propertyName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetProperty">TryGetProperty</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetProperty(System.Object,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to get the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the property.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be read; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetProperty(System.Object,System.String,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to get the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the property.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be read; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetProperty(System.Object,System.String,System.Boolean,System.Object@,System.Object[])">
            <summary>
            Tries to get the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the property.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be read; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For getting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetProperty(System.Object,System.String,System.Object@,System.Object[])">
            <summary>
            Tries to get the instance property of an object represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="instance">An instance whose property is about to be retrieved.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the property.</param>
            <param name="indexParameters">Index parameters if <paramref name="propertyName"/> refers to an indexed property. This parameter is ignored for non-indexed properties.</param>
            <returns><see langword="true"/>, if the property could be read; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties. To avoid ambiguity (in case of indexers), this method gets
            all of the properties of the same name and chooses the first one for which the provided <paramref name="indexParameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For getting the property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way
            for <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementations and the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way otherwise.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetProperty(System.Type,System.String,System.Boolean,System.Object@,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to get the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the property.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the property could be read; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetProperty(System.Type,System.String,System.Object@,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to get the static property of a <see cref="T:System.Type"/> represented by the specified <paramref name="propertyName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static property belongs to.</param>
            <param name="propertyName">The name of the property to get.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the property.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for static properties. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the property could be read; <see langword="false"/>, if a matching property could not be found.</returns>
            <remarks>
            <note>If a matching property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="propertyName"/> can refer public and non-public properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetIndexedMember(System.Object,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Gets the value of an indexable object. It can be either an array instance or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be read.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here. This parameter is ignored for arrays.</param>
            <param name="indexParameters">The index parameters.</param>
            <returns>The value returned by the indexable object.</returns>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetIndexedMember(System.Object,System.Object[])">
            <summary>
            Gets the value of an indexable object. It can be either an array instance or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be read.</param>
            <param name="indexParameters">The index parameters.</param>
            <returns>The value returned by the indexable object.</returns>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For getting an indexed property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetIndexedMember(System.Object,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to get the value of an indexable object. It can be either an array or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here. This parameter is ignored for arrays.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value returned by the indexable object.</param>
            <param name="indexParameters">The index parameters.</param>
            <returns><see langword="true"/>, if the indexed member could be read; <see langword="false"/>, if a matching property or array getter could not be found.</returns>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <note>If a matching indexed property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetIndexedMember(System.Object,System.Object@,System.Object[])">
            <summary>
            Tries to get the value of an indexable object. It can be either an array or an object with default members (indexed properties).
            </summary>
            <param name="instance">An instance to be set.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value returned by the indexable object.</param>
            <param name="indexParameters">The index parameters.</param>
            <returns><see langword="true"/>, if the indexed member could be read; <see langword="false"/>, if a matching property or array getter could not be found.</returns>
            <remarks>
            <para>This method ignores explicitly implemented interface properties.</para>
            <note>If a matching indexed property could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If you already have a <see cref="T:System.Reflection.PropertyInfo"/> instance of the indexed property, then use the <see cref="M:KGySoft.Reflection.Reflector.GetProperty(System.Object,System.Reflection.PropertyInfo,KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For getting an indexed property this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes a <paramref name="method"/> represented by the specified <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked. This parameter is ignored for static methods.</param>
            <param name="method">The method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="method"/> is a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method is an instance member of a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To invoke the method explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.MethodAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],System.Object[])">
            <summary>
            Invokes a <paramref name="method"/> represented by the specified <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked. This parameter is ignored for static methods.</param>
            <param name="method">The method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="method"/> is a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para>For invoking the <paramref name="method"/> this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method is an instance member of a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To invoke the method explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.MethodAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes a <paramref name="method"/> represented by the specified <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked. This parameter is ignored for static methods.</param>
            <param name="method">The method to be invoked.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method is an instance member of a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To invoke the method explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.MethodAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            Invokes a <paramref name="method"/> represented by the specified <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked. This parameter is ignored for static methods.</param>
            <param name="method">The method to be invoked.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para>For invoking the <paramref name="method"/> this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method is an instance member of a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To invoke the method explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.MethodAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Boolean,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Boolean,System.Type[],System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Type[],System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Boolean,System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.String,System.Object[])">
            <summary>
            Invokes an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Boolean,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Boolean,System.Type[],System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Type[],System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Boolean,System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Type,System.String,System.Object[])">
            <summary>
            Invokes a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If you are not sure whether a method with the specified <paramref name="methodName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryInvokeMethod">TryInvokeMethod</see> methods instead.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Boolean,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> is a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> is a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Boolean,System.Type[],System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> is a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Type[],System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> is a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Boolean,System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Object,System.String,System.Object@,System.Object[])">
            <summary>
            Tries to invoke an instance method of an object represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="instance">An instance whose method is about to be invoked.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method belongs to a value type (<see langword="struct"/>) or has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Boolean,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Boolean,System.Type[],System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Type[],System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="genericParameters">Type parameters if <paramref name="methodName"/> refers to a generic method definition. Otherwise, this parameter is ignored.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="genericParameters"/> and <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for invoking methods.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Boolean,System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryInvokeMethod(System.Type,System.String,System.Object@,System.Object[])">
            <summary>
            Tries to invoke a static method of a <see cref="T:System.Type"/> represented by the specified <paramref name="methodName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static method belongs to.</param>
            <param name="methodName">The name of the method to be invoked.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the return value of the method.</param>
            <param name="parameters">The parameters to be used for invoking the method.</param>
            <returns><see langword="true"/>, if the method could be invoked; <see langword="false"/>, if a matching method could not be found.</returns>
            <remarks>
            <note>If a matching method could be found and the invocation itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para><paramref name="methodName"/> can refer public and non-public methods. To avoid ambiguity this method gets
            all of the methods of the same name and chooses the first one for which the provided <paramref name="parameters"/> match.</para>
            <para>If you already have a <see cref="T:System.Reflection.MethodInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.InvokeMethod(System.Object,System.Reflection.MethodInfo,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])"/> method
            for better performance.</para>
            <para>For invoking the method this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the method has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Reflection.ConstructorInfo,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Creates a new instance by a <see cref="T:System.Reflection.ConstructorInfo"/> specified in the <paramref name="ctor"/> parameter.
            </summary>
            <param name="ctor">The constructor to be invoked.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable here.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note>To invoke the constructor explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Reflection.ConstructorInfo,System.Object[])">
            <summary>
            Creates a new instance by a <see cref="T:System.Reflection.ConstructorInfo"/> specified in the <paramref name="ctor"/> parameter.
            </summary>
            <param name="ctor">The constructor to be invoked.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns>The return value of the method.</returns>
            <remarks>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> reflection way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note>To invoke the constructor explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.CreateInstanceAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Type,System.Type[],KGySoft.Reflection.ReflectionWays)">
            <summary>
            Creates a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The created instance of <paramref name="type"/>.</returns>
            <remarks>
            <para>If you are not sure whether the type can be created without constructor parameters or by the provided <paramref name="genericParameters"/>, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryCreateInstance">TryCreateInstance</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Type,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Creates a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="way">The preferred reflection way. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The created instance of <paramref name="type"/>.</returns>
            <remarks>
            <para>If you are not sure whether the type can be created without constructor parameters, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryCreateInstance">TryCreateInstance</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object@)">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created without parameters or <paramref name="genericParameters"/> do not match to the generic type definition.</returns>
            <remarks>
            <note>If an instance can be created by its parameterless constructor and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,System.Type[],System.Object@)">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created without parameters or <paramref name="genericParameters"/> do not match to the generic type definition.</returns>
            <remarks>
            <note>If an instance can be created by its parameterless constructor and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,KGySoft.Reflection.ReflectionWays,System.Object@)">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created without parameters.</returns>
            <remarks>
            <note>If an instance can be created by its parameterless constructor and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,System.Object@)">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created without parameters.</returns>
            <remarks>
            <note>If an instance can be created by its parameterless constructor and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Type,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Creates a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns>The created instance of <paramref name="type"/>.</returns>
            <remarks>
            <para>If you are not sure whether the type can be created by the provided <paramref name="genericParameters"/> and <paramref name="parameters"/>, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryCreateInstance">TryCreateInstance</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Type,System.Type[],System.Object[])">
            <summary>
            Creates a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns>The created instance of <paramref name="type"/>.</returns>
            <remarks>
            <para>If you are not sure whether the type can be created by the provided <paramref name="genericParameters"/> and <paramref name="parameters"/>, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryCreateInstance">TryCreateInstance</see> methods instead.</para>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way, unless for value types with
            empty or <see langword="null"/>&#160;<paramref name="parameters"/>, in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way is selected, which will use the <see cref="T:System.Activator"/> class.
            When the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters, then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Type,KGySoft.Reflection.ReflectionWays,System.Object[])">
            <summary>
            Creates a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns>The created instance of <paramref name="type"/>.</returns>
            <remarks>
            <para>If you are not sure whether the type can be created by the provided <paramref name="parameters"/>, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryCreateInstance">TryCreateInstance</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way, unless for value types with
            empty or <see langword="null"/>&#160;<paramref name="parameters"/>, in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way is selected, which will use the <see cref="T:System.Activator"/> class.
            When the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters, then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CreateInstance(System.Type,System.Object[])">
            <summary>
            Creates a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns>The created instance of <paramref name="type"/>.</returns>
            <remarks>
            <para>If you are not sure whether the type can be created by the provided <paramref name="parameters"/>, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryCreateInstance">TryCreateInstance</see> methods instead.</para>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way, unless for value types with
            empty or <see langword="null"/>&#160;<paramref name="parameters"/>, in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way is selected, which will use the <see cref="T:System.Activator"/> class.
            When the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters, then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,System.Type[],KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created by the provided <paramref name="genericParameters"/> and <paramref name="parameters"/>.</returns>
            <remarks>
            <note>If a matching constructor could be found and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way,
            except when the .NET Standard 2.0 build of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,System.Type[],System.Object@,System.Object[])">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="genericParameters">Type parameters if <paramref name="type"/> refers to a generic type definition. Otherwise, this parameter is ignored.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created by the provided <paramref name="genericParameters"/> and <paramref name="parameters"/>.</returns>
            <remarks>
            <note>If a matching constructor could be found and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way, unless for value types with
            empty or <see langword="null"/>&#160;<paramref name="parameters"/>, in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way is selected, which will use the <see cref="T:System.Activator"/> class.
            When the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters, then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,KGySoft.Reflection.ReflectionWays,System.Object@,System.Object[])">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="way">The preferred reflection way.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created by the provided <paramref name="parameters"/>.</returns>
            <remarks>
            <note>If a matching constructor could be found and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way, unless for value types with
            empty or <see langword="null"/>&#160;<paramref name="parameters"/>, in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way is selected, which will use the <see cref="T:System.Activator"/> class.
            When the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters, then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryCreateInstance(System.Type,System.Object@,System.Object[])">
            <summary>
            Tries to create a new instance of the specified <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the instance to create.</param>
            <param name="result">When this method returns with <see langword="true"/> result, then this parameter contains the created instance of <paramref name="type"/>.</param>
            <param name="parameters">The parameters to be used for invoking the constructor.</param>
            <returns><see langword="true"/>, if the instance could be created; <see langword="false"/>, if <paramref name="type"/> cannot be created by the provided <paramref name="parameters"/>.</returns>
            <remarks>
            <note>If a matching constructor could be found and the constructor itself has thrown an exception, then this method also throws an exception instead of returning <see langword="false"/>.</note>
            <para>For creating the instance this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way, unless for value types with
            empty or <see langword="null"/>&#160;<paramref name="parameters"/>, in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way is selected, which will use the <see cref="T:System.Activator"/> class.
            When the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the constructor has ref/out parameters, then the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets a <paramref name="field"/> represented by the specified <see cref="T:System.Reflection.FieldInfo"/>.
            </summary>
            <param name="instance">An instance whose field is about to be set. This parameter is ignored for static fields.</param>
            <param name="field">The field to set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only or is an instance member of a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            <note>To set the property explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.PropertyAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be set.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetField">TrySetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only or belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.String,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be set.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetField">TrySetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only or belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetField(System.Type,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetField">TrySetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.SetField(System.Type,System.String,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Sets the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TrySetField">TrySetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetField(System.Object,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to set the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be set.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be set; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only or belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetField(System.Object,System.String,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to set the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be set.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be set; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only or belongs to a value type (<see langword="struct"/>),
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            <note type="tip">To preserve the changes of a mutable value type embed it into a variable of <see cref="T:System.Object"/> type and pass it to the <paramref name="instance"/> parameter of this method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetField(System.Type,System.String,System.Boolean,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to set the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be set; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TrySetField(System.Type,System.String,System.Object,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to set the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to be set.</param>
            <param name="value">The value to set.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be set; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.SetField(System.Object,System.Reflection.FieldInfo,System.Object,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used,
            except when the .NET Standard 2.0 version of the <c>KGySoft.CoreLibraries</c> assembly is referenced and the field is read-only,
            in which case the <see cref="F:KGySoft.Reflection.ReflectionWays.SystemReflection"/> way will be used.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.Reflection.FieldInfo,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets a <paramref name="field"/> represented by the specified <see cref="T:System.Reflection.FieldInfo"/>.
            </summary>
            <param name="instance">An instance whose field is about to be retrieved. This parameter is ignored for static fields.</param>
            <param name="field">The field to get.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way will be used.</para>
            <note>To get the property explicitly by dynamically created delegates use the <see cref="T:KGySoft.Reflection.FieldAccessor"/> class.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be retrieved.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.Reflection.FieldInfo,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.String,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be retrieved.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.Reflection.FieldInfo,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetField(System.Type,System.String,System.Boolean,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.Reflection.FieldInfo,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetField(System.Type,System.String,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Gets the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you already have a <see cref="T:System.Reflection.FieldInfo"/> instance use the <see cref="M:KGySoft.Reflection.Reflector.GetField(System.Object,System.Reflection.FieldInfo,KGySoft.Reflection.ReflectionWays)"/> method
            for better performance.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetField(System.Object,System.String,System.Boolean,System.Object@,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to get the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be retrieved.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the field.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be read; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetField(System.Object,System.String,System.Object@,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to get the instance field of an object represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="instance">An instance whose field is about to be retrieved.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the field.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be read; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetField(System.Type,System.String,System.Boolean,System.Object@,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to get the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="ignoreCase"><see langword="true"/> to ignore case; <see langword="false"/> to regard case.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the field.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be read; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.TryGetField(System.Type,System.String,System.Object@,KGySoft.Reflection.ReflectionWays)">
            <summary>
            Tries to get the static field of a <see cref="T:System.Type"/> represented by the specified <paramref name="fieldName"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> the static field belongs to.</param>
            <param name="fieldName">The name of the field to get.</param>
            <param name="value">When this method returns with <see langword="true"/> result, then this parameter contains the value of the field.</param>
            <param name="way">The preferred reflection way. <see cref="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor"/> way is not applicable for fields. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>.</param>
            <returns><see langword="true"/>, if the field could be read; <see langword="false"/>, if a field with name <paramref name="fieldName"/> could not be found.</returns>
            <remarks>
            <para><paramref name="fieldName"/> can refer public and non-public fields.</para>
            <para>If you are not sure whether a field with the specified <paramref name="fieldName"/> exists, then you can use the
            <see cref="O:KGySoft.Reflection.Reflector.TryGetField">TryGetField</see> methods instead.</para>
            <para>If <paramref name="way"/> is <see cref="F:KGySoft.Reflection.ReflectionWays.Auto"/>, then this method uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.CheckParameters(System.Reflection.ParameterInfo[],System.Object[])">
            <summary>
            Checks whether the awaited parameter list can receive an actual parameter list
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveAssembly(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.Assembly"/> with the specified <paramref name="assemblyName"/>.
            </summary>
            <param name="assemblyName">Name of the <see cref="T:System.Reflection.Assembly"/> to retrieve. May contain a fully or partially defined assembly name.</param>
            <param name="tryToLoad">If <see langword="false"/>, searches the assembly among the already loaded assemblies. If <see langword="true"/>, tries to load the assembly when it is not already loaded.</param>
            <param name="matchBySimpleName"><see langword="true"/> to ignore version, culture and public key token information differences;
            <see langword="false"/> to allow only an exact match with the provided information.</param>
            <returns>An <see cref="T:System.Reflection.Assembly"/> instance with the loaded assembly, or <see langword="null"/> if
            <paramref name="assemblyName"/> could not be resolved by the provided arguments.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="assemblyName"/> is empty.</exception>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveAssembly(System.String,KGySoft.Reflection.ResolveAssemblyOptions)">
            <summary>
            Gets the <see cref="T:System.Reflection.Assembly"/> with the specified <paramref name="assemblyName"/>.
            </summary>
            <param name="assemblyName">Name of the <see cref="T:System.Reflection.Assembly"/> to retrieve. May contain a fully or partially defined assembly name.</param>
            <param name="options">The options for resolving the assembly. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.TryToLoadAssembly"/>, <see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.AllowPartialMatch"/>.</param>
            <returns>An <see cref="T:System.Reflection.Assembly"/> instance with the loaded assembly, or <see langword="null"/> if
            the <see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.ThrowError"/> flag is not enabled in <paramref name="options"/> and
            <paramref name="assemblyName"/> could not be resolved with the provided <paramref name="options"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="assemblyName"/> is empty
            <br/>-or-
            <bir/><see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.ThrowError"/> is enabled in <paramref name="options"/>
            and <paramref name="assemblyName"/> does not contain a valid assembly name.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options"/> has an invalid value.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException"><see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.ThrowError"/> is enabled in <paramref name="options"/> and the assembly cannot be resolved or loaded.
            In case of a load error the <see cref="P:System.Exception.InnerException"/> property is set.</exception>
            <seealso cref="T:KGySoft.Reflection.ResolveAssemblyOptions"/>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveAssembly(System.Reflection.AssemblyName,KGySoft.Reflection.ResolveAssemblyOptions)">
            <summary>
            Gets the <see cref="T:System.Reflection.Assembly"/> with the specified <paramref name="assemblyName"/>.
            </summary>
            <param name="assemblyName">Name of the <see cref="T:System.Reflection.Assembly"/> to retrieve. May contain a fully or partially defined assembly name.</param>
            <param name="options">The options for resolving the assembly. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.TryToLoadAssembly"/>, <see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.AllowPartialMatch"/>.</param>
            <returns>An <see cref="T:System.Reflection.Assembly"/> instance with the loaded assembly, or <see langword="null"/> if
            the <see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.ThrowError"/> flag is not enabled in <paramref name="options"/> and
            <paramref name="assemblyName"/> could not be resolved with the provided <paramref name="options"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options"/> has an invalid value.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException"><see cref="F:KGySoft.Reflection.ResolveAssemblyOptions.ThrowError"/> is enabled in <paramref name="options"/> and the assembly cannot be resolved or loaded.
            In case of a load error the <see cref="P:System.Exception.InnerException"/> property is set.</exception>
            <seealso cref="T:KGySoft.Reflection.ResolveAssemblyOptions"/>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetLoadedAssemblies">
            <summary>
            Gets the already loaded assemblies in a transparent way of any frameworks.
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Type"/> with the specified <paramref name="typeName"/>.
            When no assembly is defined in <paramref name="typeName"/>, the type can be defined in any loaded assembly.
            </summary>
            <param name="typeName">The type name as a string representation with or without assembly name.</param>
            <param name="tryLoadAssemblies"><see langword="true"/> to try loading assemblies present in <paramref name="typeName"/> if they are not loaded already;
            <see langword="false"/> to locate assemblies among the loaded ones only.</param>
            <param name="allowPartialAssemblyMatch"><see langword="true"/> to allow resolving assembly names by simple assembly name, and ignoring
            version, culture and public key token information even if they present in <paramref name="typeName"/>;
            <see langword="false"/> to consider every provided information in assembly names. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
            <returns>The resolved <see cref="T:System.Type"/>, or <see langword="null"/> if <paramref name="typeName"/> cannot be resolved.</returns>
            <remarks>
            <para><paramref name="typeName"/> can be generic and may contain fully or partially defined assembly names.</para>
            <para><paramref name="typeName"/> can contain generic parameter types in the format as they are returned by the
            <see cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</see> extension method.</para>
            <note>If <paramref name="tryLoadAssemblies"/> is <see langword="true"/> and <paramref name="allowPartialAssemblyMatch"/> is <see langword="false"/>, then
            it can happen that the assembly of a different version will be loaded and the method returns <see langword="null"/>.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">
            <summary>
            Gets the <see cref="T:System.Type"/> with the specified <paramref name="typeName"/>.
            When no assembly is defined in <paramref name="typeName"/>, the type can be defined in any loaded assembly.
            </summary>
            <param name="typeName">The type name as a string representation with or without assembly name.</param>
            <param name="options">The options for resolving the type. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ResolveTypeOptions.TryToLoadAssemblies"/>, <see cref="F:KGySoft.Reflection.ResolveTypeOptions.AllowPartialAssemblyMatch"/>.</param>
            <returns>The resolved <see cref="T:System.Type"/>, or <see langword="null"/> if
            the <see cref="F:KGySoft.Reflection.ResolveTypeOptions.ThrowError"/> flag is not enabled in <paramref name="options"/> and
            <paramref name="typeName"/> could not be resolved with the provided <paramref name="options"/>.</returns>
            <remarks>
            <para><paramref name="typeName"/> can be generic and may contain fully or partially defined assembly names.</para>
            <para><paramref name="typeName"/> can contain generic parameter types in the format as they are returned by
            the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</see> extension method.</para>
            </remarks>
            <example>
            <code lang="C#"><![CDATA[
            // Here mscorlib types are defined without assembly, System.Uri is defined with fully qualified assembly name:
            // it will be resolved only if the System.dll of the same version is already loaded.
            var type = Reflector.ResolveType("System.Collections.Generic.Dictionary`2[System.String,[System.Uri, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]",
                ResolveTypeOptions.None);
            
            // If System.dll is already loaded, then System.Uri will be resolved even if the loaded System.dll has a different version.
            // If System.dll is not loaded, then null will be returned.
            var type = Reflector.ResolveType("System.Collections.Generic.Dictionary`2[System.String,[System.Uri, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]",
                ResolveTypeOptions.AllowPartialAssemblyMatch);
            
            // If System.dll is not loaded, then it will be tried to be loaded and it can have any version.
            var type = Reflector.ResolveType("System.Collections.Generic.Dictionary`2[System.String,[System.Uri, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]",
                // this are actually the default options:
                ResolveTypeOptions.TryToLoadAssemblies | ResolveTypeOptions.AllowPartialAssemblyMatch);
            
            // System.Uri is defined with partial assembly name. It will be resolved by default settings.
            var type = Reflector.ResolveType("System.Collections.Generic.Dictionary`2[System.String,[System.Uri, System]]");
            
            // All types are defined without assembly names. System.Uri will be resolved only if its assembly is already loaded.
            var type = Reflector.ResolveType("System.Collections.Generic.Dictionary`2[System.String, System.Uri]");
            
            // This is how a generic parameter of Dictionary<,> can be resolved. See also TypeExtensions.GetName.
            var type = Reflector.ResolveType("!TKey:System.Collections.Generic.Dictionary`2");
            ]]></code>
            </example>
            <seealso cref="T:KGySoft.Reflection.ResolveTypeOptions"/>
            <seealso cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</seealso>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveType(System.String,System.Func{System.Reflection.AssemblyName,System.String,System.Type},KGySoft.Reflection.ResolveTypeOptions)">
            <summary>
            Gets the <see cref="T:System.Type"/> with the specified <paramref name="typeName"/> using the specified <paramref name="typeResolver"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)"/> overload for some examples.
            </summary>
            <param name="typeName">The type name as a string representation.</param>
            <param name="typeResolver">If not <see langword="null"/>, then will be called for every generic type definition and ultimate element types
            occur in <paramref name="typeName"/>. The passed <see cref="T:System.Reflection.AssemblyName"/> argument can be <see langword="null"/> if no assembly is
            specified for the type to resolve. Can return <see langword="null"/> to let the default resolve logic take over based on <paramref name="options"/>.</param>
            <param name="options">The options for resolving the type. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ResolveTypeOptions.TryToLoadAssemblies"/>, <see cref="F:KGySoft.Reflection.ResolveTypeOptions.AllowPartialAssemblyMatch"/>.</param>
            <returns>The resolved <see cref="T:System.Type"/>, or <see langword="null"/> if
            the <see cref="F:KGySoft.Reflection.ResolveTypeOptions.ThrowError"/> flag is not enabled in <paramref name="options"/> and
            <paramref name="typeName"/> could not be resolved with the provided <paramref name="options"/>.</returns>
            <remarks>
            <para><paramref name="typeName"/> can be generic and may contain fully or partially defined assembly names.</para>
            <para><paramref name="typeName"/> can contain generic parameter types in the format as they are returned by
            the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</see> extension method.</para>
            </remarks>
            <seealso cref="T:KGySoft.Reflection.ResolveTypeOptions"/>
            <seealso cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</seealso>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.ResolveType(System.Reflection.Assembly,System.String,KGySoft.Reflection.ResolveTypeOptions)">
            <summary>
            Gets the <see cref="T:System.Type"/> with the specified <paramref name="typeName"/> from the specified <paramref name="assembly"/>.
            As the type is about to be resolved from the specified <paramref name="assembly"/>, assembly names are allowed to be specified in the generic arguments only.
            <br/>See the <strong>Examples</strong> section of the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)"/> overload for some examples.
            </summary>
            <param name="assembly">The assembly that contains the type to retrieve.</param>
            <param name="typeName">The type name as a string representation.</param>
            <param name="options">The options for resolving the type. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Reflection.ResolveTypeOptions.TryToLoadAssemblies"/>, <see cref="F:KGySoft.Reflection.ResolveTypeOptions.AllowPartialAssemblyMatch"/>.</param>
            <returns>The resolved <see cref="T:System.Type"/>, or <see langword="null"/> if
            the <see cref="F:KGySoft.Reflection.ResolveTypeOptions.ThrowError"/> flag is not enabled in <paramref name="options"/> and
            <paramref name="typeName"/> could not be resolved with the provided <paramref name="options"/>.</returns>
            <remarks>
            <para><paramref name="typeName"/> can be generic and may contain fully or partially defined assembly names.</para>
            <para><paramref name="typeName"/> can contain generic parameter types in the format as they are returned by
            the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</see> extension method.</para>
            <para>If the <see cref="F:KGySoft.Reflection.ResolveTypeOptions.AllowIgnoreAssemblyName"/> flag is enabled in <paramref name="options"/>,
            then <paramref name="typeName"/> can be resolved not just from the provided <paramref name="assembly"/> but from any loaded assemblies.</para>
            </remarks>
            <seealso cref="T:KGySoft.Reflection.ResolveTypeOptions"/>
            <seealso cref="M:KGySoft.CoreLibraries.TypeExtensions.GetName(System.Type,KGySoft.CoreLibraries.TypeNameKind)">TypeExtensions.GetName</seealso>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.EmptyArray``1">
            <summary>
            Returns an empty array of <typeparamref name="T"/>. The same as <see cref="M:System.Array.Empty``1">Array.Empty</see> but works on every platform.
            </summary>
            <typeparam name="T">The element type of the returned array.</typeparam>
            <returns>An empty array of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.MemberOf``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the returned member of an expression providing a refactoring-safe way for
            referencing a field, property, constructor or function method.
            </summary>
            <typeparam name="T">Type of the returned member in the expression.</typeparam>
            <param name="expression">An expression returning a member.</param>
            <returns>A <see cref="T:System.Reflection.MemberInfo"/> instance that represents the returned member of the <paramref name="expression"/></returns>
            <remarks>
            <para>Similarly to the <see langword="typeof"/> operator, which provides a refactoring-safe reference to a <see cref="T:System.Type"/>,
            this method provides a non-string access to a field, property, constructor or function method:
            <example><code lang="C#"><![CDATA[
            MemberInfo ctorList = Reflector.MemberOf(() => new List<int>()); // ConstructorInfo: List<int>().ctor()
            MemberInfo methodIndexOf = Reflector.MemberOf(() => default(List<int>).IndexOf(default(int))); // MethodInfo: List<int>.IndexOf(int) - works without a reference to a List
            MemberInfo fieldEmpty = Reflector.MemberOf(() => string.Empty); // FieldInfo: String.Empty
            MemberInfo propertyLength = Reflector.MemberOf(() => default(string).Length); // PropertyInfo: String.Length - works without a reference to a string
            ]]></code></example></para>
            <para>Constant fields cannot be reflected by this method because the C# compiler emits the value of the constant into
            the expression instead of the access of the constant field.</para>
            <para>To reflect an action method, you can use the <see cref="M:KGySoft.Reflection.Reflector.MemberOf(System.Linq.Expressions.Expression{System.Action})"/> method.</para>
            <para>To reflect methods, you can actually cast the method to a delegate and get its <see cref="P:System.Delegate.Method"/> property:
            <example><code lang="C#"><![CDATA[
            MemberInfo methodIndexOf = ((Action<int>)new List<int>().IndexOf).Method; // MethodInfo: List<int>.IndexOf(int) - a reference to a List is required
            ]]></code></example>
            <note>
            Accessing a method by the delegate cast is usually faster than using this method. However, you must have an instance to
            access instance methods. That means that you cannot use the <see langword="default"/> operator for reference types
            to access their instance methods. If the constructor of such a type is slow, then using this method can be
            more effective to access an instance method.
            </note>
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="expression"/> does not return a member.</exception>
            <seealso cref="M:KGySoft.Reflection.Reflector.MemberOf(System.Linq.Expressions.Expression{System.Action})"/>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.MemberOf(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Gets the action method of an expression by a refactoring-safe way.
            </summary>
            <param name="expression">An expression accessing an action method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> instance of the <paramref name="expression"/>.</returns>
            <remarks>
            <para>Similarly to the <see langword="typeof"/> operator, which provides a refactoring-safe reference to a <see cref="T:System.Type"/>,
            this method provides a non-string access to an action method:
            <example><code lang="C#"><![CDATA[
            MethodInfo methodAdd = Reflector.MemberOf(() => default(List<int>).Add(default(int))); // MethodInfo: List<int>.Add() - works without a reference to a List
            ]]></code></example></para>
            <para>To reflect a function method, constructor, property or a field, you can use the <see cref="M:KGySoft.Reflection.Reflector.MemberOf``1(System.Linq.Expressions.Expression{System.Func{``0}})"/> method.</para>
            <para>To reflect methods, you can actually cast the method to a delegate and get its <see cref="P:System.Delegate.Method"/> property:
            <example><code lang="C#"><![CDATA[
            MethodInfo methodAdd = ((Action<int>)new List<int>().Add).Method; // MethodInfo: List<int>.Add() - a reference to a List is required
            ]]></code></example>
            <note>
            Accessing a method by the delegate cast is usually faster than using this method. However, you must have an instance to
            access instance methods. That means that you cannot use the <see langword="default"/> operator for reference types
            to access their instance methods. If the constructor of such a type is slow, then using this method can be
            more effective to access an instance method.
            </note>
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="expression"/> does not access an action method.</exception>
            <seealso cref="M:KGySoft.Reflection.Reflector.MemberOf``1(System.Linq.Expressions.Expression{System.Func{``0}})"/>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.IsExplicitInterfaceImplementation(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified <paramref name="method"/> is an explicit interface implementation.
            </summary>
            <param name="method">The method to check.</param>
            <returns><see langword="true"/>, if the specified <paramref name="method"/> is an explicit interface implementation; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.IsExplicitInterfaceImplementation(System.Reflection.MethodInfo,System.Reflection.MethodInfo@)">
            <summary>
            Determines whether the specified <paramref name="method"/> is an explicit interface implementation.
            </summary>
            <param name="method">The method to check.</param>
            <param name="interfaceMethod">When this method returns <see langword="true"/>, then contains the method declared on the interface. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if the specified <paramref name="method"/> is an explicit interface implementation; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.IsExplicitInterfaceImplementation(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether the specified <paramref name="property"/> is an explicit interface implementation.
            </summary>
            <param name="property">The property to check.</param>
            <returns><see langword="true"/>, if the specified <paramref name="property"/> is an explicit interface implementation; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.IsExplicitInterfaceImplementation(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo@)">
            <summary>
            Determines whether the specified <paramref name="property"/> is an explicit interface implementation.
            </summary>
            <param name="property">The property to check.</param>
            <param name="interfaceProperty">When this method returns <see langword="true"/>, then contains the property declared on the interface. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if the specified <paramref name="property"/> is an explicit interface implementation; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.IsExplicitInterfaceImplementation(System.Reflection.EventInfo)">
            <summary>
            Determines whether the specified <see cref="T:System.Reflection.EventInfo"/> is an explicit interface implementation.
            </summary>
            <param name="info">The <see cref="T:System.Reflection.EventInfo"/> to check.</param>
            <returns><see langword="true"/>, if the specified <see cref="T:System.Reflection.EventInfo"/> is an explicit interface implementation; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.IsExplicitInterfaceImplementation(System.Reflection.EventInfo,System.Reflection.EventInfo@)">
            <summary>
            Determines whether the specified <see cref="T:System.Reflection.EventInfo"/> is an explicit interface implementation.
            </summary>
            <param name="info">The <see cref="T:System.Reflection.EventInfo"/> to check.</param>
            <param name="interfaceEvent">When this method returns <see langword="true"/>, then contains the event declared on the interface. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if the specified <see cref="T:System.Reflection.EventInfo"/> is an explicit interface implementation; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetReferencedDataAddress(System.TypedReference)">
            <summary>
            Gets a pointer to the raw data (first field member or array header) of a reference created from a reference type (including boxed values).
            </summary>
        </member>
        <member name="M:KGySoft.Reflection.Reflector.GetValueAddress(System.TypedReference)">
            <summary>
            Gets a pointer to the actual value (first field if the struct has fields) of a reference created from a value type.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.TypeResolver">
            <summary>
            Represents a class that is able to convert/parse every runtime type to/from string.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.None">
            <summary>
            Empty stack.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.FullNameOrAqn">
            <summary>
            A type name optionally with assembly name.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.TypeName">
            <summary>
            A type name without assembly name.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.AssemblyName">
            <summary>
            Assembly name part.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.ArrayOrGeneric">
            <summary>
            [ in FullName or TypeName
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.Modifiers">
            <summary>
            Array, pointer, ByRef part
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.BeforeArgument">
            <summary>
            After , in generic type
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.AfterArgument">
            <summary>
            After inner ] in generic type argument
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.Array">
            <summary>
            Inside an array declaration
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.GenericParameterName">
            <summary>
            ! at the beginning of FullNameOrAqn or TypeName
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.GenericMethodParameterName">
            <summary>
            !! at the beginning of FullNameOrAqn or TypeName
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.MethodSignature">
            <summary>
            Signature of declaring method of generic parameter.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.Return">
            <summary>
            Return from recursion.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.TypeResolver.State.Invalid">
            <summary>
            Invalid state.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Reflection"/> namespace contains the static <see cref="T:KGySoft.Reflection.Reflector"/> class that provides most of the needed reflection tasks.
            Additionally, contains several classes derived from <see cref="T:KGySoft.Reflection.MemberAccessor"/> that can dynamically reflect objects, their members and type information by on-the-fly generated delegates.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.DynamicMethodOptions">
            <summary>
            Options for the <see cref="M:KGySoft.Reflection.MemberAccessor.CreateMethodInvokerAsDynamicMethod(System.Reflection.MethodBase,KGySoft.Reflection.DynamicMethodOptions)">MemberAccessor.CreateMethodInvokerAsDynamicMethod</see> method.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.DynamicMethodOptions.None">
            <summary>
            No special handling.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.DynamicMethodOptions.HandleByRefParameters">
            <summary>
            Generates local variables for ref/out parameters and assigns them back in the object[] parameters array
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.DynamicMethodOptions.TreatAsPropertySetter">
            <summary>
            Generates an object value parameter and also an object[] arguments parameter in case of indexers
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.DynamicMethodOptions.OmitParameters">
            <summary>
            Does not emit the object[] parameter for method arguments (for simple property getters)
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.DynamicMethodOptions.TreatCtorAsMethod">
            <summary>
            Treats a ConstructorInfo as a regular method
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.ReflectionWays">
            <summary>
            Represents the possible ways of reflection for the methods of the <see cref="T:KGySoft.Reflection.Reflector"/> class.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ReflectionWays.Auto">
            <summary>
            Auto decision. In most cases it uses the <see cref="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate"/> way.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ReflectionWays.DynamicDelegate">
            <summary>
            Dynamic delegate way. This option uses cached <see cref="T:KGySoft.Reflection.MemberAccessor"/> instances for reflection.
            In this case first access of a member is slower than accessing it via system reflection but further accesses are much more faster.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ReflectionWays.SystemReflection">
            <summary>
            Uses the standard system reflection way.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ReflectionWays.TypeDescriptor">
            <summary>
            Uses the type descriptor way. If there is no <see cref="T:System.ComponentModel.ICustomTypeDescriptor"/> implementation for an instance,
            then this can be the slowest way as it internally falls back to use system reflection. Not applicable in all cases.
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.ResolveAssemblyOptions">
            <summary>
            Provides options for the <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveAssemblyOptions.None">
            <summary>
            <para>Represents no enabled options.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveAssemblyOptions.TryToLoadAssembly">
            <summary>
            <para>If this flag is enabled, then the <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods
            try to load the assembly if it is not loaded yet. Otherwise, the assembly is tried to be located among the already loaded assemblies.</para>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveAssemblyOptions.AllowPartialMatch">
            <summary>
            <para>If this flag is enabled, then the <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods
            allow to return an already loaded assembly of any version, culture and public key token, or, if the assembly
            is not loaded, this flag allows to load it by partial identity if possible.
            If this flag is disabled, then the provided assembly information must match (which still can be a partial name).</para>
            <note>Depending on the type system of the current platform it can happen that a new assembly of an unmatching identity is loaded even if this flag is disabled.
            In such case the loaded assembly is not returned though.</note>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveAssemblyOptions.ThrowError">
            <summary>
            <para>If this flag is enabled and the assembly cannot be resolved, then a <see cref="T:KGySoft.Reflection.ReflectionException"/>
            will be thrown from the <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods.</para>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveAssembly">Reflector.ResolveAssembly</see> methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="T:KGySoft.Reflection.ResolveTypeOptions">
            <summary>
            Provides options for the <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods.
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveTypeOptions.None">
            <summary>
            <para>Represents no enabled options.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveTypeOptions.TryToLoadAssemblies">
            <summary>
            <para>If this flag is enabled, then the <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods
            try to load the assemblies optionally present in the type name if they are not loaded yet. Otherwise, the assemblies are tried to be located among the already loaded assemblies.</para>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveTypeOptions.AllowPartialAssemblyMatch">
            <summary>
            <para>If this flag is enabled, then the <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods
            allow to resolve assembly names optionally present in the type name by partial name.
            If this flag is disabled, then the provided assembly information must match (which still can be partially specified).</para>
            <para>If a type name is specified without an assembly, then this flag is ignored (as if the <see cref="F:KGySoft.Reflection.ResolveTypeOptions.AllowIgnoreAssemblyName"/> was set).</para>
            <note>Depending on the type system of the current platform it can happen that new assemblies of unmatching identity are loaded even if this flag is disabled.
            In such case the loaded assemblies are ignored.</note>
            <note type="tip">Forwarded types can be loaded even if this flag is disabled but only if the old assembly of the exact identity can be resolved.
            So for example, to allow a type, which was forwarded from the <c>mscorlib 4.0</c> assembly, to be resolved by an <c>mscorlib 2.0</c> identity,
            this flag should be enabled.</note>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveTypeOptions.AllowIgnoreAssemblyName">
            <summary>
            <para>If a type is specified with an assembly name, which cannot be resolved at all, then this flag makes possible to
            completely ignore the assembly information and that the <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see>
            methods can return a type by its full name from any loaded assembly.</para>
            <para>If a type name is specified without an assembly, then it will be tried to be resolved from the loaded assemblies as if this flag was enabled.</para>
            <para>If this flag is enabled, then the <see cref="F:KGySoft.Reflection.ResolveTypeOptions.AllowPartialAssemblyMatch"/> flag is ignored.</para>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveTypeOptions.IgnoreCase">
            <summary>
            <para>If this flag is enabled, then the type name is identified in a case-insensitive manner.</para>
            <note>Assembly name is always resolved in a case-insensitive manner.</note>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Reflection.ResolveTypeOptions.ThrowError">
            <summary>
            <para>If this flag is enabled and the type cannot be resolved, then a <see cref="T:KGySoft.Reflection.ReflectionException"/>
            will be thrown from the <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods.</para>
            <para>Default state at <see cref="O:KGySoft.Reflection.Reflector.ResolveType">Reflector.ResolveType</see> methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="T:KGySoft.Res">
            <summary>
            Contains the string resources of the project.
            </summary>
        </member>
        <member name="P:KGySoft.Res.Undefined">
            <summary>&lt;undefined&gt;</summary>
        </member>
        <member name="P:KGySoft.Res.Null">
            <summary>&lt;null&gt;</summary>
        </member>
        <member name="P:KGySoft.Res.ArgumentNull">
            <summary>Value cannot be null.</summary>
        </member>
        <member name="P:KGySoft.Res.ArgumentEmpty">
            <summary>Value cannot be empty.</summary>
        </member>
        <member name="P:KGySoft.Res.ArgumentInvalid">
            <summary>The specified argument is invalid.</summary>
        </member>
        <member name="P:KGySoft.Res.CollectionEmpty">
            <summary>The collection contains no elements.</summary>
        </member>
        <member name="P:KGySoft.Res.ArgumentContainsNull">
            <summary>Specified argument contains a null element.</summary>
        </member>
        <member name="P:KGySoft.Res.ArgumentOutOfRange">
            <summary>Specified argument was out of the range of valid values.</summary>
        </member>
        <member name="P:KGySoft.Res.IndexOutOfRange">
            <summary>Index was outside the bounds of the array.</summary>
        </member>
        <member name="P:KGySoft.Res.ObjectDisposed">
            <summary>Cannot access a disposed object.</summary>
        </member>
        <member name="P:KGySoft.Res.NotSupported">
            <summary>This operation is not supported.</summary>
        </member>
        <member name="P:KGySoft.Res.OperationCanceled">
            <summary>The operation was canceled.</summary>
        </member>
        <member name="P:KGySoft.Res.ArgumentInvalidString">
            <summary>Input string contains an invalid value.</summary>
        </member>
        <member name="P:KGySoft.Res.MaxValueLessThanMinValue">
            <summary>Maximum value must be greater than or equal to minimum value.</summary>
        </member>
        <member name="P:KGySoft.Res.MaxLengthLessThanMinLength">
            <summary>Maximum length must be greater than or equal to minimum length.</summary>
        </member>
        <member name="P:KGySoft.Res.Yes">
            <summary>Yes</summary>
        </member>
        <member name="P:KGySoft.Res.No">
            <summary>No</summary>
        </member>
        <member name="P:KGySoft.Res.QuoteStart">
            <summary>'</summary>
        </member>
        <member name="P:KGySoft.Res.QuoteEnd">
            <summary>'</summary>
        </member>
        <member name="P:KGySoft.Res.Millisecond">
            <summary>ms</summary>
        </member>
        <member name="P:KGySoft.Res.ArrayInvalidOffsLen">
            <summary>Offset and length were out of bounds for the array.</summary>
        </member>
        <member name="P:KGySoft.Res.IEnumeratorEnumerationNotStartedOrFinished">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:KGySoft.Res.IEnumeratorCollectionModified">
            <summary>Collection was modified; enumeration operation may not execute.</summary>
        </member>
        <member name="P:KGySoft.Res.IDictionaryKeyNotFound">
            <summary>The given key was not present in the dictionary.</summary>
        </member>
        <member name="P:KGySoft.Res.IDictionaryDuplicateKey">
            <summary>An item with the same key has already been added.</summary>
        </member>
        <member name="P:KGySoft.Res.ICollectionCopyToDestArrayShort">
            <summary>Destination array is not long enough to copy all the items in the collection. Check array index and length.</summary>
        </member>
        <member name="P:KGySoft.Res.ICollectionCopyToSingleDimArrayOnly">
            <summary>Only single dimensional arrays are supported for the requested action.</summary>
        </member>
        <member name="P:KGySoft.Res.ICollectionArrayTypeInvalid">
            <summary>Target array type is not compatible with the type of items in the collection.</summary>
        </member>
        <member name="P:KGySoft.Res.ICollectionReadOnlyModifyNotSupported">
            <summary>Modifying a read-only collection is not supported.</summary>
        </member>
        <member name="P:KGySoft.Res.IListInvalidOffsLen">
            <summary>Offset and length were out of bounds for the list or count is greater than the number of elements from index to the end of the source collection.</summary>
        </member>
        <member name="P:KGySoft.Res.ArraySectionNull">
            <summary>The underlying array is null.</summary>
        </member>
        <member name="P:KGySoft.Res.ArraySectionEmpty">
            <summary>The array section has no elements.</summary>
        </member>
        <member name="P:KGySoft.Res.ArraySectionInsufficientCapacity">
            <summary>The specified buffer has insufficient capacity.</summary>
        </member>
        <member name="P:KGySoft.Res.BinarySerializationInvalidStreamData">
            <summary>Invalid stream data.</summary>
        </member>
        <member name="P:KGySoft.Res.BinarySerializationCircularIObjectReference">
            <summary>Deserialization of an IObjectReference instance has an unresolvable circular reference to itself.</summary>
        </member>
        <member name="P:KGySoft.Res.BinarySerializationDeserializeUnexpectedId">
            <summary>Unexpected id on deserialization. Serialization stream corrupted?</summary>
        </member>
        <member name="P:KGySoft.Res.BinarySerializationValueTypeExpected">
            <summary>Specified type must be a value type.</summary>
        </member>
        <member name="P:KGySoft.Res.BinarySerializationDataLengthTooSmall">
            <summary>Data length is too small.</summary>
        </member>
        <member name="P:KGySoft.Res.ByteArrayExtensionsSeparatorInvalidHex">
            <summary>The separator contains invalid characters. Hex digits are not allowed in separator.</summary>
        </member>
        <member name="P:KGySoft.Res.ByteArrayExtensionsSeparatorInvalidDec">
            <summary>The separator is empty or contains invalid characters. Decimal digits are not allowed in separator.</summary>
        </member>
        <member name="P:KGySoft.Res.CacheNullLoaderInvoke">
            <summary>Cache&lt;TKey, TValue&gt; was initialized without an item loader so elements must be added explicitly either by the Add method or by setting the indexer.</summary>
        </member>
        <member name="P:KGySoft.Res.CacheKeyNotFound">
            <summary>The given key was not found in the cache.</summary>
        </member>
        <member name="P:KGySoft.Res.CacheMinSize">
            <summary>Minimum cache size is 1.</summary>
        </member>
        <member name="P:KGySoft.Res.CircularListComparerFail">
            <summary>Failed to compare two elements in the collection.</summary>
        </member>
        <member name="P:KGySoft.Res.CircularListCapacityTooSmall">
            <summary>Capacity cannot be less than number of stored elements.</summary>
        </member>
        <member name="P:KGySoft.Res.CircularSortedListInsertByIndexNotSupported">
            <summary>Adding an element by index is not supported.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelAddNewDisabled">
            <summary>Cannot add new item to the binding list because AllowNew is false.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelRemoveDisabled">
            <summary>Cannot remove item from the binding list because AllowRemove is false.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelReentrancyNotAllowed">
            <summary>Cannot change ObservableBindingList during a CollectionChanged or ListChanged event.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelNotEditing">
            <summary>Object is not in editing state.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelMissingPropertyReference">
            <summary>&lt;Missing property value&gt;</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelDoValidationNull">
            <summary>The DoValidation method returned null.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelEnabledMustBeBool">
            <summary>'Enabled' state must have a boolean value.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelInvalidCommandSource">
            <summary>Source must be an object instance for instance events and a Type for static events.</summary>
        </member>
        <member name="P:KGySoft.Res.ComponentModelCannotAddDisposedBinding">
            <summary>Cannot add an already disposed binding to this collection.</summary>
        </member>
        <member name="P:KGySoft.Res.EnumTypeParameterInvalid">
            <summary>Type parameter is expected to be a System.Enum type.</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestNoTestCases">
            <summary>No test cases are added.</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestItem">
            <summary>item</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestByte">
            <summary>byte</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestNoDifference">
            <summary> No difference</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestDefaultName">
            <summary>Performance Test</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestSortBySize">
            <summary>size (shortest first)</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestSortByTime">
            <summary>time (quickest first)</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestSortByIterations">
            <summary>fulfilled iterations (the most first)</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestSeparator">
            <summary>--------------------------------------------------</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestBestMark">
            <summary>&#x9; &lt;---- Best</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestWorstMark">
            <summary>&#x9; &lt;---- Worst</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestWorstBestDiff">
            <summary>  Worst-Best difference: </summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestDumpedResult">
            <summary>Dumped result:</summary>
        </member>
        <member name="P:KGySoft.Res.PerformanceTestDumpedError">
            <summary>Error dump:</summary>
        </member>
        <member name="P:KGySoft.Res.ProfilerUncategorized">
            <summary>&lt;Uncategorized&gt;</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionInvalidMethodBase">
            <summary>MethodInfo or ConstructorInfo expected.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionCannotTreatPropertySetter">
            <summary>Cannot treat method as a property setter.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionTypeOrCtorInfoExpected">
            <summary>Argument must be either Type or ConstructorInfo.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionInstanceCtorExpected">
            <summary>A ConstructorInfo of an instance constructor is expected.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionGetPropertyTypeDescriptorNotSupported">
            <summary>Getting property via TypeDescriptor is not supported in this overload of GetProperty method.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionSetPropertyTypeDescriptorNotSupported">
            <summary>Setting property via TypeDescriptor is not supported in this overload of SetProperty method.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionCannotGetStaticPropertyTypeDescriptor">
            <summary>A static property cannot be retrieved via TypeDescriptor.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionCannotSetStaticPropertyTypeDescriptor">
            <summary>A static property cannot be set via TypeDescriptor.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionEmptyIndices">
            <summary>Indexer parameters are empty.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionGetIndexerTypeDescriptorNotSupported">
            <summary>An indexer cannot be retrieved via TypeDescriptor.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionSetIndexerTypeDescriptorNotSupported">
            <summary>An indexer cannot be set via TypeDescriptor.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionIndexParamsTypeMismatch">
            <summary>Index parameters cannot be cast to integer values.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionInstanceIsNull">
            <summary>Instance is null for a non-static member.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionTypeParamsAreNull">
            <summary>The method to invoke is generic but no generic parameters were passed.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionCannotCreateGenericMethod">
            <summary>Could not create generic method. For details see inner exception.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionInvokeMethodTypeDescriptorNotSupported">
            <summary>Invoking a method via TypeDescriptor is not supported.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionInvokeCtorTypeDescriptorNotSupported">
            <summary>Invoking a constructor via TypeDescriptor is not supported in this overload of CreateInstance method.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionSetFieldTypeDescriptorNotSupported">
            <summary>A field cannot be set via TypeDescriptor.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionGetFieldTypeDescriptorNotSupported">
            <summary>A field cannot be retrieved via TypeDescriptor.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionNotAMethod">
            <summary>Expression is not a method call.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionTypeWithAssemblyName">
            <summary>In this ResolveType overload the type name should not contain the assembly name.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionDeclaringTypeExpected">
            <summary>DeclaringType of the provided member should not be null.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionSecuritySettingsConflict">
            <summary>This operation is not supported if the executing assembly specifies both the AllowPartiallyTrustedCallersAttribute and the SecurityRulesAttribute with SecurityRuleSet.Level2 (which is the default if not defined). You can try the following options:
            - Use the SecurityRulesAttribute with SecurityRuleSet.Level1. This is the recommended solution.
            - Use the SecurityRulesAttribute with SkipVerificationInFullTrust = true. If used with SecurityRuleSet.Level2 this will not solve the problem from a partially trusted domain though.
            - Remove the AllowPartiallyTrustedCallersAttribute. This will not allow partially trusted callers to use your assembly though.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionIndexerGenericNotSupported">
            <summary>Generic access of indexers with more than one index parameters is not supported. Use the non-generic Get/Set methods to access such indexers.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionParametersInvalid">
            <summary>The number or type of the specified parameters are invalid.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionMethodGenericNotSupported">
            <summary>Generic access of methods with more than four parameters or by reference arguments is not supported. Use the non-generic Invoke method to access such methods.</summary>
        </member>
        <member name="P:KGySoft.Res.ReflectionCtorGenericNotSupported">
            <summary>Generic access of constructors with more than four parameters or by reference arguments is not supported. Use the non-generic CreateInstance method to access such constructors.</summary>
        </member>
        <member name="P:KGySoft.Res.ResourcesInvalidResXReaderPropertyChange">
            <summary>Property can be changed only before the enumeration.</summary>
        </member>
        <member name="P:KGySoft.Res.ResourcesInvalidResXWriterPropertyChange">
            <summary>Property can be changed only before adding a row or generating any content.</summary>
        </member>
        <member name="P:KGySoft.Res.ResourcesWriterSaved">
            <summary>Resource writer has already been saved. You may not edit it.</summary>
        </member>
        <member name="P:KGySoft.Res.ResourcesHybridResSourceBinary">
            <summary>This operation is invalid when Source is CompiledOnly.</summary>
        </member>
        <member name="P:KGySoft.Res.ResourcesInvalidDrmPropertyChange">
            <summary>Setting this property is invalid when UseLanguageSettings is true.</summary>
        </member>
        <member name="P:KGySoft.Res.SerializationRootTypeExpected">
            <summary>Simple runtime element types or generic type definitions are expected.</summary>
        </member>
        <member name="P:KGySoft.Res.StreamExtensionsStreamCannotRead">
            <summary>Source stream cannot be read.</summary>
        </member>
        <member name="P:KGySoft.Res.StreamExtensionsStreamCannotWrite">
            <summary>Destination stream cannot be written.</summary>
        </member>
        <member name="P:KGySoft.Res.StringExtensionsSeparatorNullOrEmpty">
            <summary>Separator is null or empty.</summary>
        </member>
        <member name="P:KGySoft.Res.StringExtensionsSourceLengthNotEven">
            <summary>Source must consist of even amount of hex digits.</summary>
        </member>
        <member name="P:KGySoft.Res.StringSegmentNull">
            <summary>The string segment represents a null string.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationRootTypeMissing">
            <summary>Type of the root element is not specified.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationArrayNoLength">
            <summary>Array length or dimensions are not specified.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationCrcError">
            <summary>Corrupt array data: Bad CRC.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationMixedArrayFormats">
            <summary>Mixed compact and non-compact array content found.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationKeyValueMissingKey">
            <summary>Key element not found in key/value pair element.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationKeyValueMissingValue">
            <summary>Value element not found in key/value pair element.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationMultipleKeys">
            <summary>Multiple Key elements occurred in key-value element.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationMultipleValues">
            <summary>Multiple Value elements occurred in key-value element.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationUnexpectedEnd">
            <summary>Unexpected end of XML content.</summary>
        </member>
        <member name="P:KGySoft.Res.XmlSerializationBinarySerializerSafe">
            <summary>It is not allowed to deserialize a BinarySerializationFormatter content in safe mode.</summary>
        </member>
        <member name="M:KGySoft.Res.Initialize">
            <summary>
            Just an empty method to be able to trigger the static constructor without running any code other than field initializations.
            </summary>
        </member>
        <member name="M:KGySoft.Res.ArgumentMustBeGreaterThan``1(``0)">
            <summary>Specified argument must be greater than {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ArgumentMustBeGreaterThanOrEqualTo``1(``0)">
            <summary>Specified argument must be greater than or equal to {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ArgumentMustBeLessThan``1(``0)">
            <summary>Specified argument must be less than {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ArgumentMustBeLessThanOrEqualTo``1(``0)">
            <summary>Specified argument must be less than or equal to {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ArgumentMustBeBetween``1(``0,``0)">
            <summary>Specified argument must be between {0} and {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyNull(System.String)">
            <summary>Property '{0}' must not be null.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeGreaterThan``1(System.String,``0)">
            <summary>Property '{0}' must be greater than {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeGreaterThanOrEqualTo``1(System.String,``0)">
            <summary>Property '{0}' must be greater than or equal to {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeLessThan``1(System.String,``0)">
            <summary>Property '{0}' must be less than {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeLessThanOrEqualTo``1(System.String,``0)">
            <summary>Property '{0}' must be less than or equal to {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeBetween``1(System.String,``0,``0)">
            <summary>Property '{0}' must be between {1} and {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeGreaterThanProperty(System.String,System.String)">
            <summary>Property '{0}' must be greater than property '{1}'.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMustBeGreaterThanOrEqualToProperty(System.String,System.String)">
            <summary>Property '{0}' must be greater than or equal to property '{1}'.</summary>
        </member>
        <member name="M:KGySoft.Res.PropertyMessage(System.String,System.String)">
            <summary>Property '{0}': {1}</summary>
        </member>
        <member name="M:KGySoft.Res.EnumOutOfRangeWithValues``1(``0)">
            <summary>Enum instance of '{0}' type must be one of the following values: {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.FlagsEnumOutOfRangeWithValues``1(``0)">
            <summary>Enum instance of '{0}' type must consist of the following flags: {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.EnumOutOfRange``1(``0)">
            <summary>Enum instance of '{0}' type must be one of the defined values.</summary>
        </member>
        <member name="M:KGySoft.Res.FlagsEnumOutOfRange``1(``0)">
            <summary>Enum instance of '{0}' type must consist of the defined flags.</summary>
        </member>
        <member name="M:KGySoft.Res.NotAnInstanceOfType(System.Type)">
            <summary>Specified argument is expected to be an instance of type {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ValueContainsIllegalPathCharacters(System.String)">
            <summary>Value "{0}" contains illegal path characters.</summary>
        </member>
        <member name="M:KGySoft.Res.InvalidAsyncResult(System.String)">
            <summary>Either the IAsyncResult object did not come from the corresponding '{0}' method, or the End method was called multiple times with the same IAsyncResult.</summary>
        </member>
        <member name="M:KGySoft.Res.ICollectionNonGenericValueTypeInvalid(System.Object,System.Type)">
            <summary>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</summary>
        </member>
        <member name="M:KGySoft.Res.IDictionaryNonGenericKeyTypeInvalid(System.Object,System.Type)">
            <summary>The key "{0}" is not of type "{1}" and cannot be used in this generic collection.</summary>
        </member>
        <member name="M:KGySoft.Res.InternalError(System.String)">
            <summary>Internal Error: {0}</summary>
            <remarks>Use this method to avoid CA1303 for using string literals in internal errors that never supposed to occur.</remarks>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationNotSupported(System.Type,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>Serialization of type {0} is not supported with following serialization options: {1}.
            You can try to enable the RecursiveSerializationAsFallback flag, though the serialized data will possibly not be able to be deserialized using the SafeMode flag.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationIEnumerableExpected(System.Type)">
            <summary>An IEnumerable type expected but {0} found during deserialization.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationInvalidEnumBase(System.String)">
            <summary>Invalid enum base type: {0}. Serialization stream corrupted?</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotDeserializeObject(System.String)">
            <summary>Cannot deserialize as a standalone object: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationTypePlatformNotSupported(System.String)">
            <summary>Cannot deserialize type on this platform: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationObjectHierarchyChanged(System.Type)">
            <summary>Type "{0}" cannot be deserialized because its type hierarchy has been changed since serialization. Use IgnoreObjectChanges option to suppress this exception.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationGenericMethodNotFound(System.String,System.Type)">
            <summary>Generic method with signature "{0}" was not found in type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationMissingField(System.Type,System.String)">
            <summary>Type "{0}" cannot be deserialized because it has no field "{1}". To call the deserialization constructor implement the ISerializable interface. Use IgnoreObjectChanges option to suppress this exception.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationMissingFieldBase(System.Type,System.String,System.Type)">
            <summary>Type "{0}" cannot be deserialized because field "{1}" not found in type "{2}". Use IgnoreObjectChanges option to suppress this exception.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationMissingISerializableCtor(System.Type)">
            <summary>Type "{0}" does not have a special constructor to deserialize it as ISerializable</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationSurrogateChangedObject(System.Type)">
            <summary>The serialization surrogate has changed the reference of the result object, which prevented resolving circular references to itself. Object type: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotDecodeDataType(System.String)">
            <summary>Could not decode data type: {0}. Serialization stream corrupted?</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotDecodeCollectionType(System.String)">
            <summary>Could not decode collection type: {0}. Serialization stream corrupted?</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationReadOnlyCollectionNotSupported(System.String)">
            <summary>Creating read-only collection of type "{0}" is not supported. Serialization stream corrupted?</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotResolveAssemblySafe(System.String)">
            <summary>Cannot resolve assembly in safe mode: "{0}".
            You may try to preload the assembly before deserialization or to disable SafeMode if the serialization stream is from a trusted source.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotResolveType(System.String)">
            <summary>Could not resolve type name "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotResolveTypeInAssembly(System.String,System.String)">
            <summary>Could not resolve type "{0}" in assembly "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotResolveTypeInAssemblySafe(System.String,System.String)">
            <summary>Could not resolve type "{0}" in assembly "{1}".
            You may try to preload the assembly before deserialization or disable SafeMode if the serialization stream is from a trusted source.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationUnexpectedSerializationInfoElement(System.String)">
            <summary>Unexpected element in serialization info: {0}. Maybe the instance was not serialized by NameInvariantSurrogateSelector.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationObjectHierarchyChangedSurrogate(System.Type)">
            <summary>Object hierarchy has been changed since serialization of type "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationMissingFieldSurrogate(System.Type,System.Type)">
            <summary>Number of serializable fields in type "{0}" has been decreased since serialization so cannot deserialize type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationUnexpectedFieldType(System.Type,System.Object,System.Type,System.String)">
            <summary>Fields might have been reordered since serialization. Cannot deserialize type "{0}" because cannot assign value "{1}" to field "{2}.{3}".</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotCreateUninitializedObject(System.Type)">
            <summary>The current domain has insufficient permissions to create an empty instance of type "{0}" without a default constructor.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCannotCreateObjectSafe(System.Type)">
            <summary>In safe mode it is not supported to deserialize type "{0}". Maybe because it is not marked by the SerializableAttribute.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationNotBinarySerializable(System.Type)">
            <summary>Type '{0}' was serialized as an IBinarySerializable instance though it is not IBinarySerializable now.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationNotAValueType(System.Type)">
            <summary>Type '{0}' was serialized as a raw value type, though it is not a value type now.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationNotAnEnum(System.Type)">
            <summary>Type '{0}' was serialized as an enum type though it is not an enum now.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCircularIObjectReferenceCollection(System.Type)">
            <summary>Deserialization of an IObjectReference instance has an unresolvable circular reference to itself as an element in a collection of type '{0}'. Either try to use the ForceRecursiveSerializationOfSupportedTypes option on serialization, or avoid serializing circular references in the container object.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationCollectionPlatformNotSupported(System.String)">
            <summary>The stream contains a collection of type '{0}', which is not supported on this platform.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationValueTypeContainsReferences``1">
            <summary>Type '{0}' cannot be the type argument of this method because it contains references.</summary>
        </member>
        <member name="M:KGySoft.Res.BinarySerializationValueTypeContainsReferenceSafe(System.Type)">
            <summary>Value type '{0}' cannot be deserialized from raw data in safe mode because it contains references. If the serialization stream is from a trusted source you may try to disable safe mode to attempt the deserialization with marshaling.</summary>
        </member>
        <member name="M:KGySoft.Res.CacheStatistics(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>Cache&lt;{0}, {1}&gt; cache statistics:
            <br/>Count: {2}
            <br/>Capacity: {3}
            <br/>Number of writes: {4}
            <br/>Number of reads: {5}
            <br/>Number of cache hits: {6}
            <br/>Number of deletes: {7}
            <br/>Hit rate: {8:P2}</summary>
        </member>
        <member name="M:KGySoft.Res.CircularSortedListInvalidKeyValueType(System.Type)">
            <summary>Type of value should be either {0} or DictionaryEntry.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelInvalidProperty(System.ComponentModel.PropertyDescriptor,System.Type)">
            <summary>Property '{0}' of descriptor type '{1}' does not belong to type '{2}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelCannotAddNewFastBindingList(System.Type)">
            <summary>Cannot add new item to the binding list because type '{0}' cannot be constructed without parameters. Subscribe the AddingNew event or override the AddNewCore or OnAddingNew methods to create a new item to add.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelPropertyNotExists(System.String,System.Type)">
            <summary>No property descriptor found for property name '{0}' in type '{1}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelCannotAddNewObservableBindingList(System.Type)">
            <summary>Cannot add new item to the binding list because type '{0}' cannot be constructed without parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelMissingState(System.String)">
            <summary>The property binding command state does not contain the expected entry '{0}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelMissingEvent(System.String,System.Type)">
            <summary>There is no event '{0}' in type '{1}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelInvalidEvent(System.String)">
            <summary>Event '{0}' does not have regular event handler delegate type or accessors.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelCannotGetProperty(System.String)">
            <summary>Cannot get property '{0}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelCannotSetProperty(System.String)">
            <summary>Cannot set property '{0}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelReturnedTypeInvalid(System.Type)">
            <summary>The returned value is not compatible with type {0}</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelPropertyValueNotExist(System.String)">
            <summary>No value exists for property '{0}'.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelObservableObjectHasNoDefaultCtor(System.Type)">
            <summary>The type has no parameterless constructor and thus cannot be cloned: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelCannotCastCommandTarget(System.Object,System.Type)">
            <summary>Failed to cast the command target '{0}' to type {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.ComponentModelCannotCastCommandParam(System.Object,System.Type)">
            <summary>Failed to cast the command parameter '{0}' to type {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.EnumValueCannotBeParsedAsEnum(System.String,System.Type)">
            <summary>Value '{0}' cannot be parsed as enumeration type {1}</summary>
        </member>
        <member name="M:KGySoft.Res.ObjectExtensionsCannotConvertToType(System.Type)">
            <summary>The specified argument cannot be converted to type {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseDefaultName(System.Int32)">
            <summary>Case #{0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseName(System.String)">
            <summary>{0}: </summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestHeader(System.String)">
            <summary>==[{0} Results]================================================</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestIterations(System.Int32)">
            <summary>Iterations: {0:N0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestTestTime(System.Int32)">
            <summary>Test Time: {0:N0} ms</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestWarmingUp(System.Boolean)">
            <summary>Warming up: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestTestCases(System.Int32)">
            <summary>Test cases: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestRepeats(System.Int32)">
            <summary>Repeats: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCallingGcCollect(System.Boolean)">
            <summary>Calling GC.Collect: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCpuAffinity(System.Nullable{System.Int32})">
            <summary>Forced CPU Affinity: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestSortOfCases(System.String)">
            <summary>Cases are sorted by {0}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseAverageTime(System.Double)">
            <summary>average time: {0:N2} ms</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseOrder(System.Int32)">
            <summary>{0}. </summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestDifference(System.String,System.Double,System.String,System.Double)">
            <summary> ({0}{1:N2}{2} / {3:P2})</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseIterations(System.Int32,System.Double,System.Int32,System.Double)">
            <summary>{0:N0} iterations in {1:N2} ms. Adjusted for {2:N0} ms: {3:N2}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseRepetitionOrder(System.Int32,System.String)">
            <summary>  #{0,-2} {1}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseRepetitionTime(System.Double)">
            <summary>{0,13:N2} ms</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseRepetitionIterations(System.Int32,System.Double,System.Double)">
            <summary>{0:N0} iterations in {1:N2} ms. Adjusted: {2:N2}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestCaseError(System.Type,System.String)">
            <summary>{0}: {1}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestWorstBestDiffTime(System.Double,System.Double)">
            <summary>{0:N2} ms ({1:P2})</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestWorstBestDiffIteration(System.Double,System.Double)">
            <summary>{0:N2} ({1:P2})</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestResultSize(System.Int32,System.String)">
            <summary>  Result size: {0:N0} {1}</summary>
        </member>
        <member name="M:KGySoft.Res.PerformanceTestUnitPossiblePlural(System.String)">
            <summary>{0}(s)</summary>
        </member>
        <member name="M:KGySoft.Res.ProfilerMeasureItemToString(System.String,System.String,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.Int64)">
            <summary>[{0}]{1}: Average Time: {2}; Total Time: {4}; First Call: {3}; Number of Calls: {5:N0}</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotSetConstantField(System.Type,System.String)">
            <summary>The constant field cannot be set: {0}.{1}</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionNotSupportedMemberType(System.Reflection.MemberTypes)">
            <summary>Member type {0} is not supported.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionPropertyHasNoGetter(System.Type,System.String)">
            <summary>Property has no getter accessor: {0}.{1}</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionPropertyHasNoSetter(System.Type,System.String)">
            <summary>Property has no setter accessor: {0}.{1}</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionNotAType(System.String)">
            <summary>Value "{0}" cannot be resolved as a System.Type.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionPropertyNotFoundTypeDescriptor(System.String,System.Type)">
            <summary>Property "{0}" not found and cannot be set via TypeDescriptor on type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInstancePropertyDoesNotExist(System.String,System.Type)">
            <summary>No suitable instance property "{0}" found on type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionStaticPropertyDoesNotExist(System.String,System.Type)">
            <summary>No suitable static property "{0}" found on type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionIndexParamsLengthMismatch(System.Int32)">
            <summary>Expected number of array index arguments: {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionIndexerNotFound(System.Type)">
            <summary>No suitable indexer found on type "{0}" for the passed parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotGetPropertyTypeDescriptor(System.String,System.Type)">
            <summary>Property "{0}" not found and cannot be retrieved via TypeDescriptor on type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionTypeArgsLengthMismatch(System.Int32)">
            <summary>Expected number of generic parameters: {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInstanceMethodNotFound(System.String,System.Type)">
            <summary>No suitable instance method "{0}" found on type "{1}" for the given parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionStaticMethodNotFound(System.String,System.Type)">
            <summary>No suitable static method "{0}" found on type "{1}" for the given parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCtorNotFound(System.Type)">
            <summary>No suitable constructor found on type "{0}" for the given parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInstanceFieldDoesNotExist(System.String,System.Type)">
            <summary>Instance field "{0}" not found on type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionStaticFieldDoesNotExist(System.String,System.Type)">
            <summary>Static field "{0}" not found on type "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionNotAMember(System.Type)">
            <summary>No MemberInfo can be returned from expression type "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotLoadAssembly(System.String)">
            <summary>Failed to load assembly by name: "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotResolveAssembly(System.String)">
            <summary>Cannot resolve assembly: "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInvalidAssemblyName(System.String)">
            <summary>Assembly name is invalid: "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionPointerTypeNotSupported(System.Type)">
            <summary>Pointer type '{0}' is not supported.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionSetReadOnlyFieldNetStandard20(System.String,System.Type)">
            <summary>Setting read-only field '{0}' of type '{1}' is not supported by FieldAccessor in the .NET Standard 2.0 version of this library. If possible, try to use the .NET Standard 2.1 version or any .NET Core/Framework versions instead.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionSetStructFieldNetStandard20(System.String,System.Type)">
            <summary>Setting instance field '{0}' of value type '{1}' is not supported by FieldAccessor.Set in the .NET Standard 2.0 version of this library.
            If possible, try to use the generic SetInstanceValue method, or reference the .NET Standard 2.1 version or any .NET Core/Framework versions instead.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionSetStructPropertyNetStandard20(System.String,System.Type)">
            <summary>Setting instance property '{0}' of value type '{1}' is not supported by PropertyAccessor in the .NET Standard 2.0 version of this library. If possible, try to use the .NET Standard 2.1 version or any .NET Core/Framework versions instead.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionStaticPropertyExpectedGeneric(System.String,System.Type)">
            <summary>This method can be used to access static properties but {0}.{1} is an instance property.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInstancePropertyExpectedGeneric(System.String,System.Type)">
            <summary>This method can be used to access instance properties but {0}.{1} is a static property.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotInvokePropertyGeneric(System.String,System.Type)">
            <summary>Cannot access {0}.{1} property with the provided type arguments and/or parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionStaticFieldExpectedGeneric(System.String,System.Type)">
            <summary>This method can be used to access static fields but {0}.{1} is an instance field.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInstanceFieldExpectedGeneric(System.String,System.Type)">
            <summary>This method can be used to access instance fields but {0}.{1} is a static field.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotInvokeFieldGeneric(System.String,System.Type)">
            <summary>Cannot access {0}.{1} field with the provided type arguments and/or parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionStaticMethodExpectedGeneric(System.String,System.Type)">
            <summary>This method can be used to access static methods but {0}.{1} is an instance method.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionInstanceMethodExpectedGeneric(System.String,System.Type)">
            <summary>This method can be used to access instance methods but {0}.{1} is a static method.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotInvokeMethodGeneric(System.String,System.Type)">
            <summary>Cannot access {0}.{1} method with the provided type arguments and/or parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ReflectionCannotCreateInstanceGeneric(System.Type)">
            <summary>Cannot create an instance of type {0} with the provided type arguments and/or parameters.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesUnexpectedElementAt(System.String,System.Int32,System.Int32)">
            <summary>Unexpected element: "{0}" at line {1}, position {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesNeutralResourceFileNotFoundResX(System.String)">
            <summary>Resource file not found: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesNeutralResourceNotFoundCompiled(System.String,System.String)">
            <summary>Could not find any resources appropriate for the specified culture or the neutral culture. Make sure "{0}" was correctly embedded or linked into assembly "{1}" at compile time, or that all the satellite assemblies required are loadable and fully signed.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesNeutralResourceNotFoundHybrid(System.String,System.String,System.String)">
            <summary>Could not find any resources appropriate for the specified culture or the neutral culture. Make sure "{0}" was correctly embedded or linked into assembly "{1}" at compile time, or that all the satellite assemblies required are loadable and fully signed, or that XML resource file exists: {2}</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesNoResXName(System.Int32,System.Int32)">
            <summary>Cannot find a name for the resource at line {0}, position {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesMissingAttribute(System.String,System.Int32,System.Int32)">
            <summary>"{0}" attribute is missing at line {1}, position {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesHeaderMimeTypeNotSupported(System.String,System.Int32,System.Int32)">
            <summary>Unsupported ResX header mime type "{0}" at line {1}, position {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesMimeTypeNotSupported(System.String,System.Int32,System.Int32)">
            <summary>Unsupported mime type "{0}" at line {1}, position {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesResXReaderNotSupported(System.String,System.Int32,System.Int32)">
            <summary>Unsupported ResX reader "{0}" at line {1}, position {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesResXWriterNotSupported(System.String,System.Int32,System.Int32)">
            <summary>Unsupported ResX writer "{0}" at line {1}, position {2}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesTypeLoadExceptionAt(System.String,System.Int32,System.Int32)">
            <summary>Type "{0}" in the data at line {1}, position {2} cannot be resolved.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesTypeLoadExceptionSafeAt(System.String,System.Int32,System.Int32)">
            <summary>Type "{0}" in the data at line {1}, position {2} cannot be resolved.
            You may try to preload its assembly before deserialization or use the unsafe GetValue if the resource is from a trusted source.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesTypeLoadException(System.String)">
            <summary>Type "{0}" cannot be resolved.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesTypeLoadExceptionSafe(System.String)">
            <summary>Type "{0}" cannot be resolved using safe mode.
            You may try to preload its assembly before deserialization or use the unsafe GetValue if the resource is from a trusted source.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesNonStringResourceWithType(System.String,System.String)">
            <summary>Type of resource "{0}" is not string but "{1}" - enable SafeMode or use GetObject instead.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesNonStreamResourceWithType(System.String,System.Type)">
            <summary>Type of resource "{0}" is not MemoryStream but "{1}" - enable SafeMode or use GetObject instead.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesConvertFromStringNotSupportedAt(System.String,System.Int32,System.Int32,System.String)">
            <summary>Attempting to convert type "{0}" from string on line {1}, position {2} has failed: {3}</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesConvertFromStringNotSupported(System.Type)">
            <summary>Converting from string is not supported by {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesConvertFromByteArrayNotSupportedAt(System.String,System.Int32,System.Int32,System.String)">
            <summary>Attempting to convert type "{0}" from byte array on line {1}, position {2} has failed: {3}</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesConvertFromByteArrayNotSupported(System.Type)">
            <summary>Converting from byte array is not supported by {0}.</summary>
        </member>
        <member name="M:KGySoft.Res.ResourcesFileRefFileNotFound(System.String)">
            <summary>File in ResX file reference cannot be found: {0}. Is base path set correctly?</summary>
        </member>
        <member name="M:KGySoft.Res.SerializationMissingField(System.Type,System.String)">
            <summary>Type "{0}" cannot be deserialized because it has no field "{1}". Set IgnoreNonExistingFields to true to suppress this exception.</summary>
        </member>
        <member name="M:KGySoft.Res.SerializationPointerArrayTypeNotSupported(System.Type)">
            <summary>Array of pointer type '{0}' is not supported.</summary>
        </member>
        <member name="M:KGySoft.Res.SpanExtensionsCannotParseAsType(System.String,System.Type)">
            <summary>The specified span '{0}' cannot be parsed as type {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.StringExtensionsCannotParseAsType(System.String,System.Type)">
            <summary>The specified string '{0}' cannot be parsed as type {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationSerializingTypeNotSupported(System.Type,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>Serializing type "{0}" is not supported with following options: {1}. You may either use fallback options or provide a type converter for the type.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationRootObjectExpected(System.String)">
            <summary>Root named "object" expected but "{0}" found.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCannotResolveType(System.String)">
            <summary>Could not resolve type: "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCannotResolveTypeSafe(System.String)">
            <summary>Could not resolve type in safe mode: "{0}".
            In safe mode you have to preload the assembly of the type before deserialization, even if the type name is fully qualified.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationDeserializingTypeNotSupported(System.Type)">
            <summary>Deserializing type "{0}" is not supported.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationSerializingReadOnlyCollectionNotSupported(System.Type)">
            <summary>Content serialization of read-only collection type "{0}" is not supported because populating will not work at deserialization.
            If the collection has an initializer constructor, then using XmlSerializer.Serialize method overloads instead of SerializeContent can work.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationBinarySerializationFailed(System.Type,KGySoft.Serialization.Xml.XmlSerializationOptions,System.String)">
            <summary>Binary serialization of type "{0}" failed with options "{1}": {2}</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCannotSerializeCollection(System.Type,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>Cannot serialize collection "{0}" with following options: "{1}". You may either use fallback options or provide a type converter or apply DesignerSerializationVisibilityAttribute with value Content on the container collection property.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCannotSerializeUnsupportedCollection(System.Type,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>Serialization of collection "{0}" is not supported with following options: "{1}", because it does not implement IList, IDictionary or ICollection&lt;T&gt; interfaces and has no initializer constructor that can accept an array or list.
            To force the recursive serialization of the collection enable both RecursiveSerializationAsFallback and ForcedSerializationOfReadOnlyMembersAndCollections options; however, deserialization will likely fail in this case. Using BinarySerializationAsFallback option may also work.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationNotAnIXmlSerializable(System.Type)">
            <summary>Type "{0}" does not implement IXmlSerializable.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationNoDefaultCtor(System.Type)">
            <summary>Type "{0}" does not have a parameterless constructor so it can be (de-)serialized either as a root element by SerializeContent and DeserializeContent or as a public property/field value in a parent object if the member value is not null after creating the parent object.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationPropertyTypeMismatch(System.Type,System.String,System.Type,System.Type)">
            <summary>Property value of "{0}.{1}" is expected to be a type of "{2}" but was "{3}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCannotDeserializeReadOnlyCollection(System.Type)">
            <summary>Collection "{0}" is read-only so its content cannot be restored.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationSerializingNonPopulatableCollectionNotSupported(System.Type)">
            <summary>Content serialization of collection type "{0}" is not supported because it cannot be populated by standard interfaces.
            If the collection has an initializer constructor, then using XmlSerializer.Serialize method overloads instead of SerializeContent can work.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationPropertyHasNoSetter(System.String,System.Type)">
            <summary>Cannot restore property "{0}" in type "{1}" because it has no setter.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationPropertyHasNoSetterCantSetNull(System.String,System.Type)">
            <summary>Cannot set null to non-null property "{0}" in type "{1}" because it has no setter.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationPropertyHasNoSetterGetsNull(System.String,System.Type)">
            <summary>Cannot restore property "{0}" in type "{1}" because it has no setter and it returned null.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationItemExpected(System.String)">
            <summary>Collection item expected but "{0}" found.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCannotDetermineElementType(System.Type)">
            <summary>Could not determine type of element in collection "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationNotACollection(System.Type)">
            <summary>Type "{0}" is not a regular collection so items cannot be added to it.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationHasNoMember(System.Type,System.String)">
            <summary>Type "{0}" has no public property or field "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationNoContent(System.Type)">
            <summary>Serialized content of type "{0}" not found.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationInvalidArrayLength(System.String)">
            <summary>Invalid array length: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationInvalidArrayBounds(System.String)">
            <summary>Invalid array bounds: {0}</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationArraySizeMismatch(System.Type,System.Int32)">
            <summary>Cannot restore array "{0}" because size does not match. Expected length: "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationArrayRankMismatch(System.Type,System.Int32)">
            <summary>Cannot restore array "{0}" because rank does not match. Expected rank: "{1}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationArrayDimensionSizeMismatch(System.Type,System.Int32)">
            <summary>Cannot restore array "{0}" because length of the {1}. dimension does not match.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationArrayLowerBoundMismatch(System.Type,System.Int32)">
            <summary>Cannot restore array "{0}" because lower bound of the {1}. dimension does not match.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationInconsistentArrayLength(System.Int32,System.Int32)">
            <summary>Array items length mismatch. Expected items: {0}, found items: {1}.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCrcHexExpected(System.String)">
            <summary>The crc attribute should be a hex value but "{0}" found.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationUnexpectedElement(System.String)">
            <summary>Unexpected element: "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationInvalidEscapedContent(System.String)">
            <summary>Invalid escaped string content: "{0}".</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationCircularReference(System.Object)">
            <summary>Circular reference found during serialization. Object is already serialized: "{0}". To avoid circular references use DesignerSerializationVisibilityAttribute with Hidden value on members directly or indirectly reference themselves.</summary>
        </member>
        <member name="M:KGySoft.Res.XmlSerializationValueTypeContainsReferenceSafe(System.Type)">
            <summary>Value type '{0}' cannot be deserialized from raw data in safe mode because it contains references. If the XML data is from a trusted source you may try to use unsafe mode to attempt the deserialization with marshaling.</summary>
        </member>
        <member name="T:KGySoft.Resources.AutoSaveErrorEventArgs">
            <summary>
            Provides data for the <see cref="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError"/> event.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.AutoSaveErrorEventArgs.Exception">
            <summary>
            Gets the <see cref="T:System.Exception"/> instance that occurred on auto saving.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.DynamicResourceManager">
             <summary>
             Represents a resource manager that provides convenient access to culture-specific resources at run time.
             As it is derived from <see cref="T:KGySoft.Resources.HybridResourceManager"/>, it can handle both compiled resources from <c>.dll</c> and
             <c>.exe</c> files, and XML resources from <c>.resx</c> files at the same time. Based on the selected strategies when a resource
             is not found in a language it can automatically add the missing resource from a base culture or even create completely new resource sets
             and save them into <c>.resx</c> files. For text entries the untranslated elements will be marked so they can be found easily for translation.
             </summary>
             <remarks>
             <para><see cref="T:KGySoft.Resources.DynamicResourceManager"/> class is derived from <see cref="T:KGySoft.Resources.HybridResourceManager"/> and adds the functionality
             of automatic appending the resources with the non-translated and/or unknown entries as well as
             auto-saving the changes. This makes possible to automatically create the .resx files if the language
             of the application is changed to a language, which has no translation yet. See also the static <see cref="T:KGySoft.LanguageSettings"/> class.
             The strategy of auto appending and saving can be chosen by the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/>
             and <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> properties (see <see cref="T:KGySoft.Resources.AutoAppendOptions"/> and <see cref="T:KGySoft.Resources.AutoSaveOptions"/> enumerations).</para>
             <note type="tip">To see when to use the <see cref="T:KGySoft.Resources.ResXResourceReader"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, <see cref="T:KGySoft.Resources.ResXResourceSet"/>,
             <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
             classes see the documentation of the <see cref="N:KGySoft.Resources">KGySoft.Resources</see> namespace.</note>
             <para><see cref="T:KGySoft.Resources.DynamicResourceManager"/> combines the functionality of <see cref="T:System.Resources.ResourceManager"/>, <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/>
             and extends these with the feature of auto expansion. It can be an ideal choice to use it as a resource manager of an application or a class library
             because it gives you freedom (or to the consumer of your library) to choose the strategy. If <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> and <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> functionalities
             are completely disabled, then it is equivalent to a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, which can handle resources both from compiled and XML sources but you must
             explicitly add new content and save it (see the example of the <see cref="T:KGySoft.Resources.HybridResourceManager"/> base class).
             If you restrict even the source of the resources, then you can get the functionality of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class (<see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.ResXOnly"/>),
             or the <see cref="T:System.Resources.ResourceManager"/> class (<see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>).</para>
             <h2>Additional features compared to <see cref="T:KGySoft.Resources.HybridResourceManager"/></h2>
             <para><strong>Centralized vs. individual settings</strong>:
             <br/>The behavior of <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances can be controlled in two ways, which can be configured by the <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> property.
             <list type="bullet">
             <item><term>Individual control</term>
             <description>If <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="false"/>, which is the default value, then the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> behavior is simply determined by its own properties.
             This can be alright for short-living <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances (for example, in a <see langword="using"/> block), or when you are sure you don't want let the
             consumers of your library to customize the settings of resource managers.</description></item>
             <item><term>Centralized control</term>
             <description>If you use the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class as the resource manager of a class library, you might want to let the consumers of your library to control
             how <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances should behave. For example, maybe one consumer wants to allow generating new .resx language files by using custom <see cref="T:KGySoft.Resources.AutoAppendOptions"/>,
             and another one does not want to let generating .resx files at all. If <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>, then <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/>, <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> and <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/>
             properties will be taken from the static <see cref="T:KGySoft.LanguageSettings"/> class (see <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend">LanguageSettings.DynamicResourceManagersAutoAppend</see>,
             <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave">LanguageSettings.DynamicResourceManagersAutoSave</see> and <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">LanguageSettings.DynamicResourceManagersSource</see>
             properties, respectively). This makes possible to control the behavior of <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances, which enable centralized settings,
             without exposing these manager instances of our class library to the public. See also the example at the <a href="#recommendation">Recommended usage for string resources in a class library</a> section.</description></item>
             </list>
             <note>
             <list type="bullet">
             <item>Unlike the <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> property, <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">LanguageSettings.DynamicResourceManagersSource</see> property is
             <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/> by default, ensuring that centralized <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances work the same way as regular <see cref="T:System.Resources.ResourceManager"/>
             classes by default, so the application can opt-in dynamic creation of .resx files, for example in its <c>Main</c> method.</item>
             <item>Turning on the <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> property makes the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> to subscribe multiple events. If such a <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
             is used in a non-static or short-living context make sure to dispose it to prevent leaking resources.</item>
             </list></note></para>
             <para><strong>Auto Appending</strong>:
             <br/>The automatic expansion of the resources can be controlled by the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property (or by <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend">LanguageSettings.DynamicResourceManagersAutoAppend</see>,
             property, if <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>), and it covers three different strategies, which can be combined:
             <list type="number">
             <item><term>Unknown resources</term>
             <description>If <see cref="F:KGySoft.Resources.AutoAppendOptions.AddUnknownToInvariantCulture"/> option is enabled and an unknown resource is requested, then the resource set
             of the invariant culture will be appended by the newly requested resource. It also means that <see cref="T:System.Resources.MissingManifestResourceException"/> will never be thrown,
             even if <see cref="P:KGySoft.Resources.HybridResourceManager.ThrowException"/> property is <see langword="true"/>. If the unknown resource is requested by <see cref="O:KGySoft.Resources.DynamicResourceManager.GetString">GetString</see>
             methods, then the value of the requested name will be the name itself prefixed by the <see cref="P:KGySoft.LanguageSettings.UnknownResourcePrefix">LanguageSettings.UnknownResourcePrefix</see> property.
             On the other hand, if the unknown resource is requested by the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> methods, then a <see langword="null"/> value will be added.
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.Resources;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     var manager = new DynamicResourceManager(typeof(Example));
                     manager.AutoAppend = AutoAppendOptions.AddUnknownToInvariantCulture;
            
                     // Without the option above the following line would throw a MissingManifestResourceException
                     Console.WriteLine(manager.GetString("UnknownString")); // prints [U]UnknownString
                     Console.WriteLine(manager.GetObject("UnknownObject")); // prints empty line
            
                     manager.SaveAllResources(compatibleFormat: false);
                 }
             }]]></code>
             The example above creates a <c>Resources\Example.resx</c> file under the binary output folder of the console application
             with the following content:
             <code lang="XML"><![CDATA[
             <?xml version="1.0"?>
             <root>
               <data name="UnknownString">
                 <value>[U]UnknownString</value>
               </data>
               <assembly alias="KGySoft.CoreLibraries" name="KGySoft.CoreLibraries, Version=3.6.3.1, Culture=neutral, PublicKeyToken=b45eba277439ddfe" />
               <data name="UnknownObject" type="KGySoft.Resources.ResXNullRef, KGySoft.Libraries">
                 <value />
               </data>
             </root>]]></code></description></item>
             <item><term>Appending neutral and specific cultures</term>
             <description>The previous section was about expanding the resource file of the invariant culture represented by the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
             Every other <see cref="T:System.Globalization.CultureInfo"/> instance can be classified as either a neutral or specific culture. Neutral cultures are region independent (eg. <c>en</c> is the English culture in general), whereas
             specific cultures are related to a specific region (eg. <c>en-US</c> is the American English culture). The parent of a specific culture can be another specific or a neutral one, and the parent
             of a neutral culture can be another neutral or the invariant culture. In most cases there is one specific and one neutral culture in a full chain, for example:
             <br/><c>en-US (specific) -> en (neutral) -> Invariant</c>
             <br/>But sometimes there can be more neutral cultures:
             <br/><c>ku-Arab-IR (specific) -> ku-Arab (neutral) -> ku (neutral) -> Invariant</c>
             <br/>Or more specific cultures:
             <br/><c>ca-ES-valencia (specific) -> ca-es (specific) -> ca (neutral) -> Invariant</c>
             <br/> There are two groups of options, which control where the untranslated resources should be merged from and to:
             <list type="number">
             <item><see cref="F:KGySoft.Resources.AutoAppendOptions.AppendFirstNeutralCulture"/>, <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendLastNeutralCulture"/> and <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendNeutralCultures"/> options
             will append the neutral cultures (eg. <c>en</c>) if a requested resource is found in the invariant culture.</item>
             <item><see cref="F:KGySoft.Resources.AutoAppendOptions.AppendFirstSpecificCulture"/> and <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendSpecificCultures"/> options
             will append the specific cultures (eg. <c>en-US</c>) if a requested resource is found in any parent culture. <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendLastSpecificCulture"/> does the same,
             except that the found resource must be in the resource set of a non-specific culture..</item>
             </list>
             If the merged resource is a <see cref="T:System.String"/>, then the value of the existing resource will be prefixed by the
             <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property, and
             this prefixed string will be saved in the target resource; otherwise, the original value will be duplicated in the target resource.
             <note>"First" and "last" terms above refer the first and last neutral/specific cultures in the order from
             most specific to least specific one as in the examples above. See the descriptions of the referred <see cref="T:KGySoft.Resources.AutoAppendOptions"/> options for more details and for examples
             with a fully artificial culture hierarchy with multiple neutral and specific cultures.</note>
             <code lang="C#"><![CDATA[
             using System;
             using System.Globalization;
             using KGySoft;
             using KGySoft.Resources;
            
             class Example
             {
                 private static CultureInfo enUS = CultureInfo.GetCultureInfo("en-US");
                 private static CultureInfo en = enUS.Parent;
                 private static CultureInfo inv = en.Parent;
            
                 static void Main(string[] args)
                 {
                     var manager = new DynamicResourceManager(typeof(Example));
            
                     // this will cause to copy the non-existing entries from invariant to "en"
                     manager.AutoAppend = AutoAppendOptions.AppendFirstNeutralCulture;
            
                     // preparation
                     manager.SetObject("TestString", "Test string in invariant culture", inv);
                     manager.SetObject("TestString", "Test string in English culture", en);
                     manager.SetObject("TestString2", "Another test string in invariant culture", inv);
                     manager.SetObject("TestObject", 42, inv);
                     manager.SetObject("DontCareObject", new byte[0], inv);
            
                     // setting the UI culture so we do not need to specify the culture in GetString/Object
                     LanguageSettings.DisplayLanguage = enUS;
            
                     Console.WriteLine(manager.GetString("TestString")); // already exists in en
                     Console.WriteLine(manager.GetString("TestString2")); // copied to en with prefix
                     Console.WriteLine(manager.GetObject("TestObject")); // copied to en
                     // Console.WriteLine(manager.GetObject("DontCareObject")); // not copied because not accessed
            
                     // saving the changes
                     manager.SaveAllResources(compatibleFormat: false);
                 }
             }]]></code>
             The example above creates the <c>Example.resx</c> and <c>Example.en.resx</c> files.
             No <c>Example.en-US.resx</c> is created because we chose appending the first neutral culture only. The content of <c>Example.en.resx</c> will be the following:
             <code lang="XML"><![CDATA[
             <?xml version="1.0"?>
             <root>
               <data name="TestString">
                 <value>Test string in English culture</value>
               </data>
               <data name="TestString2">
                 <value>[T]Another test string in invariant culture</value>
               </data>
               <data name="TestObject" type="System.Int32">
                 <value>42</value>
               </data>
             </root>]]></code>
             By looking for '<c>[T]</c>' occurrences we can easily find the merged strings to translate.</description></item>
             <item><term>Merging complete resource sets</term>
             <description>The example above demonstrates how the untranslated entries will be applied to the target language files. However, in that example only the
             actually requested entries will be copied on demand. It is possible that we want to generate a full language file in order to be able to make complete translations.
             If that is what we need we can use the <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/> option. This option should be used together with at least one of the options from
             the previous point to have any effect.
             <code lang="C#"><![CDATA[
             using System;
             using System.Globalization;
             using System.Resources;
             using KGySoft;
             using KGySoft.Resources;
            
             // we can tell what the language of the invariant resource is
             [assembly: NeutralResourcesLanguage("en")]
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     var manager = new DynamicResourceManager(typeof(Example));
            
                     // actually this is the default option:
                     manager.AutoAppend = AutoAppendOptions.AppendFirstNeutralCulture | AutoAppendOptions.AppendOnLoad;
            
                     // we prepare only the invariant resource
                     manager.SetObject("TestString", "Test string", CultureInfo.InvariantCulture);
                     manager.SetObject("TestString2", "Another test string", CultureInfo.InvariantCulture);
                     manager.SetObject("TestObject", 42, CultureInfo.InvariantCulture);
                     manager.SetObject("AnotherObject", new byte[0], CultureInfo.InvariantCulture);
            
                     // Getting an English resource will not create the en.resx file because this is
                     // the default language of our application thanks to the NeutralResourcesLanguage attribute
                     LanguageSettings.DisplayLanguage = CultureInfo.GetCultureInfo("en-US");
                     Console.WriteLine(manager.GetString("TestString")); // Displays "Test string", no resource is created
            
                     LanguageSettings.DisplayLanguage = CultureInfo.GetCultureInfo("fr-FR");
                     Console.WriteLine(manager.GetString("TestString")); // Displays "[T]Test string", resource "fr" is created
            
                     // saving the changes
                     manager.SaveAllResources(compatibleFormat: false);
                 }
             }]]></code>
             The example above creates <c>Example.resx</c> and <c>Example.fr.resx</c> files. Please note that no <c>Example.en.resx</c> is created because
             the <see cref="T:System.Resources.NeutralResourcesLanguageAttribute"/> indicates that the language of the invariant resource is English. If we open the
             created <c>Example.fr.resx</c> file we can see that every resource was copied from the invariant resource even though we accessed a single item:
             <code lang="XML"><![CDATA[
             <?xml version="1.0"?>
             <root>
               <data name="TestString">
                 <value>[T]Test string</value>
               </data>
               <data name="TestString2">
                 <value>[T]Another test string</value>
               </data>
               <data name="TestObject" type="System.Int32">
                 <value>42</value>
               </data>
               <data name="AnotherObject" type="System.Byte[]">
                 <value />
               </data>
             </root>]]></code></description></item>
             </list>
             <note>Please note that auto appending affects resources only. Metadata are never merged.</note>
             </para>
             <para><strong>Auto Saving</strong>:
             <br/>By setting the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> property (or <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave">LanguageSettings.DynamicResourceManagersAutoSave</see>,
             if <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>), the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is able to save the dynamically created content automatically on specific events:
             <list type="bullet">
             <item><term>Changing the display language</term>
             <description>If <see cref="F:KGySoft.Resources.AutoSaveOptions.LanguageChange"/> option is enabled the changes are saved whenever the current UI culture is set via the
             <see cref="P:KGySoft.LanguageSettings.DisplayLanguage">LanguageSettings.DisplayLanguage</see> property.
             <note>Enabling this option makes the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> to subscribe to the static <see cref="E:KGySoft.LanguageSettings.DisplayLanguageChanged">LanguageSettings.DisplayLanguageChanged</see>
             event. To prevent leaking resources make sure to dispose the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> if it is used in a non-static or short-living context.</note>
             </description></item>
             <item><term>Application exit</term>
             <description>If <see cref="F:KGySoft.Resources.AutoSaveOptions.DomainUnload"/> option is enabled the changes are saved when current <see cref="T:System.AppDomain"/> is being unloaded, including the case when
             the application exits.
             <note>Enabling this option makes the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> to subscribe to the <see cref="E:System.AppDomain.ProcessExit">AppDomain.ProcessExit</see>
             or <see cref="E:System.AppDomain.DomainUnload">AppDomain.DomainUnload</see> event. To prevent leaking resources make sure to dispose the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> if it is used in a non-static or short-living context.
             However, to utilize saving changes on application exit or domain unload, <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is best to be used in a static context.</note>
             </description></item>
             <item><term>Changing resource source</term>
             <description>If <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> property changes it may cause data loss in terms of unsaved changes. To prevent this <see cref="F:KGySoft.Resources.AutoSaveOptions.SourceChange"/> option can be enabled
             so the changes will be saved before actualizing the new value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> property.</description></item>
             <item><term>Disposing</term>
             <description>Enabling the <see cref="F:KGySoft.Resources.AutoSaveOptions.Dispose"/> option makes possible to save changes automatically when the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is being disposed.
             <code lang="C#"><![CDATA[
             using System.Globalization;
             using KGySoft.Resources;
            
             class Example
             {
                 static void Main(string[] args)
                 {
                     // thanks to the AutoSave = Dispose the Example.resx will be created at the end of the using block
                     using (var manager = new DynamicResourceManager(typeof(Example)) { AutoSave = AutoSaveOptions.Dispose })
                     {
                         manager.SetObject("Test string", "Test value", CultureInfo.InvariantCulture);
                     }
                 }
             }]]></code></description></item></list></para>
             <para>Considering <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> is indirectly called on auto save, you cannot set its parameters directly.
             However, by setting the <see cref="P:KGySoft.Resources.DynamicResourceManager.CompatibleFormat"/> property, you can tell whether the result .resx files should be able to be read by a
             <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
             and the Visual Studio Resource Editor. If it is <see langword="false"/> the result .resx files are often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
             but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class.</para>
             <para>Normally, if you save the changes by the <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method, you can handle the possible exceptions locally.
             To handle errors occurred during auto save you can subscribe the <see cref="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError"/> event.</para>
             <h2>Recommended usage for string resources in a class library<a name="recommendation">&#160;</a></h2>
             <para>A class library can be used by any consumers who want to use the features of that library. If it contains resources it can be useful if we allow the consumer
             of our class library to create translations for it in any language. In an application it can be the decision of the consumer whether generating new XML resource (.resx) files
             should be allowed or not. If so, we must be prepared for invalid files or malicious content (for example, the .resx file can contain serialized data of any type, whose constructor
             can run any code when deserialized). The following example takes all of these aspects into consideration.
             <note>In the following example there is a single compiled resource created in a class library, without any satellite assemblies. The additional language files
             can be generated at run-time if the consumer application allows it. </note>
             <list type="number">
             <item>
             Create a new project (Class Library)
             <br/><img src="../Help/Images/NewClassLibrary.png" alt="New class library"/></item>
             <item>Delete the automatically created <c>Class1.cs</c></item>
             <item>Create a new class: <c>Res</c>. The class will be <see langword="static"/> and <see langword="internal"/>, and it will contain the resource manager for
             this class library. The initial content of the file will be the following:
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft;
             using KGySoft.Resources;
             
             namespace ClassLibrary1
             {
                 internal static class Res
                 {
                     // internal resources for errors
                     private const string unavailableResource = "Resource ID not found: {0}";
                     private const string invalidResource = "Resource text is not valid for {0} arguments: {1}";
             
                     private static readonly DynamicResourceManager resourceManager =
                         // the name of the compiled resources must match (see also point 5)
                         new DynamicResourceManager("ClassLibrary1.Messages", typeof(Res).Assembly)
                         {
                             SafeMode = true,
                             UseLanguageSettings = true,
                             ThrowException = false,
                             // CompatibleFormat = true // use this if you want to edit the result files with VS resource editor
                         };
             
                     // Here will be the properties for the resources. This one is private because used from this class.
                     private static string NullReference => Get(nameof(NullReference));
             
                     // [...] Your resources can be added here (see point 8. and 9.)
             
                     private static string Get(string id) =>
                         resourceManager.GetString(id, LanguageSettings.DisplayLanguage) ?? String.Format(unavailableResource, id);
             
                     private static string Get(string id, params object[] args)
                     {
                         string format = Get(id);
                         return args == null || args.Length == 0 ? format : SafeFormat(format, args);
                     }
             
                     private static string SafeFormat(string format, object[] args)
                     {
                         try
                         {
                             int i = Array.IndexOf(args, null);
                             if (i >= 0)
                             {
                                 string nullRef = Get(NullReference);
                                 for (; i < args.Length; i++)
                                 {
                                     if (args[i] == null)
                                         args[i] = nullRef;
                                 }
                             }
             
                             return String.Format(LanguageSettings.FormattingLanguage, format, args);
                         }
                         catch (FormatException)
                         {
                             return String.Format(invalidResource, args.Length, format);
                         }
                     }
                 }
             }]]></code></item>
             <item>In Solution Explorer right click on <c>ClassLibrary1</c>, then select Add, New Item, Resources File.
             <br/><img src="../Help/Images/NewResourcesFile.png" alt="New Resources file"/></item>
             <item>To make sure the compiled name of the resource is what you want (it must match the name in the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> constructor)
             you can edit the .csproj file as follows:
             <list type="bullet">
             <item>In Solution Explorer right click on <c>ClassLibrary1</c>, Unload Project</item>
             <item>In Solution Explorer right click on <c>ClassLibrary1 (unavailable)</c>, Edit ClassLibrary1.csproj</item>
             <item>Search for the <c>EmbeddedResource</c> element and edit it as follows (or in case of a .NET Core project add it if it does not exist):
             <code lang="XML"><![CDATA[
             <!-- .NET Framework project: -->
             <EmbeddedResource Include="Resource1.resx" >
               <LogicalName>ClassLibrary1.Messages.resources</LogicalName>
             </EmbeddedResource>
            
             <!-- .NET Core project (note "Update" in place of "Include"): -->
             <EmbeddedResource Update="Resource1.resx" >
               <LogicalName>ClassLibrary1.Messages.resources</LogicalName>
             </EmbeddedResource>]]></code></item>
             <item>In Solution Explorer right click on <c>ClassLibrary1 (unavailable)</c>, Reload ClassLibrary1.csproj</item>
             </list>
             </item>
             <item>In Solution Explorer right click on the new resource file (<c>Resource1.resx</c>) and select Properties</item>
             <item>Clear the default <c>Custom Tool</c> value because the generated file uses a <see cref="T:System.Resources.ResourceManager"/> class internally, which cannot handle the dynamic expansions.
             It means also, that instead of the generated <c>Resources</c> class we will use our <c>Res</c> class.
             Leave the <c>Build Action</c> so its value is <c>Embedded Resource</c>, which means that the resource will be compiled into the assembly.
             The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> will use these compiled resources as default values. If the consumer application of our class library sets the
             <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">LanguageSettings.DynamicResourceManagersSource</see> property to <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/>,
             then for the different languages the .resx files will be automatically created containing the resource set of our class library, ready to translate.
             <br/><img src="../Help/Images/ResourceFileProperties_DynamicResourceManager.png" alt="Resources1.resx properties"/></item>
             <item>In Solution Explorer double click on <c>Resource1.resx</c> and add any resource entries you want to use in your library.
             Add <c>NullReference</c> key as well as it is used by the default <c>Res</c> implementation.
             <br/><img src="../Help/Images/DynamicResourceManager_ExampleResources.png" alt="Example resources"/></item>
             <item>Define a property for all of your simple resources and a method for the format strings with placeholders in the <c>Res</c> class. For example:
             <code lang="C#"><![CDATA[
             // simple resource: can be a property
             internal static string MyResourceExample => Get(nameof(MyResourceExample));
             
             // resource format string with placeholders: can be a method
             internal static string MyResourceFormatExample(int arg1, string arg2) => Get(nameof(MyResourceFormatExample), arg1, arg2);]]></code></item>
             <item>You can retrieve any resources in your library as it is shown in the example below:
             <code lang="C#"><![CDATA[
             using System;
            
             namespace ClassLibrary1
             {
                 public class Example
                 {
                     public void SomeMethod(int someParameter)
                     {
                         if (someParameter == 42)
                             // simple resource
                             throw new InvalidOperationException(Res.MyResourceExample);
                         if (someParameter == -42)
                             // formatted resource - enough arguments must be specified for placeholders (though errors are handled in Res)
                             throw new Throw.ArgumentException(Res.MyResourceFormatExample(123, "x"), nameof(someParameter));
                     }
                 }
             }]]></code></item>
             <item>To indicate the language of your default compiled resource open the <c>AssemblyInfo.cs</c> of your project and add the following line:
             <code lang="C#"><![CDATA[
             // this informs the resource manager about the language of the default culture
             [assembly:NeutralResourcesLanguage("en")]]]></code></item>
             <item>Now a consumer application can enable dynamic resource creation for new languages. Create a new console application, add reference to <c>ClassLibrary1</c> project
             and edit the <c>Program.cs</c> file as follows:
             <code lang="C#"><![CDATA[
             using System;
             using System.Globalization;
             using ClassLibrary1;
             using KGySoft;
             using KGySoft.Resources;
            
             namespace ConsoleApp1
             {
                 class Program
                 {
                     static void Main(string[] args)
                     {
                         // Enabling dynamic .resx creation for all DynamicResourceManager instances in this application,
                         // which are configured to use centralized settings
                         LanguageSettings.DynamicResourceManagersSource = ResourceManagerSources.CompiledAndResX;
            
                         // Setting the language of the application
                         LanguageSettings.DisplayLanguage = CultureInfo.GetCultureInfo("fr-FR");
            
                         LaunchMyApplication();
                     }
            
                     private static void LaunchMyApplication()
                     {
                         // if we use anything that has a reference to the Res class in ClassLibrary1, then
                         // a .resx file with the language of the application will be used or created if not exists yet.
                         var example = new Example();
                         try
                         {
                             example.SomeMethod(42);
                         }
                         catch (Exception e)
                         {
                             Console.WriteLine($"{e.GetType().Name}: {e.Message}");
                         }
                     }
                 }
             }]]></code>
             When the console application above exits, it creates a <c>Resources\ClassLibrary1.Messages.fr.resx</c> file with the following content:
             <code lang="XML"><![CDATA[
             <?xml version="1.0"?>
             <root>
               <data name="NullReference">
                 <value>[T]&lt;null&gt;</value>
               </data>
               <data name="MyResourceExample">
                 <value>[T]This is a resource value will be used in my library</value>
               </data>
               <data name="MyResourceFormatExample">
                 <value>[T]This is a resource format string with two placeholders: {0}, {1}</value>
               </data>
             </root>]]></code>
             By looking for the '<c>[T]</c>' prefixes you can easily find the untranslated elements.</item></list></para>
             <note type="tip"><list type="bullet">
             <item>You can use the <see cref="M:KGySoft.Resources.DynamicResourceManager.EnsureResourcesGenerated(System.Globalization.CultureInfo)">EnsureResourcesGenerated</see> method to create possible non-existing resources for a language.</item>
             <item>You can use the <see cref="M:KGySoft.Resources.DynamicResourceManager.EnsureInvariantResourcesMerged(System.Globalization.CultureInfo)">EnsureInvariantResourcesMerged</see> method to forcibly merge all resource entries in the invariant
             resource set for a language. This can be useful if new resources have been introduced since a previous version and the newly introduced entries also have to be added to the localized resource sets.</item>
             <item>To see how to use dynamically created resources for any language in a live application with editing support see
             the <a href="https://github.com/koszeggy/KGySoft.Drawing.Tools" target="_blank">KGySoft.Drawing.Tools</a> GitHub repository.</item>
             </list></note>
             </remarks>
        </member>
        <member name="F:KGySoft.Resources.DynamicResourceManager.mergedCultures">
            <summary>
            If <see cref="F:KGySoft.Resources.DynamicResourceManager.autoAppend"/> contains <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/> flag,
            contains the up-to-date cultures. Value is <see langword="true"/> if that culture is merged so it can be taken as a base for merge.
            </summary>
        </member>
        <member name="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError">
            <summary>
            Occurs when an exception is thrown on auto saving. If this event is not subscribed, the following exception types are automatically suppressed,
            as they can occur on save: <see cref="T:System.IO.IOException"/>, <see cref="T:System.Security.SecurityException"/>, <see cref="T:System.UnauthorizedAccessException"/>. If such an
            exception is suppressed some resources might remain unsaved. Though the event is a static one, the sender of the handler is the corresponding <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instance.
            Thus the save failures of the non public <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instances (eg. resource managers of an assembly) can be tracked, too.
            </summary>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/>
        </member>
        <member name="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings">
            <summary>
            Gets or sets whether values of <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/>, <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> and <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> properties
            are taken centrally from the <see cref="T:KGySoft.LanguageSettings"/> class.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave"/>
            <remarks><note>For examples see the <em>Centralized vs. individual settings</em> and <em>Recommended usage for string resources in a class library</em>
            sections at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></remarks>
        </member>
        <member name="P:KGySoft.Resources.DynamicResourceManager.AutoSave">
            <summary>
            When <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="false"/>,
            gets or sets the auto saving options.
            When <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>,
            auto saving is controlled by <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave">LanguageSettings.DynamicResourceManagersAutoSave</see> property.
            <br/>Default value: <see cref="F:KGySoft.Resources.AutoSaveOptions.None"/>
            </summary>
            <seealso cref="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError"/>
            <exception cref="T:System.InvalidOperationException">The property is set and <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.</exception>
            <remarks>The default value of this property is <see cref="F:KGySoft.Resources.AutoSaveOptions.None"/>. Though, if <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>,
            the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave">LanguageSettings.DynamicResourceManagersAutoSave</see> property is used, whose default value is
            <see cref="F:KGySoft.Resources.AutoSaveOptions.LanguageChange"/>, <see cref="F:KGySoft.Resources.AutoSaveOptions.DomainUnload"/>, <see cref="F:KGySoft.Resources.AutoSaveOptions.SourceChange"/>.
            <note>For more details see the <em>Auto Saving</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></remarks>
        </member>
        <member name="P:KGySoft.Resources.DynamicResourceManager.AutoAppend">
            <summary>
            When <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="false"/>,
            gets or sets the resource auto append options.
            When <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>,
            auto appending of resources is controlled by <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend">LanguageSettings.DynamicResourceManagersAutoAppend</see> property.
            <br/>
            Default value: <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendFirstNeutralCulture"/>, <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">The property is set and <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.</exception>
            <remarks>
            <para>Auto appending affects the resources only. Metadata are never merged.</para>
            <para>Auto appending options are ignored if <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/></para>
            <para><note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></para>
            </remarks>
            <seealso cref="T:KGySoft.Resources.AutoAppendOptions"/>
        </member>
        <member name="P:KGySoft.Resources.DynamicResourceManager.Source">
            <summary>
            When <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="false"/>,
            gets or sets the source, from which the resources should be taken.
            When <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>,
            the source is controlled by <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">LanguageSettings.DynamicResourceManagersSource</see> property.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/>
            </summary>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/>
            <exception cref="T:System.InvalidOperationException">The property is set and <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>.</exception>
            <remarks>The default value of this property is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/>. Though, if <see cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/> is <see langword="true"/>,
            the <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">LanguageSettings.DynamicResourceManagersSource</see> property is used, whose default value is
            <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</remarks>
        </member>
        <member name="P:KGySoft.Resources.DynamicResourceManager.CompatibleFormat">
            <summary>
            Gets or sets whether the .resx files should use a compatible format when the resources are automatically saved.
            <br/>Default value: <see langword="false"/>
            </summary>
            <remarks>
            <para>The changes can be always saved by the <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method, where compatible format
            can be explicitly requested. This property affects the result of auto saving controlled by the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> property.</para>
            <para>If <see cref="P:KGySoft.Resources.DynamicResourceManager.CompatibleFormat"/> is <see langword="true"/> the result .resx files can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>
            instance and the Visual Studio Resource Editor. If it is <see langword="false"/>, the result .resx files are often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.#ctor(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class that looks up resources in
            compiled assemblies and resource XML files based on information from the specified <paramref name="baseName"/>
            and <paramref name="assembly"/>.
            </summary>
            <param name="baseName">A root name that is the prefix of the resource files without the extension.</param>
            <param name="assembly">The main assembly for the resources.</param>
            <param name="explicitResXBaseFileName">When <see langword="null"/> the .resx file name will be constructed based on the
            <paramref name="baseName"/> parameter; otherwise, the given <see cref="T:System.String"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.#ctor(System.Type,System.String)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class that looks up resources in
            compiled assemblies and resource XML files based on information from the specified <see cref="T:System.Type"/> object.
            </summary>
            <param name="resourceSource">A type from which the resource manager derives all information for finding resource files.</param>
            <param name="explicitResXBaseFileName">When <see langword="null"/> the .resx file name will be constructed based on the
            <paramref name="resourceSource"/> parameter; otherwise, the given <see cref="T:System.String"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Gets the value of the specified resource localized for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <param name="culture">The culture for which the resource is localized. If the resource is not localized for this culture,
            the resource manager uses fallback rules to locate an appropriate resource. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:KGySoft.LanguageSettings.DisplayLanguage" /> property.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, and the resource is from a .resx content, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, dynamic expansion of the resource sets of different cultures may occur when calling this method.</para>
            <para><note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetObject(System.String)">
            <summary>
            Returns the value of the specified resource.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, and the resource is from a .resx content, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, dynamic expansion of the resource sets of different cultures may occur when calling this method.</para>
            <para><note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string resource localized for the specified culture.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized.</param>
            <returns>
            The value of the resource localized for the specified culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then instead of throwing an <see cref="T:System.InvalidOperationException"/>
            either the raw XML value (for resources from a .resx source) or the string representation of the object (for resources from a compiled source) will be returned for non-string resources.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, dynamic expansion of the resource sets of different cultures may occur when calling this method.
            In this case the result will be prefixed either by <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see>
            or <see cref="P:KGySoft.LanguageSettings.UnknownResourcePrefix">LanguageSettings.UnknownResourcePrefix</see>.
            <note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note>
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/>  and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetString(System.String)">
            <summary>
            Returns the value of the specified string resource.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <returns>
            The value of the resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then instead of throwing an <see cref="T:System.InvalidOperationException"/>
            either the raw XML value (for resources from a .resx source) or the string representation of the object (for resources from a compiled source) will be returned for non-string resources.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, dynamic expansion of the resource sets of different cultures may occur when calling this method.
            In this case the result will be prefixed either by <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see>
            or <see cref="P:KGySoft.LanguageSettings.UnknownResourcePrefix">LanguageSettings.UnknownResourcePrefix</see>.
            <note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note>
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/>  and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="O:KGySoft.Resources.DynamicResourceManager.GetStream">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.DynamicResourceManager.GetString">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            <note>The internal buffer is tried to be obtained by reflection in the first place. On platforms, which have possibly unknown non-public member names the public APIs are used, which may copy the content in memory.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetStream(System.String)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, dynamic expansion of the resource sets of different cultures may occur when calling this method.</para>
            <para><note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></para>
            <note>The internal buffer is tried to be obtained by reflection in the first place. On platforms, which have possibly unknown non-public member names the public APIs are used, which may copy the content in memory.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="loadIfExists"><see langword="true"/> to load the resource set, if it has not been loaded yet and the corresponding resource file exists; otherwise, <see langword="false"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process.</param>
            <returns>The resource set for the specified culture.</returns>
            <remarks>
            <para>If <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/> option is enabled in <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, then dynamic expansion of the resource sets may occur when calling this method.
            <note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note>
            </para>
            <para>Appending is applied only if both <paramref name="loadIfExists"/> and <paramref name="tryParents"/> are <see langword="true"/>, though no new resource set will be created.
            To make possible to create a completely new resource set call the <see cref="M:KGySoft.Resources.DynamicResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method with <see cref="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists"/> behavior instead.</para>
            <para>If due to the current parameters no auto appending is performed during the call, then it will not happen also for successive calls for the same resource set until the <see cref="M:KGySoft.Resources.DynamicResourceManager.ReleaseAllResources">ReleaseAllResources</see>
            method is called.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents"/> and <see cref="P:KGySoft.Resources.HybridResourceManager.ThrowException"/> are <see langword="true"/> and
            the resource of the neutral culture was not found.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture, which can be dynamically modified.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="behavior">Determines the retrieval behavior of the result <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceSetRetrieval.LoadIfExists"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>
            The resource set for the specified culture, or <see langword="null"/> if the specified culture cannot be retrieved by the defined <paramref name="behavior"/>,
            or when <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/> so it cannot return an <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance.
            </returns>
            <remarks>
            <para>If <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad"/> option is enabled in <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, then dynamic expansion of the resource sets may occur when calling this method.
            <note>For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note>
            </para>
            <para>Appending is applied only if <paramref name="behavior"/> is not <see cref="F:KGySoft.Resources.ResourceSetRetrieval.GetIfAlreadyLoaded"/> and <paramref name="tryParents"/> is <see langword="true"/>.</para>
            <para>If due to the current parameters no auto appending is performed during the call, then it will not happen also for successive calls for the same resource set until the <see cref="M:KGySoft.Resources.DynamicResourceManager.ReleaseAllResources">ReleaseAllResources</see>
            method is called.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="behavior"/> does not fall in the expected range.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">Resource file of the neutral culture was not found, while <paramref name="tryParents"/> is <see langword="true"/>
            and <paramref name="behavior"/> is not <see cref="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.EnsureResourcesGenerated(System.Globalization.CultureInfo)">
            <summary>
            Ensures that the resource sets are generated for the specified <paramref name="culture"/> respecting the merging rules
            specified by the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> parameter.
            </summary>
            <param name="culture">The culture to generate the resource sets for.</param>
            <remarks>
            <note>This method is similar to <see cref="M:KGySoft.Resources.DynamicResourceManager.EnsureInvariantResourcesMerged(System.Globalization.CultureInfo)">EnsureInvariantResourcesMerged</see> but it skips
            merging of resources for already existing resource sets (either in memory or in a loadable file).
            Use the <see cref="M:KGySoft.Resources.DynamicResourceManager.EnsureInvariantResourcesMerged(System.Globalization.CultureInfo)">EnsureInvariantResourcesMerged</see> method to force a new merge even for possibly existing resource sets.</note>
            <para>This method generates the possibly missing resource sets in memory.
            Call also the <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method to save the generated resource sets immediately.</para>
            <para>When generating resources, the value of the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> is be respected.</para>
            <note>This method has no effect if <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>,
            or when there are no append options enabled in the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.EnsureInvariantResourcesMerged(System.Globalization.CultureInfo)">
            <summary>
            Ensures that all invariant resource entries are merged for the specified <paramref name="culture"/>.
            </summary>
            <param name="culture">The culture to merge the resource sets for.</param>
            <remarks>
            <note>This method is similar to <see cref="M:KGySoft.Resources.DynamicResourceManager.EnsureResourcesGenerated(System.Globalization.CultureInfo)">EnsureResourcesGenerated</see> but it forces a new merge even
            for existing resource sets. It can be useful if we want to ensure that possibly newly introduced resources (due to a new version release, for example)
            are also merged into the optionally already existing resource set files.</note>
            <para>If there are no existing resources for the specified <paramref name="culture"/> yet, then this method is functionally equivalent with
            the <see cref="M:KGySoft.Resources.DynamicResourceManager.EnsureResourcesGenerated(System.Globalization.CultureInfo)">EnsureResourcesGenerated</see> method, though it can be significantly slower than that.</para>
            <para>You can call also the <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method
            to save the generated or updated resource sets immediately.</para>
            <para>Merging is performed using the rules specified by the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property.</para>
            <note>This method has no effect if <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>,
            or when there are no append options enabled in the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.ReleaseAllResources">
            <summary>
            Tells the resource manager to call the <see cref="M:System.Resources.ResourceSet.Close">ResourceSet.Close</see> method on all <see cref="T:System.Resources.ResourceSet"/> objects and release all resources.
            All unsaved resources will be lost.
            </summary>
            <remarks>
            <note type="caution">By calling this method all of the unsaved changes will be lost.</note>
            <para>By the <see cref="P:KGySoft.Resources.HybridResourceManager.IsModified"/> property you can check whether there are unsaved changes.</para>
            <para>To save the changes you can call the <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a resource object in the current <see cref="T:KGySoft.Resources.DynamicResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The name of the resource to set.</param>
            <param name="culture">The culture of the resource to set. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <param name="value">The value of the resource to set. If <see langword="null"/>, then a null reference will be explicitly
            stored for the specified <paramref name="culture"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            As a result, the subsequent <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> calls
            with the same <paramref name="culture" /> will fall back to the parent culture, or will return <see langword="null"/> if
            <paramref name="name" /> is not found in any parent cultures. However, enumerating the result set returned by
            <see cref="M:KGySoft.Resources.DynamicResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> and <see cref="M:KGySoft.Resources.DynamicResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">GetResourceSet</see> methods will return the resources with <see langword="null"/> value.</para>
            <para>If you want to remove the user-defined ResX content and reset the original resource defined in the binary resource set (if any), use the <see cref="M:KGySoft.Resources.DynamicResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see> method.</para>
            <note>If you use the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> with some enabled options in the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> property, then do not need to call this method explicitly.
            For more details see the <em>Auto Appending</em> section at the description of the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a resource object from the current <see cref="T:KGySoft.Resources.DynamicResourceManager"/> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The case-sensitive name of the resource to remove.</param>
            <param name="culture">The culture of the resource to remove. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If there is a binary resource defined for <paramref name="name" /> and <paramref name="culture" />,
            then after this call the originally defined value will be returned by <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> method from the binary resources.
            If you want to force hiding the binary resource and make <see cref="O:KGySoft.Resources.DynamicResourceManager.GetObject">GetObject</see> to default to the parent <see cref="T:System.Globalization.CultureInfo" /> of the specified <paramref name="culture" />,
            then use the <see cref="M:KGySoft.Resources.DynamicResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see> method with a <see langword="null"/> value.</para>
            <para><paramref name="name"/> is considered as case-sensitive. If <paramref name="name"/> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to explicit disposing; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Provides the implementation for finding a resource set.
            </summary>
            <param name="culture">The culture object to look for.</param>
            <param name="loadIfExists"><see langword="true"/> to load the resource set, if it has not been loaded yet; otherwise, <see langword="false"/>.</param>
            <param name="tryParents"><see langword="true"/> to check parent <see cref="T:System.Globalization.CultureInfo" /> objects if the resource set cannot be loaded; otherwise, <see langword="false"/>.</param>
            <returns>
            The specified resource set.
            </returns>
            <remarks>Unlike in case of <see cref="M:KGySoft.Resources.DynamicResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">GetResourceSet</see> and <see cref="M:KGySoft.Resources.DynamicResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> methods,
            no auto appending occurs when this method is called.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">The .resx file of the neutral culture was not found, while <paramref name="tryParents"/> and <see cref="P:KGySoft.Resources.HybridResourceManager.ThrowException"/> are both <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.IsCachedProxyAccepted(System.Resources.ResourceSet,System.Globalization.CultureInfo)">
            <summary>
            Called by GetFirstResourceSet if cache is a proxy.
            There is always a traversal if this is called (tryParents).
            Proxy is accepted if it is no problem if a result is found in the proxied resource set.
            </summary>
            <param name="proxy">The found proxy</param>
            <param name="culture">The requested culture</param>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.OnAutoSaveError(KGySoft.Resources.AutoSaveErrorEventArgs)">
            <summary>
            Raises the <see cref="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError" /> event.
            </summary>
            <returns><see langword="true"/> if the error is handled and should not be re-thrown.</returns>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.IsAppendPossible(System.Globalization.CultureInfo,KGySoft.Resources.AutoAppendOptions)">
            <summary>
            Checks whether append is possible
            </summary>
        </member>
        <member name="M:KGySoft.Resources.DynamicResourceManager.EnsureLoadedWithMerge(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,KGySoft.Resources.AutoAppendOptions)">
            <summary>
            Applies the AppendOnLoad rule.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.HybridResourceManager">
            <summary>
            Represents a resource manager that provides convenient access to culture-specific resources at run time.
            It can handle both compiled resources from <c>.dll</c> and <c>.exe</c> files, and <c>.resx</c> files at
            the same time. New elements can be added as well, which can be saved into <c>.resx</c> files.
            </summary>
            <remarks>
            <para><see cref="T:KGySoft.Resources.HybridResourceManager"/> class is derived from <see cref="T:System.Resources.ResourceManager"/> and uses a <see cref="T:KGySoft.Resources.ResXResourceManager"/> internally.
            The <see cref="T:KGySoft.Resources.HybridResourceManager"/> combines the functionality of the regular <see cref="T:System.Resources.ResourceManager"/> and the <see cref="T:KGySoft.Resources.ResXResourceManager"/> classes.
            The source of the resources can be chosen by the <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> property (see <see cref="T:KGySoft.Resources.ResourceManagerSources"/> enumeration).
            Enabling both binary and .resx resources makes possible to expand or override the resources originally come from binary resources.
            Just like the <see cref="T:KGySoft.Resources.ResXResourceManager"/> it is an <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> implementation. The replacement and newly added content can be saved into .resx files.</para>
            <para>See the <a href="#comparison">Comparison with ResourceManager</a> section to see all of the differences.</para>
            <note type="tip">To see when to use the <see cref="T:KGySoft.Resources.ResXResourceReader"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, <see cref="T:KGySoft.Resources.ResXResourceSet"/>, <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
            classes see the documentation of the <see cref="N:KGySoft.Resources">KGySoft.Resources</see> namespace.</note>
            <h2>Example: Expanding compiled resources created by Visual Studio</h2>
            <para>You can create compiled resources by Visual Studio and you can dynamically expand them by <see cref="T:KGySoft.Resources.HybridResourceManager"/>. The new and overridden content
            will be saved as .resx files. See the following example for a step-by-step guide.
            <list type="number">
            <item>Create a new project (Console Application)
            <br/><img src="../Help/Images/NewConsoleApp.png" alt="New console application"/></item>
            <item>In Solution Explorer right click on <c>ConsoleApp1</c>, Add, New Folder, name it <c>Resources</c>.</item>
            <item>In Solution Explorer right click on <c>Resources</c>, Add, New Item, Resources File.
            <br/><img src="../Help/Images/NewResourcesFile.png" alt="New Resources file"/></item>
            <item>In Solution Explorer right click on the new resource file (<c>Resource1.resx</c> if not named otherwise) and select Properties</item>
            <item>The default value of <c>Build Action</c> is <c>Embedded Resource</c>, which means that the resource will be compiled into the assembly.
            The <see cref="T:KGySoft.Resources.HybridResourceManager"/> will be able to read these compiled resources if its <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> property is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/> or <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/>.
            We can clear the default <c>Custom Tool</c> value because the generated file uses a <see cref="T:System.Resources.ResourceManager"/> class internally, which cannot handle the dynamic expansions.
            <br/><img src="../Help/Images/ResourceFileProperties_HybridResourceManager.png" alt="Resources1.resx properties"/>
            <note type="tip">To use purely the .resx files you can use the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class. To provide dynamic creation and expansion of new .resx files with the untranslated items for any language use the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class.</note></item>
            <item>Now we can either use the built-on resource editor of Visual Studio or just edit the .resx file by the XML Editor. If we add new or existing files to the resources, they will be automatically added to the project's Resources folder.</item>
            <item>To add culture-specific resources you can add further resource files with the same base name, extended by culture names. For example, if the invariant resource is called <c>Resource1.resx</c>, then a
            region neutral English resource can be called <c>Resource1.en.resx</c> and the American English resource can be called <c>Resource1.en-US.resx</c>.</item>
            <item>If we now compile the project, the <c>ConsoleApp1.exe</c> will contain an embedded resource named <c>ConsoleApp1.Resources.Resource1.resources</c>. If we created
            language-specific resources they will be compiled into so-called satellite assemblies. For example, if we have a resource file named <c>Resource1.en.resx</c>, then
            building the project will create an <c>en</c> folder containing a <c>ConsoleApp1.resources.dll</c>, which will contain an embedded resource named <c>ConsoleApp1.Resources.Resource1.en.resources</c>.
            In both cases the base name is <c>ConsoleApp1.Resources.Resource1</c>, this must be the <c>baseName</c> parameter in the constructors of the <see cref="T:KGySoft.Resources.HybridResourceManager"/>.
            <note type="tip">The automatically generated base name can be changed in the .csproj file. If you want to change the base name to <c>MyResources</c>, then
            follow the steps below:
            <list type="number">
            <item>In Solution Explorer right click on <c>ConsoleApp1</c>, Unload Project</item>
            <item>In Solution Explorer right click on <c>ConsoleApp1 (unavailable)</c>, Edit ConsoleApp1.csproj</item>
            <item>Search for the <c>EmbeddedResource</c> nodes and edit them as follows:
            <code lang="XML"><![CDATA[
            <EmbeddedResource Include="Resources\Resource1.resx" >
              <LogicalName>MyResources.resources</LogicalName>
            </EmbeddedResource>
            <EmbeddedResource Include="Resources\Resource1.en.resx" >
              <LogicalName>MyResources.en.resources</LogicalName>
            </EmbeddedResource>]]></code></item>
            <item>In Solution Explorer right click on <c>ConsoleApp1 (unavailable)</c>, Reload ConsoleApp1.csproj</item>
            </list></note></item>
            <item>Reference <c>KGySoft.CoreLibraries.dll</c> and paste the following code in <c>Program.cs</c>:</item>
            </list></para>
            <code lang="C#"><![CDATA[
            using System;
            using System.Globalization;
            using KGySoft.Resources;
            
            public class Program
            {
                public static void Main()
                {
                    var enUS = CultureInfo.GetCultureInfo("en-US");
                    var en = enUS.Parent;
                    var inv = en.Parent; // same as CultureInfo.InvariantCulture
            
                    var resourceManager = new HybridResourceManager(
                            baseName: "ConsoleApp1.Resources.Resource1", // Or "MyResources" if you followed the tip above.
                            assembly: typeof(Program).Assembly, // This is the assembly contains the compiled resources
                            explicitResXBaseFileName: null) // (optional) if not null, a different name can be specified from baseName
                        {
                            ResXResourcesDir = "Resources", // The subfolder of .resx resources. Default is "Resources"
                            Source = ResourceManagerSources.CompiledAndResX // Both types of resources are used. Default is CompiledAndResX
                        };
            
                    // If no .resx file exists yet the results will come purely from compiled resources
                    Console.WriteLine("Results before adding some content:");
                    Console.WriteLine(resourceManager.GetString("String1", enUS)); // from en because en-US does not exist
                    Console.WriteLine(resourceManager.GetString("String1", en)); // from en
                    Console.WriteLine(resourceManager.GetString("String1", inv)); // from invariant
            
                    // Adding some new content
                    resourceManager.SetObject("String1", "Replaced content in invariant culture", inv); // overriding existing compiled entry
                    resourceManager.SetObject("NewObject", 42, inv); // completely newly defined entry
                    resourceManager.SetObject("String1", "Test string in lately added American English resource file", enUS);
            
                    Console.WriteLine();
                    Console.WriteLine("Results after adding some content:");
                    Console.WriteLine(resourceManager.GetString("String1", enUS)); // from en-US resx
                    Console.WriteLine(resourceManager.GetString("String1", en)); // from compiled en
                    Console.WriteLine(resourceManager.GetString("String1", inv)); // from invariant .resx
            
                    // Removing works for .resx content. Removing an overridden entry resets the original compiled content.
                    resourceManager.RemoveObject("String1", inv);
            
                    // But by setting null explicitly even a compiled value can be suppressed.
                    // By removing the null entry the compiled content will re-appear
                    resourceManager.SetObject("String1", null, en);
            
                    Console.WriteLine();
                    Console.WriteLine("Results after deleting some content:");
                    Console.WriteLine(resourceManager.GetString("String1", enUS)); // from en-US .resx
                    Console.WriteLine(resourceManager.GetString("String1", en)); // from invariant because en is overridden by null
                    Console.WriteLine(resourceManager.GetString("String1", inv)); // from original invariant because .resx is removed
            
                    // By saving the resources the changes above can be persisted
                    // resourceManager.SaveAllResources();
                }
            }
            
            // A possible result of the example above (depending on the created resource files and the added content)
            // Results before adding some content:
            // Test string in compiled en resource
            // Test string in compiled en resource
            // Test string in compiled invariant resource
            //
            // Results after adding some content:
            // Test string in lately added American English resource file
            // Test string in compiled en resource
            // Replaced content in invariant culture
            // 
            // Results after deleting some content:
            // Test string in lately added American English resource file
            // Test string in compiled invariant resource
            // Test string in compiled invariant resource]]></code>
            <para>Considering there are .resx files in the background not just <see cref="T:System.String"/> and other <see cref="T:System.Object"/> resources
            can be obtained by <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> and <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods
            but metadata as well by <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods. Please note that accessing aliases are not exposed
            by the <see cref="T:KGySoft.Resources.HybridResourceManager"/> class, but you can still access them via the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> type returned by the <see cref="M:KGySoft.Resources.HybridResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method.
            <note>Please note that unlike in case of <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> and <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods,
            there is no falling back to the parent cultures (as seen in the example above) for metadata accessed by the <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods.</note></para>
            <h2>Safety<a name="safety">&#160;</a></h2>
            <para>Similarly to <see cref="T:KGySoft.Resources.ResXResourceSet"/>, <see cref="T:KGySoft.Resources.ResXResourceReader"/> and <see cref="T:KGySoft.Resources.ResXResourceManager"/>, the <see cref="T:KGySoft.Resources.HybridResourceManager"/>
            class also has a <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> property, which changes the behavior of <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see>
            and <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see>
            methods:
            <list type="bullet">
            <item>If the <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> property is <see langword="true"/>, and the result is from a .resx resource, then the return value
            of <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see>
            methods is a <see cref="T:KGySoft.Resources.ResXDataNode"/> rather than the resource or metadata value.
            This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source.
            The actual value can be obtained by the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.
            See also the third example at the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class.</item>
            <item>If the <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> property is <see langword="true"/>, then <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see>
            and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods will not throw an <see cref="T:System.InvalidOperationException"/> even for non-string entries.
            For non-string values the raw XML string value will be returned for resources from a .resx source and the result of the <see cref="M:System.Object.ToString">ToString</see> method
            for resources from a compiled source.</item>
            <item>If the <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> property is <see langword="true"/>, then <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see>
            and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> methods will not throw an <see cref="T:System.InvalidOperationException"/>.
            For values, which are neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see> instances, they return a stream wrapper for the same string value
            that is returned by the <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods.</item>
            </list>
            <note type="security">Even if <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/>, loading a .resx content with corrupt or malicious entry
            will have no effect until we try to obtain the corresponding value. See the last example at <see cref="T:KGySoft.Resources.ResXResourceSet"/> for the demonstration
            and the example at <see cref="T:KGySoft.Resources.ResXDataNode"/> to see what members can be checked in safe mode.
            </note></para>
            <h2>Comparison with ResourceManager<a name="comparison">&#160;</a></h2>
            <para>While <see cref="T:System.Resources.ResourceManager"/> is read-only and works on binary resources, <see cref="T:KGySoft.Resources.HybridResourceManager"/> supports expansion (see <see cref="T:KGySoft.Resources.IExpandoResourceManager"/>)
            and works both on binary and XML resources (.resx files).</para>
            <para><strong>Incompatibility</strong> with <see cref="T:System.Resources.ResourceManager"/>:
            <list type="bullet">
            <item>There is no constructor where the type of the resource sets can be specified. As <see cref="T:KGySoft.Resources.HybridResourceManager"/> works with multiple resource types
            you must not rely on the value of the <see cref="P:System.Resources.ResourceManager.ResourceSetType"/> property.</item>
            <item>If <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">ResourceManager.GetResourceSet</see> method is called with <c>createIfNotExists = false</c> for a culture,
            which has a corresponding but not loaded resource file, then a resource set for a parent culture might be cached and on successive calls that cached parent set will be
            returned even if the <c>createIfNotExists</c> argument is <see langword="true"/>. In <see cref="T:KGySoft.Resources.HybridResourceManager"/> the corresponding argument of
            the <see cref="M:KGySoft.Resources.HybridResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">GetResourceSet</see> method has been renamed to <c>loadIfExists</c> and works as expected.</item>
            <item>The <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods have <see cref="T:System.IO.MemoryStream"/> return type instead of <see cref="T:System.IO.UnmanagedMemoryStream"/> and they can be used also for <see cref="T:System.Array">byte[]</see> values.</item>
            </list></para>
            <para><strong>New features and improvements</strong> compared to <see cref="T:System.Resources.ResourceManager"/>:
            <list type="bullet">
            <item><term>Write support</term>
            <description>The stored content can be expanded or existing entries can be replaced (see <see cref="M:KGySoft.Resources.HybridResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">SetMetaObject</see>),
            the entries can be removed (see <see cref="M:KGySoft.Resources.HybridResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">RemoveMetaObject</see>),
            and the new content can be saved (see <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">SaveResourceSet</see>).
            You can start even with pure compiled resources, add new content during runtime and save the changes (see the example above).</description></item>
            <item><term>Security</term>
            <description>During the initialization of <see cref="T:KGySoft.Resources.HybridResourceManager"/> and loading of a resource set from a .resx file no object is deserialized even if <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/>
            property is <see langword="false"/>. Objects are deserialized only when they are accessed (see <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see>).
            If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then security is even more increased because the <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods
            return a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of a deserialized object so you can check whether the resource or metadata
            can be treat as a safe object before actually deserializing it. See the <a href="#safety">Safety</a> section above for more details.</description></item>
            <item><term>Disposal</term>
            <description>As <see cref="T:System.Resources.ResourceSet"/> implementations are disposable objects, <see cref="T:KGySoft.Resources.HybridResourceManager"/> itself implements
            the <see cref="T:System.IDisposable"/> interface as well.</description></item>
            </list>
            </para>
            </remarks>
            <seealso cref="T:KGySoft.LanguageSettings"/>
            <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
            <seealso cref="T:KGySoft.Resources.ResXFileRef"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceSet"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceManager"/>
            <seealso cref="T:KGySoft.Resources.DynamicResourceManager"/>
        </member>
        <member name="T:KGySoft.Resources.HybridResourceManager.ProxyResourceSet">
            <summary>
            Represents a cached resource set for a child culture, which might be replaced later.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.ProxyResourceSet.WrappedResourceSet">
            <summary>
            Gets the wrapped resource set. This is always a parent of the represented resource set.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.ProxyResourceSet.WrappedCulture">
            <summary>
            Gets the culture of the wrapped resource set
            </summary>
        </member>
        <member name="F:KGySoft.Resources.HybridResourceManager.lastUsedResourceSet">
            <summary>
            The lastly used resource set. Unlike in base, this is not necessarily the resource set in which a result
            has been found but the resource set was requested last time. In cases there are different this method performs usually better.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.ThrowException">
            <summary>
            Gets or sets whether a <see cref="T:System.Resources.MissingManifestResourceException"/> should be thrown when a resource
            .resx file or compiled manifest is not found even for the neutral culture.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.IgnoreResXParseErrors">
            <summary>
            Gets or sets whether .resx file errors should be ignored when attempting to load a resource set. If <see langword="true"/>,
            then non-loadable resource sets are considered as missing ones; otherwise, an exception is thrown.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.ResXResourcesDir">
            <summary>
            Gets or sets the relative path to .resx resource files.
            <br/>Default value: <c>Resources</c>
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.ResourceSetType">
            <summary>
            Gets the type of the resource set object that the <see cref="T:KGySoft.Resources.HybridResourceManager"/> uses to create a resource set for the binary resources.
            Please note that for .resx based resources other types can be created as well.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.Source">
            <summary>
            Gets or sets the source, from which the resources should be taken.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX"/>
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.IgnoreCase">
            <summary>
            Gets or sets a value that indicates whether the resource manager allows case-insensitive resource lookups in the
            <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see>
            and <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.SafeMode">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.Resources.HybridResourceManager"/> works in safe mode. In safe mode the retrieved
            objects returned from .resx sources are not deserialized automatically.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods
            return <see cref="T:KGySoft.Resources.ResXDataNode"/> instances instead of deserialized objects, if they are returned from .resx resource. You can retrieve the deserialized
            objects by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.</para>
            <para>When <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods
            will return a <see cref="T:System.String"/> also for non-string objects.
            For non-string values the raw XML string value will be returned for resources from a .resx source and the result of the <see cref="M:System.Object.ToString">ToString</see> method
            for resources from a compiled source.</para>
            <para>When <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> methods
            will return a <see cref="T:System.IO.MemoryStream"/> for any object.
            For values, which are neither <see cref="T:System.IO.MemoryStream"/>, nor <see cref="T:System.Array">byte[]</see> instances these methods return a stream wrapper for the same string value
            that is returned by the <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods.</para>
            </remarks>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.CloneValues">
            <summary>
            Gets or sets whether <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods return always a new copy of the stored values.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            <para>To be compatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/System.Resources.ResourceManager" target="_blank">System.Resources.ResourceManager</a> this
            property is <see langword="true"/> by default. If this <see cref="T:KGySoft.Resources.HybridResourceManager"/> contains no mutable values or it is known that modifying values is not
            an issue, then this property can be set to <see langword="false"/> for better performance.</para>
            <para>String values are not cloned.</para>
            <para>The value of this property affects only the objects returned from .resx sources. Non-string values from compiled sources are always cloned.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.IsModified">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.HybridResourceManager"/> instance has modified and unsaved data.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.IsDisposed">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.HybridResourceManager"/> instance is disposed.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.HybridResourceManager.NeutralResourcesCulture">
            <summary>
            Gets the <see cref="T:System.Globalization.CultureInfo"/> that is specified as neutral culture in the <see cref="T:System.Reflection.Assembly"/>
            used to initialized this instance, or the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> if no such culture is defined.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.#ctor(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Resources.HybridResourceManager"/> class that looks up resources in
            compiled assemblies and resource XML files based on information from the specified <paramref name="baseName"/>
            and <paramref name="assembly"/>.
            </summary>
            <param name="baseName">A root name that is the prefix of the resource files without the extension.</param>
            <param name="assembly">The main assembly for the resources. The compiled resources will be searched in this assembly.</param>
            <param name="explicitResXBaseFileName">When <see langword="null"/> the .resx file name will be constructed based on the
            <paramref name="baseName"/> parameter; otherwise, the given <see cref="T:System.String"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.#ctor(System.Type,System.String)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Resources.HybridResourceManager"/> class that looks up resources in
            compiled assemblies and resource XML files based on information from the specified type object.
            </summary>
            <param name="resourceSource">A type from which the resource manager derives all information for finding resource files.</param>
            <param name="explicitResXBaseFileName">When <see langword="null"/> the .resx file name will be constructed based on the
            <paramref name="resourceSource"/> parameter; otherwise, the given <see cref="T:System.String"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetString(System.String)">
            <summary>
            Returns the value of the specified string resource.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <returns>
            The value of the resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then instead of throwing an <see cref="T:System.InvalidOperationException"/>
            either the raw XML value (for resources from a .resx source) or the string representation of the object (for resources from a compiled source) will be returned for non-string resources.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/>  and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string resource localized for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <returns>
            The value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then instead of throwing an <see cref="T:System.InvalidOperationException"/>
            either the raw XML value (for resources from a .resx source) or the string representation of the object (for resources from a compiled source) will be returned for non-string resources.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/>  and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetStream(System.String)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            <note>The internal buffer is tried to be obtained by reflection in the first place. On platforms, which have possibly unknown non-public member names the public APIs are used, which may copy the content in memory.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            <note>The internal buffer is tried to be obtained by reflection in the first place. On platforms, which have possibly unknown non-public member names the public APIs are used, which may copy the content in memory.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetObject(System.String)">
            <summary>
            Returns the value of the specified resource.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, and the resource is from a .resx content, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Gets the value of the specified resource localized for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <param name="culture">The culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, and the resource is from a .resx content, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="loadIfExists"><see langword="true"/> to load the resource set, if it has not been loaded yet and the corresponding resource file exists; otherwise, <see langword="false"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process.</param>
            <returns>The resource set for the specified culture.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents"/> and <see cref="P:KGySoft.Resources.HybridResourceManager.ThrowException"/> are <see langword="true"/> and
            the resource of the neutral culture was not found.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.ReleaseAllResources">
            <summary>
            Tells the resource manager to call the <see cref="M:System.Resources.ResourceSet.Close">ResourceSet.Close</see> method on all <see cref="T:System.Resources.ResourceSet"/> objects and release all resources.
            All unsaved resources will be lost.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <remarks>
            <note type="caution">By calling this method all of the unsaved changes will be lost.</note>
            <para>By the <see cref="P:KGySoft.Resources.HybridResourceManager.IsModified"/> property you can check whether there are unsaved changes.</para>
            <para>To save the changes you can call the <see cref="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string metadata for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /> property.
            Unlike in case of <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>
            The value of the metadata of the specified culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is a non-<see langword="string"/> metadata, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns the underlying raw XML content of the metadata.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/> and the type of the metadata is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the metadata of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="O:KGySoft.Resources.HybridResourceManager.GetStream">GetStream</see> methods, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified metadata, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property, the <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> method returns either
            a full copy of the specified metadata, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> method
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.HybridResourceManager.CloneValues"/> property.</para>
            <para><see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> can be used also for byte array metadata.</para>
            <para>If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array metadata, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.HybridResourceManager.GetString">GetString</see> methods,
            which will be the raw XML content for non-string metadata.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="false"/> and the type of the metadata is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the specified non-string metadata for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/> is <see langword="true"/>, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the metadata localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture, which can be dynamically modified.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="behavior">Determines the retrieval behavior of the result <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceSetRetrieval.LoadIfExists"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The resource set for the specified culture, or <see langword="null"/> if the specified culture cannot be retrieved by the defined <paramref name="behavior"/>,
            or when <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/> so it cannot return an <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="behavior"/> does not fall in the expected range.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">Resource file of the neutral culture was not found, while <paramref name="tryParents"/> is <see langword="true"/>
            and <paramref name="behavior"/> is not <see cref="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a resource object in the current <see cref="T:KGySoft.Resources.HybridResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The name of the resource to set.</param>
            <param name="culture">The culture of the resource to set. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <param name="value">The value of the resource to set. If <see langword="null"/>, then a null reference will be explicitly
            stored for the specified <paramref name="culture"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            As a result, the subsequent <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> calls
            with the same <paramref name="culture" /> will fall back to the parent culture, or will return <see langword="null"/> if
            <paramref name="name" /> is not found in any parent cultures. However, enumerating the result set returned by
            <see cref="M:KGySoft.Resources.HybridResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> and <see cref="M:KGySoft.Resources.HybridResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">GetResourceSet</see> methods will return the resources with <see langword="null"/> value.</para>
            <para>If you want to remove the user-defined ResX content and reset the original resource defined in the binary resource set (if any), use the <see cref="M:KGySoft.Resources.HybridResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see> method.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a resource object from the current <see cref="T:KGySoft.Resources.HybridResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The case-sensitive name of the resource to remove.</param>
            <param name="culture">The culture of the resource to remove. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If there is a binary resource defined for <paramref name="name" /> and <paramref name="culture" />,
            then after this call the originally defined value will be returned by <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> method from the binary resources.
            If you want to force hiding the binary resource and make <see cref="O:KGySoft.Resources.HybridResourceManager.GetObject">GetObject</see> to default to the parent <see cref="T:System.Globalization.CultureInfo" /> of the specified <paramref name="culture" />,
            then use the <see cref="M:KGySoft.Resources.HybridResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see> method with a <see langword="null"/> value.</para>
            <para><paramref name="name"/> is considered as case-sensitive. If <paramref name="name"/> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a metadata object in the current <see cref="T:KGySoft.Resources.HybridResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The name of the metadata to set.</param>
            <param name="value">The value of the metadata to set. If <see langword="null" />,  then a null reference will be explicitly
            stored for the specified <paramref name="culture" />.</param>
            <param name="culture">The culture of the metadata to set.
            If this value is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            Its effect is similar to the <see cref="M:KGySoft.Resources.HybridResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">RemoveMetaObject</see> method: the subsequent <see cref="M:KGySoft.Resources.HybridResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> calls
            with the same <paramref name="culture" /> will return <see langword="null" />.
            However, enumerating the result set returned by <see cref="M:KGySoft.Resources.HybridResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method will return the meta objects with <see langword="null"/> value.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a metadata object from the current <see cref="T:KGySoft.Resources.HybridResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The case-sensitive name of the metadata to remove.</param>
            <param name="culture">The culture of the metadata to remove.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <paramref name="name" /> is considered as case-sensitive. If <paramref name="name" /> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Saves the resource set of a particular <paramref name="culture" /> if it has been already loaded.
            </summary>
            <param name="culture">The culture of the resource set to save.</param>
            <param name="force"><see langword="true"/> to save the resource set even if it has not been modified; <see langword="false"/> to save it only if it has been modified. This parameter is optional.
            <br />Default value: <see langword="false"/>.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class. This parameter is optional.
            <br />Default value: <see langword="false"/>.</param>
            <returns>
            <see langword="true"/> if the resource set of the specified <paramref name="culture" /> has been saved;
            otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.IO.IOException">The resource set could not be saved.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.SaveAllResources(System.Boolean,System.Boolean)">
            <summary>
            Saves all already loaded resources.
            </summary>
            <param name="force"><see langword="true"/> to save all of the already loaded resource sets regardless if they have been modified; <see langword="false"/> to save only the modified resource sets. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx files can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx files are often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns><see langword="true"/> if at least one resource set has been saved; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.HybridResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.IO.IOException">A resource set could not be saved.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.Dispose">
            <summary>
            Disposes the resources of the current instance.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Provides the implementation for finding a resource set.
            </summary>
            <param name="culture">The culture object to look for.</param>
            <param name="loadIfExists"><see langword="true"/> to load the resource set, if it has not been loaded yet; otherwise, <see langword="false"/>.</param>
            <param name="tryParents"><see langword="true"/> to check parent <see cref="T:System.Globalization.CultureInfo" /> objects if the resource set cannot be loaded; otherwise, <see langword="false"/>.</param>
            <returns>The specified resource set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">The .resx file of the neutral culture was not found, while <paramref name="tryParents"/> and <see cref="P:KGySoft.Resources.HybridResourceManager.ThrowException"/> are both <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.Resources.HybridResourceManager"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.Resources.HybridResourceManager.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.SetSource(KGySoft.Resources.ResourceManagerSources)">
            <summary>
            Sets the source of the resources.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.IsNonProxyLoaded(System.Globalization.CultureInfo)">
            <summary>
            Gets whether a non-proxy resource set is present for the specified culture.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.IsAnyProxyLoaded">
            <summary>
            Gets whether a proxy resource set is present for any culture.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.IsExpandoExists(System.Globalization.CultureInfo)">
            <summary>
            Gets whether an expando resource set is present for the specified culture.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.SetCache(System.Globalization.CultureInfo,System.Resources.ResourceSet)">
            <summary>
            Updates last used ResourceSet
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.IsCachedProxyAccepted(System.Resources.ResourceSet,System.Globalization.CultureInfo)">
            <summary>
            Gets whether a cached proxy can be accepted as a result.
            </summary>
            <param name="proxy">The found proxy</param>
            <param name="culture">The requested culture</param>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean,System.Boolean)">
            <summary>
            Warning: It CAN return a proxy
            </summary>
        </member>
        <member name="M:KGySoft.Resources.HybridResourceManager.GetFirstResourceSet(System.Globalization.CultureInfo)">
            <summary>
            Tries to get the first resource set in the traversal hierarchy,
            so the resource set for the culture itself.
            Warning: it CAN return a proxy
            </summary>
        </member>
        <member name="T:KGySoft.Resources.HybridResourceSet">
            <summary>
            Represents a resource set of hybrid sources (both .resx and compiled source).
            </summary>
        </member>
        <member name="T:KGySoft.Resources.HybridResourceSet.Enumerator">
            <summary>
            An enumerator for a HybridResourceSet. If both .resx and compiled resources contain the same key, returns only the value from the .resx.
            Must be implemented because yield return does not work for IDictionaryEnumerator.
            Cannot be serializable because the compiled enumerator is not serializable (supports reset, though).
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXCommon.GetAssemblyQualifiedName(System.Type,System.Func{System.Type,System.String},System.Boolean)">
            <summary>
            Gets assembly info for the corresponding type. If the delegate is provided it is used to get this information.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXDataNode">
            <summary>
            Represents a resource or metadata element in an XML resource (.resx) file.
            </summary>
            <remarks>
            <note>This class is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>
            in <c>System.Windows.Forms.dll</c>. See the <a href="#comparison">Comparison with System.Resources.ResXDataNode</a> section for the differences.</note>
            <para>The <see cref="T:KGySoft.Resources.ResXDataNode"/> class supports the representation of rich data types within a resource file. It can support the storage of any object in a resource file.</para>
            <para>You can create a <see cref="T:KGySoft.Resources.ResXDataNode"/> object by calling one of its overloaded class constructors.
            You can then add the resource item or element to a resource file by one of the following options:
            <list type="bullet">
            <item>Call the <see cref="M:KGySoft.Resources.ResXResourceWriter.AddResource(KGySoft.Resources.ResXDataNode)">ResXResourceWriter.AddResource(ResXDataNode)</see> or <see cref="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(KGySoft.Resources.ResXDataNode)">ResXResourceWriter.AddMetadata(ResXDataNode)</see> method.</item>
            <item>Call the <see cref="M:KGySoft.Resources.ResXResourceSet.SetObject(System.String,System.Object)">ResXResourceSet.SetObject(string, object)</see> or <see cref="M:KGySoft.Resources.ResXResourceSet.SetMetaObject(System.String,System.Object)">ResXResourceSet.SetMetaObject(string, object)</see> method and then
            call the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">Save</see> method on it.</item>
            <item>Call the <see cref="M:KGySoft.Resources.IExpandoResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see> or <see cref="M:KGySoft.Resources.IExpandoResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">SetMetaObject</see> method on any <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> implementation
            (such as <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/>, <see cref="T:KGySoft.Resources.DynamicResourceManager"/>) and then call the <see cref="M:KGySoft.Resources.IExpandoResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">SaveResourceSet</see>
            or <see cref="M:KGySoft.Resources.IExpandoResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> methods on them.</item>
            </list>
            <note>If you call any of the <c>SetObject</c> methods of the list above by any <see cref="T:System.Object"/>, then a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance will be implicitly created.
            A <see cref="T:KGySoft.Resources.ResXDataNode"/> instance should be explicitly created only if you want to set the <see cref="P:KGySoft.Resources.ResXDataNode.Comment"/> property.</note>
            </para>
            <para>To retrieve a <see cref="T:KGySoft.Resources.ResXDataNode"/> object from a resource you have the following options:
            <list type="bullet">
            <item>Enumerate the <see cref="T:KGySoft.Resources.ResXDataNode"/> objects in an XML (.resx file) by instantiating a <see cref="T:KGySoft.Resources.ResXResourceReader"/> object,
            setting the <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode">ResXResourceReader.SafeMode</see> property to <see langword="true"/>, and calling the
            <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">ResXResourceReader.GetEnumerator</see> or <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">ResXResourceReader.GetMetadataEnumerator</see> method to get an enumerator.
            See also the example below.</item>
            <item>Instantiate a new <see cref="T:KGySoft.Resources.ResXResourceSet"/> from a .resx file, set <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode">ResXResourceSet.SafeMode</see> to <see langword="true"/>,
            and call the <see cref="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String)">ResXResourceSet.GetObject</see> or <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">ResXResourceSet.GetMetaObject</see>
            methods with a key, which exists in the .resx file. You can use the <see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">ResXResourceSet.GetEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">ResXResourceSet.GetMetadataEnumerator</see>
            methods in a similar way as in case of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class.</item>
            <item>Instantiate a new <see cref="T:KGySoft.Resources.ResXResourceManager"/>/<see cref="T:KGySoft.Resources.HybridResourceManager"/> or <see cref="T:KGySoft.Resources.DynamicResourceManager"/> class, set <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> to <see langword="true"/>,
            and call the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> or <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see>
            methods with a key, which exists in the .resx file.</item>
            </list>
            </para>
            <example>
            The following example shows how to retrieve <see cref="T:KGySoft.Resources.ResXDataNode"/> instances from the <see cref="T:System.Collections.IDictionaryEnumerator"/> returned by <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">ResXResourceReader.GetEnumerator</see>
            and <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">ResXResourceReader.GetMetadataEnumerator</see> methods. For example, you can check the type information before deserialization if the .resx file is from an untrusted source.
            <code lang="C#"><![CDATA[
            using System;
            using System.Collections;
            using System.IO;
            
            using KGySoft.Resources;
            
            public class Example
            {
                private const string resx = @"<?xml version='1.0' encoding='utf-8'?>
            <root>
              <data name='string'>
                <value>Test string</value>
                <comment>Default data type is string.</comment>
              </data>
            
              <metadata name='meta string'>
                <value>Meta String</value>
              </metadata>
            
              <data name='int' type='System.Int32'>
                <value>42</value>
              </data>
            
              <assembly alias='CustomAlias' name='System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' />
            
              <data name='color' type='System.Drawing.Color, CustomAlias'>
                <value>Red</value>
                <comment>When this entry is deserialized in an unsafe way, System.Drawing assembly will be loaded.</comment>
              </data>
            
              <data name='bytes' type='System.Byte[]'>
                <value>VGVzdCBieXRlcw==</value>
              </data>
              
              <data name='dangerous' mimetype='application/x-microsoft.net.object.binary.base64'>
                <value>YmluYXJ5</value>
                <comment>BinaryFormatter will throw an exception for this invalid content.</comment>
              </data>
            
            </root>";
            
                public static void Main()
                {
                    // In SafeMode the enumerator values will be ResXDataNode instances instead of deserialized objects
                    var reader = new ResXResourceReader(new StringReader(resx)) { SafeMode = true };
            
                    Console.WriteLine("____Resources in .resx:____");
                    Dump(reader.GetEnumerator());
            
                    Console.WriteLine("____Metadata in .resx:____");
                    Dump(reader.GetMetadataEnumerator());
                }
            
                private static void Dump(IDictionaryEnumerator enumerator)
                {
                    while (enumerator.MoveNext())
                    {
                        var node = (ResXDataNode)enumerator.Value;
                        Console.WriteLine($"Name: {node.Name}");
                        Console.WriteLine($"  Type:        {node.TypeName}");
                        Console.WriteLine($"  Alias value: {node.AssemblyAliasValue}");
                        Console.WriteLine($"  MIME type:   {node.MimeType}");
                        Console.WriteLine($"  Comment:     {node.Comment}");
                        Console.WriteLine($"  Raw value:   {node.ValueData}");
                        try
                        {
                            var value = node.GetValueSafe();
                            Console.WriteLine($"  Real value:  {value} ({value.GetType()})");
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine($"  Safe deserialization of the node thrown an exception: {e.Message}");
                            try
                            {
                                var value = node.GetValue();
                                Console.WriteLine($"  Real value (unsafe):  {value} ({value.GetType()})");
                            }
                            catch (Exception)
                            {
                                Console.WriteLine($"  Unsafe deserialization of the node thrown an exception: {e.Message}");
                            }
                        }
                        Console.WriteLine();
                    }
                }
            }]]>
            
            // The example displays the following output:
            //  ____Resources in .resx:____
            // Name: string
            //   Type:
            //   Alias value:
            //   MIME type:
            //   Comment:     Default data type is string.
            //   Raw value:   Test string
            //   Real value:  Test string (System.String)
            // 
            // Name: int
            //   Type:        System.Int32
            //   Alias value:
            //   MIME type:
            //   Comment:
            //   Raw value:   42
            //   Real value:  42 (System.Int32)
            // 
            // Name: color
            //   Type:        System.Drawing.Color, CustomAlias
            //   Alias value: System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
            //   MIME type:
            //   Comment:     When this entry is deserialized in an unsafe way, System.Drawing assembly will be loaded.
            //   Raw value:   Red
            //   Safe deserialization of the node thrown an exception: Type "System.Drawing.Color, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" in the data at line 18, position 4 cannot be resolved.
            // You may try to preload its assembly before deserialization or use the unsafe GetValue if the resource is from a trusted source.
            //   Real value (unsafe):  Color[Red] (System.Drawing.Color)
            // 
            // Name: bytes
            //  Type:        System.Byte[]
            //  Alias value:
            //   MIME type:
            //   Comment:
            //   Raw value:   VGVzdCBieXRlcw==
            //   Real value:  System.Byte[] (System.Byte[])
            // 
            // Name: dangerous
            //   Type:
            //   Alias value:
            //   MIME type:   application/x-microsoft.net.object.binary.base64
            //   Comment:     BinaryFormatter will throw an exception for this invalid content.
            //   Raw value:   YmluYXJ5
            //   Safe deserialization of the node thrown an exception: End of Stream encountered before parsing was completed.
            //   Unsafe deserialization of the node thrown an exception: End of Stream encountered before parsing was completed.
            // 
            // ____Metadata in .resx:____
            // Name: meta string
            //   Type:
            //   Alias value:
            //   MIME type:
            //   Comment:
            //   Raw value:   Meta String
            //   Real value:  Meta String (System.String) </code>
            </example>
            <h2 class="heading">Comparison with System.Resources.ResXDataNode<a name="comparison">&#160;</a></h2>
            <para>
            If instantiated from a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>
            instance, an internal conversion into <see cref="T:KGySoft.Resources.ResXDataNode">KGySoft.Resources.ResXDataNode</see> and <see cref="T:KGySoft.Resources.ResXFileRef">KGySoft.Resources.ResXFileRef</see> automatically occurs.
            <note>The compatibility with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a> is provided without any reference to <c>System.Windows.Forms.dll</c>, where that type is located.</note>
            </para>
            <para>Unlike <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>, this <see cref="T:KGySoft.Resources.ResXDataNode"/> implementation
            really preserves the original information stored in the .resx file. No deserialization, assembly loading and type resolving occurs until a deserialization is explicitly
            requested by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> methods.</para>
            <note>When serialized in compatibility mode (see <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat">ResXResourceWriter.CompatibleFormat</see>, <see cref="O:KGySoft.Resources.ResXResourceSet.Save">ResXResourceSet.Save</see>, <see cref="M:KGySoft.Resources.ResXResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">ResXResourceManager.SaveResourceSet</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.SaveAllResources(System.Boolean,System.Boolean)">ResXResourceManager.SaveAllResources</see>),
            the result will be able to be parsed by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a> type, too.</note>
            <para><strong>Incompatibility</strong> with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>:
            <list type="bullet">
            <item><see cref="P:KGySoft.Resources.ResXDataNode.Name"/> property is read-only. If you want to use a new name, instantiate a new <see cref="T:KGySoft.Resources.ResXDataNode"/> instance by the <see cref="M:KGySoft.Resources.ResXDataNode.#ctor(System.String,System.Object)">ResXDataNode(string, object)</see> constructor and pass the new name and the original <see cref="T:KGySoft.Resources.ResXDataNode"/> as parameters.</item>
            <item>There are no <strong>GetValueTypeName</strong> methods. The problem with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode.getvaluetypename" target="_blank">System.Resources.ResXDataNode.GetValueTypeName</a>
            methods is that they are unsafe as they may deserialize the inner object, load assemblies and can throw various unexpected exceptions.
            Instead, you can read the original type information stored in the .resx file by <see cref="P:KGySoft.Resources.ResXDataNode.TypeName"/> and <see cref="P:KGySoft.Resources.ResXDataNode.AssemblyAliasValue"/> properties. Based on the
            retrieved information you can decide whether you really want to deserialize the object by the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> method.
            </item>
            <item>There is no <strong>GetValue</strong> method with <see cref="T:System.Reflection.AssemblyName">AssemblyName[]</see> argument. That overload ended up using the obsolete
            <see cref="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">Assembly.LoadWithPartialName</see> method. The weakly referenced assemblies however are handled automatically
            by using <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method so this overload is actually not needed.</item>
            <item>The <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> method has three parameters instead of one. But all of them are optional so if called from a regular C# code, the method is compatible with
            the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode.getvalue" target="_blank">System.Resources.ResXDataNode.GetValue(ITypeResolutionService)</a> method.</item>
            <item>There are no public constructors with <see cref="T:System.Func`2">Func&lt;Type, string&gt;</see> arguments. In the system version these <c>typeNameConverter</c> parameters are used exclusively by non-public methods, which are
            called by the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> class. But you can pass such a custom <c>typeNameConverter</c> to the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> constructors.</item>
            <item>There is no <strong>GetNodePosition</strong> method because it returned a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.drawing.point" target="_blank">Point</a> structure
            from the <c>System.Drawing</c> assembly, which is not referenced by this library. Use <see cref="M:KGySoft.Resources.ResXDataNode.GetNodeLinePosition">GetNodeLinePosition</see> and <see cref="M:KGySoft.Resources.ResXDataNode.GetNodeColumnPosition">GetNodeColumnPosition</see> methods instead.</item>
            <item>The <see cref="P:KGySoft.Resources.ResXDataNode.FileRef"/> property returns the same reference during the lifetime of the <see cref="T:KGySoft.Resources.ResXDataNode"/> instance. This is alright as <see cref="T:KGySoft.Resources.ResXFileRef"/> is immutable.
            Unlike the system version, the <see cref="P:KGySoft.Resources.ResXDataNode.FileRef"/> property in this <see cref="T:KGySoft.Resources.ResXDataNode"/> contains exactly the same type information as the original .resx file.</item>
            <item>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode.getvalue" target="_blank">System.Resources.ResXDataNode.GetValue</a> method often throws <see cref="T:System.Xml.XmlException"/> if the node contains invalid data. In contrast,
            this <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> implementation may throw <see cref="T:System.Xml.XmlException"/>, <see cref="T:System.TypeLoadException"/>, <see cref="T:System.Runtime.Serialization.SerializationException"/> or <see cref="T:System.NotSupportedException"/> instead, depending on the actual issue.</item>
            </list></para>
            <para><strong>New features and improvements</strong> compared to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>:
            <list type="bullet">
            <item><term>Preserving original type information</term>
            <description>The originally stored type information, MIME type and the current assembly alias are preserved (see <see cref="P:KGySoft.Resources.ResXDataNode.TypeName"/>, <see cref="P:KGySoft.Resources.ResXDataNode.MimeType"/> and <see cref="P:KGySoft.Resources.ResXDataNode.AssemblyAliasValue"/> properties).
            The system version may replace type information with assembly qualified names when the .resx file is parsed. If the assembly qualified name is really needed, you can get it
            after explicit deserialization by calling <see cref="P:System.Type.AssemblyQualifiedName">GetType().AssemblyQualifiedName</see> on the <see cref="T:System.Object"/> returned by the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> method.</description></item>
            <item><term>Raw content</term><description>You can use the <see cref="P:KGySoft.Resources.ResXDataNode.ValueData"/> property to read the original raw <see cref="T:System.String"/> content stored in the .resx file for this element.</description></item>
            <item><term>Advanced string representation</term><description>The <see cref="M:KGySoft.Resources.ResXDataNode.ToString">ToString</see> method displays the string representation (either of the deserialized object if already cached, or the raw content) so can be used easily in a format argument and provides more debugging information.</description></item>
            <item><term>Security</term>
            <description>No deserialization, assembly loading and type resolving occurs until a deserialization is explicitly requested by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> methods.
            If you use the <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> method, then it is guaranteed that no new assembly is loaded during the deserialization, even if the resource was serialized by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
            Additionally, you can check the <see cref="P:KGySoft.Resources.ResXDataNode.TypeName"/>, <see cref="P:KGySoft.Resources.ResXDataNode.MimeType"/> and <see cref="P:KGySoft.Resources.ResXDataNode.AssemblyAliasValue"/> properties to get information
            about the type before obtaining the object. You can even check the raw string content by the <see cref="P:KGySoft.Resources.ResXDataNode.ValueData"/> property.
            </description></item>
            <item><term>Performance</term>
            <description>As there is no deserialization and assembly/type resolving during parsing a .resx file by the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class, the parsing is
            much faster. This is true even if <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode">ResXResourceReader.SafeMode</see> is <see langword="false"/>, because there are always <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instances stored internally and deserialization occurs only when a resource is actually accessed.</description></item>
            <item><term>Support of non-serializable types</term>
            <description>When serializing an object, the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a> type
            throws an <see cref="T:System.InvalidOperationException"/> for non-serializable types. This implementation can serialize also such types even if compatibility mode is used
            (see <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat">ResXResourceWriter.CompatibleFormat</see> property and the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">ResXResourceSet.Save</see> methods).
            In compatibility mode this is achieved by wrapping the non-serializable types into an <see cref="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper"/> instance so the <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> will
            able to handle them, too.</description></item>
            <item><term>Support of generics</term>
            <description>This <see cref="T:KGySoft.Resources.ResXDataNode"/> class uses a special <see cref="T:System.Runtime.Serialization.SerializationBinder"/> implementation, which supports generic types correctly.</description></item>
            </list></para>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXFileRef"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceSet"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceManager"/>
            <seealso cref="T:KGySoft.Resources.HybridResourceManager"/>
            <seealso cref="T:KGySoft.Resources.DynamicResourceManager"/>
        </member>
        <member name="T:KGySoft.Resources.ResXDataNode.ResXSerializationBinder">
            <summary>
            A partial type resolver for the formatters for a custom <see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> type resolver (deserialization) or
            a type name converter (serialization). For deserialization if there is no type resolver a <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> is used instead.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.ResXSerializationBinder.#ctor(System.ComponentModel.Design.ITypeResolutionService,System.Boolean)">
            <summary>
            This is the constructor for deserialization
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.ResXSerializationBinder.#ctor(System.Func{System.Type,System.String},System.Boolean)">
            <summary>
            This is the constructor for serialization
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXDataNode.assemblyQualifiedName">
            <summary>
            The cached assembly qualified name of the value. For FileRef it is initialized as FileRef and once the value
            is retrieved it returns the real type of the value.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXDataNode.aqnValid">
            <summary>
            Gets whether the <see cref="F:KGySoft.Resources.ResXDataNode.assemblyQualifiedName"/> is from a real type. It is false if the <see cref="F:KGySoft.Resources.ResXDataNode.assemblyQualifiedName"/>
            is created from a string or is FileRef.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXDataNode.rawValue">
            <summary>
            May contain a cached serialized value of <see cref="F:KGySoft.Resources.ResXDataNode.cachedValue"/> for cloning a bit faster. If null, can be restored.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.Comment">
            <summary>
            Gets or sets an arbitrary comment regarding this resource.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.Name">
            <summary>
            Gets the name of this resource.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.FileRef">
            <summary>
            Gets the file reference for this resource, or <see langword="null"/>, if this resource does not have a file reference.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.AssemblyAliasValue">
            <summary>
            Gets the assembly name defined in the source .resx file if <see cref="P:KGySoft.Resources.ResXDataNode.TypeName"/> contains an assembly alias name,
            or <see langword="null"/>, if <see cref="P:KGySoft.Resources.ResXDataNode.TypeName"/> contains the assembly qualified name.
            If the resource does not contain the .resx information (that is, if the <see cref="T:KGySoft.Resources.ResXDataNode"/> was created from an object or the raw .resx data was removed on a <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> call), then this property returns <see langword="null"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.TypeName">
            <summary>
            Gets the type information as <see cref="T:System.String"/> as it is stored in the source .resx file. It can be either an assembly qualified name,
            or a type name with or without an assembly alias name. If <see cref="P:KGySoft.Resources.ResXDataNode.AssemblyAliasValue"/> is not <see langword="null"/>, this property value
            contains an assembly alias name. The property returns <see langword="null"/>, if the <c>type</c> attribute is not defined in the .resx file.
            If the resource does not contain the .resx information (that is, if the <see cref="T:KGySoft.Resources.ResXDataNode"/> was created from an object or the raw .resx data was removed on a <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> call), then this property returns <see langword="null"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.MimeType">
            <summary>
            Gets the MIME type as it is stored in the .resx file for this resource, or <see langword="null"/>, if the <c>mimetype</c> attribute was not defined in the .resx file.
            If the resource does not contain the .resx information (that is, if the <see cref="T:KGySoft.Resources.ResXDataNode"/> was created from an object or the raw .resx data was removed on a <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> call), then this property returns <see langword="null"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.ValueData">
            <summary>
            Gets the raw value data as <see cref="T:System.String"/> as it was stored in the source .resx file.
            If the resource does not contain the .resx information (that is, if the <see cref="T:KGySoft.Resources.ResXDataNode"/> was created from an object or the raw .resx data was removed on a <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> call), then this property returns <see langword="null"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXDataNode.AssemblyQualifiedName">
            <summary>
            Gets the assembly qualified name of the node, or null, if type cannot be determined until deserialized.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXDataNode"/> class.
            </summary>
            <param name="name">The name of the resource.</param>
            <param name="value">The resource to store.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is a string of zero length.</exception>
            <remarks>
            <para>Unlike <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>,
            <see cref="T:KGySoft.Resources.ResXDataNode">KGySoft.Resources.ResXDataNode</see> supports non-serializable types, too. See the details in the <strong>Remarks</strong>
            section of the <see cref="T:KGySoft.Resources.ResXDataNode"/>.</para>
            <para>If <paramref name="value"/> is another <see cref="T:KGySoft.Resources.ResXDataNode"/> instance the new <see cref="T:KGySoft.Resources.ResXDataNode"/> instance will be a copy of it with a possibly new name specified in the <paramref name="name"/> parameter.
            A <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a> instance is also recognized.
            <note>The compatibility with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a> is provided without any reference to <c>System.Windows.Forms.dll</c>, where that type is located.</note>
            </para>
            <para>If <paramref name="value"/> is a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance, the new <see cref="T:KGySoft.Resources.ResXDataNode"/> will refer to a file reference.
            A <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> instance is also recognized.
            For <see cref="T:KGySoft.Resources.ResXFileRef"/> a <paramref name="value"/> with relative path you might want to use the <see cref="M:KGySoft.Resources.ResXDataNode.#ctor(System.String,KGySoft.Resources.ResXFileRef,System.String)">ResXDataNode(string, ResXFileRef, string)</see> constructor where you can specify a base path.
            <note>The compatibility with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> is provided without any reference to <c>System.Windows.Forms.dll</c>, where that type is located.</note>
            </para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.#ctor(System.String,KGySoft.Resources.ResXFileRef,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXDataNode"/> class with a reference to a resource file.
            </summary>
            <param name="name">The name of the resource.</param>
            <param name="fileRef">The file reference.</param>
            <param name="basePath">A default base path for the relative path defined in <paramref name="fileRef"/>. This can be overridden on calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> method.
            <br/>Default value: <see langword="null"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> or <paramref name="fileRef"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name"/> is a string of zero length.</exception>
            <exception cref="T:System.ArgumentException">name</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.#ctor(KGySoft.Resources.DataNodeInfo,System.String)">
            <summary>
            Called by <see cref="T:KGySoft.Resources.ResXResourceReader"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetTypeName(KGySoft.Resources.DataNodeInfo)">
            <summary>
            Gets the type name stored in the node or string, which is the default type.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetNodeLinePosition">
            <summary>
            Retrieves the line position of the resource in the resource file.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> that specifies the line position of this resource in the resource file.
            If the resource does not contain the .resx information (that is, if the <see cref="T:KGySoft.Resources.ResXDataNode"/> was created from an object or the raw .resx data was removed on a <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> call), then this method returns 0.
            </returns>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetNodeColumnPosition">
            <summary>
            Retrieves the column position of the resource in the resource file.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> that specifies the column position of this resource in the resource file.
            If the resource does not contain the .resx information (that is, if the <see cref="T:KGySoft.Resources.ResXDataNode"/> was created from an object or the raw .resx data was removed on a <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> call), then this method returns 0.
            </returns>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">
            <summary>
            Retrieves the object that is stored by this node.
            </summary>
            <returns>The object that corresponds to the stored value.</returns>
            <param name="typeResolver">A custom type resolution service to use for resolving type names.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="basePath">Defines a base path for file reference values. Used when <see cref="P:KGySoft.Resources.ResXDataNode.FileRef"/> is not <see langword="null"/>.
            If this parameter is <see langword="null"/>, tries to use the original base path, if any.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="cleanupRawData"><see langword="true"/> to free the underlying XML data once the value is deserialized; otherwise, <see langword="false"/>.
            <br/>Default value: <see langword="false"/>.</param>
            <exception cref="T:System.TypeLoadException">The corresponding type or its container assembly could not be loaded.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">An error occurred during the binary deserialization of the resource.</exception>
            <exception cref="T:System.IO.FileNotFoundException">The resource is a file reference and the referenced file cannot be found.</exception>
            <exception cref="T:System.NotSupportedException">Unsupported MIME type or an appropriate type converter is not available.</exception>
            <remarks>
            <note type="security">When using this method make sure that the .resx data to be deserialized is from a trusted source.
            This method might load assemblies during type resolve. To disallow loading assemblies use the <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> method instead.</note>
            <para>If the stored value currently exists in memory, it is returned directly.</para>
            <para>If the resource is a file reference, <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> tries to open the file and deserialize its content.</para>
            <para>If the resource is not a file reference, <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> tries to deserialize the value from the raw .resx string content.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">
            <summary>
            Retrieves the object that is stored by this node, not allowing loading assemblies during the possible deserialization.
            </summary>
            <returns>The object that corresponds to the stored value.</returns>
            <param name="typeResolver">A custom type resolution service to use for resolving type names.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="basePath">Defines a base path for file reference values. Used when <see cref="P:KGySoft.Resources.ResXDataNode.FileRef"/> is not <see langword="null"/>.
            If this parameter is <see langword="null"/>, tries to use the original base path, if any.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="cleanupRawData"><see langword="true"/> to free the underlying XML data once the value is deserialized; otherwise, <see langword="false"/>.
            <br/>Default value: <see langword="false"/>.</param>
            <exception cref="T:System.TypeLoadException">The corresponding type or its container assembly could not be loaded.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">An error occurred during the binary deserialization of the resource.</exception>
            <exception cref="T:System.IO.FileNotFoundException">The resource is a file reference and the referenced file cannot be found.</exception>
            <exception cref="T:System.NotSupportedException">Unsupported MIME type or an appropriate type converter is not available.</exception>
            <remarks>
            <note type="security">When using this method it is guaranteed that no new assembly is loaded during the deserialization, unless it is resolved by the specified <paramref name="typeResolver"/>.
            To allow loading assemblies use the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValue</see> method instead.</note>
            <para>If the stored value currently exists in memory, it is returned directly.</para>
            <para>If the resource is a file reference, <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> tries to open the file and deserialize its content.
            The deserialization will fail if the assembly of the type to create type is not already loaded.</para>
            <para>If the resource is not a file reference, <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> tries to deserialize the value from the raw .resx string content.
            The deserialization will fail if the assembly of the type to create type is not already loaded.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>The string representation of this <see cref="T:KGySoft.Resources.ResXDataNode"/>.</returns>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.Clone">
            <summary>
            Creates a new <see cref="T:KGySoft.Resources.ResXDataNode"/> that is a copy of the current instance.
            </summary>
            <returns>
            A new <see cref="T:KGySoft.Resources.ResXDataNode"/> instance that is a copy of this instance.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetSafeValueInternal(System.Boolean,System.Boolean)">
            <summary>
            Called from <see cref="T:KGySoft.Resources.ResXResourceSet"/> when <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetUnsafeValueInternal(System.ComponentModel.Design.ITypeResolutionService,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Called from <see cref="T:KGySoft.Resources.ResXResourceSet"/> when <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.GetDataNodeInfo(System.Func{System.Type,System.String},System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets or (re)generates the nodeInfo. Parameters are not null only if called from a <see cref="T:KGySoft.Resources.ResXResourceWriter"/>.
            <paramref name="safeMode"/> is relevant only when <paramref name="compatibleFormat"/> is changed to true and there is no cached value yet.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXDataNode.InitNodeInfo(System.Func{System.Type,System.String},System.Boolean)">
            <summary>
            (Re)generates the nodeInfo from a value.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXFileRef">
            <summary>
            Represents a link to an external resource.
            </summary>
            <remarks>
            <note>This class is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>
            in <c>System.Windows.Forms.dll</c>. See the <a href="#comparison">Comparison with System.Resources.ResXFileRef</a> section for the differences.</note>
            <para>The <see cref="T:KGySoft.Resources.ResXFileRef"/> class is used to include references to files in an XML resource (.resx) file.
            A <see cref="T:KGySoft.Resources.ResXFileRef"/> object represents a link to an external resource in an XML resource (.resx) file.
            You can add a <see cref="T:KGySoft.Resources.ResXFileRef"/> object to a .resx file programmatically by one of the following options:
            <list type="bullet">
            <item>Call the <see cref="M:KGySoft.Resources.ResXResourceWriter.AddResource(System.String,System.Object)">ResXResourceWriter.AddResource(string, object)</see> method where the second parameter is a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance.</item>
            <item>Call the <see cref="M:KGySoft.Resources.ResXResourceSet.SetObject(System.String,System.Object)">ResXResourceSet.SetObject(string, object)</see> method where the second parameter is a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance and then save the <see cref="T:KGySoft.Resources.ResXResourceSet"/> instance.</item>
            <item>Call the <see cref="M:KGySoft.Resources.ResXResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">ResXResourceManager.SetObject(string, object, CultureInfo)</see> method where the second parameter is a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance and then save the <see cref="T:KGySoft.Resources.ResXResourceManager"/> instance.</item>
            <item>Call the <see cref="M:KGySoft.Resources.HybridResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">HybridResourceManager.SetObject(string, object, CultureInfo)</see> method where the second parameter is a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance and then save the <see cref="T:KGySoft.Resources.HybridResourceManager"/> instance.</item>
            <item>Call the <see cref="M:KGySoft.Resources.DynamicResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">HybridResourceManager.SetObject(string, object, CultureInfo)</see> method where the second parameter is a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance and then save the <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instance.</item>
            </list>
            </para>
            <h2>Comparison with System.Resources.ResXFileRef<a name="comparison">&#160;</a></h2>
            <note>The compatibility with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> is provided without any reference to <c>System.Windows.Forms.dll</c>, where that type is located.</note>
            <note>When serialized in compatibility mode (see <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat">ResXResourceWriter.CompatibleFormat</see>, <see cref="O:KGySoft.Resources.ResXResourceSet.Save">ResXResourceSet.Save</see>,
            <see cref="M:KGySoft.Resources.ResXResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">ResXResourceManager.SaveResourceSet</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.SaveAllResources(System.Boolean,System.Boolean)">ResXResourceManager.SaveAllResources</see>),
            the result will be able to be parsed by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> type, too.</note>
            <para><strong>Incompatibility</strong> with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>:
            <list type="bullet">
            <item>The <see cref="M:KGySoft.Resources.ResXFileRef.#ctor(System.String,System.Type,System.Text.Encoding)">constructor</see> is incompatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>
            implementation. Unlike in system version you must specify the type by a <see cref="T:System.Type"/> instance instead of a string.</item>
            </list></para>
            <para><strong>New features and improvements</strong> compared to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>:
            <list type="bullet">
            <item><term>Parsing</term><description>A string can parsed to a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance by <see cref="M:KGySoft.Resources.ResXFileRef.Parse(System.String)"/> and <see cref="M:KGySoft.Resources.ResXFileRef.TryParse(System.String,KGySoft.Resources.ResXFileRef@)"/> methods.</description></item>
            </list></para>
            <note type="security">The <see cref="T:System.ComponentModel.TypeConverter"/> that is assigned to the <see cref="T:KGySoft.Resources.ResXFileRef"/> type may load assemblies when its <see cref="M:System.ComponentModel.TypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">ConvertFrom</see> method is called.
            The recommended way to retrieve a file resource is via the <see cref="T:KGySoft.Resources.ResXDataNode"/> class. Its <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">GetValueSafe</see> method guarantees that no assembly is loaded
            during the deserialization, including retrieving resources from file references.</note>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceSet"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceManager"/>
            <seealso cref="T:KGySoft.Resources.HybridResourceManager"/>
        </member>
        <member name="P:KGySoft.Resources.ResXFileRef.FileName">
            <summary>
            Gets the file name specified in the <see cref="M:KGySoft.Resources.ResXFileRef.#ctor(System.String,System.Type,System.Text.Encoding)">constructor</see>.
            </summary>
            <returns>
            The name of the referenced file.
            </returns>
        </member>
        <member name="P:KGySoft.Resources.ResXFileRef.TypeName">
            <summary>
            Gets the type name specified in the <see cref="M:KGySoft.Resources.ResXFileRef.#ctor(System.String,System.Type,System.Text.Encoding)">constructor</see>.
            </summary>
            <returns>
            The type name of the resource that is referenced.
            </returns>
        </member>
        <member name="P:KGySoft.Resources.ResXFileRef.TextFileEncoding">
            <summary>
            Gets the encoding specified in the <see cref="M:KGySoft.Resources.ResXFileRef.#ctor(System.String,System.Type,System.Text.Encoding)">constructor</see>.
            </summary>
            <returns>
            The encoding used in the referenced file.
            </returns>
        </member>
        <member name="M:KGySoft.Resources.ResXFileRef.#ctor(System.String,System.Type,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXFileRef"/> class that references the specified file.
            </summary>
            <param name="fileName">The file to reference. </param>
            <param name="type">The type of the resource that is referenced. Should be either <see cref="T:System.String"/>, array of <see cref="T:System.Byte"/>, <see cref="T:System.IO.MemoryStream"/> or a type, which has a constructor with one <see cref="T:System.IO.Stream"/> parameter.</param>
            <param name="textFileEncoding">The encoding used in the referenced file. Used if <paramref name="type"/> is <see cref="T:System.String"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXFileRef.Parse(System.String)">
            <summary>
            Converts the string representation of a file reference to a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance.
            </summary>
            <param name="s">The string representation of the file reference to convert.</param>
            <returns>A <see cref="T:KGySoft.Resources.ResXFileRef"/> instance that represents the file reference specified in <paramref name="s"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="s"/> is contains invalid value.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXFileRef.TryParse(System.String,KGySoft.Resources.ResXFileRef@)">
            <summary>
            Converts the string representation of a file reference to a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance. A return value indicates whether the conversion succeeded.
            </summary>
            <param name="s">The string representation of the file reference to convert.</param>
            <param name="result">When this method returns, contains a <see cref="T:KGySoft.Resources.ResXFileRef"/> instance that represents the file reference specified in <paramref name="s"/>,
            if the conversion succeeded, or <see langword="null"/> if the conversion failed.</param>
            <returns><see langword="true"/> if <paramref name="s"/> was converted successfully; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Resources.ResXFileRef.ToString">
            <summary>
            Gets the text representation of the current <see cref="T:KGySoft.Resources.ResXFileRef"/> object.
            </summary>
            <returns>
            A string that consists of the concatenated text representations of the parameters specified in the <see cref="M:KGySoft.Resources.ResXFileRef.#ctor(System.String,System.Type,System.Text.Encoding)">constructor</see>.
            </returns>
        </member>
        <member name="P:KGySoft.Resources.ResXNullRef.Value">
            <summary>
            Represents the sole instance of <see cref="T:KGySoft.Resources.ResXNullRef"/> class.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceEnumerator">
            <summary>
            Provides an enumerator for .resx resource classes, which have already cached resource data.
            Non-serializable (the original returns a ListDictionary enumerator, which is non-serializable either - and hybrid cannot be serializable either).
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceEnumerator.#ctor(KGySoft.Resources.IResXResourceContainer,KGySoft.Resources.ResXEnumeratorModes,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceEnumerator"/> class.
            Should be called from lock.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceManager">
            <summary>
            Represents a resource manager that provides convenient access to culture-specific XML resources (.resx files) at run time.
            New elements can be added as well, which can be saved into the <c>.resx</c> files.
            </summary>
            <remarks>
            <para><see cref="T:KGySoft.Resources.ResXResourceManager"/> class is derived from <see cref="T:System.Resources.ResourceManager"/> so it can be used the same way.
            The main difference is that instead of working with binary compiled resources the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class uses XML resources (.resx files) directly.
            As an <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> implementation it is able to add/replace/remove entries in the resource sets belonging to specified cultures and it can save the changed contents.</para>
            <para>See the <a href="#comparison">Comparison with ResourceManager</a> section to see all of the differences.</para>
            <note type="tip">To see when to use the <see cref="T:KGySoft.Resources.ResXResourceReader"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, <see cref="T:KGySoft.Resources.ResXResourceSet"/>, <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
            classes see the documentation of the <see cref="N:KGySoft.Resources">KGySoft.Resources</see> namespace.</note>
            <h2>Example: Using XML resources created by Visual Studio</h2>
            <para>You can create XML resource files by Visual Studio and you can use them by <see cref="T:KGySoft.Resources.ResXResourceManager"/>. See the following example for a step-by-step guide.
            <list type="number">
            <item>Create a new project (Console Application)
            <br/><img src="../Help/Images/NewConsoleApp.png" alt="New console application"/></item>
            <item>In Solution Explorer right click on <c>ConsoleApp1</c>, Add, New Folder, name it <c>Resources</c>.</item>
            <item>In Solution Explorer right click on <c>Resources</c>, Add, New Item, Resources File.
            <br/><img src="../Help/Images/NewResourcesFile.png" alt="New Resources file"/></item>
            <item>In Solution Explorer right click on the new resource file (<c>Resource1.resx</c> if not named otherwise) and select Properties</item>
            <item>The default value of <c>Build Action</c> is <c>Embedded Resource</c>, which means that the resource will be compiled into the assembly and will be able to be read by the <see cref="T:System.Resources.ResourceManager"/> class.
            To be able to handle it by the <see cref="T:KGySoft.Resources.ResXResourceManager"/> we might want to deploy the .resx file with the application. To do so, select <c>Copy if newer</c> at <c>Copy to Output directory</c>.
            If we want to use purely the .resx file, then we can change the <c>Build Action</c> to <c>None</c> and we can clear the default <c>Custom Tool</c> value because we do not need the generated file.
            <br/><img src="../Help/Images/ResourceFileProperties_ResXResourceManager.png" alt="Resources1.resx properties"/>
            <note>To use both the compiled binary resources and the .resx file you can use the <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/> classes.</note></item>
            <item>Now we can either use the built-on resource editor of Visual Studio or just edit the .resx file by the XML Editor. If we add new or existing files to the resources, they will be automatically added to the project's Resources folder.
            Do not forget to set <c>Copy if newer</c> for the linked resources as well so they will be copied to the output directory along with the .resx file. Now add some string resources and files if you wish.</item>
            <item>To add culture-specific resources you can add further resource files with the same base name, extended by culture names. For example, if the invariant resource is called <c>Resource1.resx</c>, then a
            region neutral English resource can be called <c>Resource1.en.resx</c> and the American English resource can be called <c>Resource1.en-US.resx</c>.</item>
            <item>Reference <c>KGySoft.CoreLibraries.dll</c> and paste the following code in <c>Program.cs</c>:</item>
            </list></para>
            <code lang="C#"><![CDATA[
            using System;
            using System.Globalization;
            using KGySoft;
            using KGySoft.Resources;
            
            public class Program
            {
                public static void Main()
                {
                    var enUS = CultureInfo.GetCultureInfo("en-US");
                    var en = enUS.Parent;
            
                    // The base name parameter is the name of the resource file without extension and culture specifier.
                    // The ResXResourcesDir property denotes the relative path to the resource files.
                    // Actually "Resources" is the default value.
                    var resourceManager = new ResXResourceManager(baseName: "Resource1") { ResXResourcesDir = "Resources" };
            
                    // Tries to get the resource from Resource1.en-US.resx, then Resource1.en.resx, then Resource1.resx
                    // and writes the result to the console.
                    Console.WriteLine(resourceManager.GetString("String1", enUS));
            
                    // Sets the UI culture (similarly to Thread.CurrentThread.CurrentUICulture) so now this is the default
                    // culture for looking up resources.
                    LanguageSettings.DisplayLanguage = en;
            
                    // The Current UI Culture is now en so tries to get the resource from Resource1.en.resx, then Resource1.resx
                    // and writes the result to the console.
                    Console.WriteLine(resourceManager.GetString("String1"));
                }
            }]]>
            
            // A possible result of the example above (depending on the created resource files and the added content)
            // 
            // Test string in en-US resource set.
            // Test string in en resource set.</code>
            <para>Considering there are .resx files in the background not just <see cref="T:System.String"/> and other <see cref="T:System.Object"/> resources
            can be obtained by <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> and <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> methods
            but metadata as well by <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods. Please note that accessing aliases are not exposed
            by the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class, but you can still access them via the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> type returned by the <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method.
            <note>Please note that unlike in case of <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> and <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> methods,
            there is no falling back to the parent cultures (as seen in the example above) for metadata accessed by the <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods.</note></para>
            <h2>Instantiating a <see cref="T:KGySoft.Resources.ResXResourceManager"/> object</h2>
            <para>You instantiate a <see cref="T:KGySoft.Resources.ResXResourceManager"/> object that retrieves resources from .resx files by calling one of its class constructor overloads.
            This tightly couples a <see cref="T:KGySoft.Resources.ResXResourceManager"/> object with a particular set of .resx files (see the previous example as well).</para>
            <para>There are three possible constructors to use:
            <list type="bullet">
            <item><see cref="M:KGySoft.Resources.ResXResourceManager.#ctor(System.String,System.Globalization.CultureInfo)">ResXResourceManager(baseName string, CultureInfo neutralResourcesLanguage = null)</see>
            looks up resources in <c>baseName.cultureName.resx</c> files, where <c>baseName.resx</c> contains the resource set of the ultimate fallback culture (also known as default or invariant or neutral resources culture).
            If <c>neutralResourcesLanguage</c> is specified, then <see cref="T:KGySoft.Resources.ResXResourceManager"/> will use the <c>baseName.resx</c> file when the culture to be used equals to the <c>neutralResourcesLanguage</c>.
            If <c>neutralResourcesLanguage</c> is not specified, then the default culture is auto detected by the current application's <see cref="T:System.Resources.NeutralResourcesLanguageAttribute"/>.
            If it is not defined, then <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> will be used as default culture.
            <code lang="C#">var manager = new ResXResourceManager("MyResources", CultureInfo.GetCultureInfo("en-US"));</code></item>
            <item><see cref="M:KGySoft.Resources.ResXResourceManager.#ctor(System.String,System.Reflection.Assembly)">ResXResourceManager(baseName string, Assembly assembly)</see> is similar to the previous one, except that
            it does not set the default culture explicitly but tries to detect it from the provided <see cref="T:System.Reflection.Assembly"/>. If it has a <see cref="T:System.Resources.NeutralResourcesLanguageAttribute"/> defined,
            then it will be used; otherwise, the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> will be used as the default culture.
            <code lang="C#">var manager = new ResXResourceManager("MyResources", typeof(Example).Assembly);</code></item>
            <item><see cref="M:KGySoft.Resources.ResXResourceManager.#ctor(System.Type)">ResXResourceManager(Type resourceSource)</see> will use the name of the provided <see cref="T:System.Type"/> as base name, and its <see cref="T:System.Reflection.Assembly"/> to detect the default culture.
            <code lang="C#">var manager = new ResXResourceManager(typeof(Example));</code></item></list></para>
            <para><note>If a <see cref="T:KGySoft.Resources.ResXResourceManager"/> instance is created with a <c>baseName</c> without corresponding .resx file for the default culture, then accessing a non-existing
            resource will throw a <see cref="T:System.Resources.MissingManifestResourceException"/> unless <see cref="P:KGySoft.Resources.ResXResourceManager.ThrowException"/> property is <see langword="false"/>, in which case only a <see langword="null"/> value will be
            returned in such case. The exception can be avoided, if a resource set is created for the default culture either by adding a new resource (see next section) or by creating the resource set
            explicitly by calling the <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method with <see cref="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists"/> behavior.</note></para>
            <h2>Example: Adding and saving new resources at runtime</h2>
            <para>As <see cref="T:KGySoft.Resources.ResXResourceManager"/> maintains <see cref="T:KGySoft.Resources.ResXResourceSet"/> instances for each culture, it also supports adding new resources at runtime.
            By <see cref="M:KGySoft.Resources.ResXResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see> method you can add a resource to a specific culture. You can add metadata as well by <see cref="M:KGySoft.Resources.ResXResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">SetMetaObject</see> method.
            The resources and metadata can be removed, too (see <see cref="M:KGySoft.Resources.ResXResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">RemoveMetaObject</see> methods).</para>
            <para>The changes in the resource sets can be saved by calling the <see cref="M:KGySoft.Resources.ResXResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method. A single resource set can be saved
            by calling the <see cref="M:KGySoft.Resources.ResXResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">SaveResourceSet</see> method.
            <note>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> always saves the resources into files and never embeds the resources if they are file references (see <see cref="T:KGySoft.Resources.ResXFileRef"/>). If you need more control
            over saving you can call the <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method to access the various <see cref="O:KGySoft.Resources.IExpandoResourceSet.Save">Save</see> overloads)</note></para>
            <code lang="C#"><![CDATA[
            using System;
            using System.Globalization;
            using System.Resources;
            using KGySoft;
            using KGySoft.Resources;
            
            // You can put this into AssemblyInfo.cs. Indicates that the invariant (default) resource set uses the American English culture.
            // Try commenting out next line and see the differences.
            [assembly:NeutralResourcesLanguage("en-US")]
            
            public static class Example
            {
                private static CultureInfo enUS = CultureInfo.GetCultureInfo("en-US");
                private static CultureInfo en = enUS.Parent;
                private static CultureInfo invariant = en.Parent;
            
                // Now that we don't specify the neutralResourcesLanguage optional parameter it will be auto detected
                private static ResXResourceManager manager = new ResXResourceManager("NewResource");
            
                public static void Main()
                {
                    // If NewResource.resx does not exist yet a MissingManifestResourceException will be thrown here
                    DumpValue("unknown");
            
                    // This now creates the resource set for the default culture
                    manager.SetObject("StringValue", "This is a string in the default resource", invariant);
            
                    // No exception is thrown any more because the default resource set exists now.
                    DumpValue("unknown");
            
                    // If NeutralResourcesLanguage attribute above is active, invariant == enUS now. 
                    manager.SetObject("StringValue", "This is a string in the English resource", en);
                    manager.SetObject("StringValue", "This is a string in the American English resource", enUS);
            
                    manager.SetObject("IntValue", 42, invariant);
                    manager.SetObject("IntValue", 52, en);
                    manager.SetObject("IntValue", 62, enUS);
            
                    manager.SetObject("DefaultOnly", "This resource is the same everywhere", invariant);
            
                    DumpValue("StringValue", invariant);
                    DumpValue("StringValue", en);
                    DumpValue("StringValue", enUS);
            
                    DumpValue("IntValue", invariant);
                    DumpValue("IntValue", en);
                    DumpValue("IntValue", enUS);
            
                    DumpValue("DefaultOnly", invariant);
                    DumpValue("DefaultOnly", en);
                    DumpValue("DefaultOnly", enUS);
            
                    // This now creates NewResource.resx and NewResource.en.resx files
                    manager.SaveAllResources(compatibleFormat: true); // so the saved files can be edited by VisualStudio
                }
            
                private static void DumpValue(string name, CultureInfo culture = null)
                {
                    try
                    {
                        Console.WriteLine($"Value of resource '{name}' for culture '{culture ?? LanguageSettings.DisplayLanguage}': " +
                            $"{manager.GetObject(name, culture) ?? "<null>"}");
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine($"Accessing resource '{name}' caused an exception: {e.Message}");
                    }
                }
            }
            
            // If NeutralLanguagesResource is en-US, the example above produces the following output:
            // 
            // Accessing resource 'unknown' caused an exception: Resource file not found: D:\ConsoleApp1\bin\Debug\Resources\NewResource.resx
            // Value of resource 'unknown' for culture 'en-US': <null>
            // Value of resource 'StringValue' for culture '': This is a string in the American English resource
            // Value of resource 'StringValue' for culture 'en': This is a string in the English resource
            // Value of resource 'StringValue' for culture 'en-US': This is a string in the American English resource
            // Value of resource 'IntValue' for culture '': 62
            // Value of resource 'IntValue' for culture 'en': 52
            // Value of resource 'IntValue' for culture 'en-US': 62
            // Value of resource 'DefaultOnly' for culture '': This resource is the same everywhere
            // Value of resource 'DefaultOnly' for culture 'en': This resource is the same everywhere
            // Value of resource 'DefaultOnly' for culture 'en-US': This resource is the same everywhere]]></code>
            <h2>Safety<a name="safety">&#160;</a></h2>
            <para>Similarly to <see cref="T:KGySoft.Resources.ResXResourceSet"/> and <see cref="T:KGySoft.Resources.ResXResourceReader"/>, the <see cref="T:KGySoft.Resources.ResXResourceManager"/>
            class also has a <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> which changes the behavior of <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see>
            and <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see>
            methods:
            <list type="bullet">
            <item>If the <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> property is <see langword="true"/> the return value of <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see>
            and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods is a <see cref="T:KGySoft.Resources.ResXDataNode"/> rather than the resource or metadata value.
            This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source.
            The actual value can be obtained by the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.
            See also the third example at the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class.</item>
            <item>If the <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> property is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see>
            and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods will not throw an <see cref="T:System.InvalidOperationException"/>
            even for non-string entries; they return the raw XML value instead.</item>
            <item>If the <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> property is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see>
            and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> methods will not throw an <see cref="T:System.InvalidOperationException"/>.
            For values, which are neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see> instances, they return a stream wrapper for the same string value
            that is returned by the <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods.</item>
            </list>
            <note type="security">Even if <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/>, loading a .resx content with corrupt or malicious entry
            will have no effect until we try to obtain the corresponding value. See the last example at <see cref="T:KGySoft.Resources.ResXResourceSet"/> for the demonstration
            and the example at <see cref="T:KGySoft.Resources.ResXDataNode"/> to see what members can be checked in safe mode.
            </note>
            </para>
            <h2>Comparison with ResourceManager<a name="comparison">&#160;</a></h2>
            <para>While <see cref="T:System.Resources.ResourceManager"/> is read-only and works on binary resources, <see cref="T:KGySoft.Resources.ResXResourceManager"/> supports expansion (see <see cref="T:KGySoft.Resources.IExpandoResourceManager"/>) and works on XML resource (.resx) files.</para>
            <para><strong>Incompatibility</strong> with <see cref="T:System.Resources.ResourceManager"/>:
            <list type="bullet">
            <item>There is no constructor where the type of the resource sets can be specified. The <see cref="P:System.Resources.ResourceManager.ResourceSetType"/> property
            returns always the type of <see cref="T:KGySoft.Resources.ResXResourceSet"/>.</item>
            <item>If <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">ResourceManager.GetResourceSet</see> method is called with <c>createIfNotExists = false</c> for a culture,
            which has a corresponding but not loaded resource file, then a resource set for a parent culture might be cached and on successive calls that cached parent set will be
            returned even if the <c>createIfNotExists</c> argument is <see langword="true"/>. In <see cref="T:KGySoft.Resources.ResXResourceManager"/> the corresponding argument of
            the <see cref="M:KGySoft.Resources.ResXResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">GetResourceSet</see> method has been renamed to <c>loadIfExists</c> and works as expected.</item>
            <item>The <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> methods have <see cref="T:System.IO.MemoryStream"/> return type instead of <see cref="T:System.IO.UnmanagedMemoryStream"/> and they can be used also for <see cref="T:System.Array">byte[]</see> values.</item>
            </list></para>
            <para><strong>New features and improvements</strong> compared to <see cref="T:System.Resources.ResourceManager"/>:
            <list type="bullet">
            <item><term>Write support</term>
            <description>The stored content can be expanded or existing entries can be replaced (see <see cref="M:KGySoft.Resources.ResXResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">SetMetaObject</see>),
            the entries can be removed (see <see cref="M:KGySoft.Resources.ResXResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">RemoveMetaObject</see>),
            and the new content can be saved (see <see cref="M:KGySoft.Resources.ResXResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">SaveResourceSet</see>).
            You can start even with a completely empty manager, add content dynamically and save the new resources (see the example above).</description></item>
            <item><term>Security</term>
            <description>During the initialization of <see cref="T:KGySoft.Resources.ResXResourceManager"/> and loading of a resource set no object is deserialized even if <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/>
            property is <see langword="false"/>. Objects are deserialized only when they are accessed (see <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see>).
            If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then security is even more increased because <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods
            return a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of a deserialized object so you can check whether the resource or metadata
            can be treat as a safe object before actually deserializing it. See the <a href="#safety">Safety</a> section above for more details.</description></item>
            <item><term>Disposal</term>
            <description>As <see cref="T:System.Resources.ResourceSet"/> implementations are disposable objects, <see cref="T:KGySoft.Resources.ResXResourceManager"/> itself implements
            the <see cref="T:System.IDisposable"/> interface as well.</description></item>
            </list>
            </para>
            </remarks>
            <seealso cref="T:KGySoft.LanguageSettings"/>
            <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
            <seealso cref="T:KGySoft.Resources.ResXFileRef"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="T:KGySoft.Resources.ResXResourceSet"/>
            <seealso cref="T:KGySoft.Resources.HybridResourceManager"/>
            <seealso cref="T:KGySoft.Resources.DynamicResourceManager"/>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceManager.ProxyResourceSet">
            <summary>
            Represents a cached resource set for a child culture, which might be replaced later.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.ProxyResourceSet.ResXResourceSet">
            <summary>
            Gets the wrapped resource set. This is always a parent of <see cref="P:KGySoft.Resources.ResXResourceManager.ProxyResourceSet.WrappedCulture"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.ProxyResourceSet.WrappedCulture">
            <summary>
            Gets the culture of the wrapped resource set
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.ProxyResourceSet.CanHaveLoadableParent">
            <summary>
            Gets whether this proxy has been loaded by <see cref="F:KGySoft.Resources.ResourceSetRetrieval.GetIfAlreadyLoaded"/> and trying parents.
            In this case there might be unloaded parents for this resource set.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.ProxyResourceSet.FileExists">
            <summary>
            Gets whether this proxy has been loaded by <see cref="F:KGySoft.Resources.ResourceSetRetrieval.GetIfAlreadyLoaded"/> and trying parents,
            and there is an existing file for this resource. File name itself is not stored so it will be re-groveled next time
            handling the case if it has been deleted.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceManager.lastUsedResourceSet">
            <summary>
            The lastly used resource set. Unlike in base, this is not necessarily the resource set in which a result
            has been found but the resource set was requested last time. In cases it means difference this way performs usually better (no unneeded traversal again and again).
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceManager.resourceSets">
            <summary>
            Local cache of the resource sets.
            Before serializing we remove proxies and unmodified sets.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.ResXResourcesDir">
            <summary>
            Gets or sets the relative path to .resx resource files.
            <br/>Default value: <c>Resources</c>
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.ThrowException">
            <summary>
            Gets or sets whether a <see cref="T:System.Resources.MissingManifestResourceException"/> should be thrown when a resource
            .resx file is not found even for the neutral culture.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.IgnoreResXParseErrors">
            <summary>
            Gets or sets whether .resx file errors should be ignored when attempting to load a resource set. If <see langword="true"/>,
            then non-loadable resource sets are considered as missing ones; otherwise, an exception is thrown.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.SafeMode">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.Resources.ResXResourceManager"/> works in safe mode. In safe mode the retrieved
            objects are not deserialized automatically.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods
            return <see cref="T:KGySoft.Resources.ResXDataNode"/> instances instead of deserialized objects. You can retrieve the deserialized objects by calling
            the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.</para>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods
            will return a <see cref="T:System.String"/> also for non-string objects. For non-string values the raw XML string value will be returned.</para>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> methods
            will return a <see cref="T:System.IO.MemoryStream"/> for any object.
            For values, which are neither <see cref="T:System.IO.MemoryStream"/>, nor <see cref="T:System.Array">byte[]</see> instances these methods return a stream wrapper for the same string value
            that is returned by the <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see>/<see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods.</para>
            </remarks>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.CloneValues">
            <summary>
            Gets or sets whether <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods return always a new copy of the stored values.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            <para>To be compatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/System.Resources.ResourceManager" target="_blank">System.Resources.ResourceManager</a> this
            property is <see langword="true"/> by default. If this <see cref="T:KGySoft.Resources.ResXResourceManager"/> contains no mutable values or it is known that modifying values is not
            an issue, then this property can be set to <see langword="false"/> for better performance.</para>
            <para>String values are not cloned.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.IsDisposed">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.ResXResourceManager"/> instance is disposed.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceManager.IsModified">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.ResXResourceManager"/> instance has modified and unsaved data.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class that looks up resources in
            resource XML files based on the provided <paramref name="baseName"/>.
            </summary>
            <param name="baseName">A base name that is the prefix of the resource files.
            For example, the prefix for the resource file named <c>Resource1.en-US.resx</c> is <c>Resource1</c>.</param>
            <param name="assembly">The assembly, from which the language of the neutral resources is tried to be auto detected. See the <strong>Remarks</strong> section for details.</param>
            <remarks>
            <para>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> looks up resources in <c>baseName.cultureName.resx</c> files, where <c>baseName.resx</c> contains the resource set of the
            ultimate fallback culture (also known as default or invariant or neutral resources culture).</para>
            <para>If the provided <paramref name="assembly"/> has a <see cref="T:System.Resources.NeutralResourcesLanguageAttribute"/> defined, then it will be used to determine the language
            of the fallback culture. If the provided <paramref name="assembly"/> does not define this attribute, then <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> will be used as the default culture.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class that looks up resources in
            resource XML files based on the provided <paramref name="baseName"/>.
            </summary>
            <param name="baseName">A base name that is the prefix of the resource files.
            For example, the prefix for the resource file named <c>Resource1.en-US.resx</c> is <c>Resource1</c>.</param>
            <param name="neutralResourcesLanguage">Determines the language of the neutral resources. When <see langword="null"/>,
            it will be determined by the entry assembly, or if that is not available, then by the assembly of the caller's method. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> looks up resources in <c>baseName.cultureName.resx</c> files, where <c>baseName.resx</c> contains the resource set of the
            ultimate fallback culture (also known as default or invariant or neutral resources culture).</para>
            <para>If <paramref name="neutralResourcesLanguage"/> is <see langword="null"/>, then the default culture is auto detected by the current application's <see cref="T:System.Resources.NeutralResourcesLanguageAttribute"/>.
            If it is not defined, then <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> will be used as default culture.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.#ctor(System.Type)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Resources.ResXResourceManager"/> class that looks up resources in
            resource XML files based on information from the specified type object.
            </summary>
            <param name="resourceSource">A type from which the resource manager derives all information for finding resource files.</param>
            <remarks>
            <para>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> looks up resources in <c>resourceSourceTypeName.cultureName.resx</c> files, where <c>resourceSourceTypeName.resx</c> contains the resource set of the
            ultimate fallback culture (also known as default or invariant or neutral resources culture).</para>
            <para>If the <see cref="T:System.Reflection.Assembly"/> of <paramref name="resourceSource"/> has a <see cref="T:System.Resources.NeutralResourcesLanguageAttribute"/> defined, then it will be used to determine the language
            of the fallback culture. If the <see cref="T:System.Reflection.Assembly"/> of <paramref name="resourceSource"/> does not define this attribute, then <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> will be used as the default culture.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetString(System.String)">
            <summary>
            Returns the value of the specified string resource.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <returns>
            The value of the resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is a non-<see langword="string"/> resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns the underlying raw XML content of the resource.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
            <remarks>For examples, see the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string resource localized for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo"/> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <returns>
            The value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is a non-<see langword="string"/> resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns the underlying raw XML content of the resource.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
            <remarks>For examples, see the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetStream(System.String)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            <para><see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            <note>The internal buffer is tried to be obtained by reflection in the first place. On platforms, which have possibly unknown non-public member names the public APIs are used, which may copy the content in memory.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            <para><see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            <note>The internal buffer is tried to be obtained by reflection in the first place. On platforms, which have possibly unknown non-public member names the public APIs are used, which may copy the content in memory.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetObject(System.String)">
            <summary>
            Returns the value of the specified resource.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class for examples.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the caller's current UI culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Gets the value of the specified resource localized for the specified <paramref name="culture"/>.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class for examples.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <param name="culture">The culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> property.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property, the <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> methods return either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> methods
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string metadata for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            The value of the metadata of the specified culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is a non-<see langword="string"/> metadata, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns the underlying raw XML content of the metadata.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/> and the type of the metadata is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the metadata of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="O:KGySoft.Resources.ResXResourceManager.GetStream">GetStream</see> methods, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified metadata, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property, the <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> method returns either
            a full copy of the specified metadata, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> method
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.ResXResourceManager.CloneValues"/> property.</para>
            <para><see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> can be used also for byte array metadata.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array metadata, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="O:KGySoft.Resources.ResXResourceManager.GetString">GetString</see> methods,
            which will be the raw XML content for non-string metadata.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="false"/> and the type of the metadata is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the specified non-string metadata for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="O:KGySoft.Resources.ResXResourceManager.GetObject">GetObject</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            If <see cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/> is <see langword="true"/>, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the metadata localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a resource object in the current <see cref="T:KGySoft.Resources.ResXResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The name of the resource to set.</param>
            <param name="culture">The culture of the resource to set. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <param name="value">The value of the resource to set. If <see langword="null" />, then a null reference will be explicitly
            stored for the specified <paramref name="culture"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            Its effect is similar to the <see cref="M:KGySoft.Resources.ResXResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see> method: the subsequent <see cref="M:KGySoft.Resources.ResXResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> calls
            with the same <paramref name="culture" /> will fall back to the parent culture, or will return <see langword="null"/> if
            <paramref name="name" /> is not found in any parent cultures. However, enumerating the result set returned by
            <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> and <see cref="M:KGySoft.Resources.ResXResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">GetResourceSet</see> methods will return the resources with
            <see langword="null"/> value.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a resource object from the current <see cref="T:KGySoft.Resources.ResXResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The case-sensitive name of the resource to remove.</param>
            <param name="culture">The culture of the resource to remove. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para><paramref name="name"/> is considered as case-sensitive. If <paramref name="name"/> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a metadata object in the current <see cref="T:KGySoft.Resources.ResXResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The name of the metadata to set.</param>
            <param name="culture">The culture of the metadata to set.
            If this value is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="value">The value of the metadata to set. If <see langword="null" />,  then a null reference will be explicitly
            stored for the specified <paramref name="culture" />.</param>
            <remarks>
            If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            Its effect is similar to the <see cref="M:KGySoft.Resources.ResXResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">RemoveMetaObject</see> method: the subsequent <see cref="M:KGySoft.Resources.ResXResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> calls
            with the same <paramref name="culture" /> will return <see langword="null" />.
            However, enumerating the result set returned by <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method will return the meta objects with <see langword="null"/> value.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a metadata object from the current <see cref="T:KGySoft.Resources.ResXResourceManager" /> with the specified
            <paramref name="name" /> for the specified <paramref name="culture" />.
            </summary>
            <param name="name">The case-sensitive name of the metadata to remove.</param>
            <param name="culture">The culture of the metadata to remove.
            If this value is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <paramref name="name" /> is considered as case-sensitive. If <paramref name="name" /> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Saves the resource set of a particular <paramref name="culture" /> if it has been already loaded.
            </summary>
            <param name="culture">The culture of the resource set to save.</param>
            <param name="force"><see langword="true"/> to save the resource set even if it has not been modified; <see langword="false"/> to save it only if it has been modified.
            <br />Default value: <see langword="false"/>.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class.
            <br />Default value: <see langword="false"/>.</param>
            <returns>
            <see langword="true"/> if the resource set of the specified <paramref name="culture" /> has been saved;
            otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.IO.IOException">The resource set could not be saved.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.SaveAllResources(System.Boolean,System.Boolean)">
            <summary>
            Saves all already loaded resources.
            </summary>
            <param name="force"><see langword="true"/> to save all of the already loaded resource sets regardless if they have been modified; <see langword="false"/> to save only the modified resource sets. This parameter is optional.
            <br />Default value: <see langword="false"/>.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx files can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx files are often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class. This parameter is optional.
            <br />Default value: <see langword="false"/>.</param>
            <returns>
              <see langword="true"/> if at least one resource set has been saved; otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.IO.IOException">A resource set could not be saved.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.ReleaseAllResources">
            <summary>
            Disposes all of the cached <see cref="T:KGySoft.Resources.ResXResourceSet"/> instances and releases all resources.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <remarks>
            <note type="caution">By calling this method all of the unsaved changes will be lost.</note>
            <para>By the <see cref="P:KGySoft.Resources.ResXResourceManager.IsModified"/> property you can check whether there are unsaved changes.</para>
            <para>To save the changes you can call the <see cref="M:KGySoft.Resources.ResXResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="loadIfExists"><see langword="true"/> to load the resource set, if it has not been loaded yet and the corresponding resource file exists; otherwise, <see langword="false"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process.</param>
            <returns>
            The resource set for the specified <paramref name="culture"/>.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents"/> and <see cref="P:KGySoft.Resources.ResXResourceManager.ThrowException"/> are <see langword="true"/> and the .resx file of the neutral culture was not found.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture, which can be dynamically modified.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="behavior">Determines the retrieval behavior of the result <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceSetRetrieval.LoadIfExists"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The resource set for the specified culture, or <see langword="null"/> if the specified culture cannot be retrieved by the defined <paramref name="behavior"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="behavior"/> does not fall in the expected range.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">Resource file of the neutral culture was not found, while <paramref name="tryParents"/> is <see langword="true"/>
            and <paramref name="behavior"/> is not <see cref="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.Dispose">
            <summary>
            Disposes the resources of the current instance.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.CreateResourceSet(System.Globalization.CultureInfo)">
            <summary>
            Creates an empty resource set for the given culture so it can be expanded.
            Does not make the resource set dirty until it is actually edited.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetResourceFileName(System.Globalization.CultureInfo)">
            <summary>
            Generates the name of the resource file for the given <see cref="T:System.Globalization.CultureInfo"/> object.
            </summary>
            <param name="culture">The culture object for which a resource file name is constructed.</param>
            <returns>
            The name that can be used for a resource file for the given <see cref="T:System.Globalization.CultureInfo" /> object.
            </returns>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Provides the implementation for finding a resource set.
            </summary>
            <param name="culture">The culture object to look for.</param>
            <param name="loadIfExists"><see langword="true"/> to load the resource set, if it has not been loaded yet; otherwise, <see langword="false"/>.</param>
            <param name="tryParents"><see langword="true"/> to check parent <see cref="T:System.Globalization.CultureInfo" /> objects if the resource set cannot be loaded; otherwise, <see langword="false"/>.</param>
            <returns>The specified resource set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">The .resx file of the neutral culture was not found, while <paramref name="tryParents"/> and <see cref="P:KGySoft.Resources.ResXResourceManager.ThrowException"/> are both <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.Resources.ResXResourceManager"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.Resources.ResXResourceManager.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceManager.GetFirstResourceSet(System.Globalization.CultureInfo)">
            <summary>
            Tries to get the first resource set in the traversal path from the caches.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceReader">
             <summary>
             Enumerates XML resource (.resx) files and streams, and reads the sequential resource name and value pairs.
             </summary>
             <remarks>
             <note>This class is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>
             in <c>System.Windows.Forms.dll</c>. See the <a href="#comparison">Comparison with System.Resources.ResXResourceReader</a> section for the differences.</note>
             <note type="tip">To see when to use the <see cref="T:KGySoft.Resources.ResXResourceReader"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, <see cref="T:KGySoft.Resources.ResXResourceSet"/>, <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
             classes see the documentation of the <see cref="N:KGySoft.Resources">KGySoft.Resources</see> namespace.</note>
             <para>You can use the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class to enumerate resources in .resx files by traversing the dictionary enumerator (<see cref="T:System.Collections.IDictionaryEnumerator"/>) that is returned by the
             <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> method. You call the methods provided by <see cref="T:System.Collections.IDictionaryEnumerator"/> to advance to the next resource and to read the name and value of each resource in the .resx file.
             <note>The <see cref="T:KGySoft.Resources.ResXResourceReader"/> class provides more enumerators.
             <list type="bullet">
             <item>The <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> method returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> object, which enumerates the resources.
             The <see cref="P:System.Collections.IDictionaryEnumerator.Key">IDictionaryEnumerator.Key</see> property returns the resource names, while <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see>
             returns either <see cref="T:KGySoft.Resources.ResXDataNode"/> instances, if <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="true"/>; or returns deserialized <see cref="T:System.Object"/> instances if <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="false"/>.</item>
             <item>The <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> method returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> object, which enumerates the metadata entries.
             The <see cref="P:System.Collections.IDictionaryEnumerator.Key">IDictionaryEnumerator.Key</see> property returns the metadata names, while <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see>
             returns either <see cref="T:KGySoft.Resources.ResXDataNode"/> instances, if <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="true"/>; or returns deserialized <see cref="T:System.Object"/> instances if <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="false"/>.</item>
             <item>The <see cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">GetAliasEnumerator</see> method returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> object, which enumerates the aliases in the .resx file.
             The <see cref="P:System.Collections.IDictionaryEnumerator.Key">IDictionaryEnumerator.Key</see> property returns the alias names, while <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see>
             returns the corresponding assembly names for the alias names.</item>
             <item>As an explicit interface implementation, <see cref="T:KGySoft.Resources.ResXResourceReader"/> implements <see cref="M:System.Collections.IEnumerable.GetEnumerator">IEnumerable.GetEnumerator</see> method, which returns the same enumerator as
             the <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> method as an <see cref="T:System.Collections.IEnumerator"/> instance. The <see cref="P:System.Collections.IEnumerator.Current">IEnumerator.Current</see> property will return <see cref="T:System.Collections.DictionaryEntry"/> instances.</item>
             </list>
             </note>
             </para>
             <para>If the <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="true"/>, the value of the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
             instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the example at <see cref="T:KGySoft.Resources.ResXDataNode"/>.</para>
             <para>If you want to retrieve named resources from a .resx file rather than enumerating its resources, then you can instantiate a <see cref="T:KGySoft.Resources.ResXResourceSet"/> object and call its
             <see cref="M:KGySoft.Resources.ResXResourceSet.GetString(System.String)">GetString</see>/<see cref="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String)">GetObject</see>, <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see>/<see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetAliasValue(System.String)">GetAliasValue</see> methods.
             Also <see cref="T:KGySoft.Resources.ResXResourceSet"/> supports <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/>.</para>
             <example>
             The following example shows how to enumerate the resources, metadata and aliases of a .resx file and what is the difference between safe and non-safe mode.
             Please note that <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property can be switched on and off during the enumeration, too. Please also note that the values returned by the <see cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">GetAliasEnumerator</see> are always
             strings, regardless of the value of <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property. See also the example of the <see cref="T:KGySoft.Resources.ResXDataNode"/> class to see how to examine the properties of the <see cref="T:KGySoft.Resources.ResXDataNode"/> instances
             in safe mode.
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections;
             using System.IO;
             using KGySoft.Resources;
             
             public class Example
             {
                 private const string resx = @"<?xml version='1.0' encoding='utf-8'?>
             <root>
               <data name='string'>
                 <value>Test string</value>
                 <comment>Default data type is string.</comment>
               </data>
            
               <metadata name='meta string'>
                 <value>Meta String</value>
               </metadata>
            
               <data name='int' type='System.Int32'>
                 <value>42</value>
               </data>
            
               <assembly alias='CustomAlias' name='System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' />
            
               <data name='color' type='System.Drawing.Color, CustomAlias'>
                 <value>Red</value>
                 <comment>When this entry is deserialized, System.Drawing assembly will be loaded.</comment>
               </data>
            
               <data name='bytes' type='System.Byte[]'>
                 <value>VGVzdCBieXRlcw==</value>
               </data>
            
               <data name='dangerous' mimetype='application/x-microsoft.net.object.binary.base64'>
                 <value>YmluYXJ5</value>
                 <comment>BinaryFormatter will throw an exception for this invalid content.</comment>
               </data>
            
             </root>";
            
                public static void Main()
                {
                    var reader = new ResXResourceReader(new StringReader(resx));
                    Console.WriteLine("____Resources in .resx:____");
                    Dump(reader, reader.GetEnumerator);
                    Console.WriteLine("____Metadata in .resx:____");
                    Dump(reader, reader.GetMetadataEnumerator);
                    Console.WriteLine("____Aliases in .resx:____");
                    Dump(reader, reader.GetAliasEnumerator);
                }
             
                private static void Dump(ResXResourceReader reader, Func<IDictionaryEnumerator> getEnumeratorFunction)
                {
                    var enumerator = getEnumeratorFunction();
                    while (enumerator.MoveNext())
                    {
                        Console.WriteLine($"Name: {enumerator.Key}");
                        reader.SafeMode = true;
                        Console.WriteLine($"  Value in SafeMode:     {enumerator.Value} ({enumerator.Value.GetType()})");
                        try
                        {
                            reader.SafeMode = false;
                            Console.WriteLine($"  Value in non-SafeMode: {enumerator.Value} ({enumerator.Value.GetType()})");
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine($"Getting the deserialized value thrown an exception: {e.Message}");
                        }
                        Console.WriteLine();
                    }
                }
            }]]>
            
             // The example displays the following output:
             // ____Resources in .resx:____
             // Name: string
             // Value in SafeMode:     Test string (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: Test string (System.String)
            
             // Name: int
             // Value in SafeMode:     42 (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: 42 (System.Int32)
            
             // Name: color
             // Value in SafeMode:     Red (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: Color[Red] (System.Drawing.Color)
            
             // Name: bytes
             // Value in SafeMode:     VGVzdCBieXRlcw== (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: System.Byte[] (System.Byte[])
            
             // Name: dangerous
             // Value in SafeMode:     YmluYXJ5 (KGySoft.Resources.ResXDataNode)
             // Getting the deserialized value thrown an exception: End of Stream encountered before parsing was completed.
            
             // ____Metadata in .resx:____
             // Name: meta string
             // Value in SafeMode:     Meta String (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: Meta String (System.String)
            
             // ____Aliases in .resx:____
             // Name: CustomAlias
             // Value in SafeMode:     System.Drawing, Version= 4.0.0.0, Culture= neutral, PublicKeyToken= b03f5f7f11d50a3a (System.String)
             // Value in non-SafeMode: System.Drawing, Version= 4.0.0.0, Culture= neutral, PublicKeyToken= b03f5f7f11d50a3a (System.String)</code>
             </example>
             <para>
             By default, <see cref="T:KGySoft.Resources.ResXResourceReader"/> allows duplicated keys with different values (see <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> property). Though such a .resx file is not strictly valid, its
             complete content can be retrieved. When <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="true"/>, <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see>, <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> and
             <see cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">GetAliasEnumerator</see> return a lazy enumerator for the first time meaning the .resx file is parsed only during the enumeration. When any of the enumerators are obtained
             for the second time, a cached enumerator is returned with the whole parsed .resx content. If duplicates are disabled, the lastly defined values will be returned of a redefined name. This behavior is
             similar to the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class, which does not allow duplicates.
             </para>
             <example>
             The following example demonstrates the difference of lazy (allowing duplicates) and greedy (disabling duplicates) reading.
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections;
             using System.IO;
             using KGySoft.Resources;
            
             public class Example
             {
                 private const string resx = @"<?xml version='1.0' encoding='utf-8'?>
             <root>
               <data name='item'>
                 <value>Test string</value>
               </data>
            
               <data name='item'>
                 <value>This is a duplicate for key 'item'.</value>
               </data>
             </root>";
            
                 public static void Main()
                 {
                     // Allowing duplicates and lazy reading.
                     Console.WriteLine("-------Lazy reading------");
                     var reader = new ResXResourceReader(new StringReader(resx)) { AllowDuplicatedKeys = true };
                     IDictionaryEnumerator enumerator = reader.GetEnumerator();
                     Dump(enumerator); // if resx contains a syntax error, an exception is thrown during the enumeration.
            
                     // Disabling duplicates and lazy reading
                     Console.WriteLine("-------Greedy reading------");
                     reader = new ResXResourceReader(new StringReader(resx)) { AllowDuplicatedKeys = false };
                     enumerator = reader.GetEnumerator(); // if resx contains a syntax error, an exception is thrown here.
                     Dump(enumerator);
                 }
            
                 private static void Dump(IDictionaryEnumerator enumerator)
                 {
                     while (enumerator.MoveNext())
                     {
                         Console.WriteLine($"Key: {enumerator.Key}");
                         Console.WriteLine($"Value: {enumerator.Value}");
                         Console.WriteLine();
                     }
                 }
             }]]>
            
             // The example displays the following output:
             // -------Lazy reading------
             // Key: item
             // Value: Test string
             //
             // Key: item
             // Value: This is a duplicate for key 'item'.
             //
             // -------Greedy reading------
             // Key: item
             // Value: This is a duplicate for key 'item'.</code>
             </example>
             <h2>Comparison with System.Resources.ResXResourceReader<a name="comparison">&#160;</a></h2>
             <para><see cref="T:KGySoft.Resources.ResXResourceReader"/> can read .resx files produced both by <see cref="T:KGySoft.Resources.ResXResourceWriter"/> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a>.
             <note>When reading a .resx file written by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a> class,
             the <c>System.Windows.Forms.dll</c> is not loaded during resolving <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>
             and <strong>System.Resources.ResXNullRef</strong> types.</note>
             </para>
             <para><strong>Incompatibility</strong> with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>:
             <list type="bullet">
             <item>Constructors do not have overloads with <see cref="T:System.Reflection.AssemblyName">AssemblyName[]</see> parameters. The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>
             uses them to load the assemblies in advance occasionally by calling the obsolete <see cref="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">Assembly.LoadPartial</see> method. However, this <see cref="T:KGySoft.Resources.ResXResourceReader"/>
             implementation uses the <see cref="M:KGySoft.Reflection.Reflector.ResolveType(System.String,KGySoft.Reflection.ResolveTypeOptions)">Reflector.ResolveType</see> method, which does not use obsolete techniques (and if <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> is <see langword="true"/>,
             then no type resolving, assembly loading and deserialization occurs at all, until explicit request).
             If you need a completely custom type resolution the constructor overloads with <see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> parameters still can be used.</item>
             <item>This <see cref="T:KGySoft.Resources.ResXResourceReader"/> is a sealed class.</item>
             <item>After disposing the <see cref="T:KGySoft.Resources.ResXResourceReader"/> instance or calling the <see cref="M:KGySoft.Resources.ResXResourceReader.Close">Close</see> method the enumerators cannot be obtained: an <see cref="T:System.ObjectDisposedException"/> will be thrown
             on calling <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see>, <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">GetAliasEnumerator</see> methods.</item>
             <item>After disposing the <see cref="T:KGySoft.Resources.ResXResourceReader"/> instance or calling the <see cref="M:KGySoft.Resources.ResXResourceReader.Close">Close</see> method every source stream will be closed (if any).</item>
             <item>Unlike <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>, this implementation returns every resources and metadata of the
             same name by default. This behavior can be adjusted by <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> property.</item>
             <item><a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> often throws <see cref="T:System.ArgumentException"/> on getting the enumerator
             or on retrieving the value of a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance, which contains invalid data. In contrast, this implementation may throw <see cref="T:System.Xml.XmlException"/>, <see cref="T:System.TypeLoadException"/> or <see cref="T:System.NotSupportedException"/> instead.</item>
             <item>Though the <see cref="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes"/> property is still supported, it is obsolete in favor of <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property.</item>
             <item>In <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> if <see cref="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes"/> property is <see langword="true"/>,
             the resource and metadata entries are mixed in the returned enumerator, while when it is <see langword="false"/>, then only the resources are returned. In this implementation the <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> always
             returns only the resources and <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> returns the metadata regardless of the value of the <see cref="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes"/> and <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> properties.</item>
             </list>
             </para>
             <para><strong>New features and improvements</strong> compared to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>:
             <list type="bullet">
             <item><term>Lazy processing</term>
             <description>If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="true"/>, the .resx file is processed on demand, during the actual enumeration. The .resx file is processed immediately if
             <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="false"/>. If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="true"/> and any enumerator is obtained after getting one, the rest of the .resx file is immediately processed.</description></item>
             <item><term>Handling duplicates</term>
             <description>If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="true"/>, every occurrence of a duplicated name is returned by the enumerators. Otherwise, only the last occurrence of
             a name is returned.</description></item>
             <item><term>Headers</term>
             <description>The .resx header is allowed to be completely missing; however, it is checked when exists and <see cref="P:KGySoft.Resources.ResXResourceReader.CheckHeader"/> property is <see langword="true"/>. If header tags contain invalid values a <see cref="T:System.NotSupportedException"/> may be thrown during the enumeration.
             You can configure the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> class to omit the header by the <see cref="P:KGySoft.Resources.ResXResourceWriter.OmitHeader">ResXResourceWriter.OmitHeader</see> property.</description></item>
             <item><term>Using <see cref="T:KGySoft.Resources.ResXDataNode"/> instances</term>
             <description>The <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> (<see cref="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes"/>) property can be toggled also after getting an enumerator or even during the enumeration.</description></item>
             <item><term>Clear purpose of the enumerators</term>
             <description>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader.getenumerator" target="_blank">System.Resources.ResXResourceReader.GetEnumerator</a> either returns resources only or returns both resources and metadata mixed together
             depending on the value of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader.useresxdatanodes" target="_blank">System.Resources.ResXResourceReader.UseResXDataNodes</a> property.
             This <see cref="T:KGySoft.Resources.ResXResourceReader"/> implementation has separated <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see>, <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">GetAliasEnumerator</see>
             methods, which return always the resources, metadata and aliases, respectively.</description></item>
             <item><term>Security</term>
             <description>If <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> is <see langword="true"/>, no deserialization, assembly loading and type resolving occurs until a deserialization is explicitly requested
             by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method on the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see>
             instances returned by the <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> methods.</description></item>
             <item><term>Base path</term>
             <description>The <see cref="P:KGySoft.Resources.ResXResourceReader.BasePath"/> property, which is used for resolving file references can be set during the enumeration, too.</description></item>
             <item><term>New MIME type</term>
             <description>A new MIME type <c>text/kgysoft.net/object.binary.base64</c> is supported, indicating that an object is serialized by <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> instead of <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
             The <see cref="T:KGySoft.Resources.ResXResourceWriter"/> can produce such .resx content if <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat">ResXResourceWriter.CompatibleFormat</see> is <see langword="false"/>.</description></item>
             <item><term>Soap formatter support</term>
             <description>The Soap formatter support is provided without referencing the <c>System.Runtime.Serialization.Formatters.Soap.dll</c> assembly. If the assembly cannot be loaded from the GAC (platform dependent),
             then a <see cref="T:System.NotSupportedException"/> will be thrown.</description></item>
             <item><term>Type resolving</term>
             <description>If an <see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> instance is passed to one of the constructors, it is used also for the type references in <see cref="T:KGySoft.Resources.ResXFileRef"/> instances.</description></item>
             </list></para>
             </remarks>
             <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
             <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
             <seealso cref="T:KGySoft.Resources.ResXResourceSet"/>
             <seealso cref="T:KGySoft.Resources.ResXResourceManager"/>
             <seealso cref="T:KGySoft.Resources.HybridResourceManager"/>
             <seealso cref="T:KGySoft.Resources.DynamicResourceManager"/>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceReader.LazyEnumerator">
            <summary>
            An enumerator that reads the underlying .resx on-demand. Returns the duplicated elements, too.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceReader.LazyEnumerator.bufferedEnumerator">
            <summary>
            Represents buffered items, which should be returned before reading the next items from the underlying XML.
            Reset and ReadToEnd may produce buffered items.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.LazyEnumerator.ReadToEnd">
            <summary>
            Hasting the enumeration and reading all of the elements into a buffer. Occurs on a second GetEnumerator
            call while the first enumeration has not been finished.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceReader.ResXReader">
            <summary>
            Required because a reader returned by XmlReader.Create would normalize the \r characters
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceReader.reader">
            <summary>
            The internally created reader. Will be closed automatically when stream ends or on Dispose
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceReader.activeAliases">
            <summary>
            The currently active aliases. Same as <see cref="F:KGySoft.Resources.ResXResourceReader.aliases"/> if duplication is disabled.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceReader.enumerator">
            <summary>
            Stored in a field so first enumeration can be handled in a special way if duplicates are allowed.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceReader.BasePath">
            <summary>
            Gets or sets the base path for the relative file path specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object.
            <br/>Default value: <see langword="null"/>.
            </summary>
            <returns>
            A path that, if prepended to the relative file path specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object, yields an absolute path to a resource file.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="M:KGySoft.Resources.ResXResourceReader.Close">Close</see> or <see cref="M:System.IDisposable.Dispose">IDisposable.Dispose</see> method has already been called on this
            <see cref="T:KGySoft.Resources.ResXResourceReader"/> instance.</exception>
            <remarks>
            Unlike in case of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class, in this
            <see cref="T:KGySoft.Resources.ResXResourceReader"/> implementation this property can be set even after calling the <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see>, <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see>
            or <see cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">GetAliasEnumerator</see> methods.
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes">
            <summary>
            Gets or sets whether <see cref="T:KGySoft.Resources.ResXDataNode"/> objects are returned when reading the current XML resource file or stream.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <note>This property is maintained due to compatibility reasons with the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class.
            Use <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property instead.</note>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceReader.SafeMode">
            <summary>
            Gets or sets whether <see cref="T:KGySoft.Resources.ResXDataNode"/> objects are returned when reading the current XML resource file or stream.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="M:KGySoft.Resources.ResXResourceReader.Close">Close</see> or <see cref="M:System.IDisposable.Dispose">IDisposable.Dispose</see> method has already been called on this
            <see cref="T:KGySoft.Resources.ResXResourceReader"/> instance.</exception>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> is <see langword="true"/>, then objects returned by the <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> methods
            return <see cref="T:KGySoft.Resources.ResXDataNode"/> instances instead of deserialized objects. You can retrieve the deserialized
            objects on demand by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> method on the <see cref="T:KGySoft.Resources.ResXDataNode"/> instance.
            <br/>See also the examples at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class.</para>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceReader.CheckHeader">
            <summary>
            Gets or sets whether "resheader" entries are checked in the .resx file. When <see langword="true"/>, a <see cref="T:System.NotSupportedException"/>
            can be thrown during the enumeration when "resheader" entries contain invalid values. When header entries are
            missing, no exception is thrown.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">In a set operation, a value cannot be specified because the XML resource file has already been accessed and is in use.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="M:KGySoft.Resources.ResXResourceReader.Close">Close</see> or <see cref="M:System.IDisposable.Dispose">IDisposable.Dispose</see> method has already been called on this
            <see cref="T:KGySoft.Resources.ResXResourceReader"/> instance.</exception>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys">
            <summary>
            Gets or sets whether all entries of same name of the .resx file should be returned.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            <para>If an element is defined more than once and <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="true"/>,
            then the enumeration returns every occurrence of the entries with identical names.
            If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> is <see langword="false"/> the enumeration returns always the last occurrence of the entries with identical names.</para>
            <para>If duplicated keys are allowed, the enumeration of the .resx file is lazy for the first time.
            A lazy enumeration means that the underlying .resx file is read only on demand. It is possible that
            not the whole .resx is read if enumeration is canceled. After the first enumeration elements are cached.</para>
            <note>To be compatible with the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>
            class set the value of this property to <see langword="false"/>.</note>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="M:KGySoft.Resources.ResXResourceReader.Close">Close</see> or <see cref="M:System.IDisposable.Dispose">IDisposable.Dispose</see> method has already been called on this
            <see cref="T:KGySoft.Resources.ResXResourceReader"/> instance.</exception>
            <exception cref="T:System.InvalidOperationException">In a set operation, a value cannot be specified because the XML resource file has already been accessed and is in use.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.#ctor(System.String,System.ComponentModel.Design.ITypeResolutionService)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class for the specified resource file.
            </summary>
            <param name="fileName">The name of an XML resource file that contains resources.</param>
            <param name="typeResolver">An object that resolves type names specified in a resource. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <note type="tip">To create a <see cref="T:KGySoft.Resources.ResXResourceReader"/> from a string use the <see cref="M:KGySoft.Resources.ResXResourceReader.FromFileContents(System.String,System.ComponentModel.Design.ITypeResolutionService)">FromFileContents</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.#ctor(System.IO.TextReader,System.ComponentModel.Design.ITypeResolutionService)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class for the specified <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="reader">A text stream reader that contains resources.</param>
            <param name="typeResolver">An object that resolves type names specified in a resource. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.#ctor(System.IO.Stream,System.ComponentModel.Design.ITypeResolutionService)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class for the specified <paramref name="stream"/>.
            </summary>
            <param name="stream">An input stream that contains resources.</param>
            <param name="typeResolver">An object that resolves type names specified in a resource. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.Finalize">
            <summary>
            This member overrides the <see cref="M:System.Object.Finalize"/> method.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.FromFileContents(System.String,System.ComponentModel.Design.ITypeResolutionService)">
            <summary>
            Creates a new <see cref="T:KGySoft.Resources.ResXResourceReader"/> object and initializes it to read a string whose contents are in the form of an XML resource file.
            </summary>
            <returns>A <see cref="T:KGySoft.Resources.ResXResourceReader"/> object that reads resources from the <paramref name="fileContents"/> string.</returns>
            <param name="fileContents">A string containing XML resource-formatted information.</param>
            <param name="typeResolver">An object that resolves type names specified in a resource. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.Close">
            <summary>
            Releases all resources used by the <see cref="T:KGySoft.Resources.ResXResourceReader"/>.
            </summary>
            <remarks>
            If the <see cref="T:KGySoft.Resources.ResXResourceReader"/> is initialized in a <see langword="using"/> statement, it is not needed to call this method explicitly.
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> instance for the current <see cref="T:KGySoft.Resources.ResXResourceReader"/> object that enumerates the resources
            in the source XML resource file or stream.
            </summary>
            <returns>An <see cref="T:System.Collections.IDictionaryEnumerator" /> for that can be used to iterate through the resources from the current XML resource file or stream.</returns>
            <remarks>
            <para>In <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> if <see cref="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes"/> property is <see langword="true"/>,
            the resource and metadata entries are mixed in the returned enumerator, while when it is <see langword="false"/>, then only the resources are returned. In this <see cref="T:KGySoft.Resources.ResXResourceReader"/> implementation the <see cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator">GetEnumerator</see> method always
            returns only the resources and <see cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">GetMetadataEnumerator</see> returns the metadata regardless of the value of the <see cref="P:KGySoft.Resources.ResXResourceReader.UseResXDataNodes"/> or <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> properties.</para>
            <para>If the <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="true"/>, the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the example at <see cref="T:KGySoft.Resources.ResXDataNode"/>.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> property is <see langword="true"/>, then this method returns a lazy enumerator for the first time meaning the .resx file is parsed only during the enumeration. When any of the enumerators are obtained
            for the second time, a cached enumerator is returned with the whole parsed .resx content. If duplicates are disabled, the lastly defined value will be returned of a redefined name.</para>
            <para>See also the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class for examples.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> instance for the current <see cref="T:KGySoft.Resources.ResXResourceReader"/> object that enumerates the design-time properties (<c>&lt;metadata&gt;</c> elements)
            in the source XML resource file or stream.
            </summary>
            <returns>An <see cref="T:System.Collections.IDictionaryEnumerator" /> for that can be used to iterate through the design-time properties (<c>&lt;metadata&gt;</c>; elements) from the current XML resource file or stream.</returns>
            <remarks>
            <para>If the <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property is <see langword="true"/>, the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the example at <see cref="T:KGySoft.Resources.ResXDataNode"/>.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> property is <see langword="true"/>, then this method returns a lazy enumerator for the first time meaning the .resx file is parsed only during the enumeration. When any of the enumerators are obtained
            for the second time, a cached enumerator is returned with the whole parsed .resx content. If duplicates are disabled, the lastly defined value will be returned of a redefined name.</para>
            <para>See also the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class for examples.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.GetAliasEnumerator">
            <summary>
            Provides an <see cref="T:System.Collections.IDictionaryEnumerator"/> instance that can retrieve the aliases from the current XML resource file or stream.
            </summary>
            <returns>An <see cref="T:System.Collections.IDictionaryEnumerator" /> for that can be used to iterate through the aliases from the current XML resource file or stream.</returns>
            <remarks>
            <para>The <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is always a <see cref="T:System.String"/> regardless of the value of the <see cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/> property.</para>
            <para>The <see cref="P:System.Collections.IDictionaryEnumerator.Key">IDictionaryEnumerator.Key</see> property of the returned enumerator is the alias name, whereas <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> is the corresponding assembly name.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> property is <see langword="true"/>, then this method returns a lazy enumerator for the first time meaning the .resx file is parsed only during the enumeration. When any of the enumerators are obtained
            for the second time, a cached enumerator is returned with the whole parsed .resx content. If duplicates are disabled, the lastly defined value will be returned of a redefined alias.</para>
            <para>See also the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Resources.ResXResourceReader"/> class for examples.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceReader.GetEnumerator"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceReader.GetMetadataEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.ReadAllInternal(KGySoft.Collections.StringKeyedDictionary{KGySoft.Resources.ResXDataNode},KGySoft.Collections.StringKeyedDictionary{KGySoft.Resources.ResXDataNode},KGySoft.Collections.StringKeyedDictionary{System.String})">
            <summary>
            Special initialization for ResXResourceSet. No lock is needed because called from ctor. Reads raw xml content only.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.ParseResHeaderNode">
            <summary>
            Parses the resource header node. Header can be completely missing; however, it is checked when required and exists.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.ReadNext(KGySoft.Resources.ResXEnumeratorModes,System.String@,KGySoft.Resources.ResXDataNode@)">
            <summary>
            Reads next element (depending on mode) from the XML. Skipped elements (on mode mismatch) are stored into the appropriate caches.
            Callers must be in a lock.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.ReadToEnd(KGySoft.Resources.ResXEnumeratorModes)">
            <summary>
            Reads the rest of the elements and returns the passed read elements.
            Must not be implemented as an iterator because it must read all of the remaining elements immediately.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.ReadAll">
            <summary>
            Reads the whole .resx file into the internal caches. This is just simple parsing, no deserialization occurs.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.Advance(System.Nullable{KGySoft.Resources.ResXEnumeratorModes},System.String@,KGySoft.Resources.ResXDataNode@)">
            <summary>
            Advances in the XML file based on the specified mode or the whole file if mode is null.
            Calls must be in a lock or from a ctor.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceReader.ParseDataNode(System.String@,KGySoft.Resources.ResXDataNode@)">
            <summary>
            Parses a data or metadata node.
            Must be called in a lock or from a ctor.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceSet">
             <summary>
             Represents the complete content of an XML resource (.resx) file including resources, metadata and aliases.
             </summary>
             <remarks>
             <note>This class is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourceset" target="_blank">System.Resources.ResXResourceSet</a>
             in <c>System.Windows.Forms.dll</c>. See the <a href="#comparison">Comparison with System.Resources.ResXResourceSet</a> section for the differences.</note>
             <note type="tip">To see when to use the <see cref="T:KGySoft.Resources.ResXResourceReader"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, <see cref="T:KGySoft.Resources.ResXResourceSet"/>, <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
             classes see the documentation of the <see cref="N:KGySoft.Resources">KGySoft.Resources</see> namespace.</note>
             <para>The <see cref="T:KGySoft.Resources.ResXResourceSet"/> class represents a single XML resource file (.resx file) in memory. It uses <see cref="T:KGySoft.Resources.ResXResourceReader"/> internally to read the .resx content and <see cref="T:KGySoft.Resources.ResXResourceWriter"/> to save it.</para>
             <para>A <see cref="T:KGySoft.Resources.ResXResourceSet"/> instance can contain resources, metadata and aliases (unlike the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourceset" target="_blank">System.Resources.ResXResourceSet</a> class, which contains only the resources).
             These contents are available either by enumerators (<see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">GetEnumerator</see>, <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetAliasEnumerator">GetAliasEnumerator</see> methods) or directly by key
             (<see cref="M:KGySoft.Resources.ResXResourceSet.GetString(System.String)">GetString</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String)">GetObject</see> methods for resources, <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see>
             for metadata, and <see cref="M:KGySoft.Resources.ResXResourceSet.GetAliasValue(System.String)">GetAliasValue</see> for aliases).</para>
             <h2>Example: Enumerating resources, metadata and aliases</h2>
             <para>
             The following example demonstrates how to access the content of a .resx file by the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class using the enumerators.
             This is very similar to the first example of <see cref="T:KGySoft.Resources.ResXResourceReader"/>.
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections;
             using System.IO;
             using KGySoft.Resources;
             
             public class Example
             {
                 private const string resx = @"<?xml version='1.0' encoding='utf-8'?>
             <root>
               <data name='string'>
                 <value>Test string</value>
                 <comment>Default data type is string.</comment>
               </data>
            
               <metadata name='meta string'>
                 <value>Meta String</value>
               </metadata>
            
               <data name='int' type='System.Int32'>
                 <value>42</value>
               </data>
            
               <assembly alias='CustomAlias' name='System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' />
            
               <data name='color' type='System.Drawing.Color, CustomAlias'>
                 <value>Red</value>
                 <comment>When this entry is deserialized, System.Drawing assembly will be loaded.</comment>
               </data>
            
               <data name='bytes' type='System.Byte[]'>
                 <value>VGVzdCBieXRlcw==</value>
               </data>
            
               <data name='dangerous' mimetype='application/x-microsoft.net.object.binary.base64'>
                 <value>YmluYXJ5</value>
                 <comment>BinaryFormatter will throw an exception for this invalid content.</comment>
               </data>
            
             </root>";
            
                public static void Main()
                {
                    var set = new ResXResourceSet(new StringReader(resx));
                    Console.WriteLine("____Resources in .resx:____");
                    Dump(set, set.GetEnumerator);
                    Console.WriteLine("____Metadata in .resx:____");
                    Dump(set, set.GetMetadataEnumerator);
                    Console.WriteLine("____Aliases in .resx:____");
                    Dump(set, set.GetAliasEnumerator);
                }
             
                private static void Dump(ResXResourceSet set, Func<IDictionaryEnumerator> getEnumeratorFunction)
                {
                    var enumerator = getEnumeratorFunction();
                    while (enumerator.MoveNext())
                    {
                        Console.WriteLine($"Name: {enumerator.Key}");
                        set.SafeMode = true;
                        Console.WriteLine($"  Value in SafeMode:     {enumerator.Value} ({enumerator.Value.GetType()})");
                        try
                        {
                            set.SafeMode = false;
                            Console.WriteLine($"  Value in non-SafeMode: {enumerator.Value} ({enumerator.Value.GetType()})");
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine($"Getting the deserialized value thrown an exception: {e.Message}");
                        }
                        Console.WriteLine();
                    }
                }
            }]]>
            
             // The example displays the following output:
             // ____Resources in .resx:____
             // Name: string
             // Value in SafeMode:     Test string (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: Test string (System.String)
            
             // Name: int
             // Value in SafeMode:     42 (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: 42 (System.Int32)
            
             // Name: color
             // Value in SafeMode:     Red (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: Color[Red] (System.Drawing.Color)
            
             // Name: bytes
             // Value in SafeMode:     VGVzdCBieXRlcw== (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: System.Byte[] (System.Byte[])
            
             // Name: dangerous
             // Value in SafeMode:     YmluYXJ5 (KGySoft.Resources.ResXDataNode)
             // Getting the deserialized value thrown an exception: End of Stream encountered before parsing was completed.
            
             // ____Metadata in .resx:____
             // Name: meta string
             // Value in SafeMode:     Meta String (KGySoft.Resources.ResXDataNode)
             // Value in non-SafeMode: Meta String (System.String)
            
             // ____Aliases in .resx:____
             // Name: CustomAlias
             // Value in SafeMode:     System.Drawing, Version= 4.0.0.0, Culture= neutral, PublicKeyToken= b03f5f7f11d50a3a (System.String)
             // Value in non-SafeMode: System.Drawing, Version= 4.0.0.0, Culture= neutral, PublicKeyToken= b03f5f7f11d50a3a (System.String)</code>
             </para>
             <para>The <see cref="T:KGySoft.Resources.ResXResourceSet"/> class supports adding new resources (<see cref="M:KGySoft.Resources.ResXResourceSet.SetObject(System.String,System.Object)">SetObject</see>), metadata (<see cref="M:KGySoft.Resources.ResXResourceSet.SetMetaObject(System.String,System.Object)">SetMetaObject</see>) and aliases (<see cref="M:KGySoft.Resources.ResXResourceSet.SetAliasValue(System.String,System.String)">SetAliasValue</see>).
             Existing entries can be removed by <see cref="M:KGySoft.Resources.ResXResourceSet.RemoveObject(System.String)">RemoveObject</see>, <see cref="M:KGySoft.Resources.ResXResourceSet.RemoveMetaObject(System.String)">RemoveMetaObject</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.RemoveAliasValue(System.String)">RemoveAliasValue</see> methods.
             The changed set can be saved by the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">Save</see> overloads.</para>
             <h2>Example: Populating and saving a new resource set</h2>
             <para>
             The following example shows how to create a new resource set, add a new resource and save the content. It demonstrates the usage of the key-based resource access, too.
             <code lang="C#"><![CDATA[
             using System;
             using System.IO;
             using System.Text;
             using KGySoft.Resources;
             
             public class Example
             {
                 public static void Main()
                 {
                     const string key = "myKey";
                     var set = new ResXResourceSet();
             
                     // GetString/GetObject: reads a resource by key (GetMetaString/GetMetaObject for metadata, GetAliasValue for alias)
                     Console.WriteLine($"Getting a non-existing key: {set.GetString(key) ?? "<null>"}");
             
                     // SetObject: adds a new resource or replaces an existing one (SetMetaObject for metadata, SetAliasValue for assembly alias)
                     // you can even remove entries by RemoveObject/RemoveMetaObject/RemoveAliasValue)
                     set.SetObject(key, "a string value");
                     Console.WriteLine($"Getting an existing key: {set.GetString(key) ?? "<null>"}");
             
                     var savedContent = new StringBuilder();
                     set.Save(new StringWriter(savedContent), compatibleFormat: false); // try compatibleFormat: true as well
                     Console.WriteLine("Saved .resx content:");
                     Console.WriteLine(savedContent);
                 }
             }
            
             // The example displays the following output:
             // Getting a non-existing key: <null>
             // Getting an existing key: a string value
             // Saved .resx content:
             // <?xml version="1.0" encoding="utf-8"?>
             // <root>
             //   <data name="myKey">
             //     <value>a string value</value>
             //   </data>
             // </root>]]></code>
             </para>
             <para>If a .resx content contains the same resource name multiple times, <see cref="T:KGySoft.Resources.ResXResourceSet"/> will contain the lastly defined key. To obtain redefined values use <see cref="T:KGySoft.Resources.ResXResourceReader"/> explicitly
             and set <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys"/> to <see langword="true"/>.</para>
             <para>If the <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> property is <see langword="true"/> the value of the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property returned by the enumerator methods is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
             instance rather than the resource value. The same applies for the return value of <see cref="O:KGySoft.Resources.ResXResourceSet.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> methods. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the example at <see cref="T:KGySoft.Resources.ResXDataNode"/>.
             <note type="security">Even if <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/>, loading a .resx content with corrupt or malicious entry will have no effect until we try to obtain the corresponding value. See the example below for the demonstration.</note>
             </para>
             <para>If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> property is <see langword="true"/> the <see cref="O:KGySoft.Resources.ResXResourceSet.GetString">GetString</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> methods will not throw an
             <see cref="T:System.InvalidOperationException"/> even for non-string values; they return the raw XML value instead.</para>
             <h2>Example: The SafeMode property</h2>
             <para>
             The following example demonstrates the behavior of <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> property (see the first example as well, where the entries are accessed by the enumerators).
             <code lang="C#"><![CDATA[
             using System;
             using KGySoft.Resources;
             
             public class Example
             {
                 private const string resx = @"<?xml version='1.0' encoding='utf-8'?>
             <root>
               <data name='string'>
                 <value>Test string</value>
                 <comment>Default data type is string (when there is neither 'type' nor 'mimetype' attribute).</comment>
               </data>
             
               <data name='binary' type='System.Byte[]'>
                 <value>VGVzdCBieXRlcw==</value>
               </data>
             
               <data name='dangerous' mimetype='application/x-microsoft.net.object.binary.base64'>
                 <value>boo!</value>
                 <comment>BinaryFormatter will throw an exception for this invalid content.</comment>
               </data>
             </root>";
             
                 public static void Main()
                 {
                     // please note that default value of SafeMode is false. Nevertheless, reading the .resx containing an invalid node (dangerous)
                     // will not cause any problem because nothing is deserialized yet.
                     var set = ResXResourceSet.FromFileContents(resx); // same as "new ResXResourceSet(new StringReader(resx));"
             
                     // enabling SafeMode changes the GetObject/GetString behavior
                     set.SafeMode = true;
             
                     Console.WriteLine($"Return type of GetObject in safe mode: {set.GetObject("string").GetType()}");
             
                     Console.WriteLine();
                     Console.WriteLine("*** Demonstrating SafeMode=true ***");
                     TreatSafely(set, "unknown");
                     TreatSafely(set, "string");
                     TreatSafely(set, "binary");
                     TreatSafely(set, "dangerous");
             
                     set.SafeMode = false;
                     Console.WriteLine();
                     Console.WriteLine("*** Demonstrating SafeMode=false ***");
                     TreatUnsafely(set, "unknown");
                     TreatUnsafely(set, "string");
                     TreatUnsafely(set, "binary");
                     TreatUnsafely(set, "dangerous");
                 }
             
                 private static void TreatSafely(ResXResourceSet set, string resourceName)
                 {
                     // in SafeMode GetObject returns a ResXDataNode
                     var resource = set.GetObject(resourceName) as ResXDataNode;
                     if (resource == null)
                     {
                         Console.WriteLine($"Resource name '{resourceName}' does not exist in resource set or SafeMode is off.");
                         return;
                     }
             
                     if (resource.TypeName == null && resource.MimeType == null)
                     {
                         // to deserialize a node considered safe call GetValue
                         Console.WriteLine($"Resource with name '{resourceName}' is a string so it is safe. Its value is '{resource.GetValue()}'");
                         return;
                     }
             
                     if (resource.TypeName != null)
                     {
                         Console.WriteLine($"Resource with name '{resourceName}' is a '{resource.TypeName}'. If we trust this type we can call GetValue to deserialize it.");
                     }
                     else
                     {
                         Console.WriteLine($"Resource with name '{resourceName}' has only mime type: '{resource.MimeType}'.");
                         Console.WriteLine("  We cannot tell its type before we deserialize it. We can consider this entry potentially dangerous.");
                     }
             
                     // In SafeMode GetString(resourceName) never fails.
                     // resource.ValueData is similar but ValueData can be null if we allow cleanup .resx content after deserialization.
                     Console.WriteLine($"  Raw string value: {set.GetString(resourceName)}");
                 }
             
                 private static void TreatUnsafely(ResXResourceSet set, string resourceName)
                 {
                     // If SafeMode is false, GetObject returns null for existing resources containing null value, too.
                     // Use ContainsResource to distinct non-existing and null values.
                     if (!set.ContainsResource(resourceName))
                     {
                         Console.WriteLine($"The resource set does not contain a resource named '{resourceName}'.");
                         return;
                     }
                     try
                     {
                         // If SafeMode is false, GetObject tries to deserialize the resource.
                         // GetString would throw an InvalidOperationException on non-string values.
                         var value = set.GetObject(resourceName);
                         Console.WriteLine($"Type of resource with name '{resourceName}' is {value?.GetType().ToString() ?? "<none>"}. String representation: {value ?? "<null>"}");
                     }
                     catch (Exception e)
                     {
                         Console.WriteLine($"Obtaining '{resourceName}' failed with an error: {e.Message}");
                     }
                 }
             }]]>
             
             // The example displays the following output:
             // Return type of GetObject in safe mode: KGySoft.Resources.ResXDataNode
             // 
             // *** Demonstrating SafeMode=true ***
             // Resource name 'unknown' does not exist in resource set or SafeMode is off.
             // Resource with name 'string' is a string so it is safe. Its value is 'Test string'
             // Resource with name 'binary' is a 'System.Byte[]'. If we trust this type we can call GetValue to deserialize it.
             //   Raw string value: VGVzdCBieXRlcw==
             // Resource with name 'dangerous' has only mime type: 'application/x-microsoft.net.object.binary.base64'.
             //   We cannot tell its type before we deserialize it. We can consider this entry potentially dangerous.
             //   Raw string value: boo!
             // 
             // *** Demonstrating SafeMode=false ***
             // The resource set does not contain a resource named 'unknown'.
             // Type of resource with name 'string' is System.String. String representation: Test string
             // Type of resource with name 'binary' is System.Byte[]. String representation: System.Byte[]
             // Obtaining 'dangerous' failed with an error: The input is not a valid Base-64 string as it contains a non-base 64 character,
             // more than two padding characters, or an illegal character among the padding characters.</code>
             </para>
             <h2>Comparison with System.Resources.ResXResourceSet<a name="comparison">&#160;</a></h2>
             <para><see cref="T:KGySoft.Resources.ResXResourceSet"/> can load .resx files produced both by <see cref="T:KGySoft.Resources.ResXResourceWriter"/> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a>.
             <note>When reading a .resx file written by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a> class,
             the <c>System.Windows.Forms.dll</c> is not loaded during resolving <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a>
             and <strong>System.Resources.ResXNullRef</strong> types.</note>
             </para>
             <para><strong>Incompatibility</strong> with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourceset" target="_blank">System.Resources.ResXResourceSet</a>:
             <list type="bullet">
             <item>There are no constructors with single <see cref="T:System.String"/> and <see cref="T:System.IO.Stream"/> arguments; though if using pure C# (without reflection) this is a compatible change as the second parameter of the constructors is optional.</item>
             <item>The constructors of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourceset" target="_blank">System.Resources.ResXResourceSet</a> throw an <see cref="T:System.ArgumentException"/> on any
             kind of error, including when an object cannot be deserialized. This <see cref="T:KGySoft.Resources.ResXResourceSet"/> implementation does not deserialize anything on construction just parses the raw XML content. If there is a syntax error in the .resx
             content an <see cref="T:System.Xml.XmlException"/> will be thrown from the constructors. If an entry cannot be deserialized, the <see cref="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String)">GetObject</see>, <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see>,
             <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> and <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> methods will throw
             an <see cref="T:System.Xml.XmlException"/>, <see cref="T:System.TypeLoadException"/>, <see cref="T:System.Runtime.Serialization.SerializationException"/> or <see cref="T:System.NotSupportedException"/> based on the nature of the error.</item>
             <item>This <see cref="T:KGySoft.Resources.ResXResourceSet"/> is a sealed class.</item>
             </list>
             </para>
             <para><strong>New features and improvements</strong> compared to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourceset" target="_blank">System.Resources.ResXResourceSet</a>:
             <list type="bullet">
             <item><term>Supporting file references</term>
             <description>If the .resx file contains file references with relative paths, then a base path can be defined in the constructors so the file references can be resolved successfully. See also the <see cref="T:KGySoft.Resources.ResXFileRef"/> class.</description></item>
             <item><term>Full .resx support</term>
             <description>A .resx file can contain also metadata and assembly alias entries in addition to resources and this <see cref="T:KGySoft.Resources.ResXResourceSet"/> implementation handles them.</description></item>
             <item><term>Performance</term>
             <description>Load time is much faster because the constructors just simply parse the raw XML content. The actual deserialization occurs on demand only for the really accessed resources and metadata.
             Memory footprint is tried to be kept minimal as well. If <see cref="P:KGySoft.Resources.ResXResourceSet.AutoFreeXmlData"/> is <see langword="true"/>, then raw XML data is freed after deserializing and caching an entry.</description></item>
             <item><term>Security</term>
             <description>This <see cref="T:KGySoft.Resources.ResXResourceSet"/> is much more safe, even if <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/>, because no object is deserialized at load time.
             If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, then security is even more increased as <see cref="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String,System.Boolean)">GetObject</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> methods, and the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see>
             property of the enumerators returned by <see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">GetEnumerator</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> methods return a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of a deserialized object
             so you can check whether the resource or metadata can be treat as a safe object before actually deserializing it. See the example above for more details.</description></item>
             <item><term>Write support</term>
             <description>The .resx file content can be expanded, existing entries can be replaced or removed and the new content can be saved by the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">Save</see> methods.
             You can start even with a completely empty set, add content dynamically and save the new resource set.</description></item>
             </list>
             </para>
             </remarks>
             <seealso cref="T:KGySoft.Resources.ResXDataNode"/>
             <seealso cref="T:KGySoft.Resources.ResXFileRef"/>
             <seealso cref="T:KGySoft.Resources.ResXResourceReader"/>
             <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
             <seealso cref="T:KGySoft.Resources.ResXResourceManager"/>
             <seealso cref="T:KGySoft.Resources.HybridResourceManager"/>
             <seealso cref="T:KGySoft.Resources.DynamicResourceManager"/>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceSet.FileName">
            <summary>
            If this <see cref="T:KGySoft.Resources.ResXResourceSet"/> has been created from a file, returns the name of the original file.
            This property will not change if the <see cref="T:KGySoft.Resources.ResXResourceSet"/> is saved into another file.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceSet.SafeMode">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.Resources.ResXResourceSet"/> works in safe mode. In safe mode the retrieved
            objects are not deserialized automatically.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceSet.GetObject">GetObject</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> methods
            return <see cref="T:KGySoft.Resources.ResXDataNode"/> instances instead of deserialized objects. You can retrieve the deserialized objects by calling
            the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.</para>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, then <see cref="O:KGySoft.Resources.ResXResourceSet.GetString">GetString</see> and <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> methods
            will return a <see cref="T:System.String"/> also for non-string objects. For non-string elements the raw XML string value will be returned.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, then <see cref="P:KGySoft.Resources.ResXResourceSet.AutoFreeXmlData"/> property is ignored. The raw XML data of a node
            can be freed when calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> method.</para>
            <para>For examples see the documentation of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class.</para>
            </remarks>
            <seealso cref="P:KGySoft.Resources.ResXResourceReader.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceManager.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.HybridResourceManager.SafeMode"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceSet.AutoFreeXmlData"/>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceSet.BasePath">
            <summary>
            Gets the base path for the relative file paths specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object.
            </summary>
            <returns>
            A path that, if prepended to the relative file path specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object, yields an absolute path to a resource file.
            </returns>
            <remarks>This property is read-only. To define a base path specify it in the constructors. When a <see cref="T:KGySoft.Resources.ResXResourceSet"/> is saved by
            one of the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">Save</see> methods you can define an alternative path, which will not overwrite the value of this property.</remarks>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceSet.AutoFreeXmlData">
            <summary>
            Gets or sets whether the raw XML data of the stored elements should be freed once their value has been deserialized.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <value>
            <see langword="true"/> to free the stored raw XML data automatically; otherwise, <see langword="false"/>.
            </value>
            <remarks>
            <para>If the value of the property is <see langword="true"/>, then the stored raw XML data will be automatically freed when
            a resource or metadata item is obtained by <see cref="O:KGySoft.Resources.ResXResourceSet.GetObject">GetObject</see>, <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see>,
            <see cref="O:KGySoft.Resources.ResXResourceSet.GetString">GetString</see> or <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> methods.
            The raw XML data is re-generated on demand if needed, it is transparent to the user.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> or <see cref="P:KGySoft.Resources.ResXResourceSet.CloneValues"/> properties are <see langword="true"/>, this property has no effect.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceSet.IsModified">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.ResXResourceSet" /> instance is modified (contains unsaved data).
            </summary>
            <value>
            <see langword="true"/> if this instance is modified; otherwise, <see langword="false"/>.
            </value>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceSet.CloneValues">
            <summary>
            Gets or sets whether <see cref="O:KGySoft.Resources.ResXResourceSet.GetObject">GetObject</see>/<see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see>
            and <see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">GetEnumerator</see>/<see cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> methods return always a new copy of the stored values.
            <br/>Default value: <see langword="false" />.
            </summary>
            <exception cref="T:System.NotImplementedException">
            </exception>
            <remarks>
            <para>To be compatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/System.Resources.ResXResourceSet" target="_blank">System.Resources.ResXResourceSet</a> this
            property is <see langword="false"/> by default. However, it can be a problem for mutable types if the returned value is changed by the consumer.</para>
            <para>To be compatible with <see cref="T:System.Resources.ResourceSet"/> set this property to <see langword="true"/>.</para>
            <para>Some known immutable types are not cloned.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of a <see cref="T:KGySoft.Resources.ResXResourceSet"/> class using the <see cref="T:KGySoft.Resources.ResXResourceReader"/> that opens and reads resources from the specified file.
            </summary>
            <param name="fileName">The name of the file to read resources from. If <see langword="null"/>, just an empty <see cref="T:KGySoft.Resources.ResXResourceSet"/> will be created. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="basePath">The base path for the relative file paths specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object. If <see langword="null"/> and <paramref name="fileName"/> is not <see langword="null"/>, the directory part of <paramref name="fileName"/> will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <note type="tip">To create a <see cref="T:KGySoft.Resources.ResXResourceSet"/> from a string use the <see cref="M:KGySoft.Resources.ResXResourceSet.FromFileContents(System.String,System.String)">FromFileContents</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.#ctor(System.IO.Stream,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class using the <see cref="T:KGySoft.Resources.ResXResourceReader"/> to read resources from the specified <paramref name="stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> of resources to be read. The stream should refer to a valid resource file content.</param>
            <param name="basePath">The base path for the relative file paths specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object. If <see langword="null"/>, the current directory will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class using the <see cref="T:KGySoft.Resources.ResXResourceReader"/> to read resources from the specified <paramref name="textReader"/>.
            </summary>
            <param name="textReader">The <see cref="T:System.IO.TextReader"/> of resources to be read. The reader should refer to a valid resource file content.</param>
            <param name="basePath">The base path for the relative file paths specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object. If <see langword="null"/>, the current directory will be used. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.#ctor(System.String)">
            <summary>
            Initializes a new, empty instance of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class.
            </summary>
            <param name="basePath">The base path for the relative file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects,
            which will be added to this empty <see cref="T:KGySoft.Resources.ResXResourceSet"/> instance.</param>
            <remarks>This constructor is private so the single string parameter in the public constructors means file name, which is compatible with the system version.</remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.FromFileContents(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:KGySoft.Resources.ResXResourceSet"/> object and initializes it to read a string whose contents are in the form of an XML resource file.
            </summary>
            <returns>A <see cref="T:KGySoft.Resources.ResXResourceSet"/> instance that reads resources from the <paramref name="fileContents"/> string.</returns>
            <param name="fileContents">A string containing XML resource-formatted information.</param>
            <param name="basePath">The base path for the relative file paths specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns></returns>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetDefaultReader">
            <summary>
            Returns the type of <see cref="T:KGySoft.Resources.ResXResourceReader"/>, which is the preferred resource reader class for <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            </summary>
            <returns>
            The <see cref="T:System.Type"/> of <see cref="T:KGySoft.Resources.ResXResourceReader"/>, which is the preferred resource reader for <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetDefaultWriter">
            <summary>
            Returns the type of <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, which is the preferred resource writer class for <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            </summary>
            <returns>
            The <see cref="T:System.Type"/> of <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, which is the preferred resource writer for <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> that can iterate through the resources of the <see cref="T:KGySoft.Resources.ResXResourceSet" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> for the resources of this <see cref="T:KGySoft.Resources.ResXResourceSet" />.
            </returns>
            <remarks>
            <para>The returned enumerator iterates through the resources of the <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            To obtain a specific resource by name, use the <see cref="O:KGySoft.Resources.ResXResourceSet.GetObject">GetObject</see> or <see cref="O:KGySoft.Resources.ResXResourceSet.GetString">GetString</see> methods.
            To obtain an enumerator for the metadata entries instead, use the <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> method instead.</para>
            <para>If the <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> property is <see langword="true"/>, the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the examples at <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXResourceSet"/> classes.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <seealso cref="O:KGySoft.Resources.ResXResourceSet.GetObject"/>
            <seealso cref="O:KGySoft.Resources.ResXResourceSet.GetString"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetAliasEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> that can iterate through the metadata of the <see cref="T:KGySoft.Resources.ResXResourceSet" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> for the metadata of this <see cref="T:KGySoft.Resources.ResXResourceSet" />.
            </returns>
            <remarks>
            <para>The returned enumerator iterates through the metadata entries of the <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            To obtain a specific metadata by name, use the <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> or <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> methods.
            To obtain an enumerator for the resources use the <see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">GetEnumerator</see> method instead.</para>
            <para>If the <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> property is <see langword="true"/>, the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the examples at <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXResourceSet"/> classes.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetAliasEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetAliasEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> that can iterate through the aliases of the <see cref="T:KGySoft.Resources.ResXResourceSet" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> for the aliases of this <see cref="T:KGySoft.Resources.ResXResourceSet" />.
            </returns>
            <remarks>
            <para>The returned enumerator iterates through the assembly aliases of the <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            To obtain a specific alias value by assembly name, use the <see cref="M:KGySoft.Resources.ResXResourceSet.GetAliasValue(System.String)">GetAliasValue</see> method.
            To obtain an enumerator for the resources use the <see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">GetEnumerator</see> method instead.</para>
            <para>The <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is always a <see cref="T:System.String"/> regardless of the value of the <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> property.</para>
            <para>The <see cref="P:System.Collections.IDictionaryEnumerator.Key">IDictionaryEnumerator.Key</see> property of the returned enumerator is the alias name, whereas <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> is the corresponding assembly name.</para>
            <note>The returned enumerator supports the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetAliasValue(System.String)"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator"/>
            <seealso cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String)">
            <summary>
            Searches for a resource object with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Case-sensitive name of the resource to search for.</param>
            <returns>
            The requested resource, or when <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance
            from which the resource can be obtained. If the requested <paramref name="name"/> cannot be found, <see langword="null"/> is returned.
            </returns>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, the returned object is a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance from which the resource can be obtained.</para>
            <para>For examples, see the description of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetObject(System.String,System.Boolean)">
            <summary>
            Searches for a resource object with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored.</param>
            <returns>
            The requested resource, or when <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance
            from which the resource can be obtained. If the requested <paramref name="name"/> cannot be found, <see langword="null"/> is returned.
            </returns>
            <remarks> 
            <para>When <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, the returned object is a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance from which the resource can be obtained.</para>
            <para>For examples, see the description of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> and <see cref="T:KGySoft.Resources.ResXDataNode"/> classes.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetString(System.String)">
            <summary>
            Searches for a <see cref="T:System.String" /> resource with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource to search for.</param>
            <returns>
            The <see cref="T:System.String"/> value of a resource.
            If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/>, an <see cref="T:System.InvalidOperationException"/> will be thrown for
            non-string resources. If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, the raw XML value will be returned for non-string resources.
            </returns>
            <remarks>
            <para>For examples, see the description of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/> and the type of the resource is not <see cref="T:System.String"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetString(System.String,System.Boolean)">
            <summary>
            Searches for a <see cref="T:System.String" /> resource with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored.</param>
            <returns>
            The <see cref="T:System.String"/> value of a resource.
            If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/>, an <see cref="T:System.InvalidOperationException"/> will be thrown for
            non-string resources. If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, the raw XML value will be returned for non-string resources.
            </returns>
            <remarks>
            <para>For examples, see the description of the <see cref="T:KGySoft.Resources.ResXResourceSet"/> class.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/> and the type of the resource is not <see cref="T:System.String"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">
            <summary>
            Searches for a metadata object with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional
            <br/>Default value: <see langword="false"/></param>
            <returns>
            The requested metadata, or when <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance
            from which the metadata can be obtained. If the requested <paramref name="name"/> cannot be found, <see langword="null"/> is returned.
            </returns>
            <remarks>
            When <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, the returned object is a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance
            from which the metadata can be obtained.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetMetaString(System.String,System.Boolean)">
            <summary>
            Searches for a <see cref="T:System.String" /> metadata with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional
            <br/>Default value: <see langword="false"/></param>
            <returns>
            The <see cref="T:System.String"/> value of a metadata.
            If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/>, an <see cref="T:System.InvalidOperationException"/> will be thrown for
            non-string metadata. If <see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="true"/>, the raw XML value will be returned for non-string metadata.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.ResXResourceSet.SafeMode"/> is <see langword="false"/> and the type of the metadata is not <see cref="T:System.String"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.GetAliasValue(System.String)">
            <summary>
            Gets the assembly name for the specified <paramref name="alias"/>.
            </summary>
            <param name="alias">The alias of the assembly name, which should be retrieved.</param>
            <returns>The assembly name of the <paramref name="alias"/>, or <see langword="null"/> if there is no such alias defined.</returns>
            <remarks>If an alias is redefined in the .resx file, then this method returns the last occurrence of the alias value.</remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="alias"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.SetObject(System.String,System.Object)">
            <summary>
            Adds or replaces a resource object in the current <see cref="T:KGySoft.Resources.ResXResourceSet" /> with the specified <paramref name="name" />.
            </summary>
            <param name="name">Name of the resource to set. Casing is not ignored.</param>
            <param name="value">The resource value to set.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet" /> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <remarks>
            <para>If <paramref name="value"/> is <see langword="null"/>, a null reference will be explicitly stored.
            Its effect is similar to the <see cref="M:KGySoft.Resources.ResXResourceSet.RemoveObject(System.String)">RemoveObject</see> method (<see cref="O:KGySoft.Resources.ResXResourceSet.GetObject">GetObject</see> will return <see langword="null"/> in both cases),
            but if <see langword="null"/> has been set, it will returned among the results of the <see cref="M:KGySoft.Resources.ResXResourceSet.GetEnumerator">GetEnumerator</see> method.</para>
            <para><paramref name="value"/> can be a <see cref="T:KGySoft.Resources.ResXDataNode"/> as well, its value will be interpreted correctly and added to the <see cref="T:KGySoft.Resources.ResXResourceSet"/> with the specified <paramref name="name"/>.</para>
            <para>If <paramref name="value"/> is a <see cref="T:KGySoft.Resources.ResXFileRef"/>, then a file reference will be added to the <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            On saving its path will be made relative to the specified <c>basePath</c> argument of the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">Save</see> methods.
            If <c>forceEmbeddedResources</c> is <see langword="true"/> on saving, the file references will be converted to embedded ones.</para>
            <note>Not just <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXFileRef"/> are handled but <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>
            and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> as well. The compatibility with the system versions
            is provided without any reference to <c>System.Windows.Forms.dll</c>, where those types are located.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.SetMetaObject(System.String,System.Object)">
            <summary>
            Adds or replaces a metadata object in the current <see cref="T:KGySoft.Resources.ResXResourceSet" /> with the specified <paramref name="name" />.
            </summary>
            <param name="name">Name of the metadata value to set.</param>
            <param name="value">The metadata value to set. If <see langword="null" />, the value will be removed.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <remarks>
            <para>If <paramref name="value"/> is <see langword="null"/>, a null reference will be explicitly stored.
            Its effect is similar to the <see cref="M:KGySoft.Resources.ResXResourceSet.RemoveMetaObject(System.String)">RemoveMetaObject</see> method (<see cref="M:KGySoft.Resources.ResXResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> will return <see langword="null"/> in both cases),
            but if <see langword="null"/> has been set, it will returned among the results of the <see cref="M:KGySoft.Resources.ResXResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> method.</para>
            <para><paramref name="value"/> can be a <see cref="T:KGySoft.Resources.ResXDataNode"/> as well, its value will be interpreted correctly and added to the <see cref="T:KGySoft.Resources.ResXResourceSet"/> with the specified <paramref name="name"/>.</para>
            <para>If <paramref name="value"/> is a <see cref="T:KGySoft.Resources.ResXFileRef"/>, then a file reference will be added to the <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            On saving its path will be made relative to the specified <c>basePath</c> argument of the <see cref="O:KGySoft.Resources.ResXResourceSet.Save">Save</see> methods.
            If <c>forceEmbeddedResources</c> is <see langword="true"/> on saving, the file references will be converted to embedded ones.</para>
            <note>Not just <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXFileRef"/> are handled but <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>
            and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> as well. The compatibility with the system versions
            is provided without any reference to <c>System.Windows.Forms.dll</c>, where those types are located.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.SetAliasValue(System.String,System.String)">
            <summary>
            Adds or replaces an assembly alias value in the current <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            </summary>
            <param name="alias">The alias name to use instead of <paramref name="assemblyName"/> in the saved .resx file.</param>
            <param name="assemblyName">The fully or partially qualified name of the assembly.</param>
            <remarks>
            <note>The added alias values are dumped on demand when saving: only when a resource type is defined in the <see cref="T:System.Reflection.Assembly"/>, whose name is the <paramref name="assemblyName"/>.
            Other alias names will be auto generated for non-specified assemblies.</note>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName"/> or <paramref name="alias"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.RemoveObject(System.String)">
            <summary>
            Removes a resource object from the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource value to remove. Name is treated case sensitive.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.RemoveMetaObject(System.String)">
            <summary>
            Removes a metadata object from the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata value to remove. Name is treated case sensitive.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.RemoveAliasValue(System.String)">
            <summary>
            Removes an assembly alias value from the current <see cref="T:KGySoft.Resources.ResXResourceSet"/>.
            </summary>
            <param name="alias">The alias, which should be removed.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="alias"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.Save(System.String,System.Boolean,System.Boolean,System.String)">
            <summary>
            Saves the <see cref="T:KGySoft.Resources.ResXResourceSet" /> to the specified file.</summary>
            <param name="fileName">The location of the file where you want to save the resources.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>),
            but the result can be read only by <see cref="T:KGySoft.Resources.ResXResourceReader"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="forceEmbeddedResources">If set to <see langword="true"/> the resources using a file reference (<see cref="T:KGySoft.Resources.ResXFileRef"/>) will be replaced by embedded resources. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="newBasePath">A new base path for the file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects. If <see langword="null"/>,
            the original <see cref="P:KGySoft.Resources.ResXResourceSet.BasePath"/> will be used. The file paths in the saved .resx file will be relative to the <paramref name="newBasePath"/>.
            Applicable if <paramref name="forceEmbeddedResources"/> is <see langword="false"/>. This parameter is optional.
            <br/>Default value: <c><see langword="null"/>.</c></param>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.Save(System.IO.Stream,System.Boolean,System.Boolean,System.String)">
            <summary>
            Saves the <see cref="T:KGySoft.Resources.ResXResourceSet" /> to the specified <paramref name="stream"/>.</summary>
            <param name="stream">The stream to which you want to save.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>),
            but the result can be read only by <see cref="T:KGySoft.Resources.ResXResourceReader"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="forceEmbeddedResources">If set to <see langword="true"/> the resources using a file reference (<see cref="T:KGySoft.Resources.ResXFileRef"/>) will be replaced by embedded resources. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="newBasePath">A new base path for the file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects. If <see langword="null"/>,
            the original <see cref="P:KGySoft.Resources.ResXResourceSet.BasePath"/> will be used. The file paths in the saved .resx file will be relative to the <paramref name="newBasePath"/>.
            Applicable if <paramref name="forceEmbeddedResources"/> is <see langword="false"/>. This parameter is optional.
            <br/>Default value: <c><see langword="null"/>.</c></param>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.Save(System.IO.TextWriter,System.Boolean,System.Boolean,System.String)">
            <summary>
            Saves the <see cref="T:KGySoft.Resources.ResXResourceSet" /> by the specified <paramref name="textWriter"/>.</summary>
            <param name="textWriter">The text writer to which you want to save.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>),
            but the result can be read only by <see cref="T:KGySoft.Resources.ResXResourceReader"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="forceEmbeddedResources">If set to <see langword="true"/> the resources using a file reference (<see cref="T:KGySoft.Resources.ResXFileRef"/>) will be replaced by embedded resources. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="newBasePath">A new base path for the file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects. If <see langword="null"/>,
            the original <see cref="P:KGySoft.Resources.ResXResourceSet.BasePath"/> will be used. The file paths in the saved .resx file will be relative to the <paramref name="newBasePath"/>.
            Applicable if <paramref name="forceEmbeddedResources"/> is <see langword="false"/>. This parameter is optional.
            <br/>Default value: <c><see langword="null"/>.</c></param>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.ContainsResource(System.String,System.Boolean)">
            <summary>
            Gets whether the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> contains a resource with the given <paramref name="name"/>.
            </summary>
            <param name="name">The name of the resource to check.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <returns><see langword="true"/>, if the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> contains a resource with name <paramref name="name"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.ContainsMeta(System.String,System.Boolean)">
            <summary>
            Gets whether the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> contains a metadata with the given <paramref name="name"/>.
            </summary>
            <param name="name">The name of the metadata to check.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <returns><see langword="true"/>, if the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> contains a metadata with name <paramref name="name"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceSet.Dispose(System.Boolean)">
            <summary>
            Releases the resources of the current <see cref="T:KGySoft.Resources.ResXResourceSet"/> instance.
            </summary>
            <param name="disposing">Indicates whether the objects contained in the current instance should be explicitly closed.</param>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceWriter">
             <summary>
             Writes resources in an XML resource (.resx) file or an output stream.
             </summary>
             <remarks>
             <note>This class is similar to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a>
             in <c>System.Windows.Forms.dll</c>. See the <a href="#comparison">Comparison with System.Resources.ResXResourceWriter</a> section for the differences.</note>
             <note type="tip">To see when to use the <see cref="T:KGySoft.Resources.ResXResourceReader"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/>, <see cref="T:KGySoft.Resources.ResXResourceSet"/>, <see cref="T:KGySoft.Resources.ResXResourceManager"/>, <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
             classes see the documentation of the <see cref="N:KGySoft.Resources">KGySoft.Resources</see> namespace.</note>
             <para>Resources are specified as name/value pairs using the <see cref="M:KGySoft.Resources.ResXResourceWriter.AddResource(System.String,System.Object)">AddResource</see> method.</para>
             <para>If <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> property is <see langword="true"/>, <see cref="T:KGySoft.Resources.ResXResourceWriter"/> emits .resx files, which can be then read not just by <see cref="T:KGySoft.Resources.ResXResourceReader"/>
             but by the original <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class, too.</para>
             <example>
             The following example shows how to create a resource file by <see cref="T:KGySoft.Resources.ResXResourceWriter"/> and add different kind of resource objects to it. At the end it displays the resulting .resx file content.
             <code lang="C#"><![CDATA[
             using System;
             using System.Drawing;
             using System.IO;
             using KGySoft.Resources;
            
             public class Example
             {
                 [Serializable]
                 private class MyCustomClass
                 {
                     public string StringProp { get; set; }
                     public int IntProp { get; set; }
                 }
            
                 public static void Main()
                 {
                     // Check the result with CompatibleFormat = true as well.
                     // You will get a much longer result, which will be able to read by System.Resources.ResXResourceReader, too.
                     var result = new StringWriter();
                     using (var writer = new ResXResourceWriter(result) { CompatibleFormat = false })
                     {
                         writer.AddResource("string", "string value");
                         writer.AddResource("int", 42);
                         writer.AddResource("null", (object)null);
                         writer.AddResource("file", new ResXFileRef(@"images\Image.jpg", typeof(Bitmap)));
                         writer.AddResource("custom", new MyCustomClass { IntProp = 42, StringProp = "blah" });
                     }
            
                     Console.WriteLine(result.GetStringBuilder());
                 }
             }
             
             // The example displays the following output:
             // <?xml version="1.0" encoding="utf-8"?>
             // <root>
             //   <data name="string">
             //     <value>string value</value>
             //   </data>
             //   <data name="int" type="System.Int32">
             //     <value>42</value>
             //   </data>
             //   <assembly alias="KGySoft.CoreLibraries" name="KGySoft.CoreLibraries, Version=3.6.3.1, Culture=neutral, PublicKeyToken=b45eba277439ddfe" />
             //   <data name="null" type="KGySoft.Resources.ResXNullRef, KGySoft.CoreLibraries">
             //     <value />
             //   </data>
             //   <data name="file" type="KGySoft.Resources.ResXFileRef, KGySoft.CoreLibraries">
             //     <value>images\Image.jpg;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
             //   </data>
             //   <data name="custom" mimetype="text/kgysoft.net/object.binary.base64">
             //     <value>
             //       PgAChAQFQkNvbnNvbGVBcHAxLCBWZXJzaW9uPTEuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49bnVsbBVF
             //       eGFtcGxlK015Q3VzdG9tQ2xhc3MBAhs8U3RyaW5nUHJvcD5rX19CYWNraW5nRmllbGQDEgAEYmxhaBg8SW50UHJvcD5rX19CYWNr
             //       aW5nRmllbGQECEAqAA==
             //     </value>
             //   </data>
             // </root>]]></code>
             </example>
             <h2>Comparison with System.Resources.ResXResourceWriter<a name="comparison">&#160;</a></h2>
             <note>When writing a .resx file in <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>, the <c>System.Windows.Forms.dll</c> is not loaded when referencing
             <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> and <strong>System.Resources.ResXNullRef</strong> types.</note>
             <para><strong>Incompatibility</strong> with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a>:
             <list type="bullet">
             <item>The System version has several public string fields, which are not intended to be accessed by a consumer code. Therefore the following fields are missing (they are not public) in this version:
             <list type="bullet">
             <item><c>BinSerializedObjectMimeType</c></item>
             <item><c>ByteArraySerializedObjectMimeType</c></item>
             <item><c>DefaultSerializedObjectMimeType</c></item>
             <item><c>ResMimeType</c></item>
             <item><c>ResourceSchema</c></item>
             <item><c>SoapSerializedObjectMimeType</c></item>
             <item><c>Version</c></item>
             </list></item>
             <item>In this version there are no one parameter constructors. Instead, the second parameter (<c>typeNameConverter</c>) is optional. If used purely from C# (no reflection or whatsoever), this change is a
             compatible one.</item>
             <item>This <see cref="T:KGySoft.Resources.ResXResourceWriter"/> is a sealed class.</item>
             <item>After disposing the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> instance or calling the <see cref="M:KGySoft.Resources.ResXResourceWriter.Close">Close</see> method, calling the <see cref="M:KGySoft.Resources.ResXResourceWriter.Generate">Generate</see> method will throw an <see cref="T:System.ObjectDisposedException"/>.</item>
             <item>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter.addalias" target="_blank">System.Resources.ResXResourceWriter.AddAlias</a> method just
             populates an inner alias list causing that the alias will be recognized on further processing but will never be dumped into the output stream. In this <see cref="T:KGySoft.Resources.ResXResourceWriter"/> implementation
             the <see cref="M:KGySoft.Resources.ResXResourceWriter.AddAlias(System.String,System.Reflection.AssemblyName,System.Boolean)">AddAlias</see> method is somewhat different: not just registers the alias as a known one but also dumps that into the output stream.
             It can be specified though, whether the dump should be deferred until the alias is actually referenced for the first time.</item>
             </list>
             </para>
             <para><strong>New features and improvements</strong> compared to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a>:
             <list type="bullet">
             <item><term>Compatibility</term>
             <description>If <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>, the resulting .resx file can be read by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>.</description></item>
             <item><term>Compactness</term>
             <description>The more compact output is achieved in multiple ways:
             <list type="bullet">
             <item>If <see cref="P:KGySoft.Resources.ResXResourceWriter.OmitHeader"/> is <see langword="true"/>, the header and the schema is not dumped into the resulting .resx file. If <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>, then only
             the header comment can be omitted.</item>
             <item>Whitespace preserving to string values is applied only if it is really necessary (even if <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>).</item>
             <item>If an object can only be binary serialized, then instead of using <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> it is serialized by <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>, which produces a much more compact result (only if <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="false"/>).
             A new MIME type has been introduced to identify binary data serialized this new way.</item>
             </list></description></item>
             <item><strong>New overloads:</strong>
             <list type="bullet">
             <item><see cref="M:KGySoft.Resources.ResXResourceWriter.AddAlias(System.String,System.String,System.Boolean)">AddAlias</see> method now can be called with a <see cref="T:System.String"/> assembly name and not just by an <see cref="T:System.Reflection.AssemblyName"/> instance.
             Both overloads have now an optional <see cref="T:System.Boolean"/> argument for specifying whether the alias must be dumped immediately.</item>
             <item>New <see cref="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(KGySoft.Resources.ResXDataNode)">AddMetadata(ResXDataNode)</see> overload, working similarly to the existing <see cref="M:KGySoft.Resources.ResXResourceWriter.AddResource(KGySoft.Resources.ResXDataNode)">AddResource(ResXDataNode)</see> method.</item>
             </list></item>
             <item><term><see cref="P:KGySoft.Resources.ResXResourceWriter.AutoGenerateAlias"/> property</term>
             <description>If <see langword="true"/>, alias names for assemblies will be automatically generated without calling <see cref="M:KGySoft.Resources.ResXResourceWriter.AddAlias(System.String,System.String,System.Boolean)">AddAlias</see> method.
             If <see langword="false"/>, the assembly qualified names will be used for non-mscorlib types, unless an alias name was explicitly added by the <see cref="M:KGySoft.Resources.ResXResourceWriter.AddAlias(System.String,System.String,System.Boolean)">AddAlias</see> method or the <see cref="T:KGySoft.Resources.ResXDataNode"/> to dump already contains an alias name.</description></item>
             <item><strong>Better support of several types:</strong>
             <list type="table">
             <listheader><term>Type</term><term>Improvement</term><term>How it is handled by the System version</term></listheader>
             <item>
             <term><see langword="null"/> value</term>
             <term>Invalid .resx representations of <see langword="null"/> value is fixed when re-written by <see cref="T:KGySoft.Resources.ResXResourceWriter"/>.
             </term><term>When the System version rewrites such an invalid <see langword="null"/> node, it turns into empty string.</term></item>
             <item><term><see cref="T:System.Array"/> of <see cref="T:System.SByte"/></term>
             <term>Serializing <see cref="T:System.SByte">sbyte[]</see> type works properly.</term>
             <term>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a> changes the <see cref="T:System.SByte">sbyte[]</see> types to <see cref="T:System.Byte">byte[]</see>.</term></item>
             <item><term><see cref="T:System.Char"/></term>
             <term>Support of unpaired surrogate characters.</term>
             <term><a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a> cannot serialize unpaired surrogates, though
             <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> can read them successfully if they are serialized by <see cref="T:KGySoft.Resources.ResXResourceWriter"/> and <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>.</term></item>
             <item><term><see cref="T:System.String"/> and any type serialized by a <see cref="T:System.ComponentModel.TypeConverter"/>.</term>
             <term>Strings containing unpaired surrogates and invalid Unicode characters can be written without any error.</term>
             <term><a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a> cannot serialize such strings, though
             <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> can read them successfully if they are serialized by <see cref="T:KGySoft.Resources.ResXResourceWriter"/> and <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>.</term></item>
             <item><term><see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/></term>
             <term>Serialized in a different way so even the milliseconds part is preserved.</term>
             <term>The fixed form can be deserialized by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>, too;
             however, the <see cref="P:System.DateTime.Kind">DateTime.Kind</see> will be always <see cref="F:System.DateTimeKind.Local"/>.</term></item>
             <item><term><see cref="T:System.Single"/>, <see cref="T:System.Double"/> and <see cref="T:System.Decimal"/></term>
             <term>-0 (negative zero) value is handled correctly.</term>
             <term>The fixed form can be deserialized by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>, too;
             however, in case of <see cref="T:System.Single"/> and <see cref="T:System.Double"/> -0 will always turn to +0.</term></item>
             <item><term><see cref="T:System.IntPtr"/>, <see cref="T:System.UIntPtr"/>, <see cref="T:System.DBNull"/> and <see cref="T:System.Type"/> instances containing a runtime type.</term>
             <term>These types are supported natively (without a <c>mimetype</c> attribute). Only if <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="false"/>.</term>
             <term><a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcewriter" target="_blank">System.Resources.ResXResourceWriter</a> can serialize these type only by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
             Though in .NET Core and .NET Standard <see cref="T:System.Type"/> is not serializable even by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.</term></item>
             <item><term>Generic types</term>
             <term>Generic types with a <see cref="T:System.ComponentModel.TypeConverter"/> are handled correctly.</term>
             <term>Parsing generic type names may fail with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>.
             The problem does not occur on binary serialization because in that case the type name is not dumped into the .resx file but is encoded in the binary stream.</term></item>
             <item><term>Any non-serializable type</term>
             <term>As long as the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> can serialize the non-serializable type, this implementation supports non-serializable types as well. This works even if <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>.</term>
             <term>If <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/> during serialization, deserialization works even with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a>
             as long as <c>KGySoft.CoreLibraries</c> assembly can be loaded and <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> can find the <see cref="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper"/> class.</term></item>
             </list></item>
             </list>
             </para>
             </remarks>
        </member>
        <member name="T:KGySoft.Resources.ResXResourceWriter.ResXWriter">
            <summary>
            Required because a writer created by XmlWriter.Create preserves \r chars only if they are entitized;
            however, to keep things readable (and compatible), entitization should be omitted on new lines and base64 wrapping,
            but entitization cannot be changed once the writing has been started. So this writer:
            - Entitizes \r \n chars only if they are not used together
            - Can write strings containing unpaired surrogates and invalid Unicode characters. This result can be read correctly even by system ResXResourceReader.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceWriter.aliases">
            <summary>
            Stores the alias mapping that should be used when writing assemblies.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResXResourceWriter.activeAliases">
            <summary>
            Stores the already written and active alias mapping.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> instance should create a System compatible .resx file, which can be used
            by the built-in resource editor of the Visual Studio.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            The value of the property affects the following differences:
            <list type="bullet">
            <item><description>The <c>reader</c> and <c>writer</c> attributes in <c>resheader</c> elements.</description></item>
            <item><description>Type of <see cref="T:KGySoft.Resources.ResXFileRef"/> file references.</description></item>
            <item><description>The placeholder type of <see langword="null"/> references.</description></item>
            <item><description>If <c>CompatibleFormat</c> is <see langword="false"/>, some additional types are supported natively (without a <c>mimetype</c> attribute): <see cref="T:System.IntPtr"/>, <see cref="T:System.UIntPtr"/>, <see cref="T:System.DBNull"/> and <see cref="T:System.Type"/>.</description></item>
            <item><description>If <c>CompatibleFormat</c> is <see langword="false"/>, unpaired surrogate <see cref="T:System.Char"/> values are supported.</description></item>
            <item><description>The <c>mimetype</c> and content of binary serialized elements. If <c>CompatibleFormat</c> is <see langword="false"/>, these objects are
            serialized by <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>, which provides a much more compact result than the default <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.</description></item>
            </list>
            </remarks>
            <exception cref="T:System.InvalidOperationException">In a set operation, a value cannot be specified because the creation of the .resx file content has already been started.</exception>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceWriter.OmitHeader">
            <summary>
            Gets or sets whether the header should be omitted. If both <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> and <see cref="P:KGySoft.Resources.ResXResourceWriter.OmitHeader"/> are <see langword="true"/>, then
            only the XML comment will be omitted. If <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="false"/> and <see cref="P:KGySoft.Resources.ResXResourceWriter.OmitHeader"/> is <see langword="true"/>, then
            the comment, the .resx schema and the <c>&lt;resheader&gt;</c> elements will be omitted, too.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">In a set operation, a value cannot be specified because the creation of the .resx file content has already been started.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceWriter"/> instance is already disposed.</exception>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceWriter.BasePath">
            <summary>
            Gets or sets the base path for the relative file path specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object.
            <br/>Default value: <see langword="null"/>.
            </summary>
            <returns>
            A path that, if prepended to the relative file path specified in a <see cref="T:KGySoft.Resources.ResXFileRef"/> object, yields an absolute path to an XML resource file.
            </returns>
            <exception cref="T:System.InvalidOperationException">In a set operation, a value cannot be specified because the creation of the .resx file content has already been started.</exception>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceWriter.AutoGenerateAlias">
            <summary>
            Gets or sets whether an alias should be auto-generated for referenced assemblies.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceWriter.AutoGenerateAlias"/> is <see langword="false"/>, then the assembly names will be referenced by fully qualified names
            unless the alias names are explicitly added by the <see cref="O:KGySoft.Resources.ResXResourceWriter.AddAlias">AddAlias</see> methods, or when a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            added by <see cref="M:KGySoft.Resources.ResXResourceWriter.AddResource(KGySoft.Resources.ResXDataNode)"/> method already contains an alias.</para>
            <para>If <see cref="P:KGySoft.Resources.ResXResourceWriter.AutoGenerateAlias"/> is <see langword="true"/>, then the assembly aliases are re-generated, even if a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            already contains an alias. To use explicitly defined names instead of auto generated names use the <see cref="O:KGySoft.Resources.ResXResourceWriter.AddAlias">AddAlias</see> methods.</para>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.ResXResourceWriter"/> instance is already disposed.</exception>
        </member>
        <member name="P:KGySoft.Resources.ResXResourceWriter.SafeMode">
            <summary>
            Gets or sets whether it is prohibited to load assemblies when writing <see cref="T:KGySoft.Resources.ResXDataNode"/> instances whose raw .resx content
            needs to be regenerated and whose value has not been deserialized yet. This can occur only if <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/> is <see langword="true"/>,
            and when the <see cref="T:KGySoft.Resources.ResXDataNode"/> instances to write have been read from another .resx source.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>This property affects only <see cref="M:KGySoft.Resources.ResXResourceWriter.AddResource(KGySoft.Resources.ResXDataNode)"/> and <see cref="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(KGySoft.Resources.ResXDataNode)"/> methods when <see cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
            is <see langword="true"/>, and the <see cref="T:KGySoft.Resources.ResXDataNode"/> to write contains no deserialized value but only raw .resx data that is not compatible with
            the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.#ctor(System.String,System.Func{System.Type,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> class that writes the resources to a specified file.
            </summary>
            <param name="fileName">The file to send output to.</param>
            <param name="typeNameConverter">A delegate that can be used to specify type names explicitly (eg. to target earlier versions of assemblies or the .NET Framework). This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>If <paramref name="typeNameConverter"/> is specified it can be used to dump custom type names for any type. If it returns <see langword="null"/> for a <see cref="T:System.Type"/>, then the default
            name will be used. To deserialize a .resx content with custom type names the <see cref="T:KGySoft.Resources.ResXResourceReader"/> constructors should be called with a non-<see langword="null"/>&#160;<see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> instance.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName"/> is <see langowrd="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.#ctor(System.IO.Stream,System.Func{System.Type,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> class that writes the resources to a specified <paramref name="stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to send the output to.</param>
            <param name="typeNameConverter">A delegate that can be used to specify type names explicitly (eg. to target earlier versions of assemblies or the .NET Framework). This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>If <paramref name="typeNameConverter"/> is specified it can be used to dump custom type names for any type. If it returns <see langword="null"/> for a <see cref="T:System.Type"/>, then the default
            name will be used. To deserialize a .resx content with custom type names the <see cref="T:KGySoft.Resources.ResXResourceReader"/> constructors should be called with a non-<see langword="null"/>&#160;<see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> instance.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <see langowrd="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.#ctor(System.IO.TextWriter,System.Func{System.Type,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Resources.ResXResourceWriter"/> class that writes the resources by a specified <paramref name="textWriter"/>.
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter"/> object to send output to.</param>
            <param name="typeNameConverter">A delegate that can be used to specify type names explicitly (eg. to target earlier versions of assemblies or the .NET Framework). This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>If <paramref name="typeNameConverter"/> is specified it can be used to dump custom type names for any type. If it returns <see langword="null"/> for a <see cref="T:System.Type"/>, then the default
            name will be used. To deserialize a .resx content with custom type names the <see cref="T:KGySoft.Resources.ResXResourceReader"/> constructors should be called with a non-<see langword="null"/>&#160;<see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> instance.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="textWriter"/> is <see langowrd="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.Finalize">
            <summary>
            This member overrides the <see cref="M:System.Object.Finalize"/> method.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddAlias(System.String,System.Reflection.AssemblyName,System.Boolean)">
            <summary>
            Adds the specified alias to the mapping of aliases.
            </summary>
            <param name="aliasName">The name of the alias.</param>
            <param name="assemblyName">The name of the assembly represented by <paramref name="aliasName"/>.</param>
            <param name="forceWriteImmediately"><see langword="true"/> to write the alias immediately to the .resx file; <see langword="false"/> just to
            add it to the inner mapping and write it only when the assembly is referenced for the first time. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="aliasName"/> or <paramref name="assemblyName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddAlias(System.String,System.String,System.Boolean)">
            <summary>
            Adds the specified alias to the mapping of aliases.
            </summary>
            <param name="aliasName">The name of the alias.</param>
            <param name="assemblyName">The name of the assembly represented by <paramref name="aliasName"/>.</param>
            <param name="forceWriteImmediately"><see langword="true"/> to write the alias immediately to the .resx file; <see langword="false"/> just to
            add it to the inner mapping and write it only when the assembly is referenced for the first time. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="aliasName"/> or <paramref name="assemblyName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(System.String,System.Byte[])">
            <summary>
            Adds a metadata node whose value is specified as a byte array to the list of resources to write.
            </summary>
            <param name="name">The name of a property.</param>
            <param name="value">A byte array containing the value of the property to add.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(System.String,System.String)">
            <summary>
            Adds a metadata node whose value is specified as a string to the list of resources to write.
            </summary>
            <param name="name">The name of a property.</param>
            <param name="value">A string that is the value of the property to add.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(System.String,System.Object)">
            <summary>
            Adds a metadata node whose value is specified as an object to the list of resources to write.
            </summary>
            <param name="name">The name of a property.</param>
            <param name="value">An object that is the value of the property to add.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddMetadata(KGySoft.Resources.ResXDataNode)">
            <summary>
            Adds a metadata node specified in a <see cref="T:KGySoft.Resources.ResXDataNode"/> object to the list of resources to write.
            </summary>
            <param name="node">A <see cref="T:KGySoft.Resources.ResXDataNode"/> object that contains a metadata name/value pair.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddResource(System.String,System.Byte[])">
            <summary>
            Adds a named resource specified as a byte array to the list of resources to write.
            </summary>
            <param name="name">The name of the resource. </param>
            <param name="value">The value of the resource to add as an 8-bit unsigned integer array.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddResource(System.String,System.Object)">
            <summary>
            Adds a named resource specified as an object to the list of resources to write.
            </summary>
            <param name="name">The name of the resource.</param>
            <param name="value">The value of the resource.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddResource(System.String,System.String)">
            <summary>
            Adds a string resource to the resources.
            </summary>
            <param name="name">The name of the resource.</param>
            <param name="value">The value of the resource.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.AddResource(KGySoft.Resources.ResXDataNode)">
            <summary>
            Adds a named resource specified in a <see cref="T:KGySoft.Resources.ResXDataNode"/> object to the list of resources to write.
            </summary>
            <param name="node">A <see cref="T:KGySoft.Resources.ResXDataNode"/> object that contains a resource name/value pair.</param>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.Close">
            <summary>
            Releases all resources used by the <see cref="T:KGySoft.Resources.ResXResourceWriter"/>.
            If content has not been saved yet (see <see cref="M:KGySoft.Resources.ResXResourceWriter.Generate">Generate</see> method), then firstly flushes any remaining content.
            </summary>
            <remarks>Calling this method is the equivalent of calling <see cref="M:KGySoft.Resources.ResXResourceWriter.Dispose">Dispose</see>.</remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:KGySoft.Resources.ResXResourceWriter"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.Generate">
            <summary>
            Flushes all pending content into the output file, <see cref="T:System.IO.TextWriter"/> or <see cref="T:System.IO.Stream"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">The resource has already been saved.</exception>
            <exception cref="T:System.ObjectDisposedException">The writer has already been disposed.</exception>
            <remarks>If used in a <c>using</c> construct, it is not needed to call this method explicitly (see the example at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>).
            <see cref="M:KGySoft.Resources.ResXResourceWriter.Close">Close</see> and <see cref="M:KGySoft.Resources.ResXResourceWriter.Dispose">Dispose</see> methods call it internally if necessary.</remarks>
        </member>
        <member name="M:KGySoft.Resources.ResXResourceWriter.GetTypeNameWithAlias(System.String,System.String)">
            <summary>
            Gets the type name with alias.
            </summary>
            <param name="origTypeName">Input type name with assembly or alias name.</param>
            <param name="asmName">If not null, origTypeName contains an alias name, and this is the assembly name.</param>
            <returns>The type name with a (possibly generated) alias or with the full name.</returns>
        </member>
        <member name="T:KGySoft.Resources.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Resources"/> namespace contains classes for resource management, which support read-write access directly to .resx files (<see cref="T:KGySoft.Resources.ResXResourceManager"/>)
            or even combined access to compiled and .resx resources (<see cref="T:KGySoft.Resources.HybridResourceManager"/>, <see cref="T:KGySoft.Resources.DynamicResourceManager"/>).
            </summary>
            <remarks>
            There are numerous classes in the <see cref="N:KGySoft.Resources"/> that can handle resources from XML sources (.resx files).
            The table below can help you to choose the best one for your needs.
            <list type="table">
            <listheader><term>Class</term><term>When to choose this one; added functionality compared to previous levels.</term></listheader>
            <item><term><see cref="T:KGySoft.Resources.ResXResourceReader"/></term>
            <term>Using <see cref="T:KGySoft.Resources.ResXResourceReader"/> is the most low-level option to read the content of a .resx file. It provides enumerators to retrieve the resources, metadata and aliases of a .resx content.
            In most cases you can use the more specialized classes, such as <see cref="T:KGySoft.Resources.ResXResourceSet"/> but there are some cases when you need to use <see cref="T:KGySoft.Resources.ResXResourceReader"/>:
            <list type="bullet">
            <item>The <see cref="T:KGySoft.Resources.ResXResourceReader"/> is able to read the .resx content in a lazy manner if <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys">ResXResourceReader.AllowDuplicatedKeys</see> is <see langword="true"/>.
            That means the .resx content is read on demand as you enumerate the contents (the contents are cached so if you retrieve an enumerator for the second time it will not process the .resx file again). It can be useful
            if you are looking for one specific key, after which you break the enumeration or if you want to process an incomplete or corrupted .resx file up to the point it can be parsed correctly.</item>
            <item>A .resx file may contain a key more than once (though it is somewhat incorrect). If <see cref="P:KGySoft.Resources.ResXResourceReader.AllowDuplicatedKeys">ResXResourceReader.AllowDuplicatedKeys</see> is <see langword="true"/>,
            you can retrieve all of the redefined values.</item>
            <item><see cref="T:KGySoft.Resources.ResXResourceReader"/> allows you to handle type names in a customized way (how names are mapped to a <see cref="T:System.Type"/>). To use custom name resolution pass an <see cref="T:System.ComponentModel.Design.ITypeResolutionService"/> instance to one of the constructors.</item>
            </list>
            </term></item>
            <item><term><see cref="T:KGySoft.Resources.ResXResourceWriter"/></term>
            <term>Using <see cref="T:KGySoft.Resources.ResXResourceWriter"/> is the most low-level option to write the content of a .resx file. Use this if at least one of the following points are applicable for you:
            <list type="bullet">
            <item>You want to have full control over the order of the dumped resources, metadata and aliases or you want to re-use a key or redefine an alias during the dump (though it is not recommended).</item>
            <item>You want to dump the full .resx header including the comments dumped also by Visual Studio when you create a resource file (see <see cref="P:KGySoft.Resources.ResXResourceWriter.OmitHeader">ResXResourceWriter.OmitHeader</see> property).</item>
            <item>You want to use customized type names when non-string resources are added. You can achieve this by passing a <see cref="T:System.Func`2">Func&lt;Type, string&gt;</see> delegate to one of the constructors.</item>
            </list></term></item>
            <item><term><see cref="T:KGySoft.Resources.ResXResourceSet"/></term>
            <term>The <see cref="T:KGySoft.Resources.ResXResourceSet"/> class represents the full content of a single .resx file in memory. It provides both enumerators and dictionary-like direct key access to the resources, metadata and aliases.
            It uses <see cref="T:KGySoft.Resources.ResXResourceReader"/> and <see cref="T:KGySoft.Resources.ResXResourceWriter"/> internally to load/save .resx content.
            As an <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> implementation it is able to add/replace/remove entries and save the content.
            Use this class in the following cases:
            <list type="bullet">
            <item>You want to access the resources/metadata/aliases of a single .resx file directly by name just like in a dictionary.</item>
            <item>You want to load the .resx content not just from a file but also a <see cref="T:System.IO.Stream"/>/<see cref="T:System.IO.TextReader"/> or to save it to a <see cref="T:System.IO.Stream"/>/<see cref="T:System.IO.TextWriter"/>.</item>
            </list>
            Specialization compared to <see cref="T:KGySoft.Resources.ResXResourceReader"/>/<see cref="T:KGySoft.Resources.ResXResourceWriter"/>:
            <list type="bullet">
            <item>Default type name handling and type resolution is used.</item>
            <item>When loading a .resx file, duplications are not allowed. For redefined names the last value will be stored.</item>
            <item>When saving a .resx file, header comment is always omitted. If content is saved in non-compatible format, the .resx schema header is omitted, too.</item>
            <item>When saving a .resx file, assembly aliases are auto generated for assemblies, which are not explicitly defined.</item></list>
            </term></item>
            <item><term><see cref="T:KGySoft.Resources.ResXResourceManager"/></term>
            <term>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> handles resources in the same manner as <see cref="T:System.Resources.ResourceManager"/> does but instead of working with binary compiled resources it uses XML resources (.resx files) directly.
            It takes the culture hierarchy into account so querying a resource by a specific <see cref="T:System.Globalization.CultureInfo"/> may end up loading multiple resource files.
            It stores <see cref="T:KGySoft.Resources.ResXResourceSet"/> instances internally to store the resources of the different cultures.
            As an <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> implementation it is able to add/replace/remove entries in the resource sets belonging to specified cultures and it can save the changed contents.
            <br/>Specialization compared to <see cref="T:KGySoft.Resources.ResXResourceSet"/>:
            <list type="bullet">
            <item>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> loads/saves the resource sets always from/into files.
            (Though you can call the <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method to access the various <see cref="O:KGySoft.Resources.IExpandoResourceSet.Save">Save</see> overloads)</item>
            <item>The <see cref="T:KGySoft.Resources.ResXResourceManager"/> does not contain methods to manipulate the aliases directly.
            (Though you can call the <see cref="M:KGySoft.Resources.ResXResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method to access the aliases directly)</item>
            </list>
            </term></item>
            <item><term><see cref="T:KGySoft.Resources.HybridResourceManager"/></term>
            <term>The <see cref="T:KGySoft.Resources.HybridResourceManager"/> combines the functionality of the regular <see cref="T:System.Resources.ResourceManager"/> and the <see cref="T:KGySoft.Resources.ResXResourceManager"/> classes.
            The source of the resources can be chosen by the <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> property (see <see cref="T:KGySoft.Resources.ResourceManagerSources"/> enumeration).
            Enabling both binary and .resx resources makes possible to expand or override the resources originally come from binary resources.
            Just like the <see cref="T:KGySoft.Resources.ResXResourceManager"/> it is an <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> implementation. The replacement and newly added content is saved into .resx files.</term></item>
            <item><term><see cref="T:KGySoft.Resources.DynamicResourceManager"/></term>
            <term>The <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is derived from <see cref="T:KGySoft.Resources.HybridResourceManager"/> and adds the functionality of automatically appending the resources with the non-translated and/or unknown entries as well as
            auto-saving the changes. This makes possible to automatically create the .resx files if the language of the application is changed to a language, which has no translation yet. See also the static <see cref="T:KGySoft.LanguageSettings"/> class.
            The strategy of auto appending and saving can be chosen by the <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/> and <see cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/> properties (see <see cref="T:KGySoft.Resources.AutoAppendOptions"/> and <see cref="T:KGySoft.Resources.AutoSaveOptions"/> enumerations).</term></item>
            </list>
            </remarks>
        </member>
        <member name="T:KGySoft.Resources.AutoAppendOptions">
            <summary>
            Represents the resource auto append options of a <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instance.
            These options are ignored if <see cref="P:KGySoft.Resources.DynamicResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.
            </summary>
            <seealso cref="T:KGySoft.Resources.DynamicResourceManager"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.AutoAppend"/>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoAppend"/>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.None">
            <summary>
            Represents no auto appending.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AddUnknownToInvariantCulture">
            <summary>
            <para>If a resource with an unknown key is requested, a new resource is automatically added to the
            invariant resource set.</para>
            <para>If the resource is requested as a <see cref="T:System.String"/>, the newly added
            value will be initialized by the requested key, prefixed by the <see cref="P:KGySoft.LanguageSettings.UnknownResourcePrefix">LanguageSettings.UnknownResourcePrefix</see> property.
            This new entry can be then merged into other resource sets, too.</para>
            <para>If the resource is requested as an <see cref="T:System.Object"/>, a <see langword="null"/> value will be added to the resource.
            The <see langword="null"/> value is never merged into the other resource sets because it has a special meaning:
            if a resource has a null value, the parent resources are checked for a non-null resource value.</para>
            <para>Enabling this flag causes that <see cref="T:System.Resources.MissingManifestResourceException"/> will never be thrown for non-existing resources.</para>
            <para>This option is disabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendFirstNeutralCulture">
            <summary>
            <para>If a resource is found in a parent resource set of the requested culture, and the traversal of the
            culture hierarchy hits a neutral culture, then the resource set of the first (most derived) neutral culture
            will be automatically appended by the found resource.
            <br/>Let's consider the following hypothetical culture hierarchy:
            <br/><c>en-Runic-GB-Yorkshire (specific) -> en-Runic-GB (specific) -> en-Runic (neutral) -> en (neutral) -> Invariant</c>
            <br/>If the requested culture is <c>en-Runic-GB-Yorkshire</c> and the resource is found in the invariant resource set,
            then with this option the found resource will be added to the <c>en-Runic</c> resource set.</para>
            <para>If the found resource is a <see cref="T:System.String"/>, the newly added
            value will be prefixed by the <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property.</para>
            <para>If the found non-<see langword="null"/> resource is not a <see cref="T:System.String"/>, the found value will be simply copied.</para>
            <para>This option is enabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendLastNeutralCulture">
            <summary>
            <para>If a resource is found in the resource set of the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">invariant culture</see>,
            then the resource set of the last neutral culture (whose parent is the invariant culture)
            will be automatically appended by the found resource.
            <br/>Let's consider the following hypothetical culture hierarchy:
            <br/><c>en-Runic-GB-Yorkshire (specific) -> en-Runic-GB (specific) -> en-Runic (neutral) -> en (neutral) -> Invariant</c>
            <br/>If the requested culture is <c>en-Runic-GB-Yorkshire</c> and the resource is found in the invariant resource set,
            then with this option the found resource will be added to the <c>en</c> resource set.</para>
            <para>If the found resource is a <see cref="T:System.String"/>, the newly added
            value will be prefixed by the <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property.</para>
            <para>If the found non-<see langword="null"/> resource is not a <see cref="T:System.String"/>, the found value will be simply copied.</para>
            <para>This option is disabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendNeutralCultures">
            <summary>
            <para>If a resource is found in a parent resource set of the requested culture, and the traversal of the
            culture hierarchy hits neutral cultures, then the resource sets of the neutral cultures will be automatically appended by the found resource.
            <br/>Let's consider the following hypothetical culture hierarchy:
            <br/><c>en-Runic-GB-Yorkshire (specific) -> en-Runic-GB (specific) -> en-Runic (neutral) -> en (neutral) -> Invariant</c>
            <br/>If the requested culture is <c>en-Runic-GB-Yorkshire</c> and the resource is found in the invariant resource set,
            then with this option the found resource will be added to the <c>en</c> and <c>en-Runic</c> resource sets.</para>
            <para>If the found resource is a <see cref="T:System.String"/>, the newly added
            value will be prefixed by the <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property.</para>
            <para>If the found non-<see langword="null"/> resource is not a <see cref="T:System.String"/>, the found value will be simply copied.</para>
            <para>This option includes <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendFirstNeutralCulture"/> and <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendLastNeutralCulture"/> options.</para>
            <para>This option is disabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendFirstSpecificCulture">
            <summary>
            <para>If a resource is found in a parent resource set of the requested specific culture,
            then the resource set of the requested culture will be automatically appended by the found resource.
            <br/>Let's consider the following hypothetical culture hierarchy:
            <br/><c>en-Runic-GB-Yorkshire (specific) -> en-Runic-GB (specific) -> en-Runic (neutral) -> en (neutral) -> Invariant</c>
            <br/>If the requested culture is <c>en-Runic-GB-Yorkshire</c> and the resource is found in one of its parents,
            then with this option the found resource will be added to the requested <c>en-Runic-GB-Yorkshire</c> resource set.</para>
            <para>If the found resource is a <see cref="T:System.String"/>, the newly added
            value will be prefixed by the <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property.</para>
            <para>If the found non-<see langword="null"/> resource is not a <see cref="T:System.String"/>, the found value will be simply copied.</para>
            <para>This option is disabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendLastSpecificCulture">
            <summary>
            <para>If a resource is found in a parent resource set of the requested specific culture,
            then the resource set of the last specific culture in the traversal hierarchy (whose parent is a non-specific culture)
            will be automatically appended by the found resource.
            <br/>Let's consider the following hypothetical culture hierarchy:
            <br/><c>en-Runic-GB-Yorkshire (specific) -> en-Runic-GB (specific) -> en-Runic (neutral) -> en (neutral) -> Invariant</c>
            <br/>If the requested culture is <c>en-Runic-GB-Yorkshire</c> and the resource is found in the invariant resource set,
            then with this option the found resource will be added to the <c>en-Runic-GB</c> resource set.</para>
            <para>If the found resource is a <see cref="T:System.String"/>, the newly added
            value will be prefixed by the <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property.</para>
            <para>If the found non-<see langword="null"/> resource is not a <see cref="T:System.String"/>, the found value will be simply copied.</para>
            <para>This option is disabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendSpecificCultures">
            <summary>
            <para>If a resource is found in a parent resource set of the requested specific culture,
            then the resource sets of the visited specific cultures will be automatically appended by the found resource.
            <br/>Let's consider the following hypothetical culture hierarchy:
            <br/><c>en-Runic-GB-Yorkshire (specific) -> en-Runic-GB (specific) -> en-Runic (neutral) -> en (neutral) -> Invariant</c>
            <br/>If the requested culture is <c>en-Runic-GB-Yorkshire</c> and the resource is found in the invariant resource set,
            then with this option the found resource will be added to the <c>en-Runic-GB-Yorkshire</c> and <c>en-Runic-GB</c> resource sets.</para>
            <para>If the found resource is a <see cref="T:System.String"/>, the newly added
            value will be prefixed by the <see cref="P:KGySoft.LanguageSettings.UntranslatedResourcePrefix">LanguageSettings.UntranslatedResourcePrefix</see> property.</para>
            <para>If the found non-<see langword="null"/> resource is not a <see cref="T:System.String"/>, the found value will be simply copied.</para>
            <para>This option includes <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendFirstSpecificCulture"/> and <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendLastSpecificCulture"/> options.</para>
            <para>This option is disabled by default.</para>
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoAppendOptions.AppendOnLoad">
            <summary>
            <para>If a resource set is being loaded, <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendNeutralCultures"/> and <see cref="F:KGySoft.Resources.AutoAppendOptions.AppendSpecificCultures"/> rules are
            automatically applied for all resources.</para>
            <para>This flag is enabled by default.</para>
            </summary>
        </member>
        <member name="T:KGySoft.Resources.AutoSaveOptions">
            <summary>
            Represents the auto saving options of a <see cref="T:KGySoft.Resources.DynamicResourceManager"/> instance.
            </summary>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.AutoSave"/>
            <seealso cref="E:KGySoft.Resources.DynamicResourceManager.AutoSaveError"/>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersAutoSave"/>
        </member>
        <member name="F:KGySoft.Resources.AutoSaveOptions.None">
            <summary>
            Represents no auto saving.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoSaveOptions.LanguageChange">
            <summary>
            Represents the auto saving of resources when <see cref="P:KGySoft.LanguageSettings.DisplayLanguage">LanguageSettings.DisplayLanguage</see> is changed.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoSaveOptions.DomainUnload">
            <summary>
            Represents the auto saving of resources when application exists or the current application domain is unloaded.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoSaveOptions.SourceChange">
            <summary>
            Represents the auto saving of resources when <see cref="P:KGySoft.Resources.DynamicResourceManager.Source">DynamicResourceManager.Source</see> or
            <see cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource">LanguageSettings.DynamicResourceManagersSource</see> is changed.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.AutoSaveOptions.Dispose">
            <summary>
            Represents the auto saving of resources when a <see cref="T:KGySoft.Resources.DynamicResourceManager"/> is being disposed explicitly.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResourceManagerSources">
            <summary>
            Represents the possible sources of <see cref="T:KGySoft.Resources.HybridResourceManager"/> and <see cref="T:KGySoft.Resources.DynamicResourceManager"/>
            classes.
            </summary>
            <seealso cref="P:KGySoft.Resources.HybridResourceManager.Source"/>
            <seealso cref="P:KGySoft.LanguageSettings.DynamicResourceManagersSource"/>
            <seealso cref="P:KGySoft.Resources.DynamicResourceManager.UseLanguageSettings"/>
        </member>
        <member name="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly">
            <summary>
            Indicates that the resources must be taken only from compiled binary resources.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResourceManagerSources.ResXOnly">
            <summary>
            Indicates that the resources must be taken only from .resx XML files.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResourceManagerSources.CompiledAndResX">
            <summary>
            Indicates that the resources must be taken both from compiled resources binary and .resx files.
            If a resource exists in both sources, then the one in the .resx will be returned.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.ResourceSetRetrieval">
            <summary>
            Represents the retrieval behavior of an <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> in <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">IExpandoResourceManager.GetExpandoResourceSet</see> method.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResourceSetRetrieval.GetIfAlreadyLoaded">
            <summary>
            The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> will be returned only if it is already loaded; otherwise, no resource set will be retrieved.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResourceSetRetrieval.LoadIfExists">
            <summary>
            The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> will be returned if the corresponding resource file exists and can be loaded.
            </summary>
        </member>
        <member name="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists">
            <summary>
            An <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> will be created for the requested culture even if no corresponding file can be loaded.
            </summary>
        </member>
        <member name="T:KGySoft.Resources.IExpandoResourceManager">
            <summary>
            Represents a <see cref="T:System.Resources.ResourceManager"/> with write capabilities.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceManager.IgnoreCase">
            <summary>
            Gets or sets a value that indicates whether the resource manager allows case-insensitive resource lookups in the
            <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">GetString</see>/<see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> and <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see>/<see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceManager.IsModified">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> instance has modified and unsaved data.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceManager.SafeMode">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> works in safe mode. In safe mode the retrieved
            objects returned from .resx sources are not deserialized automatically.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> and <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods
            return <see cref="T:KGySoft.Resources.ResXDataNode"/> instances instead of deserialized objects, if they are returned from .resx resource. You can retrieve the deserialized
            objects by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.</para>
            <para>When <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">GetString</see> and <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods
            will return a <see cref="T:System.String"/> also for non-string objects.
            For non-string values the raw XML string value will be returned for resources from a .resx source and the result of the <see cref="M:System.Object.ToString">ToString</see> method
            for resources from a compiled source.</para>
            <para>When <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, then <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">GetStream</see> and <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> methods
            will return a <see cref="T:System.IO.MemoryStream"/> for any object.
            For values, which are neither <see cref="T:System.IO.MemoryStream"/>, nor <see cref="T:System.Array">byte[]</see> instances these methods return a stream wrapper for the same string value
            that is returned by the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">GetString</see>/<see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">GetMetaString</see> methods.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceManager.CloneValues">
            <summary>
            Gets or sets whether <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> and <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> methods return always a new copy of the stored values.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            <para>To be compatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/System.Resources.ResourceManager" target="_blank">System.Resources.ResourceManager</a> this
            property is <see langword="true"/> by default. If this <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> instance contains no mutable values or it is known that modifying values is not
            an issue, then this property can be set to <see langword="false"/> for better performance.</para>
            <para>String values are not cloned.</para>
            <para>The value of this property affects only the objects returned from .resx sources. Non-string values from compiled sources are always cloned.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceManager.IsDisposed">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> instance is disposed.
            </summary>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">
            <summary>
            Retrieves the resource set for a particular culture, which can be dynamically modified.
            </summary>
            <param name="culture">The culture whose resources are to be retrieved.</param>
            <param name="behavior">Determines the retrieval behavior of the result <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Resources.ResourceSetRetrieval.LoadIfExists"/>.</param>
            <param name="tryParents"><see langword="true"/> to use resource fallback to load an appropriate resource if the resource set cannot be found; <see langword="false"/> to bypass the resource fallback process. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns>The resource set for the specified culture, or <see langword="null"/> if the specified culture cannot be retrieved by the defined <paramref name="behavior"/>,
            or when this <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> instance is configured so that it cannot return an <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="behavior"/> does not fall in the expected range.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">Resource file of the neutral culture was not found, while <paramref name="tryParents"/> is <see langword="true"/>
            and <paramref name="behavior"/> is not <see cref="F:KGySoft.Resources.ResourceSetRetrieval.CreateIfNotExists"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.ReleaseAllResources">
            <summary>
            Tells the resource manager to call the <see cref="M:System.Resources.ResourceSet.Close">Close</see> method on all <see cref="T:System.Resources.ResourceSet" /> objects and release all resources.
            All unsaved resources will be lost.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <remarks>
            <note type="caution">By calling this method all of the unsaved changes will be lost.</note>
            <para>By the <see cref="P:KGySoft.Resources.IExpandoResourceManager.IsModified"/> property you can check whether there are unsaved changes.</para>
            <para>To save the changes you can call the <see cref="M:KGySoft.Resources.IExpandoResourceManager.SaveAllResources(System.Boolean,System.Boolean)">SaveAllResources</see> method.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string resource localized for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>
            The value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, then instead of throwing an <see cref="T:System.InvalidOperationException"/>
            either the raw XML value (for resources from a .resx source) or the string representation of the object (for resources from a compiled source) will be returned for non-string resources.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="false"/>  and the type of the resource is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the resource of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to retrieve.</param>
            <param name="culture">An object that represents the culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property, the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> method returns either
            a full copy of the specified resource, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">GetStream</see> method
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            <para><see cref="M:KGySoft.Resources.IExpandoResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">GetStream</see> can be used also for byte array resources. However, if the value is returned from compiled resources, then always a new copy of the byte array will be wrapped.</para>
            <para>If <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array resource, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">GetString</see> method,
            which will be the raw XML content for non-string resources.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="false"/> and the type of the resource is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Gets the value of the specified resource localized for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to get.</param>
            <param name="culture">The culture for which the resource is localized. If the resource is not localized for
            this culture, the resource manager uses fallback rules to locate an appropriate resource. If this value is
            <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>
            If <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, and the resource is from a .resx content, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the resource localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property, the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> method returns either
            a full copy of the specified resource, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">GetStream</see> method
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a resource object in the current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> with the specified
            <paramref name="name"/> for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the resource to set.</param>
            <param name="culture">The culture of the resource to set. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property.</param>
            <param name="value">The value of the resource to set. If <see langword="null"/>, then a null reference will be explicitly
            stored for the specified <paramref name="culture"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            As a result, the subsequent <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> calls
            with the same <paramref name="culture" /> will fall back to the parent culture, or will return <see langword="null"/> if
            <paramref name="name" /> is not found in any parent cultures. However, enumerating the result set returned by
            <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method will return the resources with <see langword="null"/> value.</para>
            <para>If the current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, and you want to remove
            the user-defined ResX content and reset the original resource defined in the binary resource set (if any), use the <see cref="M:KGySoft.Resources.IExpandoResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">RemoveObject</see> method.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, and
            <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.RemoveObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a resource object from the current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> with the specified
            <paramref name="name"/> for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The case-sensitive name of the resource to remove.</param>
            <param name="culture">The culture of the resource to remove. If this value is <see langword="null"/>,
            the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.CurrentUICulture">CultureInfo.CurrentUICulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If this <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> instance is a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, and there is a binary resource
            defined for <paramref name="name"/> and <paramref name="culture"/>, then after this call the originally defined value will be returned by <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> method from the binary resources.
            If you want to force hiding the binary resource and make <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> to default to the parent <see cref="T:System.Globalization.CultureInfo"/> of the specified <paramref name="culture"/>,
            then use the <see cref="M:KGySoft.Resources.IExpandoResourceManager.SetObject(System.String,System.Object,System.Globalization.CultureInfo)">SetObject</see> method with a <see langword="null"/> value.</para>
            <para><paramref name="name"/> is considered as case-sensitive. If <paramref name="name"/> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, and
            <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetMetaString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the string metadata for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">GetString</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            The value of the metadata of the specified culture, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>If <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, then instead of throwing an <see cref="T:System.InvalidOperationException"/>
            the raw XML value will be returned for non-string metadata.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="false"/>  and the type of the metadata is not <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns a <see cref="T:System.IO.MemoryStream"/> instance from the metadata of the specified <paramref name="name"/> and <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetStream(System.String,System.Globalization.CultureInfo)">GetStream</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            A <see cref="T:System.IO.MemoryStream"/> object from the specified metadata, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property, the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> method returns either
            a full copy of the specified metadata, or always the same instance. For memory streams none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> method
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            <para><see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> can be used also for byte array metadata.</para>
            <para>If <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/> and <paramref name="name"/> is neither a <see cref="T:System.IO.MemoryStream"/> nor a byte array metadata, then
            instead of throwing an <see cref="T:System.InvalidOperationException"/> the method returns a stream wrapper for the same string value that is returned by the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetString(System.String,System.Globalization.CultureInfo)">GetString</see> method,
            which will be the raw XML content for non-string metadata.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="false"/> and the type of the metadata is neither <see cref="T:System.IO.MemoryStream"/> nor <see cref="T:System.Array">byte[]</see>.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Returns the value of the specified non-string metadata for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to retrieve.</param>
            <param name="culture">An object that represents the culture for which the metadata should be returned.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.
            Unlike in case of <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetObject(System.String,System.Globalization.CultureInfo)">GetObject</see> method, no fallback is used if the metadata is not found in the specified culture. This parameter is optional.
            <br/>Default value: <see langword="null"/>.
            </param>
            <returns>
            If <see cref="P:KGySoft.Resources.IExpandoResourceManager.SafeMode"/> is <see langword="true"/>, then the method returns a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance instead of the actual deserialized value.
            Otherwise, returns the value of the metadata localized for the specified <paramref name="culture"/>, or <see langword="null"/> if <paramref name="name" /> cannot be found in a resource set.
            </returns>
            <remarks>
            <para>Depending on the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property, the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> method returns either
            a full copy of the specified metadata, or always the same instance. For memory streams and byte arrays none of them are ideal because a full copy duplicates the inner buffer of a possibly large
            array of bytes, whereas returning the same stream instance can cause issues with conflicting positions or disposed state. Therefore the <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaStream(System.String,System.Globalization.CultureInfo)">GetMetaStream</see> method
            can be used to obtain a new read-only <see cref="T:System.IO.MemoryStream"/> wrapper around the same internal buffer, regardless the current value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            <para><see cref="T:System.String"/> values are not duplicated in memory, regardless the value of the <see cref="P:KGySoft.Resources.IExpandoResourceManager.CloneValues"/> property.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">No usable set of localized resources has been found, and there are no default culture resources.
            For information about how to handle this exception, see the notes under <em>Instantiating a ResXResourceManager object</em> section of the description of the <see cref="T:KGySoft.Resources.ResXResourceManager"/> class.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.SetMetaObject(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Adds or replaces a metadata object in the current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> with the specified
            <paramref name="name"/> for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The name of the metadata to set.</param>
            <param name="culture">The culture of the metadata to set.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property.</param>
            <param name="value">The value of the metadata to set. If <see langword="null"/>,  then a null reference will be explicitly
            stored for the specified <paramref name="culture"/>. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para>If <paramref name="value" /> is <see langword="null" />, a null reference will be explicitly stored.
            Its effect is similar to the <see cref="M:KGySoft.Resources.IExpandoResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">RemoveMetaObject</see> method: the subsequent <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetMetaObject(System.String,System.Globalization.CultureInfo)">GetMetaObject</see> calls
            with the same <paramref name="culture" /> will return <see langword="null" />.
            However, enumerating the result set returned by <see cref="M:KGySoft.Resources.IExpandoResourceManager.GetExpandoResourceSet(System.Globalization.CultureInfo,KGySoft.Resources.ResourceSetRetrieval,System.Boolean)">GetExpandoResourceSet</see> method will return the meta objects with <see langword="null"/> value.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, and
            <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.RemoveMetaObject(System.String,System.Globalization.CultureInfo)">
            <summary>
            Removes a metadata object from the current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> with the specified
            <paramref name="name"/> for the specified <paramref name="culture"/>.
            </summary>
            <param name="name">The case-sensitive name of the metadata to remove.</param>
            <param name="culture">The culture of the metadata to remove.
            If this value is <see langword="null"/>, the <see cref="T:System.Globalization.CultureInfo" /> object is obtained by using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture">CultureInfo.InvariantCulture</see> property. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <remarks>
            <para><paramref name="name"/> is considered as case-sensitive. If <paramref name="name"/> occurs multiple times
            in the resource set in case-insensitive manner, they can be removed one by one only.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The current <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is a <see cref="T:KGySoft.Resources.HybridResourceManager"/>, and
            <see cref="P:KGySoft.Resources.HybridResourceManager.Source"/> is <see cref="F:KGySoft.Resources.ResourceManagerSources.CompiledOnly"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.SaveResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            Saves the resource set of a particular <paramref name="culture"/> if it has been already loaded.
            </summary>
            <param name="culture">The culture of the resource set to save.</param>
            <param name="force"><see langword="true"/> to save the resource set even if it has not been modified; <see langword="false"/> to save it only if it has been modified. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns><see langword="true"/> if the resource set of the specified <paramref name="culture"/> has been saved;
            otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.IO.IOException">The resource set could not be saved.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceManager.SaveAllResources(System.Boolean,System.Boolean)">
            <summary>
            Saves all already loaded resources.
            </summary>
            <param name="force"><see langword="true"/> to save all of the already loaded resource sets regardless if they have been modified; <see langword="false"/> to save only the modified resource sets. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx files can be read by a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> instance
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx files are often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter" />),
            but the result can be read only by the <see cref="T:KGySoft.Resources.ResXResourceReader" /> class. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <returns><see langword="true"/> if at least one resource set has been saved; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceManager"/> is already disposed.</exception>
            <exception cref="T:System.IO.IOException">A resource set could not be saved.</exception>
        </member>
        <member name="T:KGySoft.Resources.IExpandoResourceSet">
            <summary>
            Represents a <see cref="T:System.Resources.ResourceSet"/> class that can hold replaceable resources.
            </summary>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceSet.SafeMode">
            <summary>
            Gets or sets whether the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> works in safe mode. In safe mode the retrieved
            objects returned from .resx sources are not deserialized automatically.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>When <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="true"/>, then <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">GetObject</see> and <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> methods
            return <see cref="T:KGySoft.Resources.ResXDataNode"/> instances instead of deserialized objects, if they are returned from .resx resource. You can retrieve the deserialized
            objects by calling the <see cref="M:KGySoft.Resources.ResXDataNode.GetValue(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValue</see> or <see cref="M:KGySoft.Resources.ResXDataNode.GetValueSafe(System.ComponentModel.Design.ITypeResolutionService,System.String,System.Boolean)">ResXDataNode.GetValueSafe</see> method.</para>
            <para>When <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="true"/>, then <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetString(System.String,System.Boolean)">GetString</see> and <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> methods
            will return a <see cref="T:System.String"/> also for non-string objects.
            For non-string values the raw XML string value will be returned for resources from a .resx source and the result of the <see cref="M:System.Object.ToString">ToString</see> method
            for resources from a compiled source.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceSet.IsModified">
            <summary>
            Gets whether this <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance is modified.
            </summary>
            <value>
            <see langword="true"/> if this instance is modified; otherwise, <see langword="false"/>.
            </value>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
        </member>
        <member name="P:KGySoft.Resources.IExpandoResourceSet.CloneValues">
            <summary>
            Gets or sets whether <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">GetObject</see>/<see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see>
            and <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetEnumerator">GetEnumerator</see>/<see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> methods return always a new copy of the stored values.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>To be compatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/System.Resources.ResXResourceSet" target="_blank">System.Resources.ResXResourceSet</a> this
            property is <see langword="false"/> by default. However, it can be a problem for mutable types if the returned value is changed by the consumer.</para>
            <para>To be compatible with <see cref="T:System.Resources.ResourceSet"/> set this property to <see langword="true"/>.</para>
            <para>String values are not cloned.</para>
            <para>The value of this property affects only the objects returned from .resx sources. Values from compiled sources are always cloned.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> that can iterate through the resources of the <see cref="T:KGySoft.Resources.IExpandoResourceSet" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> for the resources of this <see cref="T:KGySoft.Resources.IExpandoResourceSet" />.
            </returns>
            <remarks>
            <para>The returned enumerator iterates through the resources of the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            To obtain a specific resource by name, use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">GetObject</see> or <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetString(System.String,System.Boolean)">GetString</see> methods.
            To obtain an enumerator for the metadata entries instead, use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetadataEnumerator">GetMetadataEnumerator</see> method instead.</para>
            <para>If the <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> property is <see langword="true"/>, the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the examples at <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXResourceSet"/> classes.</para>
            <para>The returned enumerators in this assembly support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</para>
            </remarks>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetString(System.String,System.Boolean)"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetadataEnumerator"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetAliasEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetMetadataEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> that can iterate through the metadata of the <see cref="T:KGySoft.Resources.IExpandoResourceSet" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> for the metadata of this <see cref="T:KGySoft.Resources.IExpandoResourceSet" />.
            </returns>
            <remarks>
            <para>The returned enumerator iterates through the metadata entries of the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            To obtain a specific metadata by name, use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaObject(System.String,System.Boolean)">GetMetaObject</see> or <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaString(System.String,System.Boolean)">GetMetaString</see> methods.
            To obtain an enumerator for the resources use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetEnumerator">GetEnumerator</see> method instead.</para>
            <para>If the <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> property is <see langword="true"/>, the <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is a <see cref="T:KGySoft.Resources.ResXDataNode"/>
            instance rather than the resource value. This makes possible to check the raw .resx content before deserialization if the .resx file is from an untrusted source. See also the examples at <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXResourceSet"/> classes.</para>
            <para>The returned enumerators in this assembly support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</para>
            </remarks>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaObject(System.String,System.Boolean)"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetaString(System.String,System.Boolean)"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetEnumerator"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetAliasEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetAliasEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> that can iterate through the aliases of the <see cref="T:KGySoft.Resources.IExpandoResourceSet" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> for the aliases of this <see cref="T:KGySoft.Resources.IExpandoResourceSet" />.
            </returns>
            <remarks>
            <para>The returned enumerator iterates through the assembly aliases of the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            To obtain a specific alias value by assembly name, use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetAliasValue(System.String)">GetAliasValue</see> method.
            To obtain an enumerator for the resources use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetEnumerator">GetEnumerator</see> method instead.</para>
            <para>The <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> property of the returned enumerator is always a <see cref="T:System.String"/> regardless of the value of the <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> property.</para>
            <para>The <see cref="P:System.Collections.IDictionaryEnumerator.Key">IDictionaryEnumerator.Key</see> property of the returned enumerator is the alias name, whereas <see cref="P:System.Collections.IDictionaryEnumerator.Value">IDictionaryEnumerator.Value</see> is the corresponding assembly name.</para>
            <para>The returned enumerators in this assembly support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</para>
            </remarks>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetAliasValue(System.String)"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetEnumerator"/>
            <seealso cref="M:KGySoft.Resources.IExpandoResourceSet.GetMetadataEnumerator"/>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">
            <summary>
            Searches for a resource object with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored.</param>
            <returns>
            The requested resource, or when <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="true"/> and the resource is found in a .resx source, a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance
            from which the resource can be obtained. If the requested <paramref name="name"/> cannot be found, <see langword="null"/> is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetString(System.String,System.Boolean)">
            <summary>
            Searches for a <see cref="T:System.String" /> resource with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored.</param>
            <returns>
            The <see cref="T:System.String"/> value of a resource.
            If <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="false"/>, then an <see cref="T:System.InvalidOperationException"/> will be thrown for
            non-string resources. If <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="true"/>, then either the raw XML value (for resources from a .resx source)
            or the string representation of the object (for resources from a compiled source) will be returned for non-string resources.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="false"/>  and the type of the resource is not <see cref="T:System.String"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetMetaObject(System.String,System.Boolean)">
            <summary>
            Searches for a metadata object with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional
            <br/>Default value: <see langword="false"/></param>
            <returns>
            The requested metadata, or when <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="true"/>, a <see cref="T:KGySoft.Resources.ResXDataNode"/> instance
            from which the metadata can be obtained. If the requested <paramref name="name"/> cannot be found, <see langword="null"/> is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetMetaString(System.String,System.Boolean)">
            <summary>
            Searches for a <see cref="T:System.String" /> metadata with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata to search for.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional
            <br/>Default value: <see langword="false"/></param>
            <returns>
            The <see cref="T:System.String"/> value of a metadata.
            If <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="false"/>, an <see cref="T:System.InvalidOperationException"/> will be thrown for
            non-string metadata. If <see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="true"/>, the raw XML value will be returned for non-string metadata.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:KGySoft.Resources.IExpandoResourceSet.SafeMode"/> is <see langword="false"/> and the type of the metadata is not <see cref="T:System.String"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.GetAliasValue(System.String)">
            <summary>
            Gets the assembly name for the specified <paramref name="alias"/>.
            </summary>
            <param name="alias">The alias of the assembly name, which should be retrieved.</param>
            <returns>The assembly name of the <paramref name="alias"/>, or <see langword="null"/> if there is no such alias defined.</returns>
            <remarks>If an alias is redefined in the .resx file, then this method returns the last occurrence of the alias value.</remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="alias"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.ContainsResource(System.String,System.Boolean)">
            <summary>
            Gets whether the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> contains a resource with the given <paramref name="name"/>.
            </summary>
            <param name="name">The name of the resource to check.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <returns><see langword="true"/>, if the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> contains a resource with name <paramref name="name"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.ContainsMeta(System.String,System.Boolean)">
            <summary>
            Gets whether the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> contains a metadata with the given <paramref name="name"/>.
            </summary>
            <param name="name">The name of the metadata to check.</param>
            <param name="ignoreCase">Indicates whether the case of the specified <paramref name="name"/> should be ignored. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <returns><see langword="true"/>, if the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> contains a metadata with name <paramref name="name"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.SetObject(System.String,System.Object)">
            <summary>
            Adds or replaces a resource object in the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the resource value to set.</param>
            <param name="value">The resource value to set. If <see langword="null"/>, a null reference will be explicitly stored.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <remarks>
            <para>If <paramref name="value"/> is <see langword="null"/>, and this <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance
            is a hybrid resource set, <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">GetObject</see> will always return <see langword="null"/>, even if <paramref name="name"/> is
            defined in the original binary resource set. Thus you can force to take the parent resource set for example in case of a <see cref="T:KGySoft.Resources.HybridResourceManager"/>.</para>
            <para>To remove the user-defined content and reset the original resource defined in the binary resource set (if any), use
            the <see cref="M:KGySoft.Resources.IExpandoResourceSet.RemoveObject(System.String)">RemoveObject</see> method.</para>
            <para><paramref name="value"/> can be a <see cref="T:KGySoft.Resources.ResXDataNode"/> as well, its value will be interpreted correctly and added to the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> with the specified <paramref name="name"/>.</para>
            <para>If <paramref name="value"/> is a <see cref="T:KGySoft.Resources.ResXFileRef"/>, then a file reference will be added to the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            On saving its path will be made relative to the specified <c>basePath</c> argument of the <see cref="O:KGySoft.Resources.IExpandoResourceSet.Save">Save</see> methods.
            If <c>forceEmbeddedResources</c> is <see langword="true"/> on saving, the file references will be converted to embedded ones.</para>
            <note>Not just <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXFileRef"/> are handled but <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>
            and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> as well. The compatibility with the system versions
            is provided without any reference to <c>System.Windows.Forms.dll</c>, where those types are located.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.SetMetaObject(System.String,System.Object)">
            <summary>
            Adds or replaces a metadata object in the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata value to set.</param>
            <param name="value">The metadata value to set. If <see langword="null"/>, a null reference will be explicitly stored.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <remarks>
            <para>To remove the user-defined content use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.RemoveMetaObject(System.String)">RemoveMetaObject</see> method.</para>
            <para><paramref name="value"/> can be a <see cref="T:KGySoft.Resources.ResXDataNode"/> as well, its value will be interpreted correctly and added to the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> with the specified <paramref name="name"/>.</para>
            <para>If <paramref name="value"/> is a <see cref="T:KGySoft.Resources.ResXFileRef"/>, then a file reference will be added to the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            On saving its path will be made relative to the specified <c>basePath</c> argument of the <see cref="O:KGySoft.Resources.IExpandoResourceSet.Save">Save</see> methods.
            If <c>forceEmbeddedResources</c> is <see langword="true"/> on saving, the file references will be converted to embedded ones.</para>
            <note>Not just <see cref="T:KGySoft.Resources.ResXDataNode"/> and <see cref="T:KGySoft.Resources.ResXFileRef"/> are handled but <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxdatanode" target="_blank">System.Resources.ResXDataNode</a>
            and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxfileref" target="_blank">System.Resources.ResXFileRef</a> as well. The compatibility with the system versions
            is provided without any reference to <c>System.Windows.Forms.dll</c>, where those types are located.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.SetAliasValue(System.String,System.String)">
            <summary>
            Adds or replaces an assembly alias value in the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            </summary>
            <param name="alias">The alias name to use instead of <paramref name="assemblyName"/> in the saved .resx file.</param>
            <param name="assemblyName">The fully or partially qualified name of the assembly.</param>
            <remarks>
            <note>The added alias values are dumped on demand when saving: only when a resource type is defined in the <see cref="T:System.Reflection.Assembly"/>, whose name is the <paramref name="assemblyName"/>.
            Other alias names will be auto generated for non-specified assemblies.</note>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName"/> or <paramref name="alias"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.RemoveObject(System.String)">
            <summary>
            Removes a resource object from the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> with the specified <paramref name="name"/>.
            If this <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> represents a hybrid resource set, then the original value of <paramref name="name"/>
            will be restored (if existed).
            </summary>
            <param name="name">Name of the resource value to remove. Name is treated case sensitive.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
            <remarks>
            <para>If this <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance is a hybrid resource set, and there is a binary resource
            defined for <paramref name="name"/>, then after this call the originally defined value will be returned by <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">GetObject</see> method.
            If you want to force <see cref="M:KGySoft.Resources.IExpandoResourceSet.GetObject(System.String,System.Boolean)">GetObject</see> to return always <see langword="null"/> for this resource set, then use the <see cref="M:KGySoft.Resources.IExpandoResourceSet.SetObject(System.String,System.Object)">SetObject</see> method with a <see langword="null"/> value</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.RemoveMetaObject(System.String)">
            <summary>
            Removes a metadata object in the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> with the specified <paramref name="name"/>.
            </summary>
            <param name="name">Name of the metadata value to remove. Name is treated case sensitive.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.RemoveAliasValue(System.String)">
            <summary>
            Removes an assembly alias value in the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/>.
            </summary>
            <param name="alias">The alias, which should be removed.</param>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> is already disposed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="alias"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.Save(System.String,System.Boolean,System.Boolean,System.String)">
            <summary>
            Saves the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> to the specified file. If the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance
            represents a hybrid resource set, saves the expando-part (.resx content) only.
            </summary>
            <param name="fileName">The location of the file where you want to save the resources.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>),
            but the result can be read only by <see cref="T:KGySoft.Resources.ResXResourceReader"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
            <param name="forceEmbeddedResources">If set to <see langword="true"/> the resources using a file reference (<see cref="T:KGySoft.Resources.ResXFileRef"/>) will be replaced by embedded resources. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="newBasePath">A new base path for the file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects. If <see langword="null"/>,
            the original base path will be used. The file paths in the saved .resx file will be relative to <paramref name="newBasePath"/>.
            Applicable if <paramref name="forceEmbeddedResources"/> is <see langword="false"/>. This parameter is optional.
            <br/>Default value: <c><see langword="null"/>.</c></param>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.Save(System.IO.Stream,System.Boolean,System.Boolean,System.String)">
            <summary>
            Saves the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> to the specified <paramref name="stream"/>. If the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance
            represents a hybrid resource set, saves the expando-part (.resx content) only.
            </summary>
            <param name="stream">The stream to which you want to save.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>),
            but the result can be read only by <see cref="T:KGySoft.Resources.ResXResourceReader"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="forceEmbeddedResources">If set to <see langword="true"/> the resources using a file reference (<see cref="T:KGySoft.Resources.ResXFileRef"/>) will be replaced by embedded resources. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="newBasePath">A new base path for the file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects. If <see langword="null"/>,
            the original base path will be used. The file paths in the saved .resx file will be relative to <paramref name="newBasePath"/>.
            Applicable if <paramref name="forceEmbeddedResources"/> is <see langword="false"/>. This parameter is optional.
            <br/>Default value: <c><see langword="null"/>.</c></param>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
        </member>
        <member name="M:KGySoft.Resources.IExpandoResourceSet.Save(System.IO.TextWriter,System.Boolean,System.Boolean,System.String)">
            <summary>
            Saves the <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> by the specified <paramref name="textWriter"/>. If the current <see cref="T:KGySoft.Resources.IExpandoResourceSet"/> instance
            represents a hybrid resource set, saves the expando-part (.resx content) only.
            </summary>
            <param name="textWriter">The text writer to which you want to save.</param>
            <param name="compatibleFormat">If set to <see langword="true"/>, the result .resx file can be read by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.resources.resxresourcereader" target="_blank">System.Resources.ResXResourceReader</a> class
            and the Visual Studio Resource Editor. If set to <see langword="false"/>, the result .resx is often shorter, and the values can be deserialized with better accuracy (see the remarks at <see cref="T:KGySoft.Resources.ResXResourceWriter"/>),
            but the result can be read only by <see cref="T:KGySoft.Resources.ResXResourceReader"/>. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="forceEmbeddedResources">If set to <see langword="true"/> the resources using a file reference (<see cref="T:KGySoft.Resources.ResXFileRef"/>) will be replaced by embedded resources. This parameter is optional.
            <br/>Default value: <see langword="false"/></param>
            <param name="newBasePath">A new base path for the file paths specified in the <see cref="T:KGySoft.Resources.ResXFileRef"/> objects. If <see langword="null"/>,
            the original base path will be used. The file paths in the saved .resx file will be relative to <paramref name="newBasePath"/>.
            Applicable if <paramref name="forceEmbeddedResources"/> is <see langword="false"/>. This parameter is optional.
            <br/>Default value: <c><see langword="null"/>.</c></param>
            <seealso cref="T:KGySoft.Resources.ResXResourceWriter"/>
            <seealso cref="P:KGySoft.Resources.ResXResourceWriter.CompatibleFormat"/>
        </member>
        <member name="T:KGySoft.Resources.IExpandoResourceSetInternal">
            <summary>
            Represents a class that can hold replaceable resources
            </summary>
        </member>
        <member name="T:KGySoft.Resources.IResXResourceContainer">
            <summary>
            Represents a class that can contain cached ResX resources: resource entries, meta and aliases.
            </summary>
        </member>
        <member name="T:KGySoft.Security.Cryptography.Crc32">
            <summary>
            Implementation of the CRC-32 hash algorithm.
            </summary>
        </member>
        <member name="F:KGySoft.Security.Cryptography.Crc32.StandardPolynomial">
            <summary>
            The standard polynomial for the <see cref="T:KGySoft.Security.Cryptography.Crc32"/> hash algorithm. This field is constant.
            </summary>
        </member>
        <member name="F:KGySoft.Security.Cryptography.Crc32.CastagnoliPolynomial">
            <summary>
            The Castagnoli polynomial for the <see cref="T:KGySoft.Security.Cryptography.Crc32"/> hash algorithm (also known as CRC-32C). This field is constant.
            </summary>
        </member>
        <member name="F:KGySoft.Security.Cryptography.Crc32.KoopmanPolynomial">
            <summary>
            The Koopman polynomial for the <see cref="T:KGySoft.Security.Cryptography.Crc32"/> hash algorithm (also known as CRC-32K). This field is constant.
            </summary>
        </member>
        <member name="P:KGySoft.Security.Cryptography.Crc32.HashSize">
            <summary>
            Gets the size, in bits, of the computed hash code.
            </summary>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Security.Cryptography.Crc32"/> class with default settings.
            </summary>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.#ctor(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Security.Cryptography.Crc32"/> class.
            </summary>
            <param name="polynomial">The polynomial to use to calculate the CRC value.</param>
            <param name="initialCrc">The initial CRC value to use. If the final CRC is calculated in more sessions the result of the last calculation can be specified here. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="isBigEndian">If <see langword="true"/>, the byte order of the <see cref="O:System.Security.Cryptography.HashAlgorithm.ComputeHash">ComputeHash</see> methods and the <see cref="P:System.Security.Cryptography.HashAlgorithm.Hash"/> property
            will be big endian, which is the standard CRC32 representation; otherwise, little endian. Does not affect the <see cref="T:System.UInt32"/> return values though. This parameter is optional.
            <br/>Default value: <see langword="true"/>.</param>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.CalculateHash(System.Byte[],System.Int32,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Computes the CRC-32 hash value for the specified byte array.
            </summary>
            <param name="buffer">The input to compute the hash code for.</param>
            <param name="offset">The offset into the byte array from which to begin using data.</param>
            <param name="count">The number of bytes in the array to use as data.</param>
            <param name="initialCrc">The initial CRC value to use. If the final CRC is calculated in more sessions the result of the last calculation can be specified here. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="polynomial">The polynomial to use to calculate the CRC value. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Security.Cryptography.Crc32.StandardPolynomial"/>.</param>
            <returns>The CRC-32 hash value of the specified <paramref name="buffer"/>; or, if <paramref name="initialCrc"/> was specified, an
            accumulated hash value appended by the current <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.CalculateHash(System.Byte[],System.UInt32,System.UInt32)">
            <summary>
            Computes the CRC-32 hash value for the specified byte array.
            </summary>
            <param name="buffer">The input to compute the hash code for.</param>
            <param name="initialCrc">The initial CRC value to use. If the final CRC is calculated in more sessions the result of the last calculation can be specified here. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="polynomial">The polynomial to use to calculate the CRC value. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Security.Cryptography.Crc32.StandardPolynomial"/>.</param>
            <returns>The CRC-32 hash value of the specified <paramref name="buffer"/>; or, if <paramref name="initialCrc"/> was specified, an
            accumulated hash value appended by the current <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.CalculateHash(System.String,System.Text.Encoding,System.UInt32)">
            <summary>
            Computes the CRC-32 hash value for the specified <see cref="T:System.String"/>.
            </summary>
            <param name="s">The input <see cref="T:System.String"/> to compute the hash code for.</param>
            <param name="encoding">An <see cref="T:System.Text.Encoding"/> instance to specify the desired byte representation of the specified string, or <see langword="null"/> to use <see cref="P:System.Text.Encoding.UTF8"/> encoding. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <param name="polynomial">The polynomial to use to calculate the CRC value. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Security.Cryptography.Crc32.StandardPolynomial"/>.</param>
            <returns>The CRC-32 hash value of the specified <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.Initialize">
            <summary>
            Resets internal state of the algorithm. Used internally.
            </summary>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes the CRC-32 hash for the specified <paramref name="array"/>.
            </summary>
            <param name="array">The input to compute the hash code for.</param>
            <param name="offset">The offset into the byte array from which to begin using data.</param>
            <param name="count">The number of bytes in the array to use as data.</param>
        </member>
        <member name="M:KGySoft.Security.Cryptography.Crc32.HashFinal">
            <summary>
            Gets the final result of the computed CRC-32 hash as a byte array.
            </summary>
            <returns>
            The computed hash code.
            </returns>
        </member>
        <member name="T:KGySoft.Security.Cryptography.SecureRandom">
            <summary>
            Represents a secure random number generator, which uses a <see cref="T:System.Security.Cryptography.RandomNumberGenerator"/> instance to produce
            cryptographically secure random numbers.
            This class is functionally compatible with the <see cref="T:System.Random"/> and <see cref="T:KGySoft.CoreLibraries.FastRandom"/> classes.
            </summary>
            <remarks>
            <note>Please note that <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> class implements the <see cref="T:System.IDisposable"/> interface
            so make sure you dispose it (or use it in a <see langword="using"/> block) if not used in a static context.</note>
            </remarks>
            <seealso cref="T:KGySoft.CoreLibraries.FastRandom"/>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.#ctor(System.Security.Cryptography.RandomNumberGenerator)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> class.
            </summary>
            <param name="provider">A <see cref="T:System.Security.Cryptography.RandomNumberGenerator"/> instance to use.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="provider"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> class.
            To generate cryptographically secure random numbers, a default <see cref="T:System.Security.Cryptography.RandomNumberGenerator"/> will be used internally.
            </summary>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">An array of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.NextBytes(System.Span{System.Byte})">
            <summary>
            Fills the elements of the specified <paramref name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Span`1"/> of bytes to contain random numbers.</param>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.NextDouble">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.Next">
            <summary>
            Returns a non-negative random 32-bit integer that is less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue">Int32.MaxValue</see>.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.Next(System.Int32)">
            <summary>
            Returns a non-negative random integer that is less than the specified maximum.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number to be generated. <paramref name="maxValue" /> must be greater than or equal to 0.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random 32-bit integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. <paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</param>
            <returns>A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />;
            that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.
            However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.Dispose">
            <summary>
            Disposes the current <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> instance.
            </summary>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.Sample">
            <summary>
            Returns a random floating-point number between 0.0 and 1.0.
            </summary>
            <returns>
            A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="M:KGySoft.Security.Cryptography.SecureRandom.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> instance.
            </summary>
            <param name="disposing"><see langword="true"/> if this method is being called due to a call to <see cref="M:KGySoft.Security.Cryptography.SecureRandom.Dispose"/>; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="T:KGySoft.Security.Cryptography.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Security.Cryptography"/> namespace contains the <see cref="T:KGySoft.Security.Cryptography.Crc32"/> as a <see cref="T:System.Security.Cryptography.HashAlgorithm"/> implementation,
            and the <see cref="T:KGySoft.Security.Cryptography.SecureRandom"/> class, which is capable of producing cryptographically secure random numbers in a compatible manner with the <see cref="T:System.Random"/> class.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.ArrayIndexer">
            <summary>
            Provides a general indexer for any-dimension array for any bounds
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper">
            <summary>
            Provides a wrapper class for serializing any kind of object, including the ones
            that are not marked by the <see cref="T:System.SerializableAttribute"/>, or which are not supported by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
            Can be useful when a <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> payload cannot be used, so a <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>-compatible stream must be produced.
            When this object is deserialized, the clone of the wrapped original object is returned.
            </summary>
            <remarks>
            <note type="security">
            <para>This type has been made obsolete because just from the stream to deserialize it cannot be determined whether the consumer formatter
            is used in a safe context. Therefore <see cref="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper"/> deserialization uses safe mode,
            which denies deserializing non-serializable types. It renders this type practically useless, but it was
            meant for <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> anyway, which is also being obsoleted in upcoming .NET versions. To serialize
            non-serializable types you still can use <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>, which now supports <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/>,
            which should be enabled when deserializing anything from an untrusted source.</para>
            <para>When deserializing a stream that has an <see cref="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper"/> reference, it is ensured that no assemblies
            are loaded while unwrapping its content (it may not be true for other entries in the serialization stream, if the formatter is a <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>, for example).
            Therefore all of the assemblies that are involved by the types wrapped into an <see cref="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper"/> must be preloaded before deserializing such a stream.</para>
            <para>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
            <para>Since <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> supports serialization of
            any class, this object is not necessarily needed when <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> is used.</para>
            <para>In .NET Framework this class supports serialization of remote objects, too.</para>
            <note type="warning"><para>This class cannot guarantee that an object serialized in one platform can be deserialized in another one.
            For such cases some text-based serialization might be better (see also the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/>).</para>
            <para>In .NET Core and above the <see cref="T:System.Runtime.Serialization.ISerializable"/> implementation of some types throw a <see cref="T:System.PlatformNotSupportedException"/>.
            For such cases setting the <c>forceSerializationByFields</c> in the constructor can be a solution.</para>
            <para>For a more flexible customization use the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> class instead.</para></note>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper.#ctor(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Serialization.Binary.AnyObjectSerializerWrapper"/> with
            the provided object to be serialized.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to serialize. Non-serializable, remote objects, and <see langword="null"/> instances are supported, too.</param>
            <param name="useWeakAssemblyBinding">When <see langword="true"/>, the assembly versions of types do not need to match on deserialization.
            This makes possible to deserialize objects stored in different versions of the original assembly.</param>
            <param name="forceSerializationByFields"><see langword="true"/> to ignore <see cref="T:System.Runtime.Serialization.ISerializable"/> and <see cref="T:System.Runtime.Serialization.IObjectReference"/> implementations
            as well as serialization constructors and serializing methods; <see langword="false"/> to consider all of these techniques instead performing a forced
            field-based serialization. Can be useful for types that implement <see cref="T:System.Runtime.Serialization.ISerializable"/> but the implementation throws a <see cref="T:System.PlatformNotSupportedException"/>
            (on .NET Core, for example). It still does not guarantee that the object will be deserializable on another platform. This parameter is optional.
            <br/>Default value: <see langword="false"/>.</param>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter">
             <summary>
             Serializes and deserializes objects in binary format.
             </summary>
             <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>
             <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationOptions"/>
             <seealso cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/>
             <remarks>
             <note type="warning">The fundamental goal of binary serialization is to store the bitwise content of an object, hence in general case it relies on
             field values (including private ones), which can change from version to version. Therefore, binary serialization is recommended only for in-process purposes,
             such as deep cloning or undo/redo, etc. If it is known that a type will be deserialized in another environment and it can be completely restored by its public members,
             then a text-based serialization (see also <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/>) can be a better choice.</note>
             <note type="security"><para>Do not use binary serialization if the serialization stream may come from an untrusted source (eg. remote service, file or database).
             If you still need to do so (eg. due to compatibility), then it is highly recommended to enable the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> option, which prevents
             loading assemblies during the deserialization as well as instantiating non-serializable types, and guards against some attacks that may cause <see cref="T:System.OutOfMemoryException"/>.
             When using <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> you must preload every assembly referred by the serialization stream.</para>
             <para>Please note though that even some system types can be dangerous. In the .NET Framework there are some serializable types in the fundamental core assemblies that
             can be exploited for several attacks (causing unresponsiveness, <see cref="T:System.StackOverflowException"/> or even files to be deleted). Starting with .NET Core these types are not
             serializable anymore and some of them have been moved to separate NuGet packages anyway, but the <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> in the .NET Framework is still vulnerable against such attacks.
             When using the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> flag, the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> is protected against the known security issues
             on all platforms but of course it cannot guard you against the already loaded potentially harmful types.</para>
             <para>Please also note that <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> cannot prevent deserializing invalid content if a serializable type does not implement <see cref="T:System.Runtime.Serialization.ISerializable"/>
             and does it not validate the incoming <see cref="T:System.Runtime.Serialization.SerializationInfo"/> in its serialization constructor. All serializable types that can have an invalid state regarding the field values
             should implement <see cref="T:System.Runtime.Serialization.ISerializable"/> and should throw a <see cref="T:System.Runtime.Serialization.SerializationException"/> from their serialization constructor if validation fails.
             Other exceptions thrown by the constructor will be wrapped into a <see cref="T:System.Runtime.Serialization.SerializationException"/>.</para>
             <para>To be completely secured use binary serialization in-process only, or (especially when targeting the .NET Framework), set the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Binder"/> property to a <see cref="T:System.Runtime.Serialization.SerializationBinder"/>
             instance that uses strict mapping. For example, you can use the <see cref="T:KGySoft.Serialization.Binary.CustomSerializationBinder"/> class with handlers that throw exceptions for unexpected assemblies and types.</para>
             <para>Please also note that if the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Binder"/> property is set, then using <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> cannot prevent loading assemblies by the binder itself.
             It can just assure that if the binder returns <see langword="null"/>, then the default resolve logic will not allow loading assemblies. The binders in this library that can perform automatic
             type resolving, such the <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> and <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/> have their own <c>SafeMode</c> property.
             If you use them, make sure to set their <c>SafeMode</c> property to <see langword="true"/> to prevent loading assemblies by the binders themselves.</para>
             <para>Similarly, if the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector"/> property is set, then they provide a custom serialization even for types that are not serializable. The surrogate selectors in this library,
             such as the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> and <see cref="T:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector"/> types have their own <c>SafeMode</c> property.
             If you use them, make sure to set their <c>SafeMode</c> property to <see langword="true"/> to prevent deserializing non-serializable types.</para></note>
             <para><see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> aims to serialize objects effectively where the serialized data is almost always more compact than the results produced by the <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> class.</para>
             <para><see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> natively supports all of the primitive types and a sort of other simple types, arrays, generic and non-generic collections.
             <note>Serialization of natively supported types produce an especially compact result because these types are not serialized by traversing and storing the fields of the object graph recursively.
             This means not just better performance for these types but also prevents compatibility issues between different platforms because these types are not encoded by assembly identity and type name.
             Serialization of complex types can be somewhat slower for the first time than by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> but the serialized result is almost always shorter than the one by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>,
             especially when generic types are involved.</note></para>
             <para>Even if a type is not marked to be serializable by the <see cref="T:System.SerializableAttribute"/>, then you can use the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option to force their serialization.
             Alternatively, you can implement the <see cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/> interface, which can be used to produce a more compact custom serialization than the one provided by implementing the <see cref="T:System.Runtime.Serialization.ISerializable"/> interface.
             A custom serialization logic can be applied also by setting the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector"/> property.<para>
             </para>Similarly to <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>, <see cref="T:System.Runtime.Serialization.ISerializable"/> implementations are also supported, and they are considered only for types marked by the <see cref="T:System.SerializableAttribute"/>, unless
             the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option is enabled for the serialization.</para>
             <para>As <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> implements <see cref="T:System.Runtime.Serialization.IFormatter"/> it fully supports <see cref="T:System.Runtime.Serialization.SerializationBinder"/> and <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> implementations.
             <note type="tip">A <see cref="T:System.Runtime.Serialization.SerializationBinder"/> can be used to deserialize types of unmatching assembly identity and to specify custom type-name mappings in both directions.
             Though <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> automatically handles <see cref="T:System.Runtime.CompilerServices.TypeForwardedToAttribute"/> and <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/> (see also
             the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreTypeForwardedFromAttribute"/> option), you can use also the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/>, especially for types without a defined forwarding.
             The <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> can also be general solution if you need to ignore the assembly version or the complete assembly identity on resolving a type.
             If the name of the type has also been changed, then the <see cref="T:KGySoft.Serialization.Binary.CustomSerializationBinder"/> can be used.
             See also the <strong>Remarks</strong> section of the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Binder"/> property for more details.</note>
             <note type="tip">An <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> can be used to customize serialization and deserialization. It can be used for types that cannot be handled anyway for some reason.
             For example, if you need to deserialize types, whose field names have been renamed you can use the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/>.
             Or, if the produced raw data has to be compatible with the obfuscated version of a type, then it can be achieved by the <see cref="T:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector"/>.</note>
             </para>
             <para>There are three ways to serialize/deserialize an object. To serialize into a byte array use the <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Serialize(System.Object)">Serialize</see> method. Its result can be deserialized by the <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Deserialize(System.Byte[],System.Int32)">Deserialize</see> method.
             Additionally, you can use the <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeToStream(System.IO.Stream,System.Object)">SerializeToStream</see>/<see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializeFromStream(System.IO.Stream)">DeserializeFromStream</see> methods to dump/read the result to and from a <see cref="T:System.IO.Stream"/>, and the
             the <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeByWriter(System.IO.BinaryWriter,System.Object)">SerializeByWriter</see>/<see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializeByReader(System.IO.BinaryReader)">DeserializeByReader</see> methods to use specific <see cref="T:System.IO.BinaryWriter"/> and <see cref="T:System.IO.BinaryReader"/> instances for
             serialization and deserialization, respectively.</para>
             <note type="warning">In .NET Framework almost every type was serializable by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>. In .NET Core this principle has been
             radically changed. Many types are just simply not marked by the <see cref="T:System.SerializableAttribute"/> anymore (eg. <see cref="T:System.IO.MemoryStream"/>,
             <see cref="T:System.Globalization.CultureInfo"/>, <see cref="T:System.Text.Encoding"/>), and also there are some others, which still implement <see cref="T:System.Runtime.Serialization.ISerializable"/> but their <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">GetObjectData</see>
             throw a <see cref="T:System.PlatformNotSupportedException"/> now. Binary serialization of these types is not recommended anymore. If you still must serialize or deserialize such types
             see the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> for more details.</note>
             <h2>Natively supported simple types</h2>
             <para>Following types are natively supported. When these types are serialized, no recursive traversal of the fields occurs:
             <list type="bullet">
             <item><see langword="null"/> reference</item>
             <item>Non-derived <see cref="T:System.Object"/> instances.</item>
             <item><see cref="T:System.DBNull"/></item>
             <item><see cref="T:System.Boolean"/></item>
             <item><see cref="T:System.SByte"/></item>
             <item><see cref="T:System.Byte"/></item>
             <item><see cref="T:System.Int16"/></item>
             <item><see cref="T:System.UInt16"/></item>
             <item><see cref="T:System.Int32"/></item>
             <item><see cref="T:System.UInt32"/></item>
             <item><see cref="T:System.Int64"/></item>
             <item><see cref="T:System.UInt64"/></item>
             <item><see cref="T:System.Char"/></item>
             <item><see cref="T:System.String"/></item>
             <item><see cref="T:System.Single"/></item>
             <item><see cref="T:System.Double"/></item>
             <item><see cref="T:System.Decimal"/></item>
             <item><see cref="T:System.DateTime"/></item>
             <item><see cref="T:System.TimeSpan"/></item>
             <item><see cref="T:System.DateTimeOffset"/></item>
             <item><see cref="T:System.IntPtr"/></item>
             <item><see cref="T:System.UIntPtr"/></item>
             <item><see cref="T:System.Version"/></item>
             <item><see cref="T:System.Guid"/></item>
             <item><see cref="T:System.Uri"/></item>
             <item><see cref="T:System.Text.StringBuilder"/></item>
             <item><see cref="T:System.Numerics.BigInteger"/> (in .NET Framework 4.0 and above)</item>
             <item><see cref="T:System.Text.Rune"/> (in .NET Core 3.0 and above)</item>
             <item><see cref="T:System.Index"/> (in .NET Standard 2.1 and above)</item>
             <item><see cref="T:System.Range"/> (in .NET Standard 2.1 and above)</item>
             <item><see cref="!:Half"/> (in .NET 5.0 and above)</item>
             <item><see cref="!:DateOnly"/> (in .NET 6.0 and above)</item>
             <item><see cref="!:TimeOnly"/> (in .NET 6.0 and above)</item>
             <item><see cref="!:Int128"/> (in .NET 7.0 and above)</item>
             <item><see cref="!:UInt128"/> (in .NET 7.0 and above)</item>
             <item><see cref="T:System.Enum"/> types</item>
             <item><see cref="T:System.Type"/> instances if they are runtime types.</item>
             <item><see cref="T:System.Nullable`1"/> types if type parameter is any of the supported types.</item>
             <item>Any object that implements the <see cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/> interface.</item>
             <item><see cref="T:System.Collections.Generic.KeyValuePair`2"/> if <see cref="P:System.Collections.Generic.KeyValuePair`2.Key"/> and <see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/> are any of the supported types.</item>
             <item><see cref="T:System.Collections.DictionaryEntry"/> if <see cref="P:System.Collections.DictionaryEntry.Key"/> and <see cref="P:System.Collections.DictionaryEntry.Value"/> are any of the supported types.</item>
             </list>
             <note>
             <list type="bullet">
             <item>Serializing <see cref="T:System.Enum"/> types will result a longer raw data than serializing their numeric value, though the result will be still shorter than the one produced by <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.</item>
             <item>If <see cref="T:System.Collections.Generic.KeyValuePair`2"/> contains non-natively supported type arguments or <see cref="T:System.Collections.DictionaryEntry"/> has non-natively supported keys an values, then for them recursive serialization may occur.
             If they contain non-serializable types, then the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option should be enabled.</item>
             </list>
             </note>
             </para>
             <h2>Natively supported generic collections</h2>
             <para>Following generic collections are natively supported. When their generic arguments are one of the simple types or other supported collections, then no recursive traversal of the fields occurs:
             <list type="bullet">
             <item><see cref="T:System.Array"/> of element types above or compound of other supported collections</item>
             <item><see cref="T:System.Collections.Generic.List`1"/></item>
             <item><see cref="T:KGySoft.Collections.CircularList`1"/></item>
             <item><see cref="T:System.Collections.Generic.LinkedList`1"/></item>
             <item><see cref="T:System.Collections.Generic.HashSet`1"/></item>
             <item><see cref="T:System.Collections.Generic.Queue`1"/></item>
             <item><see cref="T:System.Collections.Generic.Stack`1"/></item>
             <item><see cref="T:System.Collections.Generic.SortedSet`1"/> (in .NET Framework 4.0 and above)</item>
             <item><see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> (in .NET Framework 4.0 and above)</item>
             <item><see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> (in .NET Framework 4.0 and above)</item>
             <item><see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> (in .NET Framework 4.0 and above)</item>
             <item><see cref="T:System.Collections.Generic.Dictionary`2"/></item>
             <item><see cref="T:System.Collections.Generic.SortedList`2"/></item>
             <item><see cref="T:System.Collections.Generic.SortedDictionary`2"/></item>
             <item><see cref="T:KGySoft.Collections.CircularSortedList`2"/></item>
             <item><see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> (in .NET Framework 4.0 and above)</item>
             </list>
             <note>
             <list type="bullet">
             <item><see cref="T:System.Array"/>s can be single- and multidimensional, jagged (array of arrays) and don't have to be zero index-based. Arrays and other generic collections can be nested.</item>
             <item>If a collection uses a non-default <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> or <see cref="T:System.Collections.Generic.IComparer`1"/> implementation, then it is possible that the type cannot be serialized without enabling
             <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option, unless the comparer is decorated by <see cref="T:System.SerializableAttribute"/> or implements the <see cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/> interface.</item>
             <item>If an <see cref="T:System.Array"/> has <see cref="T:System.Object"/> element type or <see cref="T:System.Object"/> is used in generic arguments of the collections above and an element is not a natively supported type, then recursive serialization of fields
             may occur. For non-serializable types the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option might be enabled.</item>
             <item>Even if a generic collection of <see cref="T:System.Object"/> contains natively supported types only, the result will be somewhat longer than in case of a more specific element type.</item>
             </list>
             </note>
             </para>
             <note type="tip">The shortest result can be achieved by using <see langword="sealed"/> classes or value types as array base types and generic parameters.</note>
             <h2>Natively supported non-generic collections</h2>
             <para>Following non-generic collections are natively supported. When they contain only other natively supported elements, then no recursive traversal of the fields occurs:
             <list type="table">
             <listheader><term>Collection type</term><description>Used element type</description></listheader>
             <item><term><see cref="T:System.Collections.ArrayList"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Queue"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Stack"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Specialized.StringCollection"/></term><description><see cref="T:System.String"/></description></item>
             <item><term><see cref="T:System.Collections.Hashtable"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.SortedList"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Specialized.ListDictionary"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Specialized.HybridDictionary"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Specialized.OrderedDictionary"/></term><description><see cref="T:System.Object"/></description></item>
             <item><term><see cref="T:System.Collections.Specialized.StringDictionary"/></term><description><see cref="T:System.String"/></description></item>
             <item><term><see cref="T:System.Collections.BitArray"/></term><description><see cref="T:System.Boolean"/> (actually the type is stored in a compact way)</description></item>
             <item><term><see cref="T:System.Collections.Specialized.BitVector32"/></term><description><see cref="T:System.Boolean"/> (actually the type is stored in a compact way)</description></item>
             <item><term><see cref="T:System.Collections.Specialized.BitVector32.Section"/></term><description>n.a.</description></item>
             </list>
             <note>
             <list type="bullet">
             <item>If a collection uses a non-default <see cref="T:System.Collections.IEqualityComparer"/> or <see cref="T:System.Collections.IComparer"/> implementation, then it is possible that the type cannot be serialized without enabling
             <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option, unless the comparer is decorated by <see cref="T:System.SerializableAttribute"/> or implements the <see cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/> interface.</item>
             <item>If an element in these collections is not a natively supported type, then recursive serialization of fields may occur. For non-serializable types the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/>
             option might be enabled.</item>
             </list>
             </note>
             </para>
             <h2>Serialization events</h2>
             <para><see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> supports calling methods decorated by <see cref="T:System.Runtime.Serialization.OnSerializingAttribute"/>, <see cref="T:System.Runtime.Serialization.OnSerializedAttribute"/>,
             <see cref="T:System.Runtime.Serialization.OnDeserializingAttribute"/> and <see cref="T:System.Runtime.Serialization.OnDeserializedAttribute"/> as well as calling <see cref="M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)">IDeserializationCallback.OnDeserialization</see> method.
             Attributes should be used on methods that have a single <see cref="T:System.Runtime.Serialization.StreamingContext"/> parameter.
             <note>Please note that if a value type was serialized by the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures"/> option, then the method of <see cref="T:System.Runtime.Serialization.OnDeserializingAttribute"/> can be invoked
             only after restoring the whole content so fields will be already restored.</note>
             </para>
             </remarks>
             <example>
             <note type="tip">Try also <a href="https://dotnetfiddle.net/T7BUyB" target="_blank">online</a>.</note>
             The following example demonstrates the length difference produced by the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> and <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> classes. Feel free to change the generated type.
             <code lang="C#"><![CDATA[
             using System;
             using System.Collections;
             using System.Collections.Generic;
             using System.Globalization;
             using System.IO;
             using System.Linq;
             using System.Reflection;
             using System.Runtime.Serialization;
             using System.Runtime.Serialization.Formatters.Binary;
             
             using KGySoft.CoreLibraries;
             using KGySoft.Serialization.Binary;
            
             public static class Example
             {
                 public static void Main()
                 {
                     IFormatter formatter;
            
                     // feel free to change the type in NextObject<>
                     var instance = ThreadSafeRandom.Instance.NextObject<Dictionary<int, List<string>>>();
                     Console.WriteLine("Generated object:   " + Dump(instance));
            
                     using (var ms = new MemoryStream())
                     {
                         // serializing by KGy SOFT version:
                         formatter = new BinarySerializationFormatter();
                         formatter.Serialize(ms, instance);
            
                         // deserialization:
                         ms.Position = 0L;
                         object deserialized = formatter.Deserialize(ms);
            
                         Console.WriteLine("Deserialized object " + Dump(deserialized));
                         Console.WriteLine("Length by BinarySerializationFormatter: " + ms.Length);
                     }
            
                     using (var ms = new MemoryStream())
                     {
                         // serializing by System version:
                         formatter = new BinaryFormatter();
                         formatter.Serialize(ms, instance);
                         Console.WriteLine("Length by BinaryFormatter: " + ms.Length);
                     }
                 }
            
                 private static string Dump(object o)
                 {
                     if (o == null)
                         return "<null>";
            
                     if (o is IConvertible convertible)
                         return convertible.ToString(CultureInfo.InvariantCulture);
            
                     if (o is IEnumerable enumerable)
                         return $"[{enumerable.Cast<object>().Select(Dump).Join(", ")}]";
            
                     return $"{{{o.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance).Select(p => $"{p.Name} = {Dump(p.GetValue(o))}").Join(", ")}}}";
                 }
             }
            
             // This code example produces a similar output to this one:
             // Generated object:   [{Key = 1418272504, Value = [aqez]}, {Key = 552276491, Value = [addejibude, yifefa]}]
             // Deserialized object [{Key = 1418272504, Value = [aqez]}, {Key = 552276491, Value = [addejibude, yifefa]}]
             // Length by BinarySerializationFormatter: 50
             // Length by BinaryFormatter: 2217]]></code>
             </example>
             <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo">
            <summary>
            Static descriptor for collection types. Instance-specific descriptor is in <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor"/>.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo.ctorCache">
            <summary>
            Can contain more elements only for generic collections. Will be instantiated only on deserialization.
            Thread safe accessor because the serialization info is stored in a static shared dictionary.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo.CtorArguments">
            <summary>
            Specifies the constructor arguments to be used. Order matters!
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo.SpecificAddMethod">
            <summary>
            Should be specified only when target collection is not <see cref="T:System.Collections.IList"/>, <see cref="T:System.Collections.IDictionary"/> or <see cref="T:System.Collections.Generic.ICollection`1"/> implementation,
            or when defining it results faster access than resolving the generic Add method for each access. Can refer to a generic method definition.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo.WriteSpecificProperties(System.IO.BinaryWriter,System.Collections.IEnumerable,KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager)">
            <summary>
            Writes specific properties of a collection that are needed for deserialization
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo.InitializeCollection(System.IO.BinaryReader,System.Boolean,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor,KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager,System.Boolean,System.Int32@)">
            <summary>
            Creates collection and reads all serialized specific properties that were written by <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo.WriteSpecificProperties(System.IO.BinaryWriter,System.Collections.IEnumerable,KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager)"/>.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes">
            <summary>
            Represents possible types. One of the simple types can be combined with one of the collection types and the flags.
            Nested generic collections can be encoded by multiple consecutive <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> values.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo">
            <summary>
            Special serialization info for collections
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.HasCapacity">
            <summary>
            Identifies that the collection has a Capacity property that has to be (re)stored.
            If this flag is disabled but there is a constructor with capacity parameter, then the size (Count) will be used at constructor
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.HasEqualityComparer">
            <summary>
            Indicates that the collection has an EqualityComparer that can be passed to a constructor
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.HasComparer">
            <summary>
            Indicates that the collection has a Comparer that can be passed to a constructor
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.IsDictionary">
            <summary>
            Indicates that the collection is a dictionary.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.IsGeneric">
            <summary>
            Should be enabled for generic types to process embedded non-simple elements.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.ReverseElements">
            <summary>
            Should be set for stack-like collections
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.HasCaseInsensitivity">
            <summary>
            Only in HybridDictionary
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.HasReadOnly">
            <summary>
            For types that can be both read-only and read-write (now in OrderedDictionary)
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.IsSingleElement">
            <summary>
            Indicates that the "collection" is a single element
            (now for DictionaryEntry, KeyValuePair: special "collections" with exactly two elements, which are easy to encode along with collection types)
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.DefaultEnumComparer">
            <summary>
            Indicates that <see cref="T:KGySoft.CoreLibraries.EnumComparer`1"/> is the default for enum element types.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionInfo.NonNullDefaultComparer">
            <summary>
            Indicates that even default comparer cannot be null.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionCtorArguments">
            <summary>
            Possible arguments of a collection constructor
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.TypeAttributes">
            <summary>
            Contains some serialization-time attributes for non-primitive types.
            This ensures that the deserializer can process a type (or at least throw a reasonable exception)
            if it changed since serialization (eg. sealed vs non-sealed, serialization way, etc.)
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.TypeByString">
            <summary>
            A mocked <see cref="T:System.Type"/> by name. Not derived from <see cref="T:System.Type"/> because that has tons of abstract methods.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.Compressible`1">
            <summary>
            A wrapper type for 7-bit encoded types if they are encoded by index rather than DataTypes.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.GenericMethodDefinitionPlaceholder">
            <summary>
            An indicator type for generic method parameters.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Options">
            <summary>
            Options used for serialization and deserialization.
            <br/>See the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationOptions"/> enumeration for details.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Binder">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder"/> that performs type conversions to and from <see cref="T:System.String">string</see>.
            </summary>
            <remarks>
            <para>By default, the binder is not called for natively supported types.</para>
            <para>If the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.ForceRecursiveSerializationOfSupportedTypes"/> flag is set in <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Options"/>,
            then the binder is called for the non-primitive natively supported types.</para>
            <para>This formatter does not call the binder types that have element types, for constructed generic types and generic parameter types.
            Instead, the binder is called only for the element types, the generic type definition and the generic arguments separately.</para>
            <note>In .NET Framework 3.5 setting this property has no effect during serialization unless the binder implements
            the <see cref="T:KGySoft.Serialization.Binary.ISerializationBinder"/> interface.</note>
            <note type="tip">If you serialize forwarded types that have no defined forwarding by the <see cref="T:System.Runtime.CompilerServices.TypeForwardedToAttribute"/> and <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/>
            attributes, then to ensure emitting compatible assembly identities on different .NET platforms use the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/>,
            define the missing mappings by the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">AddType</see> method and set its <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> property to <see langword="true"/>.
            Alternatively, you can use the <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> or you can just serialize the object without
            assembly information by setting the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.OmitAssemblyQualifiedNames"/> flag in the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Options"/>.</note>
            <note type="security"><para>If you use binders for deserialization, then setting the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> flag in the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Options"/>
            cannot prevent loading assemblies by the binder itself. The binders in this library that can perform automatic type resolving,
            such the <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> and <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/> have their own <c>SafeMode</c> property.
            Make sure to set them to <see langword="true"/> to prevent loading assemblies by the binders themselves.</para>
            <para>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
            </remarks>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Context">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext"/> used for serialization and deserialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector">
            <summary>
            Gets or sets an <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> can be used to customize serialization and deserialization.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.#ctor(KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Creates a new instance of <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class.
            </summary>
            <param name="options">Options used for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/>, <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures"/>.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Write7BitLong(System.IO.BinaryWriter,System.UInt64)">
            <summary>
            Must be separated from Write7BitInt because -1 would result 10 bytes here and 5 there
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeToString(KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes)">
            <summary>
            Converts a <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> enumeration into the corresponding string representation.
            This method is needed because <see cref="M:System.Enum.ToString"/> and <see cref="M:KGySoft.CoreLibraries.Enum`1.ToString(`0,KGySoft.CoreLibraries.EnumFormattingOptions,System.String)"/>
            cannot always handle the fields and flags structure of <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> enum.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Serialize(System.Object)">
            <summary>
            Serializes an object into a byte array.
            </summary>
            <param name="data">The object to serialize</param>
            <returns>Serialized raw data of the object</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Deserialize(System.Byte[],System.Int32)">
            <summary>
            Deserializes the specified part of a byte array into an object.
            </summary>
            <param name="rawData">Contains the raw data representation of the object to deserialize.</param>
            <param name="offset">Points to the starting position of the object data in <paramref name="rawData"/>. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <returns>The deserialized data.</returns>
            <overloads>In the two-parameter overload the start offset of the data to deserialize can be specified.</overloads>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeToStream(System.IO.Stream,System.Object)">
            <summary>
            Serializes the given <paramref name="data"/> into a <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream, into which the data is written. The stream must support writing and will remain open after serialization.</param>
            <param name="data">The data that will be written into the stream.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializeFromStream(System.IO.Stream)">
            <summary>
            Deserializes data beginning at current position of given <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream, from which the data is read. The stream must support reading and will remain open after deserialization.</param>
            <returns>The deserialized data.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeByWriter(System.IO.BinaryWriter,System.Object)">
            <summary>
            Serializes the given <paramref name="data"/> by using the provided <paramref name="writer"/>.
            </summary>
            <remarks>
            <note>This method produces compatible serialized data with <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Serialize(System.Object)">Serialize</see>
            and <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeToStream(System.IO.Stream,System.Object)">SerializeToStream</see> methods only when encoding of the writer is UTF-8. Otherwise, you must use <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializeByReader(System.IO.BinaryReader)">DeserializeByReader</see> with the same encoding as here.</note>
            </remarks>
            <param name="writer">The writer that will used to serialize data. The writer will remain opened after serialization.</param>
            <param name="data">The data that will be written by the writer.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializeByReader(System.IO.BinaryReader)">
            <summary>
            Deserializes data beginning at current position of given <paramref name="reader"/>.
            </summary>
            <remarks>
            <note>If data was serialized by <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.Serialize(System.Object)">Serialize</see> or <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeToStream(System.IO.Stream,System.Object)">SerializeToStream</see> methods, then
            <paramref name="reader"/> must use UTF-8 encoding to get correct result. If data was serialized by the <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializeByWriter(System.IO.BinaryWriter,System.Object)">SerializeByWriter</see> method, then you must use the same encoding as there.</note>
            </remarks>
            <param name="reader">The reader that will be used to deserialize data. The reader will remain opened after deserialization.</param>
            <returns>The deserialized data.</returns>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor">
            <summary>
            Per instance descriptor of a DataTypes encoded type. Used on deserialization, mainly for supported collections.
            Static generic type information is in <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.CollectionSerializationInfo"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.Type">
            <summary>
            Decoded type of self descriptor
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.Rank">
            <summary>
            The array rank if <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.IsArray"/> is <see langword="true"/>. Gets 0 for zero-based arrays.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.ElementDescriptor">
            <summary>
            The element the element/key descriptor for single collections and dictionaries.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.ValueDescriptor">
            <summary>
            The value descriptor for dictionaries.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.#ctor(KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes,System.IO.BinaryReader)">
            <summary>
            Initializing from stream by encoded <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.#ctor(System.Type,KGySoft.Serialization.Binary.BinarySerializationFormatter.TypeByString)">
            <summary>
            Initializing from <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.Type"/> by <see cref="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager.ReadType(System.IO.BinaryReader,System.Boolean)"/>.
            Here every non-native type is handled as recursive object (otherwise, they are decoded from <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/>).
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.#ctor(KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes,System.Type,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor)">
            <summary>
            Constructor for explicitly setting already known values.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.DecodeType(System.IO.BinaryReader,KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager,System.Boolean)">
            <summary>
            Decodes self and element types
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.GetTypeToCreate">
            <summary>
            If <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor.Type"/> cannot be created/populated, then type of the instance to create can be overridden here
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypesEnumerator">
            <summary>
            A special lightweight enumerator for encoded <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> collections.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager">
            <summary>
            A manager class that provides that stored types will be built up in the same order both at serialization and deserialization for complex types.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager.ReadType(System.IO.BinaryReader,System.Boolean)">
            <summary>
            Reads a type from the serialization stream.
            <paramref name="allowOpenTypes"/> can be <see langword="true"/> only when type is deserialized as an instance.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager.CreateArray(System.IO.BinaryReader,System.Boolean,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor)">
            <summary>
            Creates and populates array
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager.CreateCollection(System.IO.BinaryReader,System.Boolean,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor)">
            <summary>
            Creates and populates a collection
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager.ReadObject(System.IO.BinaryReader,System.Nullable{System.Boolean},KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypeDescriptor)">
            <summary>
            Reads a non-collection object from the stream.
            </summary>
            <param name="br">The reader</param>
            <param name="addToCache">When <see langword="true"/>, the result must be added to the ID cache. Otherwise, only reference types in a collection might be added to cache.</param>
            <param name="dataTypeDescriptor">The descriptor of the data type to be deserialized.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.DeserializationManager.GetAssembly(System.String)">
            <summary>
            Resolves an assembly by string
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager">
            <summary>
            A manager class that provides that stored types will be built up in the same order both at serialization and deserialization for complex types.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.GetDictionaryValueTypes(KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypesEnumerator)">
            <summary>
            Retrieves the value type(s) for a dictionary.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteRoot(System.IO.BinaryWriter,System.Object)">
            <summary>
            The entry point of writing an object. Here the type is encoded by DataTypes. The basic philosophy is
            that we write type index everywhere else (which will be at least 1 byte longer for supported types for the first time).
            (Impure objects are written by index at root level, too.)
            </summary>>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteNonRoot(System.IO.BinaryWriter,System.Object,System.ValueTuple{KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypesEnumerator,System.Type})">
            <summary>
            Writing a child object. Here the type is encoded by index.
            <paramref name="knownElementType"/> is the possible element type of a parent collection.
            We don't do the same for parent fields because we don't write the fields types at all.
            </summary>>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.GetDataType(System.Type)">
            <summary>
            Gets the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> representation of <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteTypeNamesAndRanks(System.IO.BinaryWriter,System.Type,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypesEnumerator,System.Boolean)">
            <summary>
            Writes additional info after a [series of] DataType stream needed to completely describe an exact type.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.EncodeDataType(System.Type,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes)">
            <summary>
            Encodes the type as a series of <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> elements.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteType(System.IO.BinaryWriter,System.Type,System.Collections.Generic.IList{KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes},System.Boolean)">
            <summary>
            Writes a type into the serialization stream by using assembly and type index.
            If there is no name override from Binder it can use a special index to fallback to <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/> encoding.
            <paramref name="allowOpenTypes"/> can be <see langword="true"/> only when a RuntimeType instance is serialized.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.TryWriteTypeByDataType(System.IO.BinaryWriter,System.Type,System.Boolean,System.Collections.Generic.IList{KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes}@)">
            <summary>
            Trying to write type completely or partially by pure <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes"/>.
            Returning <see langword="true"/> even for partial success (array, generics) because then the beginning of the type is encoded by DataTypes.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteNewType(System.IO.BinaryWriter,System.Type,System.Boolean,System.String,System.String)">
            <summary>
            Writes a new non-pure type if a binder did not handle it. Assembly part is already written.
            If open types are allowed a generic type definition is followed by a specifier; otherwise, by type arguments.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteTypeWithName(System.IO.BinaryWriter,System.Type,System.String,System.String)">
            <summary>
            Writes the type using explicit names. Occurs when <see cref="T:System.Runtime.Serialization.SerializationInfo"/> changes the type to an unknown one.
            The Binder is not queried this time because there is no known type to query. Instead, we handle the names as bound type names.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.WriteId(System.IO.BinaryWriter,System.Object)">
            <summary>
            Writes an ID and returns if it was already known.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManager.MarkAttributes(System.IO.BinaryWriter,System.Type,KGySoft.Serialization.Binary.BinarySerializationFormatter.DataTypes)">
            <summary>
            Marks the type attributes in the stream.
            This ensures a successful deserialization even if a type changed its sealed or class/struct attributes.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManagerBase.KnownTypes">
            <summary>
            These types are always dumped by index and are never passed to a binder.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManagerBase.CanUseSurrogate(System.Type)">
            <summary>
            Gets if a type can use a surrogate
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializationFormatter.SerializationManagerBase.TryGetSurrogate(System.Type,System.Runtime.Serialization.ISerializationSurrogate@,System.Runtime.Serialization.ISurrogateSelector@)">
            <summary>
            Tries to get a surrogate for a type
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializer">
            <summary>
            Provides public static methods for binary serialization. Most of its methods use a <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> instance internally.
            <br/>See the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for details and an example.
            </summary>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationOptions"/>
            <seealso cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.Serialize(System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Serializes an object into a byte array.
            </summary>
            <param name="data">The object to serialize</param>
            <param name="options">Options of the serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/>, <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures"/>.</param>
            <returns>Serialized raw data of the object</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.Deserialize(System.Byte[],System.Int32,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Deserializes the specified part of a byte array into an object.
            </summary>
            <param name="rawData">Contains the raw data representation of the object to deserialize.</param>
            <param name="offset">Points to the starting position of the object data in <paramref name="rawData"/>. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="options">Options of the deserialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.None"/>.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeToStream(System.IO.Stream,System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Serializes the given <paramref name="data"/> into a <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream, into which the data is written. The stream must support writing and will remain open after serialization.</param>
            <param name="data">The data that will be written into the stream.</param>
            <param name="options">Options of the serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/>, <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures"/>.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeFromStream(System.IO.Stream,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Deserializes data beginning at current position of given <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream, from which the data is read. The stream must support reading and will remain open after deserialization.</param>
            <param name="options">Options of the deserialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.None"/>.</param>
            <returns>The deserialized data.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeByWriter(System.IO.BinaryWriter,System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Serializes the given <paramref name="data"/> by using the provided <paramref name="writer"/>.
            </summary>
            <remarks>
            <note>This method produces compatible serialized data with <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.Serialize(System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">Serialize</see>
            and <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeToStream(System.IO.Stream,System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">SerializeToStream</see> methods only when encoding of the writer is UTF-8. Otherwise, you must use <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeByReader(System.IO.BinaryReader,KGySoft.Serialization.Binary.BinarySerializationOptions)">DeserializeByReader</see> with the same encoding as here.</note>
            </remarks>
            <param name="writer">The writer that will used to serialize data. The writer will remain opened after serialization.</param>
            <param name="data">The data that will be written by the writer.</param>
            <param name="options">Options of the serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/>, <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures"/>.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeByReader(System.IO.BinaryReader,KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Deserializes data beginning at current position of given <paramref name="reader"/>.
            </summary>
            <param name="reader">The reader that will be used to deserialize data. The reader will remain opened after deserialization.</param>
            <param name="options">Options of the deserialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.None"/>.</param>
            <remarks>
            <note>If data was serialized by <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.Serialize(System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">Serialize</see> or <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeToStream(System.IO.Stream,System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">SerializeToStream</see> methods, then
            <paramref name="reader"/> must use UTF-8 encoding to get correct result. If data was serialized by the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeByWriter(System.IO.BinaryWriter,System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">SerializeByWriter</see> method, then you must use the same encoding as there.</note>
            </remarks>
            <returns>The deserialized data.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType(System.ValueType)">
            <summary>
            Serializes a <see cref="T:System.ValueType"/> into a byte array. If the type of the specified instance contains any references,
            then it is tried to be serialized by marshaling as a fallback option.
            </summary>
            <param name="obj">The <see cref="T:System.ValueType"/> object to serialize.</param>
            <returns>The byte array representation of the <see cref="T:System.ValueType"/> object.</returns>
            <remarks>
            <para>If the specified instance does not have any references, then its actual raw data is returned. In this case this method is very fast.</para>
            <para>If the specified instance has reference types, then as a fallback option, it is attempted to be serialized by using the <see cref="T:System.Runtime.InteropServices.Marshal"/> class.
            To work properly the string and array fields must be decorated by the <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute"/> using <see cref="F:System.Runtime.InteropServices.UnmanagedType.ByValTStr"/>
            or <see cref="F:System.Runtime.InteropServices.UnmanagedType.ByValArray"/> values, and the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute"/> must be defined on referenced classes.
            The <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute"/> annotations are ignored if the type does not contain any references and hence it is serialized by its actual raw content.
            <note>Serializing by the <see cref="T:System.Runtime.InteropServices.Marshal"/> class as a fallback option is maintained only for compatibility reasons.
            If a value type contains references, then it is recommended to use the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.Serialize(System.Object,KGySoft.Serialization.Binary.BinarySerializationOptions)">Serialize</see> method instead.
            You can use the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.TrySerializeValueType(System.ValueType,System.Byte[]@)"/> method to serialize only pure value types without any references. </note></para>
            <para>If the instance cannot be serialized even by the <see cref="T:System.Runtime.InteropServices.Marshal"/> class, then an <see cref="T:System.ArgumentException"/> is thrown.</para>
            <note type="caution">If packing is not defined on the type of the instance by <see cref="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">StructLayoutAttribute.Pack</see>,
            or the type contains pointer fields, then the length of the result might be different on 32 and 64 bit systems.
            The serialized content depends also on the endianness of the executing architecture.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> contains references and it cannot be serialized even by the <see cref="T:System.Runtime.InteropServices.Marshal"/> class.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.TrySerializeValueType(System.ValueType,System.Byte[]@)">
            <summary>
            Tries to serialize a <see cref="T:System.ValueType"/> into a byte array.
            The operation will succeed if the type of the specified instance does not contain any references.
            <br/>See also the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType(System.ValueType)"/> method for details.
            </summary>
            <param name="obj">The <see cref="T:System.ValueType"/> object to serialize.</param>
            <param name="result">When this method returns, the byte array representation of the <see cref="T:System.ValueType"/> instance. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if the specified <see cref="T:System.ValueType"/> contains no references and could be serialized; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType``1(``0@)">
            <summary>
            Serializes the specified <paramref name="value"/> into a byte array.
            </summary>
            <typeparam name="T">The type of the object to serialize. It must be a value type that does not contain references.</typeparam>
            <param name="value">The value to serialize.</param>
            <returns>The byte array representation of the specified <paramref name="value"/>.</returns>
            <remarks>
            <note type="security">Do not use this method with <typeparamref name="T"/> types that have references.
            When using this library with a compiler that recognizes the <see langword="unmanaged"/> constraint,
            then this is enforced for direct calls; however, by using reflection <typeparamref name="T"/> can be any value type.
            For performance reasons this method does not check if <typeparamref name="T"/> has references
            but you can call the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.TrySerializeValueType``1(``0@,System.Byte[]@)"/> method that performs the check.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.TrySerializeValueType``1(``0@,System.Byte[]@)">
            <summary>
            Tries to serialize the specified <paramref name="value"/> into a byte array.
            The operation will succeed if <typeparamref name="T"/> does not contain any references.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType``1(``0@)"/> method for details.
            </summary>
            <typeparam name="T">The type of the object to serialize.</typeparam>
            <param name="value">The value to serialize.</param>
            <param name="result">When this method returns, the byte array representation of the specified <paramref name="value"/>. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if <typeparamref name="T"/> contains no references and could be serialized; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueArray``1(``0[])">
            <summary>
            Serializes an <see cref="T:System.Array"/> of <see cref="T:System.ValueType"/> elements into a byte array.
            </summary>
            <param name="array">The array to serialize.</param>
            <typeparam name="T">Element type of the array. Must be a <see cref="T:System.ValueType"/> that has no references.</typeparam>
            <returns>The byte array representation of the <paramref name="array"/>.</returns>
            <remarks>
            <note type="security">Do not use this method with <typeparamref name="T"/> types that have references.
            When using this library with a compiler that recognizes the <see langword="unmanaged"/> constraint,
            then this is enforced for direct calls; however, by using reflection <typeparamref name="T"/> can be any value type.
            For performance reasons this method does not check if <typeparamref name="T"/> has references
            but you can call the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.TrySerializeValueArray``1(``0[],System.Byte[]@)"/> method that performs the check.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.TrySerializeValueArray``1(``0[],System.Byte[]@)">
            <summary>
            Tries to serialize an <see cref="T:System.Array"/> of <see cref="T:System.ValueType"/> elements into a byte array.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueArray``1(``0[])"/> method for details.
            </summary>
            <param name="array">The array to serialize.</param>
            <typeparam name="T">Element type of the array. Must be a <see cref="T:System.ValueType"/> that has no references.</typeparam>
            <param name="result">When this method returns, the byte array representation of the specified <paramref name="array"/>. This parameter is passed uninitialized.</param>
            <returns><see langword="true"/>, if <typeparamref name="T"/> contains no references and could be serialized; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeValueType(System.Type,System.Byte[])">
            <summary>
            Deserializes a <see cref="T:System.ValueType"/> object from a byte array that was previously serialized by <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType(System.ValueType)">SerializeValueType</see> method.
            </summary>
            <param name="type">The type of the target object. Must be a <see cref="T:System.ValueType"/>.</param>
            <param name="data">The byte array that starts with byte representation of the object.</param>
            <returns>The deserialized <see cref="T:System.ValueType"/> object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> or <paramref name="type"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a value type
            <br/>-or-
            <br/>The length of <paramref name="data"/> is too small.
            <br/>-or-
            <br/>The specified <paramref name="type"/> contains references and it cannot be deserialized even by using the <see cref="T:System.Runtime.InteropServices.Marshal"/> class.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeValueType(System.Type,System.Byte[],System.Int32)">
            <summary>
            Deserializes a <see cref="T:System.ValueType"/> object from a byte array that was previously serialized by <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType(System.ValueType)">SerializeValueType</see> method
            beginning on a specified <paramref name="offset"/>.
            </summary>
            <param name="type">The type of the target object. Must be a <see cref="T:System.ValueType"/>.</param>
            <param name="data">The byte array that contains the byte representation of the object.</param>
            <param name="offset">The offset that points to the beginning of the serialized data.</param>
            <returns>The deserialized <see cref="T:System.ValueType"/> object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> or <paramref name="type"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> is negative or too large.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is not a value type
            <br/>-or-
            <br/>The length of <paramref name="data"/> is too small.
            <br/>-or-
            <br/>The specified <paramref name="type"/> contains references and it cannot be deserialized even by using the <see cref="T:System.Runtime.InteropServices.Marshal"/> class.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeValueType``1(System.Byte[])">
            <summary>
            Deserializes an instance of <typeparamref name="T"/> from a byte array that was previously serialized
            by the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType``1(``0@)"/> method.
            </summary>
            <typeparam name="T">The type of the result. It must be a value type that does not contain references.</typeparam>
            <param name="data">The byte array that starts with byte representation of the object.</param>
            <returns>The deserialized <typeparamref name="T"/> instance.</returns>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="T"/> contains references.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The length of <paramref name="data"/> is too small.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeValueType``1(System.Byte[],System.Int32)">
            <summary>
            Deserializes an instance of <typeparamref name="T"/> from a byte array that was previously serialized
            by the <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueType``1(``0@)"/> method.
            </summary>
            <typeparam name="T">The type of the result. It must be a value type that does not contain references.</typeparam>
            <param name="data">The byte array that starts with byte representation of the object.</param>
            <param name="offset">The offset that points to the beginning of the serialized data.</param>
            <returns>The deserialized <typeparamref name="T"/> instance.</returns>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="T"/> contains references.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> is negative or too large.</exception>
            <exception cref="T:System.ArgumentException">The length of <paramref name="data"/> is too small.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.DeserializeValueArray``1(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deserializes an array of <see cref="T:System.ValueType"/> objects from a byte array
            that was previously serialized by <see cref="M:KGySoft.Serialization.Binary.BinarySerializer.SerializeValueArray``1(``0[])">SerializeValueArray</see> method.
            </summary>
            <typeparam name="T">Type of the elements in the deserialized array. Must be a <see cref="T:System.ValueType"/>.</typeparam>
            <param name="data">The byte array that contains the byte representation of the structures.</param>
            <param name="offset">The offset that points to the beginning of the serialized data.</param>
            <param name="count">Number of elements to deserialize from the <paramref name="data"/>.</param>
            <returns>The deserialized <see cref="T:System.ValueType"/> object.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.BinarySerializer.CreateFormatter(KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Creates a formatter that can be used for serialization and deserialization with given <paramref name="options"/>.
            </summary>
            <returns>An <see cref="T:System.Runtime.Serialization.IFormatter"/> instance that can be used for serialization and deserialization with given <paramref name="options"/>.</returns>
            <param name="options">Options for the created formatter. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/>, <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures"/>.</param>
        </member>
        <member name="T:KGySoft.Serialization.Binary.CustomSerializationBinder">
             <summary>
             Provides a very simple customizable <see cref="T:System.Runtime.Serialization.SerializationBinder"/> that can convert <see cref="T:System.Type"/> to and from <see cref="T:System.String">string</see>
             by using assignable delegate properties.
             </summary>
             <remarks>
             <para>When serializing, you can assign the <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.AssemblyNameResolver"/> and <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeNameResolver"/> properties to customize
             the assembly and type names of a <see cref="T:System.Type"/> to be written into the serialization stream.</para>
             <para>When deserializing, you can assign the <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeResolver"/> properties to return a type from an assembly-type name pair.</para>
             <para>If the properties above are not assigned or when they return <see langword="null"/>, then the consumer <see cref="T:System.Runtime.Serialization.IFormatter"/> instance will use its internal resolve logic.</para>
             <note type="security"><para>If <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeResolver"/> is not assigned or can return <see langword="null"/>, then the consumer <see cref="T:System.Runtime.Serialization.IFormatter"/> instance
             may load assemblies during the deserialization. If the deserialization stream is not from a trusted source, then you should
             never return <see langword="null"/> from the assigned delegate of the <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeResolver"/> property. Instead, throw an
             exception if a type could not be resolved.</para>
             <para>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
             </remarks>
             <example>
             <code lang="C#"><![CDATA[
             // deserializing a renamed type
             var formatter = new BinaryFormatter(); // or a BinarySerializationFormatter
             formatter.Binder = new CustomSerializationBinder
             {
                 TypeResolver = (asmName, typeName) =>
                     typeName == "MyNamespace.MyOldClass" ? typeof(MyNewClass) : null
             };
            
             return (MyNewClass)formatter.Deserialize(streamContainingOldData);]]></code>
             <note type="tip">If the inner structure of the type has also been changed, then you can use the
             <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> class.</note>
             </example>
             <seealso cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/>
             <seealso cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/>
             <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializationBinder.AssemblyNameResolver">
            <summary>
            Gets or sets the custom assembly name resolver logic. It is invoked by the <see cref="M:KGySoft.Serialization.Binary.CustomSerializationBinder.BindToName(System.Type,System.String@,System.String@)">BindToName</see> method.
            If returns a non-<see langword="null"/> value, then it will be stored as the custom assembly name for the <see cref="T:System.Type"/> specified by the delegate argument.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeNameResolver">
            <summary>
            Gets or sets the custom type name resolver logic. It is invoked by the <see cref="M:KGySoft.Serialization.Binary.CustomSerializationBinder.BindToName(System.Type,System.String@,System.String@)">BindToName</see> method.
            If returns a non-<see langword="null"/> value, then it will be stored as the custom full type name (without the assembly name) for the <see cref="T:System.Type"/> specified by the delegate argument.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeResolver">
            <summary>
            Gets or sets the custom <see cref="T:System.Type"/> resolver logic. It is invoked by the <see cref="M:KGySoft.Serialization.Binary.CustomSerializationBinder.BindToType(System.String,System.String)">BindToType</see> method
            passing the stored assembly and type names in the delegate arguments, respectively.
            If returns <see langword="null"/> the formatter will attempt to resolve the names by its default logic.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.CustomSerializationBinder.BindToName(System.Type,System.String@,System.String@)">
            <summary>
            Binds a <see cref="T:System.Type"/> to an <paramref name="assemblyName"/> and <paramref name="typeName"/>.
            This implementation sets <paramref name="assemblyName"/> by using the <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.AssemblyNameResolver"/> property,
            and sets <paramref name="typeName"/> by using the <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeNameResolver"/> property.
            </summary>
            <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
            <param name="assemblyName">The <see cref="T:System.String">string</see>, which will represent the <see cref="T:System.Reflection.Assembly"/> name in the serialized data.
            Can return <see langword="null"/> to provide a default name.</param>
            <param name="typeName">The <see cref="T:System.String">string</see>, which will represent the <see cref="T:System.Type"/> name in the serialized data.
            Can return <see langword="null"/> to provide a default name.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.CustomSerializationBinder.BindToType(System.String,System.String)">
            <summary>
            Gets a <see cref="T:System.Type"/> associated by the provided <paramref name="assemblyName"/> and <paramref name="typeName"/>.
            This implementation uses the <see cref="P:KGySoft.Serialization.Binary.CustomSerializationBinder.TypeResolver"/> property to determine the result <see cref="T:System.Type"/>.
            </summary>
            <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object.</param>
            <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object.</param>
            <returns>The <see cref="T:System.Type"/> to be created by the formatter or <see langword="null"/> to use the default binding logic.</returns>
        </member>
        <member name="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector">
             <summary>
             An <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> implementation that makes possible to serialize and deserialize any objects,
             including non-serializable ones by an <see cref="T:System.Runtime.Serialization.IFormatter"/> such as <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
             or the legacy <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
             </summary>
             <remarks>
             <note type="security"><para>Do no use the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> class to be able to deserialize any type
             from an untrusted source. If you deserialize a stream from an untrusted source make sure that you set the <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SafeMode"/> property,
             which prevents supporting non-serializable types, or set the <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IsTypeSupported"/> property to explicitly tell what types are supported.</para>
             <para>See also the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
             <para>By using the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> you can serialize and deserialize any types.
             <note>The <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> is also able to serialize non-serializable types by itself
             by using the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> option. But the
             <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> provides more control and can be used also for other formatters.</note>
             </para>
             <para>To serialize a non-serializable type, or a type, which contains non-serializable types, it is usually enough to assign
             a <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> to the formatter:
             <code lang="C#"><![CDATA[
             var formatter = new BinaryFormatter { SurrogateSelector = new CustomSerializerSurrogateSelector() };
             formatter.Serialize(stream, myObject);]]></code></para>
             <h2>Solving compatibility issues between different platforms</h2>
             <note>Some types that are serializable in .NET Framework are not serializable in .NET Core/.NET Standard.
             This class can be a solution also for this problem. However, the solution is not always as simple as assigning
             a <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> instance to the <see cref="P:System.Runtime.Serialization.IFormatter.SurrogateSelector"/> property.
             See some cases and their solution in the list below.</note>
             <para>
             <list type="definition">
             <item><term>Basic case</term><description>If the only difference is that the type, which is serializable in the original platform
             is not marked by the <see cref="T:System.SerializableAttribute"/> in the new one (eg.: <see cref="T:System.IO.MemoryStream"/> is not serializable
             in .NET Core but otherwise it is still the same as in .NET Framework), then it is enough to use the default <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/>:
             <code lang="C#"><![CDATA[
             // deserializing a MemoryStream in .NET Core that was serialized in .NET Framework
             var formatter = new BinaryFormatter { SurrogateSelector = new CustomSerializerSurrogateSelector() };
             var memoryStream = (MemoryStream)formatter.Deserialize(streamSerializedInNetFramework); ]]></code></description></item>
             <item><term>The original type implements <see cref="T:System.Runtime.Serialization.ISerializable"/></term><description>In .NET Core there are several types that still
             implement <see cref="T:System.Runtime.Serialization.ISerializable"/>, though their <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">ISerializable.GetObjectData</see> method
             throws a <see cref="T:System.PlatformNotSupportedException"/> (eg. <see cref="T:System.DBNull"/>, <see cref="T:System.Type"/> and <see cref="T:System.Reflection.Assembly"/> in .NET Core 2.0).
             On the other hand, in .NET Core 3.0 <see cref="T:System.DBNull"/> is serializable again, <see cref="T:System.Reflection.Assembly"/> remained the same and
             from <see cref="T:System.Type"/> the <see cref="T:System.Runtime.Serialization.ISerializable"/> implementation has also been removed along with the <see cref="T:System.SerializableAttribute"/>.
             For such cases there are more possible solutions:
             <list type="bullet">
             <item>In best cases it is enough to use the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> both for serializing and deserializing without any surrogate selector.
             It natively supports <see cref="T:System.Type"/> instances on all platforms.</item>
             <item>When serializing by <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> you can set the <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IgnoreISerializable"/> property
             to force serializing the object by fields. If the fields are the same on the deserializing side, then the object will be deserializable
             by using the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> on both sides with the same settings.</item>
             <item>If fields have also changed you can customize the serializing and deserializing process by handling the events (see below).</item>
             </list></description></item>
             <item><term>Providing backwards compatibility</term><description>The <strong>Basic case</strong> might not work the other way around:
             serializing an object in .NET Core might not be deserializable in .NET Framework, for example. It can be avoided if:
             <list type="bullet">
             <item>You use <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> instead of <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>. It supports many types natively, including
             many core collections and simple types. These types are always encoded in a platform-independent way, which is also very compact.</item>
             <item>You can serialize the types using the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/> with setting the <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/>
             property to <see langword="true"/> to use assembly identities of the .NET Framework for most public types. These types can be resolved
             on all platforms. This solution works even with <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.</item>
             <item>Alternatively, you can use the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> with the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.OmitAssemblyQualifiedNames"/>,
             or the <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> (works also with <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>) to allow to omit assembly identities in the
             serialized stream. Such a stream can be deserialized if all the assemblies that contain the types to be deserialized are already loaded and the
             full names of the types are unambiguous in the loaded assemblies.</item>
             </list>
             </description></item>
             <item><term>Deserializing refactored types</term><description>If the object was serialized by fields but the field names have been
             refactored since then, then you can handle the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SettingField"/> event where you can either lookup and set the appropriate
             <see cref="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Field"/> or do whatever custom processing and set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property
             to <see langword="true"/> to indicate that you processed the entry manually. If you can initialize the complete object by yourself
             based on the serialized <see cref="T:System.Runtime.Serialization.SerializationInfo"/>, then you can handle the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Deserializing"/> event and set
             the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/>.
             <code lang="C#"><![CDATA[
             // deserializing a type, whose fields used to have "m_" prefix, which have been removed
             var surrogate = new CustomSerializerSurrogateSelector();
             surrogate.Deserializing += (sender, args) =>
             {
                 // manipulating data only if the current class is the one that changed
                 if (!(args.Object is MyChangedClass))
                     return;
            
                 // Replacing serialization entry names using the ReplaceValue extension method.
                 // An alternative solution would be initializing args.Object by ourselves and
                 // setting the args.Handled to true to prevent default deserialization logic.
                 foreach (SerializationEntry entry in args.SerializationInfo)
                 {
                     if (entry.Name.StartsWith("m_"))
                         args.SerializationInfo.ReplaceValue(entry.Name, 
                             entry.Name.Substring(2), entry.Value, entry.ObjectType);
                 }
             };
            
             var formatter = new BinaryFormatter // or a BinarySerializationFormatter
             {
                 SurrogateSelector = surrogate, // to remap field names as specified above
                 Binder = new WeakAssemblySerializationBinder() // if assembly version changed, too
             };
            
             return (MyChangedClass)formatter.Deserialize(streamContainingOldData);]]></code>
             <note type="tip">If the name of the type changed too, you can use the <see cref="T:KGySoft.Serialization.Binary.CustomSerializationBinder"/> class.</note></description></item>
             </list></para>
             <note type="caution">Some of the solutions above are more workarounds for situations arose rather than recommended practices.
             If it is known that a type will be deserialized in another environment and it can be completely restored by its public members,
             then a text-based serialization (see also <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/>) can be a better choice.</note>
             </remarks>
             <seealso cref="T:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector" />
             <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter" />
        </member>
        <member name="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Serializing">
            <summary>
            Occurs when an object is being serialized, before saving its inner content.
            <br/>If you populate the <see cref="P:KGySoft.Serialization.Binary.SerializingEventArgs.SerializationInfo"/> manually make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/>
            property to <see langword="true"/> to omit the default serialization logic.
            </summary>
        </member>
        <member name="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.ObjectDataObtained">
            <summary>
            Occurs when the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the object to be serialized has been obtained.
            You still can adjust its content before the actual serialization.
            </summary>
        </member>
        <member name="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Deserializing">
            <summary>
            Occurs when an object is being deserialized.
            <br/>If you initialize the <see cref="P:KGySoft.Serialization.Binary.SerializingEventArgs.Object"/> manually make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/>
            property to <see langword="true"/> to omit the default deserialization logic.
            </summary>
        </member>
        <member name="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.ObjectDataRestored">
            <summary>
            Occurs when the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the object to be deserialized has been processed.
            </summary>
        </member>
        <member name="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.GettingField">
            <summary>
            Occurs when a field value is about to be retrieved on serialization.
            You can adjust the <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Name"/>, <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Value"/> and <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Type"/>
            of the entry to be stored, or set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/>
            property to <see langword="true"/> to prevent storing any value for the current <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Field"/>.
            The <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property might be initialized to <see langword="true"/> for fields that are marked
            by the <see cref="T:System.NonSerializedAttribute"/>.
            </summary>
        </member>
        <member name="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SettingField">
            <summary>
            Occurs when a field value is about to be set on deserialization.
            You can adjust the associated <see cref="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Field"/> and its desired <see cref="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Value"/> to be set
            or you can set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to prevent setting any field by the default logic.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IgnoreISerializable">
            <summary>
            Gets or sets whether the <see cref="T:System.Runtime.Serialization.ISerializable"/> implementation should be ignored.
            The value of this property can be overridden by handling the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Serializing"/> event.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <value>
            <see langword="true"/> to serialize objects by fields even if it implements <see cref="T:System.Runtime.Serialization.ISerializable"/>;
            otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IgnoreNonSerializedAttribute">
            <summary>
            Gets or sets whether the fields that are marked by <see cref="T:System.NonSerializedAttribute"/> should be forcibly serialized.
            The value of this property can be overridden by handling the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.GettingField"/> event.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <value>
            <see langword="true"/> to serialize fields even if they are marked by <see cref="T:System.NonSerializedAttribute"/>;
            otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IgnoreNonExistingFields">
            <summary>
            Gets or sets whether serialization data without a corresponding field should be silently ignored on deserialization.
            The field setting can be adjusted by handling the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SettingField"/> event.
            <br/>Default value: <see langword="false"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IsTypeSupported">
            <summary>
            Gets or sets a delegate that can tell whether this <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> instance can be used
            to serialize and deserialize a type. If this property is <see langword="null"/>, and <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SafeMode"/> is <see langword="true"/>,
            then only serializable types are supported. Primitive types, <see cref="T:System.String"/>, arrays, pointers any by-ref types are not supported,
            regardless of the <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SafeMode">SafeMode</see> property.
            <br/>Default value: <see langword="null"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SafeMode">
            <summary>
            Gets or sets whether it is prohibited to serialize and deserialize types that are not marked by <see cref="T:System.SerializableAttribute"/>
            if the <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IsTypeSupported"/> property is not set.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <note>See also the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</note>
            </remarks>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="M:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.ChainSelector(System.Runtime.Serialization.ISurrogateSelector)">
            <summary>
            Specifies the next <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> for surrogates to examine if the current instance does not have a surrogate for the specified type and assembly in the specified context.
            </summary>
            <param name="selector">The next surrogate selector to examine.</param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.GetNextSelector">
            <summary>
            Returns the next surrogate selector in the chain.
            </summary>
            <returns>
            The next surrogate selector in the chain or null.
            </returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.GetSurrogate(System.Type,System.Runtime.Serialization.StreamingContext,System.Runtime.Serialization.ISurrogateSelector@)">
            <summary>
            Finds the surrogate that represents the specified object's type, starting with the specified surrogate selector for the specified serialization context.
            </summary>
            <returns>
            The appropriate surrogate for the given type in the given context.
            </returns>
            <param name="type">The <see cref="T:System.Type"/> of object that needs a surrogate.</param>
            <param name="context">The source or destination context for the current serialization.</param>
            <param name="selector">When this method returns, contains a <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> that holds a reference to the surrogate selector where the appropriate surrogate was found.</param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Dispose">
            <summary>
            Releases the resources held by this <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> instance.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder">
             <summary>
             Provides a <see cref="T:System.Runtime.Serialization.SerializationBinder"/> that makes possible to serialize and deserialize types with custom assembly identity.
             </summary>
             <remarks>
             <note type="security"><para>If a deserialization stream may come from an untrusted source, then make sure to set the <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.SafeMode"/> property
             to <see langword="true"/> to prevent loading assemblies when resolving types by the fallback logic.</para>
             <para>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
             <para>By default, the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/> does nothing. Resolving types from legacy
             assemblies works automatically if at least a chunk version of the assembly exists on the current platform containing nothing but a bunch
             of <see cref="T:System.Runtime.CompilerServices.TypeForwardedToAttribute"/> attributes (this is the case for the original .NET Framework assemblies on .NET Core and .NET Standard).</para>
             <para>To resolve types that are not forwarded by the <see cref="T:System.Runtime.CompilerServices.TypeForwardedToAttribute"/> from an existing assembly with the
             given identity you can use this binder for deserialization. Add the types to be handled by the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">AddType</see> or
             <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddTypes(System.Type[])">AddTypes</see> methods.</para>
             <para>If <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> is set to <see langword="true"/>, then mapping works also on serialization.
             For types without an explicitly set mapping the value of the <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/> attribute will be written if it is defined.
             <note>By default, both <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> and <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> dumps legacy identities on serialization
             for types decorated by the <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/>. If you use this binder on serialization without adding any type
             just after setting the <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> to <see langword="true"/>, then the only difference will be that even the <c>mscorlib</c> assembly
             name will be dumped to the output stream, which would be omitted otherwise.</note></para>
             <para>To serialize types with arbitrary assembly identity, use this binder both for serialization and deserialization.
             Add the type to be handled by the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">AddType</see> method and specify at least one <see cref="T:System.Reflection.AssemblyName"/>
             for each added <see cref="T:System.Type"/>.</para>
             </remarks>
             <example>
             <para>The following example demonstrates the usage of the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/> when types have to be deserialized from a stream,
             which have been originally serialized by another version of the assembly.
             <code lang="C#"><![CDATA[
             var binder = new ForwardedTypesSerializationBinder();
            
             // MyType will be able to be deserialized if the assembly name in the
             // serialization stream matches any of the enlisted ones.
             binder.AddType(typeof(MyType),
                 new AssemblyName("MyOldAssembly, Version=1.0.0.0"),
                 new AssemblyName("MyOldAssembly, Version=1.2.0.0"),
                 new AssemblyName("MyNewAssembly, Version=1.5.0.0"),
                 new AssemblyName("MyNewAssembly, Version=2.0.0.0"));
            
             // MyOtherType will be able to be deserialized if it was serialized by any versions of MyAssembly.
             binder.AddType(typeof(MyOtherType), new AssemblyName("MyAssembly"));
            
             // Any type of any assembly will be mapped to SomeOtherType if their full names match.
             binder.AddType(typeof(SomeOtherType));
            
             // Multiple types can be enlisted without assembly identity
             binder.AddTypes(typeof(MyType), typeof(MyOtherType), typeof(SomeOtherType));
            
             IFormatter formatter = new BinarySerializationFormatter { Binder = binder }; // or BinaryFormatter
             object result = formatter.Deserialize(serializationStream);
             ]]></code></para>
             <note>The <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> is also able to ignore assembly information but if there are two different
             types of the same name in the same namespace, then the behavior of <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> is not deterministic.</note>
             <para>
             The following example demonstrates how to control the serialized assembly name.
             <code lang="C#"><![CDATA[
             // Setting the WriteLegacyIdentity allows to use arbitrary custom indenity on serialization.
             var binder = new ForwardedTypesSerializationBinder { WriteLegacyIdentity = true };
            
             // When serializing a MyType instance, it will be saved with the firstly specified identity
             binder.AddType(typeof(MyType),
                 new AssemblyName("MyOldAssembly, Version=1.0.0.0"),
                 new AssemblyName("MyOldAssembly, Version=1.2.0.0"),
                 new AssemblyName("MyNewAssembly, Version=1.5.0.0"),
                 new AssemblyName("MyNewAssembly, Version=2.0.0.0"));
            
             // If WriteLegacyIdentity is true, types with TypeForwardedFromAttribute will be automatically written
             // with their old identity stored in the TypeForwardedFromAttribute.AssemblyFullName property.
             // List<T> has a TypeForwardedFromAttribute in .NET Core and Standard so it will be serialized with
             // mscorlib assembly identity in every platform:
             var obj = new List<MyType> { new MyType() };
             
             IFormatter formatter = new BinaryFormatter { Binder = binder }; // or BinarySerializationFormatter
             formatter.Serialize(serializationStream, obj);
             ]]></code>
             </para>
             <note type="tip">If not only the assembly name but also the inner content of a type (ie. field names) changed, then you can use
             the <see cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector"/> class.</note>
             </example>
             <seealso cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/>
             <seealso cref="T:KGySoft.Serialization.Binary.CustomSerializationBinder"/>
             <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="F:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.mapping">
            <summary>
            Key: Type.FullName for root types.
            Value.Key: Different types of the same full name
            Value.Value: AssemblyName.FullName, or empty string, if any assemblies are allowed.
                         Not AssemblyNames because they have no overridden Equals.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity">
            <summary>
            Gets or sets whether a legacy assembly identity is tried to be written on serializing.
            </summary>
            <remarks>
            <note>In Framework .NET 3.5 <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> and most <see cref="T:System.Runtime.Serialization.IFormatter"/> implementations ignore the
            value of this property. <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> is able to use the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/>
            as an <see cref="T:KGySoft.Serialization.Binary.ISerializationBinder"/> implementation and consider the value of this property even in .NET 3.5.</note>
            <para>If the value of this property is <see langword="true"/>, then on serialization a legacy identity is tried to be written for the serialized type.
            That is, the first <see cref="T:System.Reflection.AssemblyName"/> that was specified for the type by the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">AddType</see> method, or
            the value of the <see cref="P:System.Runtime.CompilerServices.TypeForwardedFromAttribute.AssemblyFullName">TypeForwardedFromAttribute.AssemblyFullName</see> property
            if it is specified for the type.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.SafeMode">
            <summary>
            Gets or sets whether loading assemblies is prohibited on deserialization, when there is no rule specified for a type
            and the default resolve logic is used.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.SafeMode"/> is <see langword="true"/>, and there is no rule specified for a type, then it ensures that no assembly loading will occur when using the default type resolving logic.</para>
            <para>If <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.SafeMode"/> is <see langword="false"/>, then <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.BindToType(System.String,System.String)">BindToType</see> may load assemblies during the deserialization.</para>
            <para>To prevent the consumer <see cref="T:System.Runtime.Serialization.IFormatter"/> from loading assemblies the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.BindToType(System.String,System.String)">BindToType</see> method never returns <see langword="null"/>;
            instead, it throws a <see cref="T:System.Runtime.Serialization.SerializationException"/> if a type could not be resolved.</para>
            <note>See also the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</note>
            </remarks>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">
            <summary>
            Adds the <paramref name="type"/> to this binder. If no <paramref name="assemblyIdentities"/> are defined, then any
            <see cref="T:System.Type"/> with the same full name will be resolved to <paramref name="type"/>; otherwise, only the ones,
            whose identities match.
            </summary>
            <param name="type">The type to be added to the handled types by this binder.</param>
            <param name="assemblyIdentities">The legacy assembly identities to be recognized. Can contain also partial names. If empty or contains a <see langword="null"/>
            element, then any type of the same full name will be resolved to <paramref name="type"/>.</param>
            <remarks>
            <para>If no assembly identities are specified, then any <see cref="T:System.Type"/> that has the same full name as <paramref name="type"/>,
            will be resolved to the specified <paramref name="type"/>.</para>
            <para>If at least one assembly identity is specified and <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> is <see langword="true"/>,
            then on serialization the first specified name will be returned as the assembly name of the <paramref name="type"/>.</para>
            <para>For generic types you should specify the generic type definition only.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddTypes(System.Type[])">
            <summary>
            Adds the <paramref name="types"/> to this binder without any specific assembly identity. Each <see cref="T:System.Type"/>
            that have the same full name as one of the given types, will be able to be resolved from any assembly.
            </summary>
            <param name="types">The types to be added to the handled types by this binder.</param>
            <remarks>
            <para>To resolve types from specific assemblies only use the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">AddType</see> method.</para>
            <para>If <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> is <see langword="true"/>, then on serialization a legacy assembly name
            will be used only for those types, which are decorated by the <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/> attribute.</para>
            <para>For generic types it is enough to specify the generic type definition only.</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.BindToName(System.Type,System.String@,System.String@)">
            <summary>
            When <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> is <see langword="true"/>, then tries to return a legacy assembly identity
            for the specified <paramref name="serializedType"/>.
            </summary>
            <param name="serializedType">The type of the object that is being serialized.</param>
            <param name="assemblyName">If <see cref="P:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.WriteLegacyIdentity"/> is <see langword="true"/>, then tries to return an old assembly identity for <paramref name="serializedType"/>.
            If at least one <see cref="T:System.Reflection.AssemblyName"/> was specified for the type by the <see cref="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.AddType(System.Type,System.Reflection.AssemblyName[])">AddType</see> method, then the firstly specified name will be used.
            Otherwise, if the type has a <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/> is specified for the type, its value will be used.
            Otherwise, returns <see langword="null"/> so the formatter will emit a default identity.</param>
            <param name="typeName">If <paramref name="assemblyName"/> is not <see langword="null"/> when this method returns, then contains the full name of the <paramref name="serializedType"/>,
            otherwise, returns <see langword="null"/>.</param>
            <remarks>
            <note>In .NET Framework 3.5 this method does not exist in the base <see cref="T:System.Runtime.Serialization.SerializationBinder"/> and is called only if the consumer
            serializer handles the <see cref="T:KGySoft.Serialization.Binary.ISerializationBinder"/> interface or calls it directly.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder.BindToType(System.String,System.String)">
            <summary>
            Retrieves a type by its <paramref name="assemblyName"/> and <paramref name="typeName"/>.
            </summary>
            <returns>
            The type of the resolved object to create.
            </returns>
            <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object.</param>
            <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The type cannot be resolved or the assembly cannot be loaded.</exception>
        </member>
        <member name="T:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector">
            <summary>
            An <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> implementation that makes possible to serialize and deserialize objects by
            <see cref="T:System.Runtime.Serialization.IFormatter"/>s without storing field names. This provides compatibility for obfuscated and non-obfuscated versions of an assembly.
            </summary>
            <remarks>
            <note type="security"><para>If you deserialize a stream from an untrusted source make sure that you set the <see cref="P:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector.SafeMode"/> property,
            which prevents supporting non-serializable types.</para>
            <para>See also the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
            <para>You can use this surrogate selector for any non-primitive types that do not implement <see cref="T:System.Runtime.Serialization.ISerializable"/> interface.</para>
            <note>Versioning by this surrogate selector can be accomplished only if new fields are always defined after the old ones on every level of the hierarchy.
            You might want to use also the <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> class to ignore version information of assemblies on deserialization.</note>
            <note type="caution">Please note that this surrogate selector does not identify field names on deserialization so reordering members may corrupt or fail deserialization.</note>
            </remarks>
            <seealso cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder" />
            <seealso cref="T:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector" />
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter" />
        </member>
        <member name="P:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector.SafeMode">
            <summary>
            Gets or sets whether it is prohibited to serialize and deserialize types that are not marked by <see cref="T:System.SerializableAttribute"/>.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <note>See also the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</note>
            </remarks>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="M:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector.ChainSelector(System.Runtime.Serialization.ISurrogateSelector)">
            <summary>
            Specifies the next <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> for surrogates to examine if the current instance does not have a surrogate for the specified type and assembly in the specified context.
            </summary>
            <param name="selector">The next surrogate selector to examine.</param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector.GetNextSelector">
            <summary>
            Returns the next surrogate selector in the chain.
            </summary>
            <returns>
            The next surrogate selector in the chain or null.
            </returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.NameInvariantSurrogateSelector.GetSurrogate(System.Type,System.Runtime.Serialization.StreamingContext,System.Runtime.Serialization.ISurrogateSelector@)">
            <summary>
            Finds the surrogate that represents the specified object's type, starting with the specified surrogate selector for the specified serialization context.
            </summary>
            <returns>
            The appropriate surrogate for the given type in the given context.
            </returns>
            <param name="type">The <see cref="T:System.Type"/> of object that needs a surrogate.</param>
            <param name="context">The source or destination context for the current serialization.</param>
            <param name="selector">When this method returns, contains a <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> that holds a reference to the surrogate selector where the appropriate surrogate was found.</param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder">
            <summary>
            Provides a <see cref="T:System.Runtime.Serialization.SerializationBinder"/> instance for <see cref="T:System.Runtime.Serialization.IFormatter"/> implementations that can ignore version and token information
            of stored assembly name. This makes possible to deserialize objects stored in different version of the original assembly.
            It also can make any <see cref="T:System.Runtime.Serialization.IFormatter"/> safe in terms of prohibiting loading assemblies during the deserialization if the <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/>
            property is <see langword="true"/>.
            </summary>
            <remarks>
            <note type="security"><para>If a deserialization stream may come from an untrusted source, then make sure to set the <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/> property
            to <see langword="true"/> to prevent loading assemblies when resolving types.</para>
            <para>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</para></note>
            <note>This binder does not use exact type mapping just tries to resolve type information automatically.
            To customize type mapping or use a custom resolve logic you can use the <see cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/>
            or <see cref="T:KGySoft.Serialization.Binary.CustomSerializationBinder"/> classes, respectively.</note>
            <para>The <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> class allows resolving type information by weak assembly identity,
            or by completely ignoring assembly information (if <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.IgnoreAssemblyNameOnResolve"/> property is <see langword="true"/>.)</para>
            <para>It also makes possible to prevent loading assembles during deserialization if the <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/> property is <see langword="true"/>.
            <note type="tip">You can make even a <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> safe by assigning a <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/>
            with <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/> = <see langword="true"/> to its <see cref="P:System.Runtime.Serialization.IFormatter.Binder"/> property so it cannot resolve any type
            whose assembly is not already loaded.
            </note></para>
            <para>If <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> is used on serialization, then it can omit assembly information from the serialization stream
            if the <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.OmitAssemblyNameOnSerialize"/> property is <see langword="true"/>.</para>
            </remarks>
            <seealso cref="T:KGySoft.Serialization.Binary.ForwardedTypesSerializationBinder"/>
            <seealso cref="T:KGySoft.Serialization.Binary.CustomSerializationBinder"/>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.OmitAssemblyNameOnSerialize">
            <summary>
            Gets or sets whether assembly name should be completely omitted on serialization.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <value>
            <see langword="true"/> to omit assembly name on serialize; otherwise, <see langword="false"/>.
            </value>
            <remarks>
            <note>In .NET Framework 3.5 <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> and most <see cref="T:System.Runtime.Serialization.IFormatter"/> implementations ignore the
            value of this property. <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> is able to use the <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/>
            as an <see cref="T:KGySoft.Serialization.Binary.ISerializationBinder"/> implementation and consider the value of this property even in .NET 3.5.</note>
            <note>The value of this property is used only on serialization; however, it affects deserialization as well:
            when assembly name is omitted, deserialization will find the first matching type from any assembly.</note>
            <para>Using <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> with <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.OmitAssemblyQualifiedNames"/>
            option enabled has a similar effect. However, using <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> with this property set to <see langword="true"/>, assembly names
            can be omitted even when using <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/> or other <see cref="T:System.Runtime.Serialization.IFormatter"/> implementations.</para>
            <para>When the value of this property is <see langword="true"/>, the serialized stream will be shorter; however,
            deserialization might be slower, and type will be searched only in already loaded assemblies. When multiple
            assemblies have types with the same name the retrieved type cannot determined.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.IgnoreAssemblyNameOnResolve">
            <summary>
            Gets or sets whether an existing assembly name is allowed to be completely ignored on deserialization.
            <br/>Default value: <see langword="true"/>.
            </summary>
            <remarks>
            <para>If the value of this property is <see langword="true"/> and the type cannot be resolved from an assembly on deserialization,
            then the type is tried to be resolved from any loaded assemblies. The effect is similar as if the
            <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.OmitAssemblyNameOnSerialize"/> property was used on serialization, except that the type is tried to be resolved
            from the provided assembly in the first place.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode">
            <summary>
            Gets or sets whether loading assemblies is prohibited on deserialization.
            <br/>Default value: <see langword="false"/>.
            </summary>
            <remarks>
            <para>If <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/> is <see langword="true"/>, then no assembly loading will occur on deserialization.</para>
            <para>If <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/> is <see langword="false"/>, then <see cref="M:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.BindToType(System.String,System.String)">BindToType</see> may load assemblies during the deserialization.</para>
            <para>To prevent the consumer <see cref="T:System.Runtime.Serialization.IFormatter"/> from loading assemblies the <see cref="M:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.BindToType(System.String,System.String)">BindToType</see> method never returns <see langword="null"/>;
            instead, it throws a <see cref="T:System.Runtime.Serialization.SerializationException"/> if a type could not be resolved.</para>
            <note>See also the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</note>
            </remarks>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
        </member>
        <member name="M:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.BindToName(System.Type,System.String@,System.String@)">
            <summary>
            When <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.OmitAssemblyNameOnSerialize"/> is <see langword="true"/>, suppresses the assembly name on serialization.
            Otherwise, returns <see langword="null"/> for both assembly and type names, indicating that the original
            names should be used.
            </summary>
            <param name="serializedType">The type of the object that is being serialized.</param>
            <param name="assemblyName">If <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.OmitAssemblyNameOnSerialize"/> is <see langword="true"/>, then returns <c>*</c> to indicate an omitted assembly;
            otherwise, returns <see langword="null"/>.</param>
            <param name="typeName">If <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.OmitAssemblyNameOnSerialize"/> is <see langword="true"/>, then returns the full name of the type without assembly information;
            otherwise, returns <see langword="null"/>.</param>
            <remarks>
            <note>In .NET Framework 3.5 this method does not exist in the base <see cref="T:System.Runtime.Serialization.SerializationBinder"/> and is called only if the consumer
            serializer handles the <see cref="T:KGySoft.Serialization.Binary.ISerializationBinder"/> interface or calls it directly.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.BindToType(System.String,System.String)">
            <summary>
            Retrieves a type by its <paramref name="assemblyName"/> and <paramref name="typeName"/>.
            </summary>
            <returns>
            The type of the resolved object to create.
            </returns>
            <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object.</param>
            <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The type cannot be resolved or the assembly cannot be loaded.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.GetAssembly(System.String)">
            <summary>
            Resolves an assembly by string
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Serialization.Binary"/> namespace contains types for binary serialization (<see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>, <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>)
            as well as other binary serialization related classes including serialization binders and surrogate selectors.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.BinarySerializationOptions">
            <summary>
            Options for serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/> and <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> classes.
            </summary>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>
            <seealso cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.None">
            <summary>
            All options are disabled.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.ForceRecursiveSerializationOfSupportedTypes">
            <summary>
            <para>Apart from primitive types, strings and arrays forces to serialize every type recursively. If <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector"/> is set,
            then the surrogate selectors will be tried to used even for the supported types (as if <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.TryUseSurrogateSelectorForAnyType"/> was also enabled).
            <note>Even if this flag is enabled, non-serializable types will not be serialized automatically. Use the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> to
            enable serialization of such types.</note></para>
            <para>This flag is considered on serialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.ForcedSerializationValueTypesAsFallback">
            <summary>
            <para>This option makes possible to serialize <see cref="T:System.ValueType"/>s (<see langword="struct"/>) that are not marked by <see cref="T:System.SerializableAttribute"/>.
            <note type="caution">
            Using this flag allows serializing value types with reference (non-value type) fields by marshaling. Deserializing such value may fail if the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> flag
            if enabled. To be able to serialize string and array reference fields they must be decorated by <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute"/> using
            <see cref="F:System.Runtime.InteropServices.UnmanagedType.ByValTStr"/> or <see cref="F:System.Runtime.InteropServices.UnmanagedType.ByValArray"/>, respectively.
            </note></para>
            <para>This flag is considered on serialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback">
            <summary>
            <para>Makes possible to serialize any object even if object is not marked with <see cref="T:System.SerializableAttribute"/>.</para>
            <para>This flag is considered on serialization.
            <note type="caution">Though this flag makes possible to serialize non-serializable types, deserializing such stream will not work
            when the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode"/> flag is enabled (unless an applicable <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector"/> is used).</note>
            </para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreSerializationMethods">
            <summary>
            <para>If a type has methods decorated with <see cref="T:System.Runtime.Serialization.OnSerializingAttribute"/>, <see cref="T:System.Runtime.Serialization.OnSerializedAttribute"/>, <see cref="T:System.Runtime.Serialization.OnDeserializingAttribute"/> or <see cref="T:System.Runtime.Serialization.OnDeserializedAttribute"/>,
            or the type implements <see cref="T:System.Runtime.Serialization.IDeserializationCallback"/>, then these methods are called during the process. By setting this flag these methods can be ignored.</para>
            <para>This flag is considered both on serialization and deserialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreIBinarySerializable">
            <summary>
            <para>This flag ignores <see cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/> implementations.</para>
            <para>This flag is considered on serialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.OmitAssemblyQualifiedNames">
            <summary>
            <para>If enabled, type references will be stored without assembly identification. This can make possible
            to restore a type even if the version of the assembly has been modified since last serialization while makes serialized data more compact;
            however, it cannot be guaranteed that the correct type will be even found on deserialization.
            <note type="caution">If there are types with the same name in the same namespace in different assemblies, then by using this flag, these types cannot be distincted.</note>
            <note>If you want to deserialize a type that was stored with strong assembly reference (without this flag) from a different version of an assembly,
            then use <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/> instead.</note></para>
            <para>This flag is considered on serialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreObjectChanges">
            <summary>
            <para>This option makes possible to deserialize an object, which has been changed since last serialization.
            When this option is enabled, names of the base classes, and fields that have been serialized but have been since then
            removed, will be ignored.
            <note type="caution">When this flag is enabled, an erroneous deserialization may silently succeed. When a field has
            been renamed or relocated into another base class, use an <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> implementation to apply mappings instead.</note></para>
            <para>This flag is considered on deserialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreTypeForwardedFromAttribute">
            <summary>
            <para>When this flag is enabled, every type will be serialized with its actual assembly identity rather than considering
            the value of an existing <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/>.</para>
            <para>This flag is ignored if <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.OmitAssemblyQualifiedNames"/> is enabled.</para>
            <para>This flag is considered on serialization.
            <note>Enabling this flag may cause that the type will not be able to be deserialized on a different platform, or at least not without using a <see cref="T:System.Runtime.Serialization.SerializationBinder"/>.</note></para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreISerializable">
            <summary>
            <para>This flag ignores <see cref="T:System.Runtime.Serialization.ISerializable"/> implementations forcing to serialize a default object graph (unless an applicable surrogate is defined).</para>
            <para>This flag is considered both on serialization and deserialization.
            <note>Usually this flag must have the same value at serialization and deserialization; otherwise, the deserialization may fail.</note></para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreIObjectReference">
            <summary>
            <para>This flag ignores <see cref="T:System.Runtime.Serialization.IObjectReference"/> implementations.
            <note>Using this flag may cause that the deserialized object or its elements will have the wrong type, or the deserialization will fail.</note></para>
            <para>This flag is considered on deserialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.CompactSerializationOfStructures">
            <summary>
            <para>If a <see cref="T:System.ValueType"/> (<see langword="struct"/>) contains no references,
            then by enabling this option the instance will be serialized in a compact way form if possible.</para>
            <para>This flag is considered on serialization.</para>
            <note>
            Note: This option has higher priority than <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> flag,
            except for natively supported structures. This option affects only instances that have no references at all.
            </note>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.TryUseSurrogateSelectorForAnyType">
            <summary>
            <para>If this flag is enabled while <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector"/> is set, then the selector is tried to be used
            even for natively supported types.</para>
            <para>This flag is considered on serialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Binary.BinarySerializationOptions.SafeMode">
            <summary>
            <para>If this flag is enabled, then it is ensured that no assembly loading is allowed during deserialization, unless a <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.Binder"/>
            is specified that can load assemblies. All of the assemblies that are referred by the serialization stream must be preloaded before starting the deserialization.</para>
            <para>Additionally, it ensures that during the deserialization collections are allocated with limited capacity to prevent
            possible attacks that can cause <see cref="T:System.OutOfMemoryException"/>. Deserializing an invalid stream still may cause to throw a <see cref="T:System.Runtime.Serialization.SerializationException"/>.</para>
            <para>It also disallows deserializing non-serializable types, unless the <see cref="P:KGySoft.Serialization.Binary.BinarySerializationFormatter.SurrogateSelector"/> property is set that allows
            deserializing a type explicitly. Please note that deserializing non-serializable types is allowed without this flag by default (see also the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.RecursiveSerializationAsFallback"/> flag).</para>
            <para>In .NET Core / .NET 5.0 and above, deserializing non-natively supported system types in safe mode may require to preload some core legacy assemblies
            such as <c>mscorlib.dll</c>, <c>System.dll</c>, <c>System.Core.dll</c>, etc., which contain only type forwards on recent .NET platforms.
            You can avoid this if the stream was serialized with the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.IgnoreTypeForwardedFromAttribute"/> option (so every non-natively supported type
            was serialized with its actual identity), or with the <see cref="F:KGySoft.Serialization.Binary.BinarySerializationOptions.OmitAssemblyQualifiedNames"/> option (so types can be located in any already loaded assembly).</para>
            <note>In safe mode no version mismatch is tolerated even for system assemblies. If you want to deserialize a stream in safe mode that contains
            different assembly identities from the loaded ones, then use <see cref="T:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder"/>, and set
            its <see cref="P:KGySoft.Serialization.Binary.WeakAssemblySerializationBinder.SafeMode"/> property to <see langword="true"/>.</note>
            <note type="security">Please note that even enabling this flag may not prevent every possible attacks, especially when targeting the .NET Framework.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class for more details.</note>
            <para>This flag is considered on deserialization.</para>
            <para>Default state at serialization methods in <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.DeserializingEventArgs">
            <summary>
            Provides arguments for the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Deserializing">CustomSerializerSurrogateSelector.Deserializing</see> event.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.DeserializingEventArgs.Object">
            <summary>
            Gets the uninitialized object that is being deserialized.
            <br/>If you initialize it manually make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default deserialization logic.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.DeserializingEventArgs.Context">
            <summary>
            Gets the context of this deserialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.DeserializingEventArgs.SerializationInfo">
            <summary>
            Gets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> from which the <see cref="P:KGySoft.Serialization.Binary.DeserializingEventArgs.Object"/> is about to be deserialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.DeserializingEventArgs.IgnoreISerializable">
            <summary>
            Gets or sets whether the <see cref="T:System.Runtime.Serialization.ISerializable"/> implementation of <see cref="P:KGySoft.Serialization.Binary.DeserializingEventArgs.Object"/> should be ignored.
            <br/>To completely omit the default deserialization logic set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/>.
            </summary>
            <value>
            <see langword="true"/> to deserialize the <see cref="P:KGySoft.Serialization.Binary.DeserializingEventArgs.Object"/> by fields even if it implements <see cref="T:System.Runtime.Serialization.ISerializable"/>;
            otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:KGySoft.Serialization.Binary.GettingFieldEventArgs">
            <summary>
            Provides arguments for the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.GettingField">CustomSerializerSurrogateSelector.GettingField</see> event.
            </summary>
            <remarks>
            <para>The default value of the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property is <see langword="true"/>, if the field is marked by <see cref="T:System.NonSerializedAttribute"/>
            and the value of <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IgnoreNonSerializedAttribute"/> property is <see langword="false"/>;
            otherwise, <see langword="false"/>.</para>
            <para>You can set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to prevent saving the current field,
            or you can set it to <see langword="false"/> to force saving even non-serialized fields.</para>
            </remarks>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Object">
            <summary>
            Gets the object that is being serialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Context">
            <summary>
            Gets the context of this serialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.SerializationInfo">
            <summary>
            Gets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Object"/> being serialized.
            If you add the data manually make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default serialization logic.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Field">
            <summary>
            Gets the field whose value is about to be stored.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Name">
            <summary>
            Gets or sets the name of the entry to be stored in the serialization stream.
            <br/>Setting it to <see langword="null"/> will cause an <see cref="T:System.ArgumentNullException"/> from <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.SerializationInfo"/>.
            <br/>To prevent storing any value make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default serialization logic.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Value">
            <summary>
            Gets or sets the value to be stored in the serialization stream.
            <br/>To prevent storing any value make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default serialization logic.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Type">
            <summary>
            Gets or sets the <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.Type"/> to be stored in the serialization stream.
            <br/>Setting <see langword="null"/> will cause an <see cref="T:System.ArgumentNullException"/> from <see cref="P:KGySoft.Serialization.Binary.GettingFieldEventArgs.SerializationInfo"/>.
            <br/>To prevent storing any value make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default serialization logic.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.ObjectDataObtainedEventArgs">
            <summary>
            Provides arguments for the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.ObjectDataObtained">CustomSerializerSurrogateSelector.ObjectDataObtained</see> event.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ObjectDataObtainedEventArgs.Object">
            <summary>
            Gets the object that is being serialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ObjectDataObtainedEventArgs.Context">
            <summary>
            Gets the context of this serialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ObjectDataObtainedEventArgs.SerializationInfo">
            <summary>
            Gets the populated <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the <see cref="P:KGySoft.Serialization.Binary.ObjectDataObtainedEventArgs.Object"/> being serialized.
            You still can change its content before the actual serialization.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.ObjectDataRestoredEventArgs">
            <summary>
            Provides arguments for the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.ObjectDataRestored">CustomSerializerSurrogateSelector.ObjectDataRestored</see> event.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ObjectDataRestoredEventArgs.Object">
            <summary>
            Gets the object that is being deserialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ObjectDataRestoredEventArgs.Context">
            <summary>
            Gets the context of this deserialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.ObjectDataRestoredEventArgs.SerializationInfo">
            <summary>
            Gets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> from which <see cref="P:KGySoft.Serialization.Binary.ObjectDataRestoredEventArgs.Object"/> has been restored.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.SerializingEventArgs">
            <summary>
            Provides arguments for the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.Serializing">CustomSerializerSurrogateSelector.Serializing</see> event.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SerializingEventArgs.Object">
            <summary>
            Gets the object that is being serialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SerializingEventArgs.Context">
            <summary>
            Gets the context of this serialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SerializingEventArgs.SerializationInfo">
            <summary>
            Gets the empty <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the <see cref="P:KGySoft.Serialization.Binary.SerializingEventArgs.Object"/> being serialized.
            <br/>If you populate it manually make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default serialization logic.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SerializingEventArgs.IgnoreISerializable">
            <summary>
            Gets or sets whether the <see cref="T:System.Runtime.Serialization.ISerializable"/> implementation of <see cref="P:KGySoft.Serialization.Binary.SerializingEventArgs.Object"/> should be ignored.
            <br/>To completely omit the default serialization logic set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/>.
            </summary>
            <value>
            <see langword="true"/> to serialize the <see cref="P:KGySoft.Serialization.Binary.SerializingEventArgs.Object"/> by fields even if it implements <see cref="T:System.Runtime.Serialization.ISerializable"/>;
            otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:KGySoft.Serialization.Binary.SettingFieldEventArgs">
            <summary>
            Provides arguments for the <see cref="E:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.SettingField">CustomSerializerSurrogateSelector.SettingField</see> event.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Object">
            <summary>
            Gets the object that is being deserialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Context">
            <summary>
            Gets the context of this deserialization.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.SerializationInfo">
            <summary>
            Gets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> of the <see cref="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Object"/> being deserialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Entry">
            <summary>
            Gets the current <see cref="T:System.Runtime.Serialization.SerializationEntry"/> of the <see cref="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Object"/> being deserialized.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Field">
            <summary>
            Gets or sets the field to be set. If <see langword="null"/> and <see cref="P:KGySoft.Serialization.Binary.CustomSerializerSurrogateSelector.IgnoreNonExistingFields"/>
            is <see langword="false"/>, then a <see cref="T:System.Runtime.Serialization.SerializationException"/> will be thrown.
            You may either set this property by the matching field or set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> to <see langword="true"/> to
            skip the default processing.
            <br/>Default value: The field identified as the matching field, or <see langword="null"/>, if such field was not found.
            </summary>
        </member>
        <member name="P:KGySoft.Serialization.Binary.SettingFieldEventArgs.Value">
            <summary>
            Gets or sets the value to set.
            <br/>To prevent setting any value make sure you set the <see cref="P:System.ComponentModel.HandledEventArgs.Handled"/> property to <see langword="true"/> to
            omit the default deserialization logic.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Binary.SerializationInfoExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.ToEnumerable(System.Runtime.Serialization.SerializationInfo)">
            <summary>
            Gets a lazy-evaluating <see cref="T:System.Collections.Generic.IEnumerable`1"/> wrapper for the specified <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to be converted.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance that contains the <see cref="T:System.Runtime.Serialization.SerializationEntry"/> items of the provided <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</returns>
            <remarks>
            <para>The returned instance has a lazy enumerator. Adding and removing elements during enumerating the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> can lead to
            an inconsistent state (it tolerates calling the <see cref="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.ReplaceValue(System.Runtime.Serialization.SerializationInfo,System.String,System.String,System.Object,System.Type)">ReplaceValue</see> though).</para>
            <note>The enumerator of the returned collection does not support the <see cref="M:System.Collections.IEnumerator.Reset">IEnumerator.Reset</see> method.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.TryGetValue(System.Runtime.Serialization.SerializationInfo,System.String,System.Object@)">
            <summary>
            Tries the get value from the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> associated with the specified <paramref name="name"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to retrieve the value from.</param>
            <param name="name">The name of the value to be retrieved.</param>
            <param name="value">When this method returns, the value associated with the specified name, if the <paramref name="name"/> is found;
            otherwise, <see langword="null"/>. This parameter is passed uninitialized.</param>
            <returns>
            <see langword="true"/>, if <see cref="T:System.Runtime.Serialization.SerializationInfo"/> contains an element with the specified name; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.TryGetValue``1(System.Runtime.Serialization.SerializationInfo,System.String,``0@)">
            <summary>
            Tries the get value from the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> associated with the specified <paramref name="name"/>.
            </summary>
            <typeparam name="T">The type of the element to get.</typeparam>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to retrieve the value from.</param>
            <param name="name">The name of the value to be retrieved.</param>
            <param name="value">When this method returns, the value associated with the specified name, if the <paramref name="name"/> is found
            and has the type of <typeparamref name="T"/>; otherwise, <see langword="null"/>. This parameter is passed uninitialized.</param>
            <returns>
            <see langword="true"/>, if <see cref="T:System.Runtime.Serialization.SerializationInfo"/> contains an element with the specified name
            and type of <typeparamref name="T"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.GetValueOrDefault(System.Runtime.Serialization.SerializationInfo,System.String,System.Object)">
            <summary>
            Tries to get a value from a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> for the given <paramref name="name"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to retrieve the value from.</param>
            <param name="name">The name of the value to be retrieved.</param>
            <param name="defaultValue">The default value to return if <paramref name="name"/> was not found. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns>The found value or <see langword="null"/> if <paramref name="name"/> was not found in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.GetValueOrDefault``1(System.Runtime.Serialization.SerializationInfo,System.String,``0)">
            <summary>
            Tries to get a value from a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> for the given <paramref name="name"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to retrieve the value from.</param>
            <param name="name">The name of the value to be retrieved.</param>
            <param name="defaultValue">The default value to return if <paramref name="name"/> was not found. This parameter is optional.
            <br/>Default value: <see langword="null"/> if <typeparamref name="T"/> is a reference type; otherwise, the bitwise zero value of <typeparamref name="T"/>.</param>
            <typeparam name="T">The type of the value with the corresponding <paramref name="name"/> to get.</typeparam>
            <returns>The found value or <paramref name="defaultValue"/> if <paramref name="name"/> was not found or its value cannot be cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.ContainsName(System.Runtime.Serialization.SerializationInfo,System.String)">
            <summary>
            Gets whether an entry with the specified <paramref name="name"/> exists in the specified <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to check.</param>
            <param name="name">The name of the value to be searched for.</param>
            <returns><see langword="true"/> if the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> contains an entry with the specified <paramref name="name"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.RemoveValue(System.Runtime.Serialization.SerializationInfo,System.String)">
            <summary>
            Removes a value of the specified <paramref name="name"/> from the <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to remove the value from.</param>
            <param name="name">The name of the entry to remove.</param>
            <returns><see langword="true"/> if an entry with the specified name existed in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
            and has been removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.UpdateValue(System.Runtime.Serialization.SerializationInfo,System.String,System.Object,System.Type)">
            <summary>
            Updates or adds a value with the specified <paramref name="name"/> in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to be updated.</param>
            <param name="name">The name of the entry to be updated or added.</param>
            <param name="value">The new value to be set.</param>
            <param name="type">The type of the value to be added. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns><see langword="true"/> if an update occurred (the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> already contained an entry with the specified <paramref name="name"/>);
            <see langword="false"/> if the value has just been added as a new value.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.SerializationInfoExtensions.ReplaceValue(System.Runtime.Serialization.SerializationInfo,System.String,System.String,System.Object,System.Type)">
            <summary>
            Replaces a value with the specified old and new names in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to be updated.</param>
            <param name="oldName">The name of the entry to be removed.</param>
            <param name="newName">The name of the entry to be added.</param>
            <param name="value">The new value to be set.</param>
            <param name="type">The type of the value to be added. This parameter is optional.
            <br/>Default value: <see langword="null"/>.</param>
            <returns><see langword="true"/> if an entry with the specified old name existed in the <see cref="T:System.Runtime.Serialization.SerializationInfo"/>
            and the replace has been performed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.Serialization.Binary.IBinarySerializable">
             <summary>
             Makes possible quick and compact custom serialization of a class by <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/> and <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>.
             </summary>
             <remarks>
             <para>By this interface a class can be serialized into a compact byte array. Unlike in case of system serialization and <see cref="T:System.Runtime.Serialization.ISerializable"/> implementations, saved data
             does not have to contain a name based mapping. Thus the saved content can be more compact but this solution can be discouraged on very large object graphs
             because the whole object has to be written into memory. In case of very large object hierarchies you might consider to implement <see cref="T:System.Runtime.Serialization.ISerializable"/>
             interface instead, which is also supported by <see cref="T:KGySoft.Serialization.Binary.BinarySerializer"/> and <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/>.
             </para>
             <para>If the implementer has a constructor with <c>(<see cref="T:KGySoft.Serialization.Binary.BinarySerializationOptions"/>, <see cref="T:System.Array">byte[]</see>)</c> parameters, then it will be called
             for deserialization. This makes possible to initialize read-only fields. If no such constructor exists, then the <see cref="M:KGySoft.Serialization.Binary.IBinarySerializable.Deserialize(KGySoft.Serialization.Binary.BinarySerializationOptions,System.Byte[])">Deserialize</see> method will be called. If the implementer has a parameterless constructor,
             then it will be called before calling the <see cref="M:KGySoft.Serialization.Binary.IBinarySerializable.Deserialize(KGySoft.Serialization.Binary.BinarySerializationOptions,System.Byte[])">Deserialize</see> method; otherwise, no constructor will be used at all.</para>
             <para>Methods decorated by <see cref="T:System.Runtime.Serialization.OnSerializingAttribute"/>, <see cref="T:System.Runtime.Serialization.OnSerializedAttribute"/>, <see cref="T:System.Runtime.Serialization.OnDeserializingAttribute"/> and <see cref="T:System.Runtime.Serialization.OnDeserializedAttribute"/> as well as calling <see cref="M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)">IDeserializationCallback.OnDeserialization</see> method
             of implementers are fully supported also for <see cref="T:KGySoft.Serialization.Binary.IBinarySerializable"/> implementers. Attributes should be used on methods that have a single <see cref="T:System.Runtime.Serialization.StreamingContext"/> parameter.</para>
             </remarks>
             <example>
             Following example demonstrates the usage of the special constructor version.
             <code lang="C#"><![CDATA[
             using System;
             using System.IO;
             using KGySoft.Serialization.Binary;
            
             // This is a simple sealed class that will never be derived
             public sealed class ExampleSimple : IBinarySerializable
             {
                 public int IntProp { get; }
                 public string StringProp { get; }
            
                 // this is the ordinary constructor
                 public ExampleSimple(int intValue, string stringValue)
                 {
                     IntProp = intValue;
                     StringProp = stringValue;
                 }
            
                 // this is the special constructor used by the deserializer
                 // if you have read-only fields you must implement this constructor
                 private ExampleSimple(BinarySerializationOptions options, byte[] serData)
                 {
                     using (BinaryReader reader = new BinaryReader(new MemoryStream(serData)))
                     {
                         IntProp = reader.ReadInt32();
                         bool isStringPropNull = reader.ReadBoolean();
                         StringProp = isStringPropNull ? null : reader.ReadString();
                     }
                 }
            
                 public byte[] Serialize(BinarySerializationOptions options)
                 {
                     MemoryStream ms = new MemoryStream();
                     using (BinaryWriter writer = new BinaryWriter(ms))
                     {
                         writer.Write(IntProp);
                         writer.Write(StringProp == null);
                         if (StringProp != null)
                             writer.Write(StringProp);
                     }
                     return ms.ToArray();
                 }
            
                 public void Deserialize(BinarySerializationOptions options, byte[] serData)
                 {
                     throw new InvalidOperationException("Will not be called because special constructor is implemented");
                 }
             }]]>
             </code>
             The following example introduces a pattern that can be used for serialization and deserialization serializable base and derived classes
             and with versioned content (optional fields):
             <code lang="C#"><![CDATA[
             using System.IO;
             using KGySoft.Serialization.Binary;
            
             public class SerializableBase : IBinarySerializable
             {
                 public int IntProp { get; set; }
                 public string StringProp { get; set; }
            
                 private static int currentVersionBase = 1;
            
                 // this is the ordinary constructor
                 public SerializableBase(int intValue, string stringValue)
                 {
                     IntProp = intValue;
                     StringProp = stringValue;
                 }
            
                 // parameterless constructor: will be called on deserialization
                 // if exists and there is no special constructor
                 protected SerializableBase()
                 {
                 }
            
                 byte[] IBinarySerializable.Serialize(BinarySerializationOptions options)
                 {
                     MemoryStream ms = new MemoryStream();
                     using (BinaryWriter writer = new BinaryWriter(ms))
                     {
                         SerializeContent(writer);
                     }
                     return ms.ToArray();
                 }
            
                 void IBinarySerializable.Deserialize(BinarySerializationOptions options, byte[] serData)
                 {
                     using (BinaryReader reader = new BinaryReader(new MemoryStream(serData)))
                     {
                         DeserializeContent(reader);
                     }
                 }
            
                 protected virtual void SerializeContent(BinaryWriter writer)
                 {
                     writer.Write(currentVersionBase);
                     writer.Write(IntProp);
                     writer.Write(StringProp == null);
                     if (StringProp != null)
                         writer.Write(StringProp);
                 }
            
                 protected virtual void DeserializeContent(BinaryReader reader)
                 {
                     int version = reader.ReadInt32();
                     IntProp = reader.ReadInt32();
                     bool isStringPropNull = reader.ReadBoolean();
                     StringProp = isStringPropNull ? null : reader.ReadString();
                     // TODO: Read rest if version changes
                 }
             }
            
             public class SerializableDerived: SerializableBase
             {
                 public bool BoolProp { get; set; }
            
                 // This property is new in this class (optional content)
                 public int NewIntProp { get; set; }
            
                 private static int currentVersionDerived = 2;
            
                 // this is the ordinary constructor
                 public SerializableDerived(int intValue, string stringValue, bool boolValue)
                     : base(intValue, stringValue)
                 {
                     BoolProp = boolValue;
                 }
            
                 // parameterless constructor: will be called on deserialization
                 // if exists and there is no special constructor
                 protected SerializableDerived()
                     : base()
                 {
                 }
            
                 protected override void SerializeContent(BinaryWriter writer)
                 {
                     base.SerializeContent(writer);
                     writer.Write(currentVersionDerived);
                     writer.Write(BoolProp);
                     writer.Write(NewIntProp);
                 }
            
                 protected override void DeserializeContent(BinaryReader reader)
                 {
                     base.DeserializeContent(reader);
                     int version = reader.ReadInt32();
                     BoolProp = reader.ReadBoolean();
                     if (version < 2)
                         return;
                     NewIntProp = reader.ReadInt32();
                 }
             }]]>
             </code>
             <note type="implement">
             Of course the special constructor way can be used here, too.
             Derived constructors should just call the base constructor, which should call <c>DeserializeContent</c>.
             In that case <strong>FxCop</strong> and <strong>ReSharper</strong> may emit a warning that
             virtual method is called from a constructor but that is alright here because this is a clean initialization pattern.</note>
             </example>
        </member>
        <member name="M:KGySoft.Serialization.Binary.IBinarySerializable.Serialize(KGySoft.Serialization.Binary.BinarySerializationOptions)">
            <summary>
            Serializes the object into a byte array.
            </summary>
            <param name="options">Options used for the serialization.</param>
            <returns>The byte data representation of the object that can be used to restore the original object state by the <see cref="M:KGySoft.Serialization.Binary.IBinarySerializable.Deserialize(KGySoft.Serialization.Binary.BinarySerializationOptions,System.Byte[])">Deserialize</see> method.</returns>
        </member>
        <member name="M:KGySoft.Serialization.Binary.IBinarySerializable.Deserialize(KGySoft.Serialization.Binary.BinarySerializationOptions,System.Byte[])">
            <summary>
            Deserializes the inner state of the object from a byte array. Called only when the implementer does not have a constructor with <c>(<see cref="T:KGySoft.Serialization.Binary.BinarySerializationOptions"/>, <see cref="T:System.Array">byte[]</see>)</c> parameters.
            Without such constructor parameterless constructor will be called if any (otherwise, no constructors will be executed). The special constructor should be used if the class has read-only fields to be restored.
            </summary>
            <param name="serData">Serialized raw data of the object created by the <see cref="M:KGySoft.Serialization.Binary.IBinarySerializable.Serialize(KGySoft.Serialization.Binary.BinarySerializationOptions)">Serialize</see> method.</param>
            <param name="options">Options used for the deserialization.</param>
        </member>
        <member name="T:KGySoft.Serialization.Binary.ISerializationBinder">
            <summary>
            Represents a binder that can convert <see cref="T:System.Type"/> to and from <see cref="T:System.String">string</see> for serialization.
            </summary>
            <remarks>
            <para>Provides the same functionality as the <see cref="T:System.Runtime.Serialization.SerializationBinder"/> class but makes the
            <see cref="M:KGySoft.Serialization.Binary.ISerializationBinder.BindToName(System.Type,System.String@,System.String@)">BindToName</see> method available also in .NET Framework 3.5.</para>
            <para>If a binder class is used in <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> and the class is derived from <see cref="T:System.Runtime.Serialization.SerializationBinder"/> and implements
            this interface, then the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class is able to bind a <see cref="T:System.Type"/> in both directions even in .NET 3.5</para>
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Binary.ISerializationBinder.BindToName(System.Type,System.String@,System.String@)">
            <summary>
            Binds a <see cref="T:System.Type"/> to an <paramref name="assemblyName"/> and <paramref name="typeName"/>.
            </summary>
            <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
            <param name="assemblyName">The <see cref="T:System.String">string</see>, which will represent the <see cref="T:System.Reflection.Assembly"/> name in the serialized data.
            Can return <see langword="null"/> to provide a default name.</param>
            <param name="typeName">The <see cref="T:System.String">string</see>, which will represent the <see cref="T:System.Type"/> name in the serialized data.
            Can return <see langword="null"/> to provide a default name.</param>
        </member>
        <member name="M:KGySoft.Serialization.Binary.ISerializationBinder.BindToType(System.String,System.String)">
            <summary>
            Gets a <see cref="T:System.Type"/> associated by the provided <paramref name="assemblyName"/> and <paramref name="typeName"/>.
            </summary>
            <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object.</param>
            <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object.</param>
            <returns>The <see cref="T:System.Type"/> to be created by the formatter or <see langword="null"/> to use the default binding logic.</returns>
        </member>
        <member name="M:KGySoft.Serialization.SerializationHelper.CopyFields(System.Object,System.Object)">
            <summary>
            Restores target from source. Can be used for read-only properties when source object is already fully serialized.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Xml.XElementDeserializer">
            <summary>
            XElement version of XML deserialization.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementDeserializer.Deserialize(System.Xml.Linq.XElement)">
            <summary>
            Deserializes an XML content to an object.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementDeserializer.DeserializeContent(System.Xml.Linq.XElement,System.Object)">
            <summary>
            Deserializes inner content of an object or collection.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementDeserializer.DeserializeContentByInitializerCollection(System.Xml.Linq.XElement,System.Reflection.ConstructorInfo,System.Type,System.Boolean)">
            <summary>
            Deserializes a non-populatable collection by an initializer collection.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementDeserializer.DeserializeMembersAndElements(System.Xml.Linq.XElement,System.Object,System.Type,System.Type,System.Collections.Generic.Dictionary{System.Reflection.MemberInfo,System.Object})">
            <summary>
            Deserializes the members and elements of <paramref name="objRealType"/>.
            Type of <paramref name="obj"/> can be different of <paramref name="objRealType"/> if a proxy collection object is populated for initialization.
            In this case members have to be stored for later initialization into <paramref name="members"/> and <paramref name="obj"/> is a populatable collection for sure.
            <paramref name="collectionElementType"/> is <see langword="null"/> only if <paramref name="objRealType"/> is not a supported collection.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementDeserializer.TryDeserializeObject(System.Type,System.Xml.Linq.XElement,System.Object,System.Object@)">
            <summary>
            Deserialize object - XElement version.
            If <paramref name="existingInstance"/> is not <see langword="null"/>, then it is preferred to deserialize its content instead of returning a new instance in <paramref name="result"/>.
            <paramref name="existingInstance"/> is considered for IXmlSerializable, arrays, collections and recursive objects.
            If <paramref name="result"/> is a different instance to <paramref name="existingInstance"/>, then content if existing instance cannot be deserialized.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementDeserializer.DeserializeArray(System.Array,System.Type,System.Xml.Linq.XElement,System.Boolean)">
            <summary>
            Array deserialization, XElement version
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementSerializer.Serialize(System.Object)">
            <summary>
            Serializes the object passed in <paramref name="obj"/> parameter into a new <see cref="T:System.Xml.Linq.XElement"/> object.
            </summary>
            <param name="obj">The object to serialize.</param>
            <returns>An <see cref="T:System.Xml.Linq.XElement"/> instance that contains the serialized object.
            Result can be deserialized by <see cref="M:KGySoft.Serialization.Xml.XElementDeserializer.Deserialize(System.Xml.Linq.XElement)"/> method.</returns>
            <exception cref="T:System.NotSupportedException">Root object is a read-only collection.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.<br/>-or-<br/>
            Serialization is not supported with provided options.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementSerializer.SerializeContent(System.Xml.Linq.XElement,System.Object)">
            <summary>
            Saves public properties or collection elements of an object given in <paramref name="obj"/> parameter
            into an already existing <see cref="T:System.Xml.Linq.XElement"/> object given in <paramref name="parent"/> parameter.
            </summary>
            <param name="obj">The object, which inner content should be serialized. Parameter value must not be <see langword="null"/>.</param>
            <param name="parent">The parent under that the object will be saved. Its content can be deserialized by <see cref="M:KGySoft.Serialization.Xml.XElementDeserializer.DeserializeContent(System.Xml.Linq.XElement,System.Object)"/> method.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="parent"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Serialization is not supported with provided <see cref="P:KGySoft.Serialization.Xml.XmlSerializerBase.Options"/></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
            <remarks>
            If the provided object in <paramref name="obj"/> parameter is a collection, then elements will be serialized, too.
            If you want to serialize a primitive type, then use the <see cref="M:KGySoft.Serialization.Xml.XElementSerializer.Serialize(System.Object)"/> method.
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementSerializer.SerializeCollection(System.Collections.IEnumerable,System.Type,System.Boolean,System.Xml.Linq.XContainer,System.ComponentModel.DesignerSerializationVisibility)">
            <summary>
            Serializing a collection by LinqToXml
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementSerializer.SerializeObject(System.Object,System.Boolean,System.Xml.Linq.XElement,System.ComponentModel.DesignerSerializationVisibility)">
            <summary>
            Serializes a whole object. May throw exceptions on invalid or inappropriate options.
            XElement version.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XElementSerializer.SerializeBinary(System.Object,System.Xml.Linq.XContainer)">
            <summary>
            Serializing binary content by LinqToXml
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlDeserializerBase.CopyContent(System.Object,System.Object)">
            <summary>
            Restores target from source. Can be used for read-only properties when source object is already fully serialized.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Xml.XmlReaderDeserializer">
            <summary>
            XmlReader version of XML deserialization.
            Actually a static class with base types - hence marked as abstract. Unlike on serialization no fields are used so no instance is needed.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.ReadStringValue(System.Xml.XmlReader)">
            <summary>
            Reads a string from XmlReader.
            At start, reader is in container element, at the end in the end element.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.Deserialize(System.Xml.XmlReader)">
            <summary>
            Deserializes an object using the provided <see cref="T:System.Xml.XmlReader"/> in <paramref name="reader"/> parameter.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.DeserializeContent(System.Xml.XmlReader,System.Object)">
            <summary>
            Deserializes an object or collection of objects.
            Position is before content (on parent start element). On exit position is in parent close element.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.DeserializeContentByInitializerCollection(System.Xml.XmlReader,System.Reflection.ConstructorInfo,System.Type,System.Boolean)">
            <summary>
            Deserializes a non-populatable collection by an initializer collection.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.DeserializeMembersAndElements(System.Xml.XmlReader,System.Object,System.Type,System.Type,System.Collections.Generic.Dictionary{System.Reflection.MemberInfo,System.Object})">
            <summary>
            Deserializes the members and elements of <paramref name="objRealType"/>.
            Type of <paramref name="obj"/> can be different of <paramref name="objRealType"/> if a proxy collection object is populated for initialization.
            In this case members have to be stored for later initialization into <paramref name="members"/> and <paramref name="obj"/> is a populatable collection for sure.
            <paramref name="collectionElementType"/> is <see langword="null"/> only if <paramref name="objRealType"/> is not a supported collection.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.TryDeserializeObject(System.Type,System.Xml.XmlReader,System.Object,System.Object@)">
            <summary>
            Deserialize object - XmlReader version.
            Reader is at open element at start and is at end element at the end.
            If <paramref name="existingInstance"/> is not <see langword="null"/>, then it is preferred to deserialize its content instead of returning a new instance in <paramref name="result"/>.
            <paramref name="existingInstance"/> is considered for IXmlSerializable, arrays, collections and recursive objects.
            If <paramref name="result"/> is a different instance to <paramref name="existingInstance"/>, then content if existing instance cannot be deserialized.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlReaderDeserializer.DeserializeArray(System.Array,System.Type,System.Xml.XmlReader,System.Boolean)">
            <summary>
            Array deserialization
            XmlReader version. Position is before content (on parent start element). On exit position is on parent close element.
            Parent is not empty here.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Xml.XmlSerializer">
            <summary>
            <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> makes possible serializing and deserializing object instances into/from XML content. The class contains various overloads to support serializing directly into file or by
            <see cref="T:System.Xml.Linq.XElement"/>, <see cref="T:System.Xml.XmlWriter"/>, any <see cref="T:System.IO.TextWriter"/> and any <see cref="T:System.IO.Stream"/> implementations.
            </summary>
            <remarks>
            <note type="security"><para>The <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> supports polymorphism and stores type information whenever the type of a member or collection element differs from the
            type of the stored instance. If the XML content to deserialize is from an untrusted source make sure to use the <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe">DeserializeSafe</see>
            and <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContentSafe">DeserializeContentSafe</see> methods to prevent loading assemblies during the deserialization.
            Please note though that it cannot protect you from all possible threats if a type of the already loaded assemblies can be exploited for a security attack.
            The <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> can only create objects by using their default constructor and is able to set the public fields and properties.
            It can also create collections by special initializer constructors and can populate them by the standard interface implementations.</para>
            <para>In safe mode you must preload every assembly that are referred in the XML content. Additionally, in safe mode an <see cref="T:System.InvalidOperationException"/> is thrown for content
            that is serialized by <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> (see the <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/> option).</para></note>
            <para><see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> supports serialization of any simple types and complex objects with their public properties and fields as well as several collection types.
            <note>Unlike the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer" target="_blank">System.Xml.Serialization.XmlSerializer</a> class,
            this <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> is not designed for customizing output format (though <see cref="T:System.Xml.Serialization.IXmlSerializable"/> implementations are considered). Not even <c>Xml...Attribute</c>s
            are supported (except <see cref="T:System.Xml.Serialization.XmlRootAttribute"/> for the root element of <see cref="T:System.Xml.Serialization.IXmlSerializable"/> implementations). Instead, this class is
            designed to support XML serialization of any type as long as they have a default constructor and their state can be fully restored by their public fields and properties.</note>
            </para>
            <para>Several <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel" target="_blank">System.ComponentModel</a> techniques are supported,
            which also makes possible to use the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> for types that can be edited in a property grid, such as components, configurations or any types in a custom designer.
            The supported component model attributes and techniques:
            <list type="bullet">
            <item><term><see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute"/></term><description>Use value <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Hidden"/> for public field or property to prevent its serialization
            and use <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Content"/> value to explicitly express that the property value can be serialized recursively (see also <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/>) option.</description></item>
            <item><term><see cref="T:System.ComponentModel.DefaultValueAttribute"/></term><description>If the value of a public property or field equals to the value specified by this attribute, then its value will not be serialized
            (see also <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.IgnoreDefaultValueAttribute"/> and <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.AutoGenerateDefaultValuesAsFallback"/> options).</description></item>
            <item><term><c>ShouldSerialize...</c> methods</term><description>If the type being serialized has an instance method with no parameters and a <see cref="T:System.Boolean"/> return type (can be private as well) named <c>ShouldSerializeMemberName</c> where <c>MemberName</c> is the name of a property or field,
            then its return value determines whether the member should be serialized. This technique is used in some designers and property grid controls (see also <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.IgnoreShouldSerialize"/> option).</description></item>
            <item><term><see cref="T:System.ComponentModel.TypeConverterAttribute"/></term><description>This attribute is supported both for types and property/field members. If a <see cref="T:System.ComponentModel.TypeConverter"/> supports serialization to and from <see cref="T:System.String"/> type,
            then it will be used for serializing its value (see also the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterTypeConverter``1(System.Type)">RegisterTypeConverter</see> extension method).</description></item>
            </list>
            </para>
            <para>Basically types with default constructors are supported. However, if a field or property value is not <see langword="null"/> after creating its parent object and the type has no parameterless constructor, then the returned instance is tried to be re-used on deserialization.
            <note>Objects without a default constructor can be serialized at root level also by the <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent">SerializeContent</see> methods into an already existing
            <see cref="T:System.Xml.Linq.XElement"/> node or by an <see cref="T:System.Xml.XmlWriter"/>, which already opened and XML element before calling the <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent">SerializeContent</see> method. When deserializing,
            the result object should be created by the caller, and the content can be deserialized by the <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContent">DeserializeContent</see> methods.</note>
            </para>
            <para><strong>Options:</strong>
            <br/>By specifying the <see cref="T:KGySoft.Serialization.Xml.XmlSerializationOptions"/> argument in the <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.Serialize">Serialize</see> and <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent">SerializeContent</see>
            methods you can override the default behavior of serialization. The default options and the <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.None"/> option ensure that only those types are serialized, which are guaranteed to be able to deserialized perfectly.
            For details see the description of the <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.None"/> option.</para>
            <para>If a type cannot be serialized with the currently used options a <see cref="T:System.Runtime.Serialization.SerializationException"/> will be thrown.</para>
            <para>You can use <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/> option to enable recursive serialization of every type of objects and collections. A collection type can be serialized if
            it implements the <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:System.Collections.IList"/> or <see cref="T:System.Collections.IDictionary"/> interfaces, and it can be deserialized if it has a default constructor, or an initializer constructor with a single parameter that can accept an <see cref="T:System.Array"/>
            or <see cref="T:System.Collections.Generic.List`1"/> instance (non-dictionaries) or a <see cref="T:System.Collections.Generic.Dictionary`2"/> instance (dictionary collections). Non-collection types must have a parameterless constructor to be able to be deserialized.
            <note type="caution">Enabling the <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/> option does not guarantee that the deserialized instances will be the same as the original ones.</note>
            </para>
            <para>If <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/> option is enabled, then types without a native support and appropriate <see cref="T:System.ComponentModel.TypeConverter"/> will be serialized into a binary stream, which
            will be stored in the result XML. Though this provides the best compatibility of any type, it hides the whole inner structure of the serialized object. If a root level object without native support is serialized by the
            <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.Serialize">Serialize</see> using the <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/>, then the whole XML result will be a single node with the binary content.
            <note>To use binary serialization only for some types or properties you can specify the <see cref="T:KGySoft.ComponentModel.BinaryTypeConverter"/> by the <see cref="T:System.ComponentModel.TypeConverterAttribute"/> for a property or type
            (or you can use the <see cref="M:KGySoft.CoreLibraries.TypeExtensions.RegisterTypeConverter``1(System.Type)">RegisterTypeConverter</see> extension method for types).</note>
            </para>
            <para>See the <see cref="T:KGySoft.Serialization.Xml.XmlSerializationOptions"/> enumeration for further options.</para>
            <para><strong>New features and improvements</strong> compared to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer" target="_blank">System.Xml.Serialization.XmlSerializer</a>:
            <list type="bullet">
            <item><term>Strings</term><description>If a string contains only white spaces, then system <see cref="T:System.Xml.Serialization.XmlSerializer"/> cannot deserialize it properly. <see cref="T:System.String"/> instances containing
            invalid UTF-16 code points are also cannot be serialized. This <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> implementation handles them correctly.</description></item>
            <item><term>Collections with base element type</term><description>If the element type of a collection is a base type or an interface, then the system serializer throws an exception for derived element types
            suggesting that <see cref="T:System.Xml.Serialization.XmlIncludeAttribute"/> should be defined for all possible derived types. Unfortunately this attribute is applicable only for possible types of properties/fields
            but not for collection elements. And in many cases it simply cannot be predefined in advance what derived types will be used at run-time.</description></item>
            <item><term>Collections with read-only properties</term><description>Usually collection properties can be read-only. But to be able to use the system serializer we need to define a setter for such properties; otherwise, serialization may fail.
            This <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> does not require setter accessor for a collection property if the property is not <see langword="null"/> after initialization and can be populated by using the usual collection interfaces.</description></item>
            <item><term>Objects without default constructors</term><description>The system serializer requires that the deserialized types have default constructors. On deserializing fields and properties, this <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> implementation tries to use
            the return value of the members. If they are not <see langword="null"/> after creating their container object, then the returned instances will be used instead of creating a new instance.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <note type="tip">Try also <a href="https://dotnetfiddle.net/M2dfrx" target="_blank">online</a>.</note>
            <code lang="C#"><![CDATA[
            using System;
            using System.IO;
            using System.Text;
            using System.ComponentModel;
            using System.Collections.Generic;
            using System.Collections.ObjectModel;
            using System.Xml.Linq;
            using KGySoft.CoreLibraries;
            using KGySoft.Serialization.Xml;
            
            // A good candidate for XML serialization:
            public class Person
            {
                public string FirstName { get; set; }
            
                [DefaultValue(null)] // will not be serialized if null
                public string MiddleName { get; set; }
            
                public string LastName { get; set; }
            
                public DateTime BirthDate { get; set; }
            
                // System serializer fails here: the property has no setter and its type cannot be instantiated.
                public IList<string> PhoneNumbers { get; } = new Collection<string>();
            }
            
            public class Program
            {
                public static void Main()
                {
                    var person = ThreadSafeRandom.Instance.NextObject<Person>();
                    var options = XmlSerializationOptions.RecursiveSerializationAsFallback;
            
                    // serializing into XElement
                    XElement element = XmlSerializer.Serialize(person, options);
                    var clone = (Person)XmlSerializer.Deserialize(element);
            
                    // serializing into file/Stream/TextWriter/XmlWriter are also supported: An XmlWriter will be used
                    var sb = new StringBuilder();
                    XmlSerializer.Serialize(new StringWriter(sb), person, options);
                    clone = (Person)XmlSerializer.Deserialize(new StringReader(sb.ToString()));
            
                    Console.WriteLine(sb);
                }
            }
            
            // This code example produces a similar output to this one:
            // <?xml version="1.0" encoding="utf-16"?>
            // <object type="Person">
            //   <FirstName>Uehaccuj</FirstName>
            //   <MiddleName>Rnig</MiddleName>
            //   <LastName>Iuvmozu</LastName>
            //   <BirthDate>1996-06-02T00:00:00Z</BirthDate>
            //   <PhoneNumbers type="System.Collections.ObjectModel.Collection`1[System.String]">
            //     <item>694677853</item>
            //     <item>6344</item>
            //   </PhoneNumbers>
            // </object>]]></code>
            </example>
            <seealso cref="T:KGySoft.Serialization.Xml.XmlSerializationOptions"/>
            <seealso cref="T:KGySoft.Serialization.Binary.BinarySerializer"/>
            <seealso cref="T:KGySoft.ComponentModel.BinaryTypeConverter"/>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Serializes the object passed in <paramref name="obj"/> parameter into a new <see cref="T:System.Xml.Linq.XElement"/> object.
            </summary>
            <param name="obj">The object to serialize.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <returns>An <see cref="T:System.Xml.Linq.XElement"/> instance that contains the serialized object.
            Result can be deserialized by <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.Deserialize(System.Xml.Linq.XElement)"/> method.</returns>
            <exception cref="T:System.NotSupportedException">Root object is a read-only collection.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.<br/>-or-<br/>
            Serialization is not supported with provided <paramref name="options"/></exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Serializes the object passed in <paramref name="obj"/> by the provided <see cref="T:System.Xml.XmlWriter"/> object.
            </summary>
            <param name="writer">A preconfigured <see cref="T:System.Xml.XmlWriter"/> object that will be used for serialization. The writer must be in proper state to serialize <paramref name="obj"/> properly
            and will just be flushed but not closed after serialization.</param>
            <param name="obj">The <see cref="T:System.Object"/> to serialize.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="writer"/> must not be null.</exception>
            <exception cref="T:System.InvalidOperationException">The state of <paramref name="writer"/> is wrong or writer is closed.</exception>
            <exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding.
            For example, if the output encoding is ASCII but public properties of a class contain non-ASCII characters, an <see cref="T:System.Text.EncoderFallbackException"/> is thrown.
            Such characters are escaped by character entity references in values when possible.</exception>
            <exception cref="T:System.NotSupportedException">Root object is a read-only collection.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.<br/>-or-<br/>
            Serialization is not supported with provided <paramref name="options"/></exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.String,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Serializes the object passed in <paramref name="obj"/> into the specified <paramref name="fileName"/>.
            </summary>
            <param name="fileName">Name of the file to create for serialization.</param>
            <param name="obj">The <see cref="T:System.Object"/> to serialize.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName"/> must not be null.</exception>
            <exception cref="T:System.IO.IOException">File cannot be created or write error.</exception>
            <exception cref="T:System.NotSupportedException">Serialization is not supported with provided <paramref name="options"/></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.IO.TextWriter,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Serializes the object passed in <paramref name="obj"/> by the provided <see cref="T:System.IO.TextWriter"/> object.
            </summary>
            <param name="writer">A <see cref="T:System.IO.TextWriter"/> implementation (for example, a <see cref="T:System.IO.StringWriter"/>) that will be used for serialization.
            The writer will not be closed after serialization.</param>
            <param name="obj">The <see cref="T:System.Object"/> to serialize.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="writer"/> must not be null.</exception>
            <exception cref="T:System.InvalidOperationException">The writer is closed.</exception>
            <exception cref="T:System.NotSupportedException">Serialization is not supported with provided <paramref name="options"/></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.IO.Stream,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Serializes the object passed in <paramref name="obj"/> into the provided <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> used to write the XML document. The stream will not be closed after serialization.</param>
            <param name="obj">The <see cref="T:System.Object"/> to serialize.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> must not be null.</exception>
            <exception cref="T:System.NotSupportedException"><para>Serialization is not supported with provided <paramref name="options"/></para>
            <para>- or -</para>
            <para>The stream does not support writing.</para></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
            <exception cref="T:System.ObjectDisposedException">The stream is already closed.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent(System.Xml.Linq.XElement,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Saves public properties or collection elements of an object given in <paramref name="obj"/> parameter
            into an already existing <see cref="T:System.Xml.Linq.XElement"/> object given in <paramref name="parent"/> parameter
            with provided <paramref name="options"/>.
            </summary>
            <param name="obj">The object, which inner content should be serialized. Parameter value must not be <see langword="null"/>.</param>
            <param name="parent">The parent under that the object will be saved. Its content can be deserialized by <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContent(System.Xml.Linq.XElement,System.Object)"/> method.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="parent"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Serialization is not supported with provided <paramref name="options"/></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
            <remarks>
            If the provided object in <paramref name="obj"/> parameter is a collection, then elements will be serialized, too.
            If you want to serialize a primitive type, then use the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method.
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent(System.Xml.XmlWriter,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)">
            <summary>
            Saves public properties or collection elements of an object given in <paramref name="obj"/> parameter
            by an already opened <see cref="T:System.Xml.XmlWriter"/> object given in <paramref name="writer"/> parameter
            with provided <paramref name="options"/>.
            </summary>
            <param name="obj">The object, which inner content should be serialized. Parameter value must not be <see langword="null"/>.</param>
            <param name="writer">A preconfigured <see cref="T:System.Xml.XmlWriter"/> object that will be used for serialization. The writer must be in proper state to serialize <paramref name="obj"/> properly
            and will not be closed or flushed after serialization.</param>
            <param name="options">Options for serialization. This parameter is optional.
            <br/>Default value: <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="writer"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Serialization is not supported with provided <paramref name="options"/></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
            <remarks>
            If the provided object in <paramref name="obj"/> parameter is a collection, then elements will be serialized, too.
            If you want to serialize a primitive type, then use the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method.
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Deserialize(System.Xml.Linq.XElement)">
            <summary>
            Deserializes an XML content to an object.
            Works for the results of the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method.
            </summary>
            <param name="content">XML content of the object.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="content"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe(System.Xml.Linq.XElement)">
            <summary>
            Deserializes an XML content to an object in safe mode.
            Works for the results of the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.Serialize(System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class for details about safe mode.
            </summary>
            <param name="content">XML content of the object.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="content"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="content"/> cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Deserialize(System.Xml.XmlReader)">
            <summary>
            Deserializes an object using the provided <see cref="T:System.Xml.XmlReader"/> in <paramref name="reader"/> parameter.
            </summary>
            <param name="reader">An <see cref="T:System.Xml.XmlReader"/> object to be used for deserialization.</param>
            <returns>The deserialized object.</returns>
            <remarks>
            <note>
            The <paramref name="reader"/> position must be <em>before</em> the content to deserialize.
            </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe(System.Xml.XmlReader)">
            <summary>
            Deserializes an object using the provided <see cref="T:System.Xml.XmlReader"/> in <paramref name="reader"/> parameter.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class for details about safe mode.
            </summary>
            <param name="reader">An <see cref="T:System.Xml.XmlReader"/> object to be used for deserialization.</param>
            <returns>The deserialized object.</returns>
            <remarks>
            <note>
            The <paramref name="reader"/> position must be <em>before</em> the content to deserialize.
            </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <exception cref="T:System.InvalidOperationException">XML content cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Deserialize(System.IO.TextReader)">
            <summary>
            Deserializes an object using the provided <see cref="T:System.IO.TextReader"/> in <paramref name="reader"/> parameter.
            </summary>
            <param name="reader">A <see cref="T:System.IO.TextReader"/> object to be used for deserialization. The reader is not closed after deserialization.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe(System.IO.TextReader)">
            <summary>
            Deserializes an object using the provided <see cref="T:System.IO.TextReader"/> in <paramref name="reader"/> parameter.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class for details about safe mode.
            </summary>
            <param name="reader">A <see cref="T:System.IO.TextReader"/> object to be used for deserialization. The reader is not closed after deserialization.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <exception cref="T:System.InvalidOperationException">XML content cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Deserialize(System.String)">
            <summary>
            Deserializes an object from the specified file passed in <paramref name="fileName"/> parameter.
            </summary>
            <param name="fileName">Name of the file that contains the serialized content.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe(System.String)">
            <summary>
            Deserializes an object from the specified file passed in <paramref name="fileName"/> parameter.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class for details about safe mode.
            </summary>
            <param name="fileName">Name of the file that contains the serialized content.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <exception cref="T:System.InvalidOperationException">XML content cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes an object from the provided <see cref="T:System.IO.Stream"/> in <paramref name="stream"/> parameter.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> object to be used for deserialization. The stream is not closed after deserialization.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe(System.IO.Stream)">
            <summary>
            Deserializes an object from the provided <see cref="T:System.IO.Stream"/> in <paramref name="stream"/> parameter.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> object to be used for deserialization. The stream is not closed after deserialization.</param>
            <returns>The deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <exception cref="T:System.InvalidOperationException">XML content cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContent(System.Xml.Linq.XElement,System.Object)">
            <summary>
            Restores inner state of an already created object passed in <paramref name="obj"/> parameter based on a saved XML.
            Works for the results of the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent(System.Xml.Linq.XElement,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method and other <c>SerializeContent</c> overloads.
            </summary>
            <param name="obj">The already constructed object whose inner state has to be deserialized.</param>
            <param name="content">XML content of the object.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="content"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> must not be a value type.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContentSafe(System.Xml.Linq.XElement,System.Object)">
            <summary>
            Restores inner state of an already created object passed in <paramref name="obj"/> parameter based on a saved XML.
            Works for the results of the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent(System.Xml.Linq.XElement,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method and other <c>SerializeContent</c> overloads.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class for details about safe mode.
            </summary>
            <param name="obj">The already constructed object whose inner state has to be deserialized.</param>
            <param name="content">XML content of the object.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="content"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> must not be a value type.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="content"/> cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContent(System.Xml.XmlReader,System.Object)">
            <summary>
            Restores inner state of an already created object passed in <paramref name="obj"/> parameter based on a saved XML.
            Works for the results of the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent(System.Xml.XmlWriter,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method and other <c>SerializeContent</c> overloads.
            </summary>
            <param name="obj">The already constructed object whose inner state has to be deserialized.</param>
            <param name="reader">An <see cref="T:System.Xml.XmlReader"/> instance to be used to read the XML content. Reader must be in at correct position for the successful deserialization.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="reader"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> must not be a value type.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContentSafe(System.Xml.XmlReader,System.Object)">
            <summary>
            Restores inner state of an already created object passed in <paramref name="obj"/> parameter based on a saved XML.
            Works for the results of the <see cref="M:KGySoft.Serialization.Xml.XmlSerializer.SerializeContent(System.Xml.XmlWriter,System.Object,KGySoft.Serialization.Xml.XmlSerializationOptions)"/> method and other <c>SerializeContent</c> overloads.
            <br/>See the security notes at the <strong>Remarks</strong> section of the <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class for details about safe mode.
            </summary>
            <param name="obj">The already constructed object whose inner state has to be deserialized.</param>
            <param name="reader">An <see cref="T:System.Xml.XmlReader"/> instance to be used to read the XML content. Reader must be in at correct position for the successful deserialization.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="reader"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> must not be a value type.</exception>
            <exception cref="T:System.NotSupportedException">Deserializing an inner type is not supported.</exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">An inner type cannot be instantiated or serialized XML content is corrupt.</exception>
            <exception cref="T:System.ArgumentException">XML content is inconsistent or corrupt.</exception>
            <exception cref="T:System.InvalidOperationException">XML content cannot be deserialized in safe mode.</exception>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializerBase.EscapeNeeded(System.String,System.Int32,System.Boolean,System.Boolean@)">
            <summary>
            Gets whether a character has to be escaped
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlSerializerBase.RegisterSerializedObject(System.Object)">
            <summary>
            Registers object to detect circular reference.
            Must be called from inside of try-finally to remove lock in finally if necessary.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlWriterSerializer.SerializeXmlSerializable(System.Xml.Serialization.IXmlSerializable,System.Xml.XmlWriter)">
            <summary>
            Writer must be in parent element, which should be closed by the parent.
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlWriterSerializer.SerializeContent(System.Xml.XmlWriter,System.Object)">
            <summary>
            Saves public properties or collection elements of an object given in <paramref name="obj"/> parameter
            by an already opened <see cref="T:System.Xml.XmlWriter"/> object given in <paramref name="writer"/> parameter.
            </summary>
            <param name="obj">The object, which inner content should be serialized. Parameter value must not be <see langword="null"/>.</param>
            <param name="writer">A preconfigured <see cref="T:System.Xml.XmlWriter"/> object that will be used for serialization. The writer must be in proper state to serialize <paramref name="obj"/> properly
            and will not be closed after serialization.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> and <paramref name="writer"/> must not be <see langword="null"/>.</exception>
            <exception cref="T:System.NotSupportedException">Serialization is not supported with provided <see cref="P:KGySoft.Serialization.Xml.XmlSerializerBase.Options"/></exception>
            <exception cref="T:KGySoft.Reflection.ReflectionException">The object hierarchy to serialize contains circular reference.</exception>
            <remarks>
            If the provided object in <paramref name="obj"/> parameter is a collection, then elements will be serialized, too.
            If you want to serialize a primitive type, then use the <see cref="M:KGySoft.Serialization.Xml.XmlWriterSerializer.Serialize(System.Xml.XmlWriter,System.Object)"/> method.
            </remarks>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlWriterSerializer.SerializeCollection(System.Collections.IEnumerable,System.Type,System.Boolean,System.Xml.XmlWriter,System.ComponentModel.DesignerSerializationVisibility)">
            <summary>
            Serializing a collection by XmlWriter
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlWriterSerializer.SerializeObject(System.Object,System.Boolean,System.Xml.XmlWriter,System.ComponentModel.DesignerSerializationVisibility)">
            <summary>
            Serializes a whole object. May throw exceptions on invalid or inappropriate options.
            XmlWriter version. Start element must be opened and closed by caller.
            obj.GetType and type can be different (properties)
            </summary>
        </member>
        <member name="M:KGySoft.Serialization.Xml.XmlWriterSerializer.SerializeBinary(System.Object,System.Xml.XmlWriter)">
            <summary>
            Serializing binary content by XmlWriter
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Xml.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Serialization.Xml"/> namespace contains types for XML serialization.
            </summary>
        </member>
        <member name="T:KGySoft.Serialization.Xml.XmlSerializationOptions">
            <summary>
            Options for serializer methods of <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> class.
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.None">
            <summary>
            <para>Represents no enabled options.</para>
            <para>
            With every options disabled only those types are serialized, which are guaranteed to be able to deserialized perfectly. Such types are:
            <list type="bullet">
            <item><term>Natively supported types</term><description>Primitive types along with their <see cref="T:System.Nullable`1"/> counterpart and the most common framework types such as <see cref="T:System.Enum"/> instances, <see cref="T:System.DateTime"/>, <see cref="T:System.DateTimeOffset"/>,
            <see cref="T:System.TimeSpan"/> and even <see cref="T:System.Type"/> itself as long as it is a runtime type instance.</description></item>
            <item><term><see cref="T:System.Xml.Serialization.IXmlSerializable"/> instances</term><description>Types that implement the <see cref="T:System.Xml.Serialization.IXmlSerializable"/> interface can be serialized.</description></item>
            <item><term>Types with <see cref="T:System.ComponentModel.TypeConverter"/></term><description>If the converter supports serializing to and from <see cref="T:System.String"/> type.</description></item>
            <item><term>Simple objects</term><description>A type can be serialized with the default options if it meets the following criteria:
            <list type="bullet">
            <item>The type has a parameterless constructor, or is a value type</item>
            <item>It has only public instance fields and properties. For properties, both accessors are public. Static members are ignored.
            <note>Compiler-generated backing fields are ignored so types with public auto properties are considered simple.</note></item>
            <item>All fields and properties can be set, or, all read-only fields and properties are either <see cref="T:System.Xml.Serialization.IXmlSerializable"/> implementations or collections of the types enlisted at next main bullet point.</item>
            <item>None of the fields and properties are delegates.</item>
            <item>The type has no instance events.</item>
            </list>
            <note>A type can be serialized if these criteria are true for the serialized properties and fields recursively.</note></description></item>
            <item><term>Collections</term><description><see cref="T:System.Array"/>, <see cref="T:System.Collections.Generic.List`1"/>, <see cref="T:System.Collections.Generic.LinkedList`1"/>, <see cref="T:System.Collections.Generic.Queue`1"/>, <see cref="T:System.Collections.Generic.Stack`1"/>,
            <see cref="T:System.Collections.ArrayList"/>, <see cref="T:System.Collections.Queue"/>,  <see cref="T:System.Collections.Stack"/>, <see cref="T:System.Collections.BitArray"/>, <see cref="T:System.Collections.Specialized.StringCollection"/>,
            <see cref="T:KGySoft.Collections.CircularList`1"/>, <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>, <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> and <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> instances are supported by the default options. To support other collections
            you can use fallback options, for example <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/>.
            <note>The reason of fallback options or attributes have to be used even for simple collections such as <see cref="T:System.Collections.Generic.Dictionary`2"/> is that they can be instantiated by special settings such as an equality comparer,
            which cannot be retrieved by the public members when the collection is being serialized. However, if a property or field returns a non-<see langword="null"/> instance after the container object is created, then the returned instance is tried to be used on deserialization.
            This makes possible to deserialize even custom-initialized dictionaries and other objects.</note>
            </description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.FullyQualifiedNames">
            <summary>
            <para>If enabled, collection elements and non binary-serialized complex objects will be identified by the assembly qualified type name; otherwise, only by full type name.
            Using fully qualified names makes possible to automatically load the assembly of a referenced type (unless safe mode is used on deserialization). Partial identity match is allowed,
            so type resolving tolerates assembly version change. When resolving non-fully qualified type names, its assembly must be loaded before the deserialization;
            otherwise, the type resolving will fail.</para>
            <note type="security">When using <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe">DeserializeSafe</see>
            and <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContentSafe">DeserializeContentSafe</see> methods, no assemblies will be loaded
            during the deserialization, even when types use fully qualified names.</note>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback">
            <summary>
            <para>If a type cannot be parsed natively and has no <see cref="T:System.ComponentModel.TypeConverter"/> with <see cref="T:System.String"/> support, then
            enabling this option makes possible to store its content in binary format (using the <see cref="T:KGySoft.Serialization.Binary.BinarySerializationFormatter"/> class) within the XML.</para>
            <para>Though trusted collections and objects with only public read-write properties and fields can be serialized with the <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.None"/> options
            as well, using this option will cause to serialize them in binary format, too.</para>
            <para>If both <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/> and <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/> options are enabled, then binary serialization
            has higher priority, except for properties that are marked by <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Content"/> visibility, which causes the property to be serialized recursively.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            <note type="security">When using <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeSafe">DeserializeSafe</see>
            and <see cref="O:KGySoft.Serialization.Xml.XmlSerializer.DeserializeContentSafe">DeserializeContentSafe</see> methods, then
            deserialization will throw an <see cref="T:System.InvalidOperationException"/> if the XML stream contains such content.</note>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback">
            <summary>
            <para>If a type cannot be parsed natively, has no <see cref="T:System.ComponentModel.TypeConverter"/> with <see cref="T:System.String"/> support
            or binary serialization is disabled, then enabling this option makes possible to serialize the object by serializing its public properties, fields and collection items recursively.
            If a property or collection element cannot be serialized, then a <see cref="T:System.Runtime.Serialization.SerializationException"/> will be thrown.</para>
            <para>Properties can be marked by <see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute"/> with <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Content"/> value to
            indicate that they should be serialized recursively without using this fallback option.
            <note type="caution">Enabling this option will not guarantee that deserialization of the object will be the same as the original instance.
            Use this option only when serialized types can be restored by setting public properties and fields, and the type has a default constructor.
            To avoid circular references use <see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute"/> with <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Hidden"/> value on back-referencing properties.</note></para>
            <para>If both <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/> and <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/> options are enabled, then binary serialization
            has higher priority, except for properties that are marked by <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Content"/> visibility, which causes the property to be serialized recursively.</para>
            <para><c>Key</c> and <c>Value</c> properties of <see cref="T:System.Collections.DictionaryEntry"/> and <see cref="T:System.Collections.Generic.KeyValuePair`2"/> instances are always serialized recursively because these are natively supported types.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfStructures">
            <summary>
            <para>If a <see cref="T:System.ValueType"/> (<see langword="struct"/>) has no <see cref="T:System.ComponentModel.TypeConverter"/> and contains no references,
            then by enabling this option the instance will be serialized in a compact binary form.
            <note>This option has higher priority than fallback options (<see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/> and <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.RecursiveSerializationAsFallback"/>),
            except for <see cref="T:System.Collections.DictionaryEntry"/> and <see cref="T:System.Collections.Generic.KeyValuePair`2"/> instances, which are always serialized recursively.
            This option affects only instances, which have no reference fields at all.</note></para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.AutoGenerateDefaultValuesAsFallback">
            <summary>
            <para>If enabled, then members without <see cref="T:System.ComponentModel.DefaultValueAttribute"/> defined, will be treated as if they were decorated by
            <see cref="T:System.ComponentModel.DefaultValueAttribute"/> with the default value of the property type (<see langword="null"/> for reference types and
            bitwise zero value of value types). This causes to skip serializing members, whose value equals to the default value of their type.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.IgnoreDefaultValueAttribute">
            <summary>
            <para>Ignores the originally defined <see cref="T:System.ComponentModel.DefaultValueAttribute"/> definitions for all of the properties. This causes that all members will be serialized regardless of their values.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.IgnoreShouldSerialize">
            <summary>
            <para>Ignores the presence of <c>ShouldSerialize&lt;PropertyName&gt;</c> methods for all of the members.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.IgnoreIXmlSerializable">
            <summary>
            <para>If enabled, <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> ignores <see cref="T:System.Xml.Serialization.IXmlSerializable"/> implementations.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays">
            <summary>
            <para>If enabled, then array of primitive types are serialized in a single XML node instead of creating XML nodes for each element in the array.</para>
            <para>Default state at serialization methods: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.EscapeNewlineCharacters">
            <summary>
            <para>Unless a well configured <see cref="T:System.Xml.XmlWriter"/> is used, newline characters of string or char values can be lost or changed during deserialization.
            This flag ensures that newline characters can be always deserialized regardless of the used <see cref="P:System.Xml.XmlWriterSettings.NewLineHandling"/> value of an <see cref="T:System.Xml.XmlWriter"/>.</para>
            <para>Default state at serialization methods: <strong>Enabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.OmitCrcAttribute">
            <summary>
            <para>When this flag is enabled, binary contents will not be protected by a CRC value.
            Affects <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfPrimitiveArrays"/>, <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.CompactSerializationOfStructures"/> and <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.BinarySerializationAsFallback"/> flags.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.ExcludeFields">
            <summary>
            <para>By default <see cref="T:KGySoft.Serialization.Xml.XmlSerializer"/> includes public fields in serialization, similarly to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer" target="_blank">System.Xml.Serialization.XmlSerializer</a>.
            By enabling this option, only public properties will be serialized.</para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.ForcedSerializationOfReadOnlyMembersAndCollections">
            <summary>
            <para>By default read-only properties and fields are serialized only if they are <see cref="T:System.Xml.Serialization.IXmlSerializable"/> implementations or collections that can be populated.
            This option forces to serialize read-only fields and properties, as well as collections that are read-only and have no recognizable initializer constructor.
            <note>Public properties with private setter accessor are serializable even without this option.</note>
            <note>Read-only collections witch recognizable collection initializer constructor are serializable even without this option.</note>
            <note type="caution">Enabling this option can make it possible that properties without setter accessor will not be able to deserialized.
            Deserialization will fail if the read-only property returns a <see langword="null"/> value or its content cannot be restored (eg. it has a simple type or is a read-only collection).
            Use this option only if an object has to be serialized only for information (eg. in logs) and deserialization is not necessary.</note>
            </para>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="F:KGySoft.Serialization.Xml.XmlSerializationOptions.IgnoreTypeForwardedFromAttribute">
            <summary>
            <para>When both <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.FullyQualifiedNames"/> and this flag are enabled, then every type will be serialized with its actual assembly identity rather than considering
            the value of an existing <see cref="T:System.Runtime.CompilerServices.TypeForwardedFromAttribute"/>.</para>
            <para>This flag is ignored if <see cref="F:KGySoft.Serialization.Xml.XmlSerializationOptions.FullyQualifiedNames"/> is disabled.</para>
            <note>Enabling this flag may cause that the type will not be able to be deserialized on a different platform.</note>
            <para>Default state at serialization methods: <strong>Disabled</strong></para>
            </summary>
        </member>
        <member name="T:KGySoft.Threading.AsyncConfig">
            <summary>
            Represents asynchronous configuration for <see cref="T:System.IAsyncResult"/>-returning methods.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncConfig.CompletedCallback">
            <summary>
            Gets or sets a callback that will be invoked when the operation is completed.
            This property is ignored for methods that expect a <see cref="T:KGySoft.Threading.ParallelConfig"/> parameter.
            <br/>Default value: <see langword="null"/>.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.AsyncConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.AsyncConfig"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.AsyncConfig.#ctor(System.AsyncCallback,System.Func{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.AsyncConfig"/> class.
            </summary>
            <param name="completedCallback">A callback that will be invoked when the operation is completed..</param>
            <param name="isCancelRequestedCallback">A callback that can return whether cancellation has been requested.</param>
        </member>
        <member name="M:KGySoft.Threading.AsyncConfig.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.AsyncConfig"/> class initializing the <see cref="P:KGySoft.Threading.ParallelConfig.IsCancelRequestedCallback"/>
            property from a <see cref="T:System.Threading.CancellationToken"/>.
            <br/>This constructor is available only for .NET Framework 4.0 and later.
            </summary>
            <param name="cancellationToken">Specifies the cancellation token for this operation.</param>
        </member>
        <member name="T:KGySoft.Threading.AsyncConfigBase">
            <summary>
            Represents the base class for configuration of possibly asynchronous and multi-threaded operations.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncConfigBase.Progress">
            <summary>
            Gets or sets an <see cref="T:KGySoft.Threading.IAsyncProgress"/> instance that can handle progress notifications.
            <br/>Default value: <see langword="null"/>.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.IAsyncProgress"/> interface for an example implementation.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncConfigBase.MaxDegreeOfParallelism">
            <summary>
            Gets or sets the maximum degree of parallelism. Zero or less means an automatic configuration based on CPU cores.
            Set one to execute the operation on a single core. The asynchronous operation will not be blocking even if 1 is set.
            <br/>Default value: 0.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled">
            <summary>
            Gets or sets whether an <see cref="T:System.OperationCanceledException"/> should be thrown when ending or awaiting a canceled async operation.
            If the value of this property is <see langword="false"/>, then canceled operations with a return value, which is usually the default value of their return type.
            <br/>Default value: <see langword="true"/>.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncConfigBase.State">
            <summary>
            Gets or sets a user-provided object that will be returned by the <see cref="P:System.IAsyncResult.AsyncState"/> property that
            can be used to distinguish this particular asynchronous operation from other ones.
            This object will be returned also in the <see cref="P:KGySoft.Threading.IAsyncContext.State">IAsyncContext.State</see> property created by
            the methods of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class.
            <br/>Default value: <see langword="null"/>.
            </summary>
        </member>
        <member name="T:KGySoft.Threading.AsyncHelper">
            <summary>
            A helper class to implement CPU-bound operations with adjustable parallelization, cancellation and progress reporting,
            allowing a single shared implementation for both sync and async overloads where the latter can be
            either <see cref="T:System.IAsyncResult"/> or <see cref="T:System.Threading.Tasks.Task"/> (.NET Framework 4.0 and later) returning methods.
            </summary>
            <example>
            The following example demonstrates how to use the <see cref="T:KGySoft.Threading.AsyncHelper"/> class to create sync/async versions of a method
            sharing the common implementation in a single method.
            <code lang="C#"><![CDATA[
            #nullable enable
            
            using System;
            using System.Threading;
            using System.Threading.Tasks;
            
            using KGySoft;
            using KGySoft.CoreLibraries;
            using KGySoft.Reflection;
            using KGySoft.Security.Cryptography;
            using KGySoft.Threading;
            
            public static class Example
            {
                // The sync version. This method is blocking, cannot be canceled, does not report progress and auto adjusts parallelization.
                public static double[] GenerateRandomValues(int count, double min, double max)
                {
                    ValidateArguments(count, min, max);
            
                    // Just to demonstrate some immediate return (which is quite trivial in this overload).
                    if (count == 0)
                        return Reflector.EmptyArray<double>(); // same as Array.Empty but available also for older targets
            
                    // The actual processing is called directly from this overload with DefaultContext. The result is never null from here.
                    return DoGenerateRandomValues(AsyncHelper.DefaultContext, count, min, max)!;
                }
            
                // Another sync overload. This is still blocking but allows cancellation, reporting progress and adjusting parallelization.
                // The result can be null if the operation is canceled and config.ThrowIfCanceled was false.
                public static double[]? GenerateRandomValues(int count, double min, double max, ParallelConfig? config)
                {
                    ValidateArguments(count, min, max);
            
                    // For immediate return use AsyncHelper.FromResult, which handles throwing possible OperationCanceledException
                    // or returning null if config.ThrowIfCanceled was false. For void methods use AsyncHelper.HandleCompleted instead.
                    if (count == 0)
                        return AsyncHelper.FromResult(Reflector.EmptyArray<double>(), config);
            
                    // Even though this is a synchronous call, use AsyncHelper to take care of the context and handle cancellation.
                    return AsyncHelper.DoOperationSynchronously(context => DoGenerateRandomValues(context, count, min, max), config);
                }
            
                // The Task-returning version. Requires .NET Framework 4.0 or later and can be awaited in .NET Framework 4.5 or later.
                public static Task<double[]?> GenerateRandomValuesAsync(int count, double min, double max, TaskConfig? asyncConfig = null)
                {
                    ValidateArguments(count, min, max);
            
                    // Use AsyncHelper.FromResult for immediate return. It handles asyncConfig.ThrowIfCanceled properly.
                    // To return a Task without a result use AsyncHelper.FromCompleted instead.
                    if (count == 0)
                        return AsyncHelper.FromResult(Reflector.EmptyArray<double>(), asyncConfig);
            
                    // The actual processing for Task returning async methods.
                    return AsyncHelper.DoOperationAsync(context => DoGenerateRandomValues(context, count, min, max), asyncConfig);
                }
            
                // The old-style Begin/End methods that work even in .NET Framework 3.5. Can be omitted if not needed.
                public static IAsyncResult BeginGenerateRandomValues(int count, double min, double max, AsyncConfig? asyncConfig = null)
                {
                    ValidateArguments(count, min, max);
            
                    // Use AsyncHelper.FromResult for immediate return. It handles asyncConfig.ThrowIfCanceled and
                    // sets IAsyncResult.CompletedSynchronously. Use AsyncHelper.FromCompleted if the End method has no return value.
                    if (count == 0)
                        return AsyncHelper.FromResult(Reflector.EmptyArray<double>(), asyncConfig);
            
                    // The actual processing for IAsyncResult returning async methods.
                    return AsyncHelper.BeginOperation(context => DoGenerateRandomValues(context, count, min, max), asyncConfig);
                }
            
                // Note that the name of "BeginGenerateRandomValues" is explicitly specified here.
                // Older compilers need it also for AsyncContext.BeginOperation.
                public static double[]? EndGenerateRandomValues(IAsyncResult asyncResult)
                    => AsyncHelper.EndOperation<double[]?>(asyncResult, nameof(BeginGenerateRandomValues));
            
                // The method of the actual processing has the same parameters as the sync version after an IAsyncContext parameter.
                // The result can be null if the operation is canceled (but see also the next comment)
                private static double[]? DoGenerateRandomValues(IAsyncContext context, int count, double min, double max)
                {
                    // Not throwing OperationCanceledException explicitly: it will be thrown by the caller
                    // if the asyncConfig.ThrowIfCanceled was true in the async overloads.
                    // Actually we could call context.ThrowIfCancellationRequested() that would be caught conditionally by the caller
                    // but use that only if really needed because using exceptions as control flow is really ineffective.
                    if (context.IsCancellationRequested)
                        return null;
            
                    // New progress without max value: in a UI this can be displayed with some indeterminate progress bar/circle
                    context.Progress?.New("Initializing");
                    Thread.Sleep(100); // imitating some really slow initialization, blocking the current thread
                    var result = new double[count];
                    using var rnd = new SecureRandom(); // just because it's slow
            
                    // We should periodically check after longer steps whether the processing has already been canceled
                    if (context.IsCancellationRequested)
                        return null;
            
                    // Possible shortcut: ParallelHelper has a For overload that can accept an already created context from
                    // implementations like this one. It will call IAsyncProgress.New and IAsyncProgress.Increment implicitly.
                    ParallelHelper.For(context, "Generating values", 0, count,
                        body: i => result[i] = rnd.NextDouble(min, max, FloatScale.ForceLogarithmic)); // some slow number generation
            
                    // Actually the previous ParallelHelper.For call returns false if the operation was canceled
                    if (context.IsCancellationRequested)
                        return null;
            
                    // Alternative version with Parallel.For (only in .NET Framework 4.0 and above)
                    context.Progress?.New("Generating values (alternative way)", maximumValue: count);
                    Parallel.For(0, count,
                        // for auto-adjusting parallelism ParallelOptions strictly requires -1, whereas context allows <= 0
                        new ParallelOptions { MaxDegreeOfParallelism = context.MaxDegreeOfParallelism <= 0 ? -1 : context.MaxDegreeOfParallelism },
                        (i, state) =>
                        {
                            // Breaking the loop on cancellation. Note that we did not set a CancellationToken in ParallelOptions
                            // because if context comes from the .NET Framework 3.5-compatible Begin method it cannot even have any.
                            // But if you really need a CancellationToken you can pass one to asyncConfig.State from the caller.
                            if (context.IsCancellationRequested)
                            {
                                state.Stop();
                                return;
                            }
            
                            result[i] = rnd.NextDouble(min, max, FloatScale.ForceLogarithmic);
                            context.Progress?.Increment();
                        });
            
                    return context.IsCancellationRequested ? null : result;
                }
            
                private static void ValidateArguments(int count, double min, double max)
                {
                    if (count < 0)
                        throw new ArgumentOutOfRangeException(nameof(count), PublicResources.ArgumentMustBeGreaterThanOrEqualTo(0));
                    if (Double.IsNaN(min))
                        throw new ArgumentOutOfRangeException(nameof(min), PublicResources.ArgumentOutOfRange);
                    if (Double.IsNaN(max))
                        throw new ArgumentOutOfRangeException(nameof(max), PublicResources.ArgumentOutOfRange);
                    if (max < min)
                        throw new ArgumentException(PublicResources.MaxValueLessThanMinValue);
                }
            }]]></code>
            </example>
        </member>
        <member name="P:KGySoft.Threading.AsyncHelper.DefaultContext">
            <summary>
            Gets a default context for non-async operations.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.DoOperationSynchronously(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.ParallelConfig)">
            <summary>
            Executes the specified <paramref name="operation"/> synchronously, in which some sub-operations may run in parallel.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <param name="operation">The operation to be executed.</param>
            <param name="configuration">The configuration for the operation.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.DoOperationSynchronously``1(System.Func{KGySoft.Threading.IAsyncContext,``0},KGySoft.Threading.ParallelConfig)">
            <summary>
            Executes the specified <paramref name="operation"/> synchronously, in which some sub-operations may run in parallel.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result of the specified <paramref name="operation"/>.</typeparam>
            <param name="operation">The operation to be executed.</param>
            <param name="configuration">The configuration for the operation.</param>
            <returns>The result of the <paramref name="operation"/> if the operation has not been canceled,
            or the default value of <typeparamref name="TResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.DoOperationSynchronously``1(System.Func{KGySoft.Threading.IAsyncContext,``0},``0,KGySoft.Threading.ParallelConfig)">
            <summary>
            Executes the specified <paramref name="operation"/> synchronously, in which some sub-operations may run in parallel.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result of the specified <paramref name="operation"/>.</typeparam>
            <param name="operation">The operation to be executed.</param>
            <param name="canceledResult">The result to be returned if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> of <paramref name="configuration"/> returns <see langword="false"/>.</param>
            <param name="configuration">The configuration for the operation.</param>
            <returns>The result of the <paramref name="operation"/> if the operation has not been canceled,
            or <paramref name="canceledResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.HandleCompleted(KGySoft.Threading.ParallelConfig)">
            <summary>
            This method can be used to immediately finish a synchronous operation that does not have a return value.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            The example uses the similarly working <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.ParallelConfig)">FromResult</see> method.
            </summary>
            <param name="configuration">The configuration for the operation.</param>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.ParallelConfig)">
            <summary>
            This method can be used to immediately return from a synchronous operation that has a return value.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="result">The result to be returned if the operation was not canceled.</param>
            <param name="configuration">The configuration for the operation.</param>
            <returns><paramref name="result"/> if the operation has not been canceled,
            or the default value of <typeparamref name="TResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,``0,KGySoft.Threading.ParallelConfig)">
            <summary>
            This method can be used to immediately return from a synchronous operation that has a return value.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="result">The result to be returned if the operation has not been canceled.</param>
            <param name="canceledResult">The result to be returned if the operation has been canceled.</param>
            <param name="configuration">The configuration for the operation.</param>
            <returns><paramref name="result"/> if the operation has not been canceled,
            or <paramref name="canceledResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.BeginOperation(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.AsyncConfig,System.String)">
            <summary>
            Exposes the specified <paramref name="operation"/> with no return value as an <see cref="T:System.IAsyncResult"/>-returning async operation.
            The operation can be completed by calling the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <param name="operation">The operation to be executed.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <param name="beginMethodName">The name of the method that represents the <paramref name="operation"/>.
            This must be passed also to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method. This parameter is optional.
            <br/>Default value: The name of the caller method when used with a compiler that recognizes <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>; otherwise, <see langword="null"/>.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> instance representing the asynchronous operation.
            To complete the operation it must be passed to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> or <paramref name="beginMethodName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.BeginOperation``1(System.Func{KGySoft.Threading.IAsyncContext,``0},KGySoft.Threading.AsyncConfig,System.String)">
            <summary>
            Exposes the specified <paramref name="operation"/> with a return value as an <see cref="T:System.IAsyncResult"/>-returning async operation.
            To obtain the result the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method must be called.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result of the specified <paramref name="operation"/>.</typeparam>
            <param name="operation">The operation to be executed.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <param name="beginMethodName">The name of the method that represents the <paramref name="operation"/>.
            This must be passed also to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method. This parameter is optional.
            <br/>Default value: The name of the caller method when used with a compiler that recognizes <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>; otherwise, <see langword="null"/>.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> instance representing the asynchronous operation.
            To complete the operation it must be passed to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> or <paramref name="beginMethodName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.BeginOperation``1(System.Func{KGySoft.Threading.IAsyncContext,``0},``0,KGySoft.Threading.AsyncConfig,System.String)">
            <summary>
            Exposes the specified <paramref name="operation"/> with a return value as an <see cref="T:System.IAsyncResult"/>-returning async operation.
            To obtain the result the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method must be called.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result of the specified <paramref name="operation"/>.</typeparam>
            <param name="operation">The operation to be executed.</param>
            <param name="canceledResult">The result to be returned by <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> if the operation is canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> of <paramref name="asyncConfig"/> returns <see langword="false"/>.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <param name="beginMethodName">The name of the method that represents the <paramref name="operation"/>.
            This must be passed also to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method. This parameter is optional.
            <br/>Default value: The name of the caller method when used with a compiler that recognizes <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>; otherwise, <see langword="null"/>.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> instance representing the asynchronous operation.
            To complete the operation it must be passed to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> or <paramref name="beginMethodName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromCompleted(KGySoft.Threading.AsyncConfig,System.String)">
            <summary>
            Returns an <see cref="T:System.IAsyncResult"/> instance that represents an already completed operation without a result.
            The <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method still must be called with the result of this method.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            The example uses the similarly working <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> method.
            </summary>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <param name="beginMethodName">The name of the method that represents the operation.
            This must be passed also to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method. This parameter is optional.
            <br/>Default value: The name of the caller method when used with a compiler that recognizes <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>; otherwise, <see langword="null"/>.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> instance representing the asynchronous operation.
            To complete the operation it must be passed to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="beginMethodName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.AsyncConfig,System.String)">
            <summary>
            Returns an <see cref="T:System.IAsyncResult"/> instance that represents an already completed operation with a result.
            To obtain the result the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method must be called.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="result">The result to be returned by the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method if the operation has not been canceled.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <param name="beginMethodName">The name of the method that represents the operation.
            This must be passed also to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method. This parameter is optional.
            <br/>Default value: The name of the caller method when used with a compiler that recognizes <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>; otherwise, <see langword="null"/>.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> instance representing the asynchronous operation.
            To complete the operation it must be passed to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="beginMethodName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,``0,KGySoft.Threading.AsyncConfig,System.String)">
            <summary>
            Returns an <see cref="T:System.IAsyncResult"/> instance that represents an already completed operation with a result.
            To obtain the result the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method must be called.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="result">The result to be returned by the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> method if the operation has not been canceled.</param>
            <param name="canceledResult">The result to be returned by <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">EndOperation</see> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> of <paramref name="asyncConfig"/> returns <see langword="false"/>.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <param name="beginMethodName">The name of the method that represents the operation.
            This must be passed also to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method. This parameter is optional.
            <br/>Default value: The name of the caller method when used with a compiler that recognizes <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>; otherwise, <see langword="null"/>.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> instance representing the asynchronous operation.
            To complete the operation it must be passed to the <see cref="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">EndOperation</see> method.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="beginMethodName"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.EndOperation(System.IAsyncResult,System.String)">
            <summary>
            Waits for the completion of an operation started by a corresponding <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>,
            <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> or <see cref="M:KGySoft.Threading.AsyncHelper.FromCompleted(KGySoft.Threading.AsyncConfig,System.String)">FromCompleted</see> call.
            If the operation is still running, then this method blocks the caller and waits for the completion.
            The possibly occurred exceptions are also thrown then this method is called.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <param name="asyncResult">The result of a corresponding <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see> or <see cref="M:KGySoft.Threading.AsyncHelper.FromCompleted(KGySoft.Threading.AsyncConfig,System.String)">FromCompleted</see> call.</param>
            <param name="beginMethodName">The same name that was passed to the <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>,
            <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> or <see cref="M:KGySoft.Threading.AsyncHelper.FromCompleted(KGySoft.Threading.AsyncConfig,System.String)">FromCompleted</see> method.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult"/> was not returned by the corresponding <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>
            or <see cref="M:KGySoft.Threading.AsyncHelper.FromCompleted(KGySoft.Threading.AsyncConfig,System.String)">FromCompleted</see> methods with a matching <paramref name="beginMethodName"/>
            <br/>-or-
            <br/>this method was already called for this <paramref name="asyncResult"/> instance.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in the corresponding <see cref="T:KGySoft.Threading.AsyncConfig"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.EndOperation``1(System.IAsyncResult,System.String)">
            <summary>
            Waits for the completion of an operation started by a corresponding <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation``1(System.Func{KGySoft.Threading.IAsyncContext,``0},``0,KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>
            or <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> call.
            If the operation is still running, then this method blocks the caller and waits for the completion.
            The possibly occurred exceptions are also thrown then this method is called.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="asyncResult">The result of a corresponding <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation``1(System.Func{KGySoft.Threading.IAsyncContext,``0},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>
            or <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> call.</param>
            <param name="beginMethodName">The same name that was passed to the <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation``1(System.Func{KGySoft.Threading.IAsyncContext,``0},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>
            or <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> method.</param>
            <returns>The result of the operation, or a default value representing the canceled result if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in the <c>asyncConfig</c> parameter was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult"/> was not returned by the corresponding <see cref="M:KGySoft.Threading.AsyncHelper.BeginOperation``1(System.Func{KGySoft.Threading.IAsyncContext,``0},KGySoft.Threading.AsyncConfig,System.String)">BeginOperation</see>
            or <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.AsyncConfig,System.String)">FromResult</see> methods with a matching <paramref name="beginMethodName"/>
            <br/>-or-
            <br/>this method was already called for this <paramref name="asyncResult"/> instance.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in the corresponding <see cref="T:KGySoft.Threading.AsyncConfig"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.DoOperationAsync(System.Action{KGySoft.Threading.IAsyncContext},KGySoft.Threading.TaskConfig)">
            <summary>
            Executes the specified <paramref name="operation"/> asynchronously.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <param name="operation">The operation to be executed.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that represents the asynchronous operation, which could still be pending.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.DoOperationAsync``1(System.Func{KGySoft.Threading.IAsyncContext,``0},KGySoft.Threading.TaskConfig)">
            <summary>
            Executes the specified <paramref name="operation"/> asynchronously.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result of the specified <paramref name="operation"/>.</typeparam>
            <param name="operation">The operation to be executed.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> that represents the asynchronous operation. Its result is the result of the <paramref name="operation"/> if it has not been canceled,
            or the default value of <typeparamref name="TResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="asyncConfig"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.DoOperationAsync``1(System.Func{KGySoft.Threading.IAsyncContext,``0},``0,KGySoft.Threading.TaskConfig)">
            <summary>
            Executes the specified <paramref name="operation"/> asynchronously.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result of the specified <paramref name="operation"/>.</typeparam>
            <param name="operation">The operation to be executed.</param>
            <param name="canceledResult">The result to be returned by the returned task if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> of <paramref name="asyncConfig"/> returns <see langword="false"/>.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> that represents the asynchronous operation. Its result is the result of the <paramref name="operation"/> if it has not been canceled,
            or <paramref name="canceledResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="asyncConfig"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="operation"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromCompleted(KGySoft.Threading.TaskConfig)">
            <summary>
            Returns a task that represents an already completed operation without a result.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            The example uses the similarly working <see cref="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.TaskConfig)">FromResult</see> method.
            </summary>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that represents the completed operation.</returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,KGySoft.Threading.TaskConfig)">
            <summary>
            Returns a task that represents an already completed operation with a result.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="result">The result to be returned by the returned task if the operation has not been canceled.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> that represents the completed operation. Its result is <paramref name="result"/> if the operation has not been canceled,
            or the default value of <typeparamref name="TResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="asyncConfig"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.AsyncHelper.FromResult``1(``0,``0,KGySoft.Threading.TaskConfig)">
            <summary>
            Returns a task that represents an already completed operation with a result.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class for details.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="result">The result to be returned by the returned task if the operation has not been canceled.</param>
            <param name="canceledResult">The result to be returned by the returned task if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> of <paramref name="asyncConfig"/> returns <see langword="false"/>.</param>
            <param name="asyncConfig">The configuration for the asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> that represents the completed operation. Its result is <paramref name="result"/> if the operation has not been canceled,
            or <paramref name="canceledResult"/> if the operation has been canceled
            and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="asyncConfig"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="T:KGySoft.Threading.ParallelConfig">
            <summary>
            Represents a configuration for parallel operations.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.ParallelConfig.IsCancelRequestedCallback">
            <summary>
            Gets or sets a callback that can return whether cancellation has been requested. To use a <see cref="T:System.Threading.CancellationToken"/>
            on .NET Framework 4.0 or later, use the appropriate <see cref="M:KGySoft.Threading.ParallelConfig.#ctor(System.Threading.CancellationToken)">constructor</see>
            or the <see cref="T:KGySoft.Threading.TaskConfig"/> type with <see cref="T:System.Threading.Tasks.Task"/>-returning methods.
            <br/>Default value: <see langword="null"/>, if the default constructor was called.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.ParallelConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.ParallelConfig"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.ParallelConfig.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.ParallelConfig"/> class initializing the <see cref="P:KGySoft.Threading.ParallelConfig.IsCancelRequestedCallback"/>
            property from a <see cref="T:System.Threading.CancellationToken"/>.
            <br/>This constructor is available only for .NET Framework 4.0 and later.
            </summary>
            <param name="cancellationToken">Specifies the cancellation token for this operation.</param>
        </member>
        <member name="T:KGySoft.Threading.ParallelHelper">
            <summary>
            The <see cref="T:KGySoft.Threading.ParallelHelper"/> class contains similar methods to the <see cref="O:System.Threading.Tasks.Parallel.For">Parallel.For</see> overloads
            in .NET Framework 4.0 and later but the ones in this class can be used even on .NET Framework 3.5, support reporting progress and have async overloads.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.For(System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop synchronously, in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <remarks>
            <para>This method is functionally the same as <see cref="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})">Parallel.For(int, int, Action&lt;int>)</see>
            but it can be used even in .NET Framework 3.5.</para>
            <para>If <paramref name="fromInclusive"/> is greater than or equal to <paramref name="toExclusive"/>, then the method returns without performing any iterations.</para>
            <para>This method has no return type because if there was no exception, then the loop is guaranteed to be completed.</para>
            <note>This method adjusts the degree of parallelization automatically, blocks the caller, and does not support cancellation or reporting progress.
            Use the <see cref="M:KGySoft.Threading.ParallelHelper.For``1(``0,System.Int32,System.Int32,KGySoft.Threading.ParallelConfig,System.Action{System.Int32})"/> overload to adjust parallelization, set up cancellation, report progress;
            or the <see cref="M:KGySoft.Threading.ParallelHelper.BeginFor``1(``0,System.Int32,System.Int32,KGySoft.Threading.AsyncConfig,System.Action{System.Int32})"/>/<see cref="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})"/>
            (in .NET Framework 4.0 and above) methods to do these asynchronously.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.For(System.Int32,System.Int32,KGySoft.Threading.ParallelConfig,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop synchronously, in which iterations may run in parallel and the execution can be configured.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Threading.ParallelHelper.For``1(``0,System.Int32,System.Int32,KGySoft.Threading.ParallelConfig,System.Action{System.Int32})"/> overload for details.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="configuration">An optional configuration to adjust parallelization or cancellation.
            This method does not report progress even if <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in this parameter.
            To report progress use the <see cref="M:KGySoft.Threading.ParallelHelper.For``1(``0,System.Int32,System.Int32,KGySoft.Threading.ParallelConfig,System.Action{System.Int32})"/> overload.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns><see langword="true"/>, if the operation completed successfully.
            <br/><see langword="false"/>, if the operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.For``1(``0,System.Int32,System.Int32,KGySoft.Threading.ParallelConfig,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop synchronously, in which iterations may run in parallel and the execution can be configured.
            </summary>
            <typeparam name="T">The type of the <paramref name="operation"/> parameter.</typeparam>
            <param name="operation">The operation to be reported when <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in <paramref name="configuration"/>.
            Progress is reported only if this parameter is not <see langword="null"/>.</param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="configuration">An optional configuration to adjust parallelization, cancellation or reporting progress.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns><see langword="true"/>, if the operation completed successfully.
            <br/><see langword="false"/>, if the operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was set to <see langword="false"/>.</returns>
            <remarks>
            <para>This method is similar to <see cref="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})">Parallel.For(int, int, ParallelOptions, Action&lt;int>)</see>
            but it can be used even in .NET Framework 3.5 and supports reporting progress.</para>
            <para>If <paramref name="fromInclusive"/> is greater than or equal to <paramref name="toExclusive"/>, then the method returns without performing any iterations.</para>
            <para>If <paramref name="operation"/> is not <see langword="null"/>, <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in <paramref name="configuration"/> and there is at least one iteration,
            then the <see cref="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">IAsyncProgress.New</see> method will be called before the first iteration passing the specified <paramref name="operation"/> to the <c>operationType</c> parameter.
            It will be followed by as many <see cref="M:KGySoft.Threading.IAsyncProgress.Increment">IAsyncProgress.Increment</see> calls as many iterations were completed successfully.</para>
            <note>This method blocks the caller until the iterations are completed. To perform the execution asynchronously use
            the <see cref="O:KGySoft.Threading.ParallelHelper.BeginFor">BeginFor</see> or <see cref="O:KGySoft.Threading.ParallelHelper.ForAsync">ForAsync</see>
            (in .NET Framework 4.0 and above) methods.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="configuration"/> was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.BeginFor(System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Begins to execute an indexed loop asynchronously, in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that represents the asynchronous operation, which could still be pending.</returns>
            <remarks>
            <para>In .NET Framework 4.0 and above you can use also the <see cref="M:KGySoft.Threading.ParallelHelper.ForAsync(System.Int32,System.Int32,System.Action{System.Int32})"/> method.</para>
            <para>To get the result or the exception that occurred during the operation you have to call the <see cref="M:KGySoft.Threading.ParallelHelper.EndFor(System.IAsyncResult)">EndFor</see> method.</para>
            <para>If <paramref name="fromInclusive"/> is greater than or equal to <paramref name="toExclusive"/>, then the operation completes synchronously without performing any iterations.</para>
            <note>This method adjusts the degree of parallelization automatically and does not support cancellation or reporting progress.
            Use the <see cref="M:KGySoft.Threading.ParallelHelper.BeginFor``1(``0,System.Int32,System.Int32,KGySoft.Threading.AsyncConfig,System.Action{System.Int32})"/> overload to adjust parallelization, set up cancellation, report progress;
            or the <see cref="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})"/> method if you target .NET Framework 4.0 or later.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.BeginFor(System.Int32,System.Int32,KGySoft.Threading.AsyncConfig,System.Action{System.Int32})">
            <summary>
            Begins to execute an indexed loop asynchronously, in which iterations may run in parallel and the execution can be configured.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Threading.ParallelHelper.BeginFor``1(``0,System.Int32,System.Int32,KGySoft.Threading.AsyncConfig,System.Action{System.Int32})"/> overload for details.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="asyncConfig">An optional configuration to adjust parallelization, cancellation or completion callback.
            This method does not report progress even if <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in this parameter.
            To report progress use the <see cref="M:KGySoft.Threading.ParallelHelper.BeginFor``1(``0,System.Int32,System.Int32,KGySoft.Threading.AsyncConfig,System.Action{System.Int32})"/> overload.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that represents the asynchronous operation, which could still be pending.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.BeginFor``1(``0,System.Int32,System.Int32,KGySoft.Threading.AsyncConfig,System.Action{System.Int32})">
            <summary>
            Begins to execute an indexed loop asynchronously, in which iterations may run in parallel and the execution can be configured.
            </summary>
            <typeparam name="T">The type of the <paramref name="operation"/> parameter.</typeparam>
            <param name="operation">The operation to be reported when <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in <paramref name="asyncConfig"/>.
            Progress is reported only if this parameter is not <see langword="null"/>.</param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="asyncConfig">An optional configuration to adjust parallelization, cancellation, completion callback or reporting progress.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns>An <see cref="T:System.IAsyncResult"/> that represents the asynchronous operation, which could still be pending.</returns>
            <remarks>
            <para>In .NET Framework 4.0 and above you can use also the <see cref="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})"/> method.</para>
            <para>To get the result or the exception that occurred during the operation you have to call the <see cref="M:KGySoft.Threading.ParallelHelper.EndFor(System.IAsyncResult)">EndFor</see> method.</para>
            <para>If <paramref name="fromInclusive"/> is greater than or equal to <paramref name="toExclusive"/>, then the operation completes synchronously without performing any iterations.</para>
            <para>If <paramref name="operation"/> is not <see langword="null"/>, <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in <paramref name="asyncConfig"/> and there is at least one iteration,
            then the <see cref="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">IAsyncProgress.New</see> method will be called before the first iteration passing the specified <paramref name="operation"/> to the <c>operationType</c> parameter.
            It will be followed by as many <see cref="M:KGySoft.Threading.IAsyncProgress.Increment">IAsyncProgress.Increment</see> calls as many iterations were completed successfully.</para>
            <para>This method is not a blocking call even if the <see cref="P:KGySoft.Threading.AsyncConfigBase.MaxDegreeOfParallelism"/> property of the <paramref name="asyncConfig"/> parameter is 1.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.EndFor(System.IAsyncResult)">
            <summary>
            Waits for the pending asynchronous operation started by one of the <see cref="O:KGySoft.Threading.ParallelHelper.BeginFor">BeginFor</see> methods to complete.
            In .NET Framework 4.0 and above you can use the <see cref="O:KGySoft.Threading.ParallelHelper.ForAsync">ForAsync</see> methods instead.
            </summary>
            <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
            <returns><see langword="true"/>, if the operation completed successfully.
            <br/><see langword="false"/>, if the operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in the <c>asyncConfig</c> parameter was set to <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult"/> was not returned by a <see cref="O:KGySoft.Threading.ParallelHelper.BeginFor">BeginFor</see> overload or
            this method was called with the same instance multiple times.</exception>
            <exception cref="T:System.OperationCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in the <c>asyncConfig</c> parameter was <see langword="true"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.ForAsync(System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop asynchronously, in which iterations may run in parallel.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that represents the asynchronous operation, which could still be pending.</returns>
            <remarks>
            <para>If <paramref name="fromInclusive"/> is greater than or equal to <paramref name="toExclusive"/>, then the operation completes synchronously without performing any iterations.</para>
            <para>The <see cref="T:System.Threading.Tasks.Task"/> returned by this method has no result because if there was no exception, then the loop is guaranteed to be completed.</para>
            <note>This method adjusts the degree of parallelization automatically and does not support cancellation or reporting progress.
            Use the <see cref="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})"/> overload to adjust parallelization, set up cancellation or to report progress.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.ForAsync(System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop asynchronously, in which iterations may run in parallel and the execution can be configured.
            <br/>See the <strong>Remarks</strong> section of the <see cref="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})"/> overload for details.
            </summary>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="asyncConfig">An optional configuration to adjust parallelization or cancellation.
            This method does not report progress even if <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in this parameter.
            To report progress use the <see cref="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})"/> overload.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns>A task that represents the asynchronous operation. Its result is <see langword="true"/>, if the operation completed successfully,
            or <see langword="false"/>, if the operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="asyncConfig"/> parameter was <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.ForAsync``1(``0,System.Int32,System.Int32,KGySoft.Threading.TaskConfig,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop asynchronously, in which iterations may run in parallel and the execution can be configured.
            </summary>
            <typeparam name="T">The type of the <paramref name="operation"/> parameter.</typeparam>
            <param name="operation">The operation to be reported when <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in <paramref name="asyncConfig"/>.
            Progress is reported only if this parameter is not <see langword="null"/>.</param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="asyncConfig">An optional configuration to adjust parallelization, cancellation, completion callback or reporting progress.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns>A task that represents the asynchronous operation. Its result is <see langword="true"/>, if the operation completed successfully,
            or <see langword="false"/>, if the operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/> in <paramref name="asyncConfig"/> parameter was <see langword="false"/>.</returns>
            <remarks>
            <para>If <paramref name="fromInclusive"/> is greater than or equal to <paramref name="toExclusive"/>, then the operation completes synchronously without performing any iterations.</para>
            <para>If <paramref name="operation"/> is not <see langword="null"/>, <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> is set in <paramref name="asyncConfig"/> and there is at least one iteration,
            then the <see cref="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">IAsyncProgress.New</see> method will be called before the first iteration passing the specified <paramref name="operation"/> to the <c>operationType</c> parameter.
            It will be followed by as many <see cref="M:KGySoft.Threading.IAsyncProgress.Increment">IAsyncProgress.Increment</see> calls as many iterations were completed successfully.</para>
            <para>This method is not a blocking call even if the <see cref="P:KGySoft.Threading.AsyncConfigBase.MaxDegreeOfParallelism"/> property of the <paramref name="asyncConfig"/> parameter is 1.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The operation has been canceled and <see cref="P:KGySoft.Threading.AsyncConfigBase.ThrowIfCanceled"/>
            in <paramref name="asyncConfig"/> was <see langword="true"/>. This exception is thrown when the result is awaited.</exception>
        </member>
        <member name="M:KGySoft.Threading.ParallelHelper.For``1(KGySoft.Threading.IAsyncContext,``0,System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes an indexed loop inside of an already created, possibly asynchronous <paramref name="context"/>.
            </summary>
            <typeparam name="T">The type of the <paramref name="operation"/> parameter.</typeparam>
            <param name="context">An <see cref="T:KGySoft.Threading.IAsyncContext"/> instance that contains information for asynchronous processing about the current operation.</param>
            <param name="operation">The operation to be reported when <see cref="P:KGySoft.Threading.AsyncConfigBase.Progress"/> in <paramref name="context"/> is not <see langword="null"/>.
            Progress is reported only if this parameter is not <see langword="null"/>.</param>
            <param name="fromInclusive">The start index, inclusive.</param>
            <param name="toExclusive">The end index, exclusive.</param>
            <param name="body">The delegate that is invoked once per iteration.</param>
            <returns><see langword="true"/>, if the operation completed successfully.
            <br/><see langword="false"/>, if the operation has been canceled.</returns>
            <remarks>
            <para>This method blocks the caller thread but if <paramref name="context"/> belongs to an async top level method, then the execution may already run
            on a pool thread. Degree of parallelism, the ability of cancellation and reporting progress depend on how these were configured at the top level method.</para>
            <note type="tip">See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/>
            class for details about how to create a context for possibly async top level methods.</note>
            <note>See the <see cref="M:KGySoft.Threading.ParallelHelper.For``1(``0,System.Int32,System.Int32,KGySoft.Threading.ParallelConfig,System.Action{System.Int32})"/> overload for more details about the other parameters.</note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="body"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:KGySoft.Threading.TaskConfig">
            <summary>
            Represents asynchronous configuration for <see cref="T:System.Threading.Tasks.Task"/>-returning methods.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.TaskConfig.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this operation.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.TaskConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.TaskConfig"/> class.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.TaskConfig.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.TaskConfig"/> class.
            </summary>
            <param name="cancellationToken">Specifies the cancellation token for this operation.</param>
        </member>
        <member name="T:KGySoft.Threading.NamespaceDoc">
            <summary>
            The <see cref="N:KGySoft.Threading"/> namespace contains the static <see cref="T:KGySoft.Threading.AsyncHelper"/> class that makes possible to implement sync and async versions of a possibly parallel operation
            supporting cancellation and reporting progress using a single shared implementation. One built-in example is the <see cref="T:KGySoft.Threading.ParallelHelper"/> class
            (which is basically a target framework independent advanced version of <see cref="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})">Parallel.For</see>)
            but you can find many examples in other dependent libraries such as the <a href="https://www.nuget.org/packages/KGySoft.Drawing.Core/" target="_blank">KGySoft.Drawing.Core</a> package
            that uses many parallel operations for image processing. Apart from these you can find here the <see cref="T:KGySoft.Threading.WaitHandleExtensions"/> and some
            other types related to configuring or tracking asynchronous operations.
            <br/>If you are looking for thread-safe collections such as the <see cref="T:KGySoft.Collections.ThreadSafeDictionary`2"/>,
            then see the <see cref="N:KGySoft.Collections">KGySoft.Collections</see> namespace instead.
            </summary>
        </member>
        <member name="T:KGySoft.Threading.WaitHandleExtensions">
            <summary>
            Provides extension methods for the <see cref="T:System.Threading.WaitHandle"/> type.
            </summary>
            <remarks>
            <note>This class is available only in .NET 4.5 and above.</note>
            </remarks>
        </member>
        <member name="M:KGySoft.Threading.WaitHandleExtensions.WaitOneAsync(System.Threading.WaitHandle,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Waits for a signal asynchronously on the provided <paramref name="handle"/>.
            </summary>
            <param name="handle">The handle to wait on.</param>
            <param name="timeout">The timeout in milliseconds. This parameter is optional.
            <br/>Default value: <see cref="F:System.Threading.Timeout.Infinite">Timeout.Infinite</see></param>
            <param name="cancellationToken">A token for cancellation. This parameter is optional.
            <br/>Default value: <see cref="P:System.Threading.CancellationToken.None">CancellationToken.None</see></param>
            <returns><see langword="true"/>, if the specified <paramref name="handle"/> receives a signal before timing out or canceling; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Threading.WaitHandleExtensions.WaitOneAsync(System.Threading.WaitHandle,System.Threading.CancellationToken)">
            <summary>
            Waits for a signal asynchronously on the provided <paramref name="handle"/>.
            </summary>
            <param name="handle">The handle to wait on.</param>
            <param name="cancellationToken">A token for cancellation.</param>
            <returns><see langword="true"/>, if the specified <paramref name="handle"/> receives a signal before canceling; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.Threading.IAsyncContext">
            <summary>
            Represents the context of a possibly asynchronous operation.
            <br/>See the <strong>Examples</strong> section of the <see cref="T:KGySoft.Threading.AsyncHelper"/> class to see how to create sync and async methods (supporting
            both <see cref="T:System.Threading.Tasks.Task"/> and <see cref="T:System.IAsyncResult"/> return types) using the same shared implementation with an <see cref="T:KGySoft.Threading.IAsyncContext"/> parameter.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.IAsyncContext.MaxDegreeOfParallelism">
            <summary>
            Gets the maximum degree of parallelism. If zero or less, then it is adjusted automatically.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.IAsyncContext.IsCancellationRequested">
            <summary>
            Gets whether the cancellation of the current operation has been requested.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.IAsyncContext.CanBeCanceled">
            <summary>
            Gets whether this operation can be canceled.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.IAsyncContext.Progress">
            <summary>
            Gets an <see cref="T:KGySoft.Threading.IAsyncProgress"/> instance that can be used to report progress, or <see langword="null"/> if
            no progress reporter belongs to the current operation.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.IAsyncContext.State">
            <summary>
            Gets the user provided object that was configured in the <see cref="P:KGySoft.Threading.AsyncConfigBase.State"/> property
            this <see cref="T:KGySoft.Threading.IAsyncContext"/> instance was created from.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.IAsyncContext.ThrowIfCancellationRequested">
            <summary>
            Throws an <see cref="T:System.OperationCanceledException"/> if <see cref="P:KGySoft.Threading.IAsyncContext.IsCancellationRequested"/> returns <see langword="true"/>.
            </summary>
        </member>
        <member name="T:KGySoft.Threading.IAsyncProgress">
            <summary>
            Represents a progress updates provider for asynchronous operations.
            It provides methods for updating the progress from concurrent threads.
            </summary>
            <example>
            The following example demonstrates how to implement this interface allowing concurrent updates.
            <code lang="C#"><![CDATA[
            #nullable enable
            
            using System;
            using System.Threading;
            using System.Timers;
            
            using KGySoft.Threading;
            
            using Timer = System.Timers.Timer;
            
            class Example
            {
                public static void Main()
                {
                    var progressTracker = new ProgressTracker();
                    using var progressReporter = new ConsoleProgressReporter(progressTracker);
                    var config = new ParallelConfig { Progress = progressTracker };
            
                    // imitating some long concurrent task
                    progressReporter.Enabled = true; // starts updating the progress periodically
                    ParallelHelper.For("Some parallel operation", 0, 1000, config,
                        body: i => Thread.Sleep(1));
                    progressReporter.UpdateProgress(); // to show the completed progress.
                    progressReporter.Enabled = false; // stopping the timer
                }
            
                // This IAsyncProgress implementation just provides an always up-to-date Current property.
                // You can add an event if you don't want to miss any tiny progress change.
                private class ProgressTracker : IAsyncProgress
                {
                    private readonly object syncRoot = new object();
                    private string? currentOperation;
                    private int maximumValue;
                    private int currentValue;
            
                    public AsyncProgress<string?> Current
                    {
                        get
                        {
                            lock (syncRoot)
                                return new AsyncProgress<string?>(currentOperation, maximumValue, currentValue);
                        }
                    }
            
                    public void Report<T>(AsyncProgress<T> progress)
                    {
                        lock (syncRoot)
                        {
                            // Converting any T to string (assuming it can be displayed as a text)
                            currentOperation = progress.OperationType?.ToString();
                            maximumValue = progress.MaximumValue;
                            currentValue = progress.CurrentValue;
                        }
                    }
            
                    public void New<T>(T operationType, int maximumValue = 0, int currentValue = 0)
                        => Report(new AsyncProgress<T>(operationType, maximumValue, currentValue));
            
                    public void Increment()
                    {
                        lock (syncRoot)
                            currentValue++;
                    }
            
                    public void SetProgressValue(int value)
                    {
                        lock (syncRoot)
                            currentValue = value;
                    }
            
                    public void Complete()
                    {
                        lock (syncRoot)
                            currentValue = maximumValue;
                    }
                }
            
                // This class is the one that displays the actual progress. It can be easily adapted to any UI.
                private class ConsoleProgressReporter : IDisposable
                {
                    private readonly Timer timer; // using System.Timers.Timer here but you can use UI-specific versions
                    private readonly ProgressTracker progressTracker;
            
                    // To turn progress reporting on and off. In a UI you can set also some progress bar visibility here.
                    public bool Enabled
                    {
                        get => timer.Enabled;
                        set => timer.Enabled = value;
                    }
            
                    public ConsoleProgressReporter(ProgressTracker progress)
                    {
                        progressTracker = progress;
                        timer = new Timer { Interval = 100 }; // Displayed progress is updated only in every 100ms.
                        timer.Elapsed += Timer_Elapsed;
                    }
            
                    // Please note that progress is updated only when the timer ticks so can skip some rapid changes.
                    private void Timer_Elapsed(object? sender, ElapsedEventArgs e) => UpdateProgress();
            
                    public void UpdateProgress()
                    {
                        // In a UI you can set progress bar value, maximum value and some text here.
                        var current = progressTracker.Current; // a local copy to prevent an inconsistent report.
                        Console.WriteLine($"{current.OperationType}: {current.CurrentValue}/{current.MaximumValue}");
                    }
            
                    public void Dispose()
                    {
                        timer.Elapsed -= Timer_Elapsed;
                        timer.Dispose();
                    }
                }
            }
            
            // The example above prints a similar output to this one:
            // Some parallel operation: 56/1000
            // Some parallel operation: 152/1000
            // Some parallel operation: 200/1000
            // Some parallel operation: 248/1000
            // Some parallel operation: 304/1000
            // Some parallel operation: 352/1000
            // Some parallel operation: 408/1000
            // Some parallel operation: 456/1000
            // Some parallel operation: 504/1000
            // Some parallel operation: 560/1000
            // Some parallel operation: 608/1000
            // Some parallel operation: 664/1000
            // Some parallel operation: 712/1000
            // Some parallel operation: 768/1000
            // Some parallel operation: 816/1000
            // Some parallel operation: 864/1000
            // Some parallel operation: 920/1000
            // Some parallel operation: 968/1000
            // Some parallel operation: 1000/1000]]></code>
            </example>
        </member>
        <member name="M:KGySoft.Threading.IAsyncProgress.Report``1(KGySoft.Threading.AsyncProgress{``0})">
            <summary>
            Reports a progress update to any arbitrary state.
            For parallel operations it is recommended to use the <see cref="M:KGySoft.Threading.IAsyncProgress.Increment">Increment</see> method
            after starting a new progress because this method cannot guarantee that <see cref="P:KGySoft.Threading.AsyncProgress`1.CurrentValue"/> will be a strictly
            increasing value when called from <see cref="T:System.Threading.Tasks.Parallel"/> members, for example.
            </summary>
            <typeparam name="T">The type of the <see cref="P:KGySoft.Threading.AsyncProgress`1.OperationType"/> property in the specified <paramref name="progress"/>.</typeparam>
            <param name="progress">The value of the updated progress.</param>
        </member>
        <member name="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">
            <summary>
            Indicates that a new progress session is started that consists of <paramref name="maximumValue"/> steps.
            </summary>
            <typeparam name="T">The type of the <paramref name="operationType"/> parameter.</typeparam>
            <param name="operationType">An instance of <typeparamref name="T"/> that describes the type of the new operation.</param>
            <param name="maximumValue">Specifies the possible maximum steps of the new operation (the <see cref="M:KGySoft.Threading.IAsyncProgress.Increment">Increment</see> method is recommended to be called later on
            if a parallel processing does not know or may reorder the current step). 0 means an operation with no separate steps. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
            <param name="currentValue">Specifies the initial current value for the new progress. Should be between 0 and <paramref name="maximumValue"/>. This parameter is optional.
            <br/>Default value: <c>0</c>.</param>
        </member>
        <member name="M:KGySoft.Threading.IAsyncProgress.Increment">
            <summary>
            Indicates a progress update of a single step. Expected to be called after the <see cref="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">New</see> or <see cref="M:KGySoft.Threading.IAsyncProgress.Report``1(KGySoft.Threading.AsyncProgress{``0})">Report</see> methods
            if they were called with nonzero maximum steps. The implementation should not be sensitive for concurrency racing conditions.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.IAsyncProgress.SetProgressValue(System.Int32)">
            <summary>
            Indicates that the current progress is at a specific position.
            </summary>
            <param name="value">The current progress value. Should not exceed the maximum value of the last <see cref="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">New</see> or <see cref="M:KGySoft.Threading.IAsyncProgress.Report``1(KGySoft.Threading.AsyncProgress{``0})">Report</see> calls
            and should not be sensitive for concurrency racing conditions.
            </param>
        </member>
        <member name="M:KGySoft.Threading.IAsyncProgress.Complete">
            <summary>
            Indicates that a progress value of the last <see cref="M:KGySoft.Threading.IAsyncProgress.New``1(``0,System.Int32,System.Int32)">New</see> or <see cref="M:KGySoft.Threading.IAsyncProgress.Report``1(KGySoft.Threading.AsyncProgress{``0})">Report</see> method should be set to the maximum value.
            It is not required to be called at the end of each sessions so it just indicates that whatever progress has reached the last step.
            </summary>
        </member>
        <member name="T:KGySoft.Threading.AsyncProgress`1">
            <summary>
            Represents the progress of an operation that can be reported by an <see cref="T:KGySoft.Threading.IAsyncProgress"/> implementation.
            </summary>
            <typeparam name="T">The type of the descriptor of the operation returned by the <see cref="P:KGySoft.Threading.AsyncProgress`1.OperationType"/> property.</typeparam>
        </member>
        <member name="P:KGySoft.Threading.AsyncProgress`1.OperationType">
            <summary>
            Gets information about the current operation in progress.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncProgress`1.MaximumValue">
            <summary>
            Gets the maximum steps of this operation.
            </summary>
        </member>
        <member name="P:KGySoft.Threading.AsyncProgress`1.CurrentValue">
            <summary>
            Gets the current step of this operation. Its value is between zero and <see cref="P:KGySoft.Threading.AsyncProgress`1.MaximumValue"/>, inclusive bounds.
            </summary>
        </member>
        <member name="M:KGySoft.Threading.AsyncProgress`1.op_Equality(KGySoft.Threading.AsyncProgress{`0},KGySoft.Threading.AsyncProgress{`0})">
            <summary>
            Gets whether two <see cref="T:KGySoft.Threading.AsyncProgress`1"/> structures are equal.
            </summary>
            <param name="left">The <see cref="T:KGySoft.Threading.AsyncProgress`1"/> instance that is to the left of the equality operator.</param>
            <param name="right">The <see cref="T:KGySoft.Threading.AsyncProgress`1"/> instance that is to the right of the equality operator.</param>
            <returns><see langword="true"/> if the two <see cref="T:KGySoft.Threading.AsyncProgress`1"/> structures are equal; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Threading.AsyncProgress`1.op_Inequality(KGySoft.Threading.AsyncProgress{`0},KGySoft.Threading.AsyncProgress{`0})">
            <summary>
            Gets whether two <see cref="T:KGySoft.Threading.AsyncProgress`1"/> structures are different.
            </summary>
            <param name="left">The <see cref="T:KGySoft.Threading.AsyncProgress`1"/> instance that is to the left of the inequality operator.</param>
            <param name="right">The <see cref="T:KGySoft.Threading.AsyncProgress`1"/> instance that is to the right of the inequality operator.</param>
            <returns><see langword="true"/> if the two <see cref="T:KGySoft.Threading.AsyncProgress`1"/> structures are different; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:KGySoft.Threading.AsyncProgress`1.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:KGySoft.Threading.AsyncProgress`1"/> struct.
            </summary>
            <param name="operationType">Provides some information about the current operation.</param>
            <param name="maximumValue">The maximum value.</param>
            <param name="currentValue">The current value.</param>
        </member>
        <member name="M:KGySoft.Threading.AsyncProgress`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:KGySoft.Threading.AsyncProgress`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:KGySoft.Threading.AsyncProgress`1.Equals(KGySoft.Threading.AsyncProgress{`0})">
            <summary>
            Indicates whether the this <see cref="T:KGySoft.Threading.AsyncProgress`1"/> is equal to another one.
            </summary>
            <param name="other">A <see cref="T:KGySoft.Threading.AsyncProgress`1"/> instance to compare with this one.</param>
            <returns><see langword="true"/> if the current object is equal to the <paramref name="other"/>&#160;<see cref="T:KGySoft.Threading.AsyncProgress`1"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:KGySoft.Throw">
            <summary>
            Helper class for throwing exceptions from performance-critical types.
            For example, a generic indexer can be 2.5x times faster if it contains no throw but a method call
            just because the presence of throw prevents inlining.
            </summary>
        </member>
        <member name="T:KGySoft._">
            <summary>
            Just a dummy type for generic nameof() expressions until the issue is fixed by the C# compiler.
            </summary>
        </member>
    </members>
</doc>
